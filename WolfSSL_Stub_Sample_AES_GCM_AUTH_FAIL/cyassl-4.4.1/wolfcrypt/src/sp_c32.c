/* sp.c
 *
 * Copyright (C) 2006-2020 wolfSSL Inc.
 *
 * This file is part of wolfSSL.
 *
 * wolfSSL is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * wolfSSL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
 */

/* Implementation by Sean Parkinson. */

#ifdef HAVE_CONFIG_H
    #include <config.h>
#endif

#include <wolfssl/wolfcrypt/settings.h>
#include <wolfssl/wolfcrypt/error-crypt.h>
#include <wolfssl/wolfcrypt/cpuid.h>
#ifdef NO_INLINE
    #include <wolfssl/wolfcrypt/misc.h>
#else
    #define WOLFSSL_MISC_INCLUDED
    #include <wolfcrypt/src/misc.c>
#endif

#if defined(WOLFSSL_HAVE_SP_RSA) || defined(WOLFSSL_HAVE_SP_DH) || \
                                    defined(WOLFSSL_HAVE_SP_ECC)

#ifdef RSA_LOW_MEM
#ifndef SP_RSA_PRIVATE_EXP_D
#define SP_RSA_PRIVATE_EXP_D
#endif

#ifndef WOLFSSL_SP_SMALL
#define WOLFSSL_SP_SMALL
#endif
#endif

#include <wolfssl/wolfcrypt/sp.h>

#ifndef WOLFSSL_SP_ASM
#if SP_WORD_SIZE == 32
#if (defined(WOLFSSL_SP_CACHE_RESISTANT) || defined(WOLFSSL_SP_SMALL)) &&              (defined(WOLFSSL_HAVE_SP_ECC) || !defined(WOLFSSL_RSA_PUBLIC_ONLY))
/* Mask for address to obfuscate which of the two address will be used. */
static const size_t addr_mask[2] = { 0, (size_t)-1 };
#endif

#if defined(WOLFSSL_SP_NONBLOCK) && (!defined(WOLFSSL_SP_NO_MALLOC) || !defined(WOLFSSL_SP_SMALL))
    #error SP non-blocking requires small and no-malloc (WOLFSSL_SP_SMALL and WOLFSSL_SP_NO_MALLOC)
#endif

#if defined(WOLFSSL_HAVE_SP_RSA) || defined(WOLFSSL_HAVE_SP_DH)
#ifndef WOLFSSL_SP_NO_2048
/* Read big endian unsigned byte array into r.
 *
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  Byte array.
 * n  Number of bytes in array to read.
 */
static void sp_2048_from_bin(sp_digit* r, int size, const byte* a, int n)
{
    int i;
    int j = 0;
    word32 s = 0;

    r[0] = 0;
    for (i = n-1; i >= 0; i--) {
        r[j] |= (((sp_digit)a[i]) << s);
        if (s >= 15U) {
            r[j] &= 0x7fffff;
            s = 23U - s;
            if (j + 1 >= size) {
                break;
            }
            r[++j] = (sp_digit)a[i] >> s;
            s = 8U - s;
        }
        else {
            s += 8U;
        }
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
}

/* Convert an mp_int to an array of sp_digit.
 *
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  A multi-precision integer.
 */
static void sp_2048_from_mp(sp_digit* r, int size, const mp_int* a)
{
#if DIGIT_BIT == 23
    int j;

    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);

    for (j = a->used; j < size; j++) {
        r[j] = 0;
    }
#elif DIGIT_BIT > 23
    int i;
    int j = 0;
    word32 s = 0;

    r[0] = 0;
    for (i = 0; i < a->used && j < size; i++) {
        r[j] |= ((sp_digit)a->dp[i] << s);
        r[j] &= 0x7fffff;
        s = 23U - s;
        if (j + 1 >= size) {
            break;
        }
        /* lint allow cast of mismatch word32 and mp_digit */
        r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
        while ((s + 23U) <= (word32)DIGIT_BIT) {
            s += 23U;
            r[j] &= 0x7fffff;
            if (j + 1 >= size) {
                break;
            }
            if (s < (word32)DIGIT_BIT) {
                /* lint allow cast of mismatch word32 and mp_digit */
                r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
            }
            else {
                r[++j] = 0L;
            }
        }
        s = (word32)DIGIT_BIT - s;
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#else
    int i;
    int j = 0;
    int s = 0;

    r[0] = 0;
    for (i = 0; i < a->used && j < size; i++) {
        r[j] |= ((sp_digit)a->dp[i]) << s;
        if (s + DIGIT_BIT >= 23) {
            r[j] &= 0x7fffff;
            if (j + 1 >= size) {
                break;
            }
            s = 23 - s;
            if (s == DIGIT_BIT) {
                r[++j] = 0;
                s = 0;
            }
            else {
                r[++j] = a->dp[i] >> s;
                s = DIGIT_BIT - s;
            }
        }
        else {
            s += DIGIT_BIT;
        }
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#endif
}

/* Write r as big endian to byte array.
 * Fixed length number of bytes written: 256
 *
 * r  A single precision integer.
 * a  Byte array.
 */
static void sp_2048_to_bin(sp_digit* r, byte* a)
{
    int i;
    int j;
    int s = 0;
    int b;

    for (i=0; i<89; i++) {
        r[i+1] += r[i] >> 23;
        r[i] &= 0x7fffff;
    }
    j = 2048 / 8 - 1;
    a[j] = 0;
    for (i=0; i<90 && j>=0; i++) {
        b = 0;
        /* lint allow cast of mismatch sp_digit and int */
        a[j--] |= (byte)(r[i] << s); /*lint !e9033*/
        b += 8 - s;
        if (j < 0) {
            break;
        }
        while (b < 23) {
            a[j--] = (byte)(r[i] >> b);
            b += 8;
            if (j < 0) {
                break;
            }
        }
        s = 8 - (b - 23);
        if (j >= 0) {
            a[j] = 0;
        }
        if (s != 0) {
            j++;
        }
    }
}

#ifndef WOLFSSL_SP_SMALL
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_2048_mul_15(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int64_t t0   = ((int64_t)a[ 0]) * b[ 0];
    int64_t t1   = ((int64_t)a[ 0]) * b[ 1]
                 + ((int64_t)a[ 1]) * b[ 0];
    int64_t t2   = ((int64_t)a[ 0]) * b[ 2]
                 + ((int64_t)a[ 1]) * b[ 1]
                 + ((int64_t)a[ 2]) * b[ 0];
    int64_t t3   = ((int64_t)a[ 0]) * b[ 3]
                 + ((int64_t)a[ 1]) * b[ 2]
                 + ((int64_t)a[ 2]) * b[ 1]
                 + ((int64_t)a[ 3]) * b[ 0];
    int64_t t4   = ((int64_t)a[ 0]) * b[ 4]
                 + ((int64_t)a[ 1]) * b[ 3]
                 + ((int64_t)a[ 2]) * b[ 2]
                 + ((int64_t)a[ 3]) * b[ 1]
                 + ((int64_t)a[ 4]) * b[ 0];
    int64_t t5   = ((int64_t)a[ 0]) * b[ 5]
                 + ((int64_t)a[ 1]) * b[ 4]
                 + ((int64_t)a[ 2]) * b[ 3]
                 + ((int64_t)a[ 3]) * b[ 2]
                 + ((int64_t)a[ 4]) * b[ 1]
                 + ((int64_t)a[ 5]) * b[ 0];
    int64_t t6   = ((int64_t)a[ 0]) * b[ 6]
                 + ((int64_t)a[ 1]) * b[ 5]
                 + ((int64_t)a[ 2]) * b[ 4]
                 + ((int64_t)a[ 3]) * b[ 3]
                 + ((int64_t)a[ 4]) * b[ 2]
                 + ((int64_t)a[ 5]) * b[ 1]
                 + ((int64_t)a[ 6]) * b[ 0];
    int64_t t7   = ((int64_t)a[ 0]) * b[ 7]
                 + ((int64_t)a[ 1]) * b[ 6]
                 + ((int64_t)a[ 2]) * b[ 5]
                 + ((int64_t)a[ 3]) * b[ 4]
                 + ((int64_t)a[ 4]) * b[ 3]
                 + ((int64_t)a[ 5]) * b[ 2]
                 + ((int64_t)a[ 6]) * b[ 1]
                 + ((int64_t)a[ 7]) * b[ 0];
    int64_t t8   = ((int64_t)a[ 0]) * b[ 8]
                 + ((int64_t)a[ 1]) * b[ 7]
                 + ((int64_t)a[ 2]) * b[ 6]
                 + ((int64_t)a[ 3]) * b[ 5]
                 + ((int64_t)a[ 4]) * b[ 4]
                 + ((int64_t)a[ 5]) * b[ 3]
                 + ((int64_t)a[ 6]) * b[ 2]
                 + ((int64_t)a[ 7]) * b[ 1]
                 + ((int64_t)a[ 8]) * b[ 0];
    int64_t t9   = ((int64_t)a[ 0]) * b[ 9]
                 + ((int64_t)a[ 1]) * b[ 8]
                 + ((int64_t)a[ 2]) * b[ 7]
                 + ((int64_t)a[ 3]) * b[ 6]
                 + ((int64_t)a[ 4]) * b[ 5]
                 + ((int64_t)a[ 5]) * b[ 4]
                 + ((int64_t)a[ 6]) * b[ 3]
                 + ((int64_t)a[ 7]) * b[ 2]
                 + ((int64_t)a[ 8]) * b[ 1]
                 + ((int64_t)a[ 9]) * b[ 0];
    int64_t t10  = ((int64_t)a[ 0]) * b[10]
                 + ((int64_t)a[ 1]) * b[ 9]
                 + ((int64_t)a[ 2]) * b[ 8]
                 + ((int64_t)a[ 3]) * b[ 7]
                 + ((int64_t)a[ 4]) * b[ 6]
                 + ((int64_t)a[ 5]) * b[ 5]
                 + ((int64_t)a[ 6]) * b[ 4]
                 + ((int64_t)a[ 7]) * b[ 3]
                 + ((int64_t)a[ 8]) * b[ 2]
                 + ((int64_t)a[ 9]) * b[ 1]
                 + ((int64_t)a[10]) * b[ 0];
    int64_t t11  = ((int64_t)a[ 0]) * b[11]
                 + ((int64_t)a[ 1]) * b[10]
                 + ((int64_t)a[ 2]) * b[ 9]
                 + ((int64_t)a[ 3]) * b[ 8]
                 + ((int64_t)a[ 4]) * b[ 7]
                 + ((int64_t)a[ 5]) * b[ 6]
                 + ((int64_t)a[ 6]) * b[ 5]
                 + ((int64_t)a[ 7]) * b[ 4]
                 + ((int64_t)a[ 8]) * b[ 3]
                 + ((int64_t)a[ 9]) * b[ 2]
                 + ((int64_t)a[10]) * b[ 1]
                 + ((int64_t)a[11]) * b[ 0];
    int64_t t12  = ((int64_t)a[ 0]) * b[12]
                 + ((int64_t)a[ 1]) * b[11]
                 + ((int64_t)a[ 2]) * b[10]
                 + ((int64_t)a[ 3]) * b[ 9]
                 + ((int64_t)a[ 4]) * b[ 8]
                 + ((int64_t)a[ 5]) * b[ 7]
                 + ((int64_t)a[ 6]) * b[ 6]
                 + ((int64_t)a[ 7]) * b[ 5]
                 + ((int64_t)a[ 8]) * b[ 4]
                 + ((int64_t)a[ 9]) * b[ 3]
                 + ((int64_t)a[10]) * b[ 2]
                 + ((int64_t)a[11]) * b[ 1]
                 + ((int64_t)a[12]) * b[ 0];
    int64_t t13  = ((int64_t)a[ 0]) * b[13]
                 + ((int64_t)a[ 1]) * b[12]
                 + ((int64_t)a[ 2]) * b[11]
                 + ((int64_t)a[ 3]) * b[10]
                 + ((int64_t)a[ 4]) * b[ 9]
                 + ((int64_t)a[ 5]) * b[ 8]
                 + ((int64_t)a[ 6]) * b[ 7]
                 + ((int64_t)a[ 7]) * b[ 6]
                 + ((int64_t)a[ 8]) * b[ 5]
                 + ((int64_t)a[ 9]) * b[ 4]
                 + ((int64_t)a[10]) * b[ 3]
                 + ((int64_t)a[11]) * b[ 2]
                 + ((int64_t)a[12]) * b[ 1]
                 + ((int64_t)a[13]) * b[ 0];
    int64_t t14  = ((int64_t)a[ 0]) * b[14]
                 + ((int64_t)a[ 1]) * b[13]
                 + ((int64_t)a[ 2]) * b[12]
                 + ((int64_t)a[ 3]) * b[11]
                 + ((int64_t)a[ 4]) * b[10]
                 + ((int64_t)a[ 5]) * b[ 9]
                 + ((int64_t)a[ 6]) * b[ 8]
                 + ((int64_t)a[ 7]) * b[ 7]
                 + ((int64_t)a[ 8]) * b[ 6]
                 + ((int64_t)a[ 9]) * b[ 5]
                 + ((int64_t)a[10]) * b[ 4]
                 + ((int64_t)a[11]) * b[ 3]
                 + ((int64_t)a[12]) * b[ 2]
                 + ((int64_t)a[13]) * b[ 1]
                 + ((int64_t)a[14]) * b[ 0];
    int64_t t15  = ((int64_t)a[ 1]) * b[14]
                 + ((int64_t)a[ 2]) * b[13]
                 + ((int64_t)a[ 3]) * b[12]
                 + ((int64_t)a[ 4]) * b[11]
                 + ((int64_t)a[ 5]) * b[10]
                 + ((int64_t)a[ 6]) * b[ 9]
                 + ((int64_t)a[ 7]) * b[ 8]
                 + ((int64_t)a[ 8]) * b[ 7]
                 + ((int64_t)a[ 9]) * b[ 6]
                 + ((int64_t)a[10]) * b[ 5]
                 + ((int64_t)a[11]) * b[ 4]
                 + ((int64_t)a[12]) * b[ 3]
                 + ((int64_t)a[13]) * b[ 2]
                 + ((int64_t)a[14]) * b[ 1];
    int64_t t16  = ((int64_t)a[ 2]) * b[14]
                 + ((int64_t)a[ 3]) * b[13]
                 + ((int64_t)a[ 4]) * b[12]
                 + ((int64_t)a[ 5]) * b[11]
                 + ((int64_t)a[ 6]) * b[10]
                 + ((int64_t)a[ 7]) * b[ 9]
                 + ((int64_t)a[ 8]) * b[ 8]
                 + ((int64_t)a[ 9]) * b[ 7]
                 + ((int64_t)a[10]) * b[ 6]
                 + ((int64_t)a[11]) * b[ 5]
                 + ((int64_t)a[12]) * b[ 4]
                 + ((int64_t)a[13]) * b[ 3]
                 + ((int64_t)a[14]) * b[ 2];
    int64_t t17  = ((int64_t)a[ 3]) * b[14]
                 + ((int64_t)a[ 4]) * b[13]
                 + ((int64_t)a[ 5]) * b[12]
                 + ((int64_t)a[ 6]) * b[11]
                 + ((int64_t)a[ 7]) * b[10]
                 + ((int64_t)a[ 8]) * b[ 9]
                 + ((int64_t)a[ 9]) * b[ 8]
                 + ((int64_t)a[10]) * b[ 7]
                 + ((int64_t)a[11]) * b[ 6]
                 + ((int64_t)a[12]) * b[ 5]
                 + ((int64_t)a[13]) * b[ 4]
                 + ((int64_t)a[14]) * b[ 3];
    int64_t t18  = ((int64_t)a[ 4]) * b[14]
                 + ((int64_t)a[ 5]) * b[13]
                 + ((int64_t)a[ 6]) * b[12]
                 + ((int64_t)a[ 7]) * b[11]
                 + ((int64_t)a[ 8]) * b[10]
                 + ((int64_t)a[ 9]) * b[ 9]
                 + ((int64_t)a[10]) * b[ 8]
                 + ((int64_t)a[11]) * b[ 7]
                 + ((int64_t)a[12]) * b[ 6]
                 + ((int64_t)a[13]) * b[ 5]
                 + ((int64_t)a[14]) * b[ 4];
    int64_t t19  = ((int64_t)a[ 5]) * b[14]
                 + ((int64_t)a[ 6]) * b[13]
                 + ((int64_t)a[ 7]) * b[12]
                 + ((int64_t)a[ 8]) * b[11]
                 + ((int64_t)a[ 9]) * b[10]
                 + ((int64_t)a[10]) * b[ 9]
                 + ((int64_t)a[11]) * b[ 8]
                 + ((int64_t)a[12]) * b[ 7]
                 + ((int64_t)a[13]) * b[ 6]
                 + ((int64_t)a[14]) * b[ 5];
    int64_t t20  = ((int64_t)a[ 6]) * b[14]
                 + ((int64_t)a[ 7]) * b[13]
                 + ((int64_t)a[ 8]) * b[12]
                 + ((int64_t)a[ 9]) * b[11]
                 + ((int64_t)a[10]) * b[10]
                 + ((int64_t)a[11]) * b[ 9]
                 + ((int64_t)a[12]) * b[ 8]
                 + ((int64_t)a[13]) * b[ 7]
                 + ((int64_t)a[14]) * b[ 6];
    int64_t t21  = ((int64_t)a[ 7]) * b[14]
                 + ((int64_t)a[ 8]) * b[13]
                 + ((int64_t)a[ 9]) * b[12]
                 + ((int64_t)a[10]) * b[11]
                 + ((int64_t)a[11]) * b[10]
                 + ((int64_t)a[12]) * b[ 9]
                 + ((int64_t)a[13]) * b[ 8]
                 + ((int64_t)a[14]) * b[ 7];
    int64_t t22  = ((int64_t)a[ 8]) * b[14]
                 + ((int64_t)a[ 9]) * b[13]
                 + ((int64_t)a[10]) * b[12]
                 + ((int64_t)a[11]) * b[11]
                 + ((int64_t)a[12]) * b[10]
                 + ((int64_t)a[13]) * b[ 9]
                 + ((int64_t)a[14]) * b[ 8];
    int64_t t23  = ((int64_t)a[ 9]) * b[14]
                 + ((int64_t)a[10]) * b[13]
                 + ((int64_t)a[11]) * b[12]
                 + ((int64_t)a[12]) * b[11]
                 + ((int64_t)a[13]) * b[10]
                 + ((int64_t)a[14]) * b[ 9];
    int64_t t24  = ((int64_t)a[10]) * b[14]
                 + ((int64_t)a[11]) * b[13]
                 + ((int64_t)a[12]) * b[12]
                 + ((int64_t)a[13]) * b[11]
                 + ((int64_t)a[14]) * b[10];
    int64_t t25  = ((int64_t)a[11]) * b[14]
                 + ((int64_t)a[12]) * b[13]
                 + ((int64_t)a[13]) * b[12]
                 + ((int64_t)a[14]) * b[11];
    int64_t t26  = ((int64_t)a[12]) * b[14]
                 + ((int64_t)a[13]) * b[13]
                 + ((int64_t)a[14]) * b[12];
    int64_t t27  = ((int64_t)a[13]) * b[14]
                 + ((int64_t)a[14]) * b[13];
    int64_t t28  = ((int64_t)a[14]) * b[14];

    t1   += t0  >> 23; r[ 0] = t0  & 0x7fffff;
    t2   += t1  >> 23; r[ 1] = t1  & 0x7fffff;
    t3   += t2  >> 23; r[ 2] = t2  & 0x7fffff;
    t4   += t3  >> 23; r[ 3] = t3  & 0x7fffff;
    t5   += t4  >> 23; r[ 4] = t4  & 0x7fffff;
    t6   += t5  >> 23; r[ 5] = t5  & 0x7fffff;
    t7   += t6  >> 23; r[ 6] = t6  & 0x7fffff;
    t8   += t7  >> 23; r[ 7] = t7  & 0x7fffff;
    t9   += t8  >> 23; r[ 8] = t8  & 0x7fffff;
    t10  += t9  >> 23; r[ 9] = t9  & 0x7fffff;
    t11  += t10 >> 23; r[10] = t10 & 0x7fffff;
    t12  += t11 >> 23; r[11] = t11 & 0x7fffff;
    t13  += t12 >> 23; r[12] = t12 & 0x7fffff;
    t14  += t13 >> 23; r[13] = t13 & 0x7fffff;
    t15  += t14 >> 23; r[14] = t14 & 0x7fffff;
    t16  += t15 >> 23; r[15] = t15 & 0x7fffff;
    t17  += t16 >> 23; r[16] = t16 & 0x7fffff;
    t18  += t17 >> 23; r[17] = t17 & 0x7fffff;
    t19  += t18 >> 23; r[18] = t18 & 0x7fffff;
    t20  += t19 >> 23; r[19] = t19 & 0x7fffff;
    t21  += t20 >> 23; r[20] = t20 & 0x7fffff;
    t22  += t21 >> 23; r[21] = t21 & 0x7fffff;
    t23  += t22 >> 23; r[22] = t22 & 0x7fffff;
    t24  += t23 >> 23; r[23] = t23 & 0x7fffff;
    t25  += t24 >> 23; r[24] = t24 & 0x7fffff;
    t26  += t25 >> 23; r[25] = t25 & 0x7fffff;
    t27  += t26 >> 23; r[26] = t26 & 0x7fffff;
    t28  += t27 >> 23; r[27] = t27 & 0x7fffff;
    r[29] = (sp_digit)(t28 >> 23);
                       r[28] = t28 & 0x7fffff;
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_2048_sqr_15(sp_digit* r, const sp_digit* a)
{
    int64_t t0   =  ((int64_t)a[ 0]) * a[ 0];
    int64_t t1   = (((int64_t)a[ 0]) * a[ 1]) * 2;
    int64_t t2   = (((int64_t)a[ 0]) * a[ 2]) * 2
                 +  ((int64_t)a[ 1]) * a[ 1];
    int64_t t3   = (((int64_t)a[ 0]) * a[ 3]
                 +  ((int64_t)a[ 1]) * a[ 2]) * 2;
    int64_t t4   = (((int64_t)a[ 0]) * a[ 4]
                 +  ((int64_t)a[ 1]) * a[ 3]) * 2
                 +  ((int64_t)a[ 2]) * a[ 2];
    int64_t t5   = (((int64_t)a[ 0]) * a[ 5]
                 +  ((int64_t)a[ 1]) * a[ 4]
                 +  ((int64_t)a[ 2]) * a[ 3]) * 2;
    int64_t t6   = (((int64_t)a[ 0]) * a[ 6]
                 +  ((int64_t)a[ 1]) * a[ 5]
                 +  ((int64_t)a[ 2]) * a[ 4]) * 2
                 +  ((int64_t)a[ 3]) * a[ 3];
    int64_t t7   = (((int64_t)a[ 0]) * a[ 7]
                 +  ((int64_t)a[ 1]) * a[ 6]
                 +  ((int64_t)a[ 2]) * a[ 5]
                 +  ((int64_t)a[ 3]) * a[ 4]) * 2;
    int64_t t8   = (((int64_t)a[ 0]) * a[ 8]
                 +  ((int64_t)a[ 1]) * a[ 7]
                 +  ((int64_t)a[ 2]) * a[ 6]
                 +  ((int64_t)a[ 3]) * a[ 5]) * 2
                 +  ((int64_t)a[ 4]) * a[ 4];
    int64_t t9   = (((int64_t)a[ 0]) * a[ 9]
                 +  ((int64_t)a[ 1]) * a[ 8]
                 +  ((int64_t)a[ 2]) * a[ 7]
                 +  ((int64_t)a[ 3]) * a[ 6]
                 +  ((int64_t)a[ 4]) * a[ 5]) * 2;
    int64_t t10  = (((int64_t)a[ 0]) * a[10]
                 +  ((int64_t)a[ 1]) * a[ 9]
                 +  ((int64_t)a[ 2]) * a[ 8]
                 +  ((int64_t)a[ 3]) * a[ 7]
                 +  ((int64_t)a[ 4]) * a[ 6]) * 2
                 +  ((int64_t)a[ 5]) * a[ 5];
    int64_t t11  = (((int64_t)a[ 0]) * a[11]
                 +  ((int64_t)a[ 1]) * a[10]
                 +  ((int64_t)a[ 2]) * a[ 9]
                 +  ((int64_t)a[ 3]) * a[ 8]
                 +  ((int64_t)a[ 4]) * a[ 7]
                 +  ((int64_t)a[ 5]) * a[ 6]) * 2;
    int64_t t12  = (((int64_t)a[ 0]) * a[12]
                 +  ((int64_t)a[ 1]) * a[11]
                 +  ((int64_t)a[ 2]) * a[10]
                 +  ((int64_t)a[ 3]) * a[ 9]
                 +  ((int64_t)a[ 4]) * a[ 8]
                 +  ((int64_t)a[ 5]) * a[ 7]) * 2
                 +  ((int64_t)a[ 6]) * a[ 6];
    int64_t t13  = (((int64_t)a[ 0]) * a[13]
                 +  ((int64_t)a[ 1]) * a[12]
                 +  ((int64_t)a[ 2]) * a[11]
                 +  ((int64_t)a[ 3]) * a[10]
                 +  ((int64_t)a[ 4]) * a[ 9]
                 +  ((int64_t)a[ 5]) * a[ 8]
                 +  ((int64_t)a[ 6]) * a[ 7]) * 2;
    int64_t t14  = (((int64_t)a[ 0]) * a[14]
                 +  ((int64_t)a[ 1]) * a[13]
                 +  ((int64_t)a[ 2]) * a[12]
                 +  ((int64_t)a[ 3]) * a[11]
                 +  ((int64_t)a[ 4]) * a[10]
                 +  ((int64_t)a[ 5]) * a[ 9]
                 +  ((int64_t)a[ 6]) * a[ 8]) * 2
                 +  ((int64_t)a[ 7]) * a[ 7];
    int64_t t15  = (((int64_t)a[ 1]) * a[14]
                 +  ((int64_t)a[ 2]) * a[13]
                 +  ((int64_t)a[ 3]) * a[12]
                 +  ((int64_t)a[ 4]) * a[11]
                 +  ((int64_t)a[ 5]) * a[10]
                 +  ((int64_t)a[ 6]) * a[ 9]
                 +  ((int64_t)a[ 7]) * a[ 8]) * 2;
    int64_t t16  = (((int64_t)a[ 2]) * a[14]
                 +  ((int64_t)a[ 3]) * a[13]
                 +  ((int64_t)a[ 4]) * a[12]
                 +  ((int64_t)a[ 5]) * a[11]
                 +  ((int64_t)a[ 6]) * a[10]
                 +  ((int64_t)a[ 7]) * a[ 9]) * 2
                 +  ((int64_t)a[ 8]) * a[ 8];
    int64_t t17  = (((int64_t)a[ 3]) * a[14]
                 +  ((int64_t)a[ 4]) * a[13]
                 +  ((int64_t)a[ 5]) * a[12]
                 +  ((int64_t)a[ 6]) * a[11]
                 +  ((int64_t)a[ 7]) * a[10]
                 +  ((int64_t)a[ 8]) * a[ 9]) * 2;
    int64_t t18  = (((int64_t)a[ 4]) * a[14]
                 +  ((int64_t)a[ 5]) * a[13]
                 +  ((int64_t)a[ 6]) * a[12]
                 +  ((int64_t)a[ 7]) * a[11]
                 +  ((int64_t)a[ 8]) * a[10]) * 2
                 +  ((int64_t)a[ 9]) * a[ 9];
    int64_t t19  = (((int64_t)a[ 5]) * a[14]
                 +  ((int64_t)a[ 6]) * a[13]
                 +  ((int64_t)a[ 7]) * a[12]
                 +  ((int64_t)a[ 8]) * a[11]
                 +  ((int64_t)a[ 9]) * a[10]) * 2;
    int64_t t20  = (((int64_t)a[ 6]) * a[14]
                 +  ((int64_t)a[ 7]) * a[13]
                 +  ((int64_t)a[ 8]) * a[12]
                 +  ((int64_t)a[ 9]) * a[11]) * 2
                 +  ((int64_t)a[10]) * a[10];
    int64_t t21  = (((int64_t)a[ 7]) * a[14]
                 +  ((int64_t)a[ 8]) * a[13]
                 +  ((int64_t)a[ 9]) * a[12]
                 +  ((int64_t)a[10]) * a[11]) * 2;
    int64_t t22  = (((int64_t)a[ 8]) * a[14]
                 +  ((int64_t)a[ 9]) * a[13]
                 +  ((int64_t)a[10]) * a[12]) * 2
                 +  ((int64_t)a[11]) * a[11];
    int64_t t23  = (((int64_t)a[ 9]) * a[14]
                 +  ((int64_t)a[10]) * a[13]
                 +  ((int64_t)a[11]) * a[12]) * 2;
    int64_t t24  = (((int64_t)a[10]) * a[14]
                 +  ((int64_t)a[11]) * a[13]) * 2
                 +  ((int64_t)a[12]) * a[12];
    int64_t t25  = (((int64_t)a[11]) * a[14]
                 +  ((int64_t)a[12]) * a[13]) * 2;
    int64_t t26  = (((int64_t)a[12]) * a[14]) * 2
                 +  ((int64_t)a[13]) * a[13];
    int64_t t27  = (((int64_t)a[13]) * a[14]) * 2;
    int64_t t28  =  ((int64_t)a[14]) * a[14];

    t1   += t0  >> 23; r[ 0] = t0  & 0x7fffff;
    t2   += t1  >> 23; r[ 1] = t1  & 0x7fffff;
    t3   += t2  >> 23; r[ 2] = t2  & 0x7fffff;
    t4   += t3  >> 23; r[ 3] = t3  & 0x7fffff;
    t5   += t4  >> 23; r[ 4] = t4  & 0x7fffff;
    t6   += t5  >> 23; r[ 5] = t5  & 0x7fffff;
    t7   += t6  >> 23; r[ 6] = t6  & 0x7fffff;
    t8   += t7  >> 23; r[ 7] = t7  & 0x7fffff;
    t9   += t8  >> 23; r[ 8] = t8  & 0x7fffff;
    t10  += t9  >> 23; r[ 9] = t9  & 0x7fffff;
    t11  += t10 >> 23; r[10] = t10 & 0x7fffff;
    t12  += t11 >> 23; r[11] = t11 & 0x7fffff;
    t13  += t12 >> 23; r[12] = t12 & 0x7fffff;
    t14  += t13 >> 23; r[13] = t13 & 0x7fffff;
    t15  += t14 >> 23; r[14] = t14 & 0x7fffff;
    t16  += t15 >> 23; r[15] = t15 & 0x7fffff;
    t17  += t16 >> 23; r[16] = t16 & 0x7fffff;
    t18  += t17 >> 23; r[17] = t17 & 0x7fffff;
    t19  += t18 >> 23; r[18] = t18 & 0x7fffff;
    t20  += t19 >> 23; r[19] = t19 & 0x7fffff;
    t21  += t20 >> 23; r[20] = t20 & 0x7fffff;
    t22  += t21 >> 23; r[21] = t21 & 0x7fffff;
    t23  += t22 >> 23; r[22] = t22 & 0x7fffff;
    t24  += t23 >> 23; r[23] = t23 & 0x7fffff;
    t25  += t24 >> 23; r[24] = t24 & 0x7fffff;
    t26  += t25 >> 23; r[25] = t25 & 0x7fffff;
    t27  += t26 >> 23; r[26] = t26 & 0x7fffff;
    t28  += t27 >> 23; r[27] = t27 & 0x7fffff;
    r[29] = (sp_digit)(t28 >> 23);
                       r[28] = t28 & 0x7fffff;
}

/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_add_15(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    r[ 0] = a[ 0] + b[ 0];
    r[ 1] = a[ 1] + b[ 1];
    r[ 2] = a[ 2] + b[ 2];
    r[ 3] = a[ 3] + b[ 3];
    r[ 4] = a[ 4] + b[ 4];
    r[ 5] = a[ 5] + b[ 5];
    r[ 6] = a[ 6] + b[ 6];
    r[ 7] = a[ 7] + b[ 7];
    r[ 8] = a[ 8] + b[ 8];
    r[ 9] = a[ 9] + b[ 9];
    r[10] = a[10] + b[10];
    r[11] = a[11] + b[11];
    r[12] = a[12] + b[12];
    r[13] = a[13] + b[13];
    r[14] = a[14] + b[14];

    return 0;
}

/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_sub_30(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 24; i += 8) {
        r[i + 0] = a[i + 0] - b[i + 0];
        r[i + 1] = a[i + 1] - b[i + 1];
        r[i + 2] = a[i + 2] - b[i + 2];
        r[i + 3] = a[i + 3] - b[i + 3];
        r[i + 4] = a[i + 4] - b[i + 4];
        r[i + 5] = a[i + 5] - b[i + 5];
        r[i + 6] = a[i + 6] - b[i + 6];
        r[i + 7] = a[i + 7] - b[i + 7];
    }
    r[24] = a[24] - b[24];
    r[25] = a[25] - b[25];
    r[26] = a[26] - b[26];
    r[27] = a[27] - b[27];
    r[28] = a[28] - b[28];
    r[29] = a[29] - b[29];

    return 0;
}

/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_add_30(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 24; i += 8) {
        r[i + 0] = a[i + 0] + b[i + 0];
        r[i + 1] = a[i + 1] + b[i + 1];
        r[i + 2] = a[i + 2] + b[i + 2];
        r[i + 3] = a[i + 3] + b[i + 3];
        r[i + 4] = a[i + 4] + b[i + 4];
        r[i + 5] = a[i + 5] + b[i + 5];
        r[i + 6] = a[i + 6] + b[i + 6];
        r[i + 7] = a[i + 7] + b[i + 7];
    }
    r[24] = a[24] + b[24];
    r[25] = a[25] + b[25];
    r[26] = a[26] + b[26];
    r[27] = a[27] + b[27];
    r[28] = a[28] + b[28];
    r[29] = a[29] + b[29];

    return 0;
}

/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_2048_mul_45(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    sp_digit p0[30];
    sp_digit p1[30];
    sp_digit p2[30];
    sp_digit p3[30];
    sp_digit p4[30];
    sp_digit p5[30];
    sp_digit t0[30];
    sp_digit t1[30];
    sp_digit t2[30];
    sp_digit a0[15];
    sp_digit a1[15];
    sp_digit a2[15];
    sp_digit b0[15];
    sp_digit b1[15];
    sp_digit b2[15];
    (void)sp_2048_add_15(a0, a, &a[15]);
    (void)sp_2048_add_15(b0, b, &b[15]);
    (void)sp_2048_add_15(a1, &a[15], &a[30]);
    (void)sp_2048_add_15(b1, &b[15], &b[30]);
    (void)sp_2048_add_15(a2, a0, &a[30]);
    (void)sp_2048_add_15(b2, b0, &b[30]);
    sp_2048_mul_15(p0, a, b);
    sp_2048_mul_15(p2, &a[15], &b[15]);
    sp_2048_mul_15(p4, &a[30], &b[30]);
    sp_2048_mul_15(p1, a0, b0);
    sp_2048_mul_15(p3, a1, b1);
    sp_2048_mul_15(p5, a2, b2);
    XMEMSET(r, 0, sizeof(*r)*2U*45U);
    (void)sp_2048_sub_30(t0, p3, p2);
    (void)sp_2048_sub_30(t1, p1, p2);
    (void)sp_2048_sub_30(t2, p5, t0);
    (void)sp_2048_sub_30(t2, t2, t1);
    (void)sp_2048_sub_30(t0, t0, p4);
    (void)sp_2048_sub_30(t1, t1, p0);
    (void)sp_2048_add_30(r, r, p0);
    (void)sp_2048_add_30(&r[15], &r[15], t1);
    (void)sp_2048_add_30(&r[30], &r[30], t2);
    (void)sp_2048_add_30(&r[45], &r[45], t0);
    (void)sp_2048_add_30(&r[60], &r[60], p4);
}

/* Square a into r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_2048_sqr_45(sp_digit* r, const sp_digit* a)
{
    sp_digit p0[30];
    sp_digit p1[30];
    sp_digit p2[30];
    sp_digit p3[30];
    sp_digit p4[30];
    sp_digit p5[30];
    sp_digit t0[30];
    sp_digit t1[30];
    sp_digit t2[30];
    sp_digit a0[15];
    sp_digit a1[15];
    sp_digit a2[15];
    (void)sp_2048_add_15(a0, a, &a[15]);
    (void)sp_2048_add_15(a1, &a[15], &a[30]);
    (void)sp_2048_add_15(a2, a0, &a[30]);
    sp_2048_sqr_15(p0, a);
    sp_2048_sqr_15(p2, &a[15]);
    sp_2048_sqr_15(p4, &a[30]);
    sp_2048_sqr_15(p1, a0);
    sp_2048_sqr_15(p3, a1);
    sp_2048_sqr_15(p5, a2);
    XMEMSET(r, 0, sizeof(*r)*2U*45U);
    (void)sp_2048_sub_30(t0, p3, p2);
    (void)sp_2048_sub_30(t1, p1, p2);
    (void)sp_2048_sub_30(t2, p5, t0);
    (void)sp_2048_sub_30(t2, t2, t1);
    (void)sp_2048_sub_30(t0, t0, p4);
    (void)sp_2048_sub_30(t1, t1, p0);
    (void)sp_2048_add_30(r, r, p0);
    (void)sp_2048_add_30(&r[15], &r[15], t1);
    (void)sp_2048_add_30(&r[30], &r[30], t2);
    (void)sp_2048_add_30(&r[45], &r[45], t0);
    (void)sp_2048_add_30(&r[60], &r[60], p4);
}

/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_add_45(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 40; i += 8) {
        r[i + 0] = a[i + 0] + b[i + 0];
        r[i + 1] = a[i + 1] + b[i + 1];
        r[i + 2] = a[i + 2] + b[i + 2];
        r[i + 3] = a[i + 3] + b[i + 3];
        r[i + 4] = a[i + 4] + b[i + 4];
        r[i + 5] = a[i + 5] + b[i + 5];
        r[i + 6] = a[i + 6] + b[i + 6];
        r[i + 7] = a[i + 7] + b[i + 7];
    }
    r[40] = a[40] + b[40];
    r[41] = a[41] + b[41];
    r[42] = a[42] + b[42];
    r[43] = a[43] + b[43];
    r[44] = a[44] + b[44];

    return 0;
}

/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_add_90(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 88; i += 8) {
        r[i + 0] = a[i + 0] + b[i + 0];
        r[i + 1] = a[i + 1] + b[i + 1];
        r[i + 2] = a[i + 2] + b[i + 2];
        r[i + 3] = a[i + 3] + b[i + 3];
        r[i + 4] = a[i + 4] + b[i + 4];
        r[i + 5] = a[i + 5] + b[i + 5];
        r[i + 6] = a[i + 6] + b[i + 6];
        r[i + 7] = a[i + 7] + b[i + 7];
    }
    r[88] = a[88] + b[88];
    r[89] = a[89] + b[89];

    return 0;
}

/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_sub_90(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 88; i += 8) {
        r[i + 0] = a[i + 0] - b[i + 0];
        r[i + 1] = a[i + 1] - b[i + 1];
        r[i + 2] = a[i + 2] - b[i + 2];
        r[i + 3] = a[i + 3] - b[i + 3];
        r[i + 4] = a[i + 4] - b[i + 4];
        r[i + 5] = a[i + 5] - b[i + 5];
        r[i + 6] = a[i + 6] - b[i + 6];
        r[i + 7] = a[i + 7] - b[i + 7];
    }
    r[88] = a[88] - b[88];
    r[89] = a[89] - b[89];

    return 0;
}

/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_2048_mul_90(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    sp_digit* z0 = r;
    sp_digit z1[90];
    sp_digit* a1 = z1;
    sp_digit b1[45];
    sp_digit* z2 = r + 90;
    (void)sp_2048_add_45(a1, a, &a[45]);
    (void)sp_2048_add_45(b1, b, &b[45]);
    sp_2048_mul_45(z2, &a[45], &b[45]);
    sp_2048_mul_45(z0, a, b);
    sp_2048_mul_45(z1, a1, b1);
    (void)sp_2048_sub_90(z1, z1, z2);
    (void)sp_2048_sub_90(z1, z1, z0);
    (void)sp_2048_add_90(r + 45, r + 45, z1);
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_2048_sqr_90(sp_digit* r, const sp_digit* a)
{
    sp_digit* z0 = r;
    sp_digit z1[90];
    sp_digit* a1 = z1;
    sp_digit* z2 = r + 90;
    (void)sp_2048_add_45(a1, a, &a[45]);
    sp_2048_sqr_45(z2, &a[45]);
    sp_2048_sqr_45(z0, a);
    sp_2048_sqr_45(z1, a1);
    (void)sp_2048_sub_90(z1, z1, z2);
    (void)sp_2048_sub_90(z1, z1, z0);
    (void)sp_2048_add_90(r + 45, r + 45, z1);
}

#endif /* !WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_add_90(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 90; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_sub_90(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 90; i++) {
        r[i] = a[i] - b[i];
    }

    return 0;
}

#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_2048_mul_90(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[89]) * b[89];
    r[179] = (sp_digit)(c >> 23);
    c = (c & 0x7fffff) << 23;
    for (k = 177; k >= 0; k--) {
        for (i = 89; i >= 0; i--) {
            j = k - i;
            if (j >= 90) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * b[j];
        }
        r[k + 2] += c >> 46;
        r[k + 1] = (c >> 23) & 0x7fffff;
        c = (c & 0x7fffff) << 23;
    }
    r[0] = (sp_digit)(c >> 23);
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_2048_sqr_90(sp_digit* r, const sp_digit* a)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[89]) * a[89];
    r[179] = (sp_digit)(c >> 23);
    c = (c & 0x7fffff) << 23;
    for (k = 177; k >= 0; k--) {
        for (i = 89; i >= 0; i--) {
            j = k - i;
            if (j >= 90 || i <= j) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * a[j] * 2;
        }
        if (i == j) {
           c += ((int64_t)a[i]) * a[i];
        }

        r[k + 2] += c >> 46;
        r[k + 1] = (c >> 23) & 0x7fffff;
        c = (c & 0x7fffff) << 23;
    }
    r[0] = (sp_digit)(c >> 23);
}

#endif /* WOLFSSL_SP_SMALL */
#if (defined(WOLFSSL_HAVE_SP_RSA) || defined(WOLFSSL_HAVE_SP_DH)) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)
#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_add_45(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 45; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_sub_45(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 45; i++) {
        r[i] = a[i] - b[i];
    }

    return 0;
}

#else
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_sub_45(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 40; i += 8) {
        r[i + 0] = a[i + 0] - b[i + 0];
        r[i + 1] = a[i + 1] - b[i + 1];
        r[i + 2] = a[i + 2] - b[i + 2];
        r[i + 3] = a[i + 3] - b[i + 3];
        r[i + 4] = a[i + 4] - b[i + 4];
        r[i + 5] = a[i + 5] - b[i + 5];
        r[i + 6] = a[i + 6] - b[i + 6];
        r[i + 7] = a[i + 7] - b[i + 7];
    }
    r[40] = a[40] - b[40];
    r[41] = a[41] - b[41];
    r[42] = a[42] - b[42];
    r[43] = a[43] - b[43];
    r[44] = a[44] - b[44];

    return 0;
}

#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_2048_mul_45(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[44]) * b[44];
    r[89] = (sp_digit)(c >> 23);
    c = (c & 0x7fffff) << 23;
    for (k = 87; k >= 0; k--) {
        for (i = 44; i >= 0; i--) {
            j = k - i;
            if (j >= 45) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * b[j];
        }
        r[k + 2] += c >> 46;
        r[k + 1] = (c >> 23) & 0x7fffff;
        c = (c & 0x7fffff) << 23;
    }
    r[0] = (sp_digit)(c >> 23);
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_2048_sqr_45(sp_digit* r, const sp_digit* a)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[44]) * a[44];
    r[89] = (sp_digit)(c >> 23);
    c = (c & 0x7fffff) << 23;
    for (k = 87; k >= 0; k--) {
        for (i = 44; i >= 0; i--) {
            j = k - i;
            if (j >= 45 || i <= j) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * a[j] * 2;
        }
        if (i == j) {
           c += ((int64_t)a[i]) * a[i];
        }

        r[k + 2] += c >> 46;
        r[k + 1] = (c >> 23) & 0x7fffff;
        c = (c & 0x7fffff) << 23;
    }
    r[0] = (sp_digit)(c >> 23);
}

#endif /* WOLFSSL_SP_SMALL */
#endif /* (WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH) & !WOLFSSL_RSA_PUBLIC_ONLY */

/* Caclulate the bottom digit of -1/a mod 2^n.
 *
 * a    A single precision number.
 * rho  Bottom word of inverse.
 */
static void sp_2048_mont_setup(const sp_digit* a, sp_digit* rho)
{
    sp_digit x;
    sp_digit b;

    b = a[0];
    x = (((b + 2) & 4) << 1) + b; /* here x*a==1 mod 2**4 */
    x *= 2 - b * x;               /* here x*a==1 mod 2**8 */
    x *= 2 - b * x;               /* here x*a==1 mod 2**16 */
    x *= 2 - b * x;               /* here x*a==1 mod 2**32 */
    x &= 0x7fffff;

    /* rho = -1/m mod b */
    *rho = (1L << 23) - x;
}

/* Multiply a by scalar b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_2048_mul_d_90(sp_digit* r, const sp_digit* a,
    sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 90; i++) {
        t += tb * a[i];
        r[i] = t & 0x7fffff;
        t >>= 23;
    }
    r[90] = (sp_digit)t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] = t[0] & 0x7fffff;
    for (i = 0; i < 88; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] = (sp_digit)(t[0] >> 23) + (t[1] & 0x7fffff);
        t[2] = tb * a[i+2];
        r[i+2] = (sp_digit)(t[1] >> 23) + (t[2] & 0x7fffff);
        t[3] = tb * a[i+3];
        r[i+3] = (sp_digit)(t[2] >> 23) + (t[3] & 0x7fffff);
        t[4] = tb * a[i+4];
        r[i+4] = (sp_digit)(t[3] >> 23) + (t[4] & 0x7fffff);
        t[5] = tb * a[i+5];
        r[i+5] = (sp_digit)(t[4] >> 23) + (t[5] & 0x7fffff);
        t[6] = tb * a[i+6];
        r[i+6] = (sp_digit)(t[5] >> 23) + (t[6] & 0x7fffff);
        t[7] = tb * a[i+7];
        r[i+7] = (sp_digit)(t[6] >> 23) + (t[7] & 0x7fffff);
        t[0] = tb * a[i+8];
        r[i+8] = (sp_digit)(t[7] >> 23) + (t[0] & 0x7fffff);
    }
    t[1] = tb * a[89];
    r[89] = (sp_digit)(t[0] >> 23) + (t[1] & 0x7fffff);
    r[90] =  (sp_digit)(t[1] >> 23);
#endif /* WOLFSSL_SP_SMALL */
}

#if (defined(WOLFSSL_HAVE_SP_RSA) || defined(WOLFSSL_HAVE_SP_DH)) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)
/* r = 2^n mod m where n is the number of bits to reduce by.
 * Given m must be 2048 bits, just need to subtract.
 *
 * r  A single precision number.
 * m  A single precision number.
 */
static void sp_2048_mont_norm_45(sp_digit* r, const sp_digit* m)
{
    /* Set r = 2^n - 1. */
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=0; i<44; i++) {
        r[i] = 0x7fffff;
    }
#else
    int i;

    for (i = 0; i < 40; i += 8) {
        r[i + 0] = 0x7fffff;
        r[i + 1] = 0x7fffff;
        r[i + 2] = 0x7fffff;
        r[i + 3] = 0x7fffff;
        r[i + 4] = 0x7fffff;
        r[i + 5] = 0x7fffff;
        r[i + 6] = 0x7fffff;
        r[i + 7] = 0x7fffff;
    }
    r[40] = 0x7fffff;
    r[41] = 0x7fffff;
    r[42] = 0x7fffff;
    r[43] = 0x7fffff;
#endif
    r[44] = 0xfffL;

    /* r = (2^n - 1) mod n */
    (void)sp_2048_sub_45(r, r, m);

    /* Add one so r = 2^n mod m */
    r[0] += 1;
}

/* Compare a with b in constant time.
 *
 * a  A single precision integer.
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
static sp_digit sp_2048_cmp_45(const sp_digit* a, const sp_digit* b)
{
    sp_digit r = 0;
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=44; i>=0; i--) {
        r |= (a[i] - b[i]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#else
    int i;

    r |= (a[44] - b[44]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[43] - b[43]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[42] - b[42]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[41] - b[41]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[40] - b[40]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    for (i = 32; i >= 0; i -= 8) {
        r |= (a[i + 7] - b[i + 7]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 6] - b[i + 6]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 5] - b[i + 5]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 4] - b[i + 4]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 3] - b[i + 3]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 2] - b[i + 2]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 1] - b[i + 1]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 0] - b[i + 0]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#endif /* WOLFSSL_SP_SMALL */

    return r;
}

/* Conditionally subtract b from a using the mask m.
 * m is -1 to subtract and 0 when not.
 *
 * r  A single precision number representing condition subtract result.
 * a  A single precision number to subtract from.
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
static void sp_2048_cond_sub_45(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 45; i++) {
        r[i] = a[i] - (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 40; i += 8) {
        r[i + 0] = a[i + 0] - (b[i + 0] & m);
        r[i + 1] = a[i + 1] - (b[i + 1] & m);
        r[i + 2] = a[i + 2] - (b[i + 2] & m);
        r[i + 3] = a[i + 3] - (b[i + 3] & m);
        r[i + 4] = a[i + 4] - (b[i + 4] & m);
        r[i + 5] = a[i + 5] - (b[i + 5] & m);
        r[i + 6] = a[i + 6] - (b[i + 6] & m);
        r[i + 7] = a[i + 7] - (b[i + 7] & m);
    }
    r[40] = a[40] - (b[40] & m);
    r[41] = a[41] - (b[41] & m);
    r[42] = a[42] - (b[42] & m);
    r[43] = a[43] - (b[43] & m);
    r[44] = a[44] - (b[44] & m);
#endif /* WOLFSSL_SP_SMALL */
}

/* Mul a by scalar b and add into r. (r += a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_2048_mul_add_45(sp_digit* r, const sp_digit* a,
        const sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 45; i++) {
        t += (tb * a[i]) + r[i];
        r[i] = t & 0x7fffff;
        t >>= 23;
    }
    r[45] += t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] += (sp_digit)(t[0] & 0x7fffff);
    for (i = 0; i < 40; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] += (sp_digit)((t[0] >> 23) + (t[1] & 0x7fffff));
        t[2] = tb * a[i+2];
        r[i+2] += (sp_digit)((t[1] >> 23) + (t[2] & 0x7fffff));
        t[3] = tb * a[i+3];
        r[i+3] += (sp_digit)((t[2] >> 23) + (t[3] & 0x7fffff));
        t[4] = tb * a[i+4];
        r[i+4] += (sp_digit)((t[3] >> 23) + (t[4] & 0x7fffff));
        t[5] = tb * a[i+5];
        r[i+5] += (sp_digit)((t[4] >> 23) + (t[5] & 0x7fffff));
        t[6] = tb * a[i+6];
        r[i+6] += (sp_digit)((t[5] >> 23) + (t[6] & 0x7fffff));
        t[7] = tb * a[i+7];
        r[i+7] += (sp_digit)((t[6] >> 23) + (t[7] & 0x7fffff));
        t[0] = tb * a[i+8];
        r[i+8] += (sp_digit)((t[7] >> 23) + (t[0] & 0x7fffff));
    }
    t[1] = tb * a[41]; r[41] += (sp_digit)((t[0] >> 23) + (t[1] & 0x7fffff));
    t[2] = tb * a[42]; r[42] += (sp_digit)((t[1] >> 23) + (t[2] & 0x7fffff));
    t[3] = tb * a[43]; r[43] += (sp_digit)((t[2] >> 23) + (t[3] & 0x7fffff));
    t[4] = tb * a[44]; r[44] += (sp_digit)((t[3] >> 23) + (t[4] & 0x7fffff));
    r[45] +=  (sp_digit)(t[4] >> 23);
#endif /* WOLFSSL_SP_SMALL */
}

/* Normalize the values in each word to 23.
 *
 * a  Array of sp_digit to normalize.
 */
static void sp_2048_norm_45(sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    for (i = 0; i < 44; i++) {
        a[i+1] += a[i] >> 23;
        a[i] &= 0x7fffff;
    }
#else
    int i;
    for (i = 0; i < 40; i += 8) {
        a[i+1] += a[i+0] >> 23; a[i+0] &= 0x7fffff;
        a[i+2] += a[i+1] >> 23; a[i+1] &= 0x7fffff;
        a[i+3] += a[i+2] >> 23; a[i+2] &= 0x7fffff;
        a[i+4] += a[i+3] >> 23; a[i+3] &= 0x7fffff;
        a[i+5] += a[i+4] >> 23; a[i+4] &= 0x7fffff;
        a[i+6] += a[i+5] >> 23; a[i+5] &= 0x7fffff;
        a[i+7] += a[i+6] >> 23; a[i+6] &= 0x7fffff;
        a[i+8] += a[i+7] >> 23; a[i+7] &= 0x7fffff;
        a[i+9] += a[i+8] >> 23; a[i+8] &= 0x7fffff;
    }
    a[40+1] += a[40] >> 23;
    a[40] &= 0x7fffff;
    a[41+1] += a[41] >> 23;
    a[41] &= 0x7fffff;
    a[42+1] += a[42] >> 23;
    a[42] &= 0x7fffff;
    a[43+1] += a[43] >> 23;
    a[43] &= 0x7fffff;
#endif
}

/* Shift the result in the high 1024 bits down to the bottom.
 *
 * r  A single precision number.
 * a  A single precision number.
 */
static void sp_2048_mont_shift_45(sp_digit* r, const sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    int64_t n = a[44] >> 12;
    n += ((int64_t)a[45]) << 11;

    for (i = 0; i < 44; i++) {
        r[i] = n & 0x7fffff;
        n >>= 23;
        n += ((int64_t)a[46 + i]) << 11;
    }
    r[44] = (sp_digit)n;
#else
    int i;
    int64_t n = a[44] >> 12;
    n += ((int64_t)a[45]) << 11;
    for (i = 0; i < 40; i += 8) {
        r[i + 0] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 46]) << 11;
        r[i + 1] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 47]) << 11;
        r[i + 2] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 48]) << 11;
        r[i + 3] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 49]) << 11;
        r[i + 4] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 50]) << 11;
        r[i + 5] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 51]) << 11;
        r[i + 6] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 52]) << 11;
        r[i + 7] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 53]) << 11;
    }
    r[40] = n & 0x7fffff; n >>= 23; n += ((int64_t)a[86]) << 11;
    r[41] = n & 0x7fffff; n >>= 23; n += ((int64_t)a[87]) << 11;
    r[42] = n & 0x7fffff; n >>= 23; n += ((int64_t)a[88]) << 11;
    r[43] = n & 0x7fffff; n >>= 23; n += ((int64_t)a[89]) << 11;
    r[44] = (sp_digit)n;
#endif /* WOLFSSL_SP_SMALL */
    XMEMSET(&r[45], 0, sizeof(*r) * 45U);
}

/* Reduce the number back to 2048 bits using Montgomery reduction.
 *
 * a   A single precision number to reduce in place.
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
static void sp_2048_mont_reduce_45(sp_digit* a, const sp_digit* m, sp_digit mp)
{
    int i;
    sp_digit mu;

    sp_2048_norm_45(a + 45);

    for (i=0; i<44; i++) {
        mu = (a[i] * mp) & 0x7fffff;
        sp_2048_mul_add_45(a+i, m, mu);
        a[i+1] += a[i] >> 23;
    }
    mu = (a[i] * mp) & 0xfffL;
    sp_2048_mul_add_45(a+i, m, mu);
    a[i+1] += a[i] >> 23;
    a[i] &= 0x7fffff;

    sp_2048_mont_shift_45(a, a);
    sp_2048_cond_sub_45(a, a, m, 0 - (((a[44] >> 12) > 0) ?
            (sp_digit)1 : (sp_digit)0));
    sp_2048_norm_45(a);
}

/* Multiply two Montogmery form numbers mod the modulus (prime).
 * (r = a * b mod m)
 *
 * r   Result of multiplication.
 * a   First number to multiply in Montogmery form.
 * b   Second number to multiply in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_2048_mont_mul_45(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit* m, sp_digit mp)
{
    sp_2048_mul_45(r, a, b);
    sp_2048_mont_reduce_45(r, m, mp);
}

/* Square the Montgomery form number. (r = a * a mod m)
 *
 * r   Result of squaring.
 * a   Number to square in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_2048_mont_sqr_45(sp_digit* r, const sp_digit* a,
        const sp_digit* m, sp_digit mp)
{
    sp_2048_sqr_45(r, a);
    sp_2048_mont_reduce_45(r, m, mp);
}

/* Multiply a by scalar b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_2048_mul_d_45(sp_digit* r, const sp_digit* a,
    sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 45; i++) {
        t += tb * a[i];
        r[i] = t & 0x7fffff;
        t >>= 23;
    }
    r[45] = (sp_digit)t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] = t[0] & 0x7fffff;
    for (i = 0; i < 40; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] = (sp_digit)(t[0] >> 23) + (t[1] & 0x7fffff);
        t[2] = tb * a[i+2];
        r[i+2] = (sp_digit)(t[1] >> 23) + (t[2] & 0x7fffff);
        t[3] = tb * a[i+3];
        r[i+3] = (sp_digit)(t[2] >> 23) + (t[3] & 0x7fffff);
        t[4] = tb * a[i+4];
        r[i+4] = (sp_digit)(t[3] >> 23) + (t[4] & 0x7fffff);
        t[5] = tb * a[i+5];
        r[i+5] = (sp_digit)(t[4] >> 23) + (t[5] & 0x7fffff);
        t[6] = tb * a[i+6];
        r[i+6] = (sp_digit)(t[5] >> 23) + (t[6] & 0x7fffff);
        t[7] = tb * a[i+7];
        r[i+7] = (sp_digit)(t[6] >> 23) + (t[7] & 0x7fffff);
        t[0] = tb * a[i+8];
        r[i+8] = (sp_digit)(t[7] >> 23) + (t[0] & 0x7fffff);
    }
    t[1] = tb * a[41];
    r[41] = (sp_digit)(t[0] >> 23) + (t[1] & 0x7fffff);
    t[2] = tb * a[42];
    r[42] = (sp_digit)(t[1] >> 23) + (t[2] & 0x7fffff);
    t[3] = tb * a[43];
    r[43] = (sp_digit)(t[2] >> 23) + (t[3] & 0x7fffff);
    t[4] = tb * a[44];
    r[44] = (sp_digit)(t[3] >> 23) + (t[4] & 0x7fffff);
    r[45] =  (sp_digit)(t[4] >> 23);
#endif /* WOLFSSL_SP_SMALL */
}

/* Conditionally add a and b using the mask m.
 * m is -1 to add and 0 when not.
 *
 * r  A single precision number representing conditional add result.
 * a  A single precision number to add with.
 * b  A single precision number to add.
 * m  Mask value to apply.
 */
static void sp_2048_cond_add_45(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 45; i++) {
        r[i] = a[i] + (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 40; i += 8) {
        r[i + 0] = a[i + 0] + (b[i + 0] & m);
        r[i + 1] = a[i + 1] + (b[i + 1] & m);
        r[i + 2] = a[i + 2] + (b[i + 2] & m);
        r[i + 3] = a[i + 3] + (b[i + 3] & m);
        r[i + 4] = a[i + 4] + (b[i + 4] & m);
        r[i + 5] = a[i + 5] + (b[i + 5] & m);
        r[i + 6] = a[i + 6] + (b[i + 6] & m);
        r[i + 7] = a[i + 7] + (b[i + 7] & m);
    }
    r[40] = a[40] + (b[40] & m);
    r[41] = a[41] + (b[41] & m);
    r[42] = a[42] + (b[42] & m);
    r[43] = a[43] + (b[43] & m);
    r[44] = a[44] + (b[44] & m);
#endif /* WOLFSSL_SP_SMALL */
}

#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_add_45(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 45; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#endif
SP_NOINLINE static void sp_2048_rshift_45(sp_digit* r, const sp_digit* a,
        byte n)
{
    int i;

#ifdef WOLFSSL_SP_SMALL
    for (i=0; i<44; i++) {
        r[i] = ((a[i] >> n) | (a[i + 1] << (23 - n))) & 0x7fffff;
    }
#else
    for (i=0; i<40; i += 8) {
        r[i+0] = ((a[i+0] >> n) | (a[i+1] << (23 - n))) & 0x7fffff;
        r[i+1] = ((a[i+1] >> n) | (a[i+2] << (23 - n))) & 0x7fffff;
        r[i+2] = ((a[i+2] >> n) | (a[i+3] << (23 - n))) & 0x7fffff;
        r[i+3] = ((a[i+3] >> n) | (a[i+4] << (23 - n))) & 0x7fffff;
        r[i+4] = ((a[i+4] >> n) | (a[i+5] << (23 - n))) & 0x7fffff;
        r[i+5] = ((a[i+5] >> n) | (a[i+6] << (23 - n))) & 0x7fffff;
        r[i+6] = ((a[i+6] >> n) | (a[i+7] << (23 - n))) & 0x7fffff;
        r[i+7] = ((a[i+7] >> n) | (a[i+8] << (23 - n))) & 0x7fffff;
    }
    r[40] = ((a[40] >> n) | (a[41] << (23 - n))) & 0x7fffff;
    r[41] = ((a[41] >> n) | (a[42] << (23 - n))) & 0x7fffff;
    r[42] = ((a[42] >> n) | (a[43] << (23 - n))) & 0x7fffff;
    r[43] = ((a[43] >> n) | (a[44] << (23 - n))) & 0x7fffff;
#endif
    r[44] = a[44] >> n;
}

#ifdef WOLFSSL_SP_DIV_32
static WC_INLINE sp_digit sp_2048_div_word_45(sp_digit d1, sp_digit d0,
    sp_digit dv)
{
    sp_digit d;
    sp_digit r;
    sp_digit t;

    /* All 23 bits from d1 and top 8 bits from d0. */
    d = (d1 << 8) | (d0 >> 15);
    r = d / dv;
    d -= r * dv;
    /* Up to 9 bits in r */
    /* Next 8 bits from d0. */
    r <<= 8;
    d <<= 8;
    d |= (d0 >> 7) & ((1 << 8) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 17 bits in r */
    /* Remaining 7 bits from d0. */
    r <<= 7;
    d <<= 7;
    d |= d0 & ((1 << 7) - 1);
    t = d / dv;
    r += t;

    return r;
}
#endif /* WOLFSSL_SP_DIV_32 */

/* Divide d in a and put remainder into r (m*d + r = a)
 * m is not calculated as it is not needed at this time.
 *
 * a  Nmber to be divided.
 * d  Number to divide with.
 * m  Multiplier result.
 * r  Remainder from the division.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_2048_div_45(const sp_digit* a, const sp_digit* d,
        const sp_digit* m, sp_digit* r)
{
    int i;
#ifndef WOLFSSL_SP_DIV_32
    int64_t d1;
#endif
    sp_digit dv;
    sp_digit r1;
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit t1d[90 + 1];
    sp_digit t2d[45 + 1];
    sp_digit sdd[45 + 1];
#endif
    sp_digit* t1;
    sp_digit* t2;
    sp_digit* sd;
    int err = MP_OKAY;

    (void)m;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * (4 * 45 + 3), NULL,
                                                       DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    (void)m;

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t1 = td;
        t2 = td + 90 + 1;
        sd = t2 + 45 + 1;
#else
        t1 = t1d;
        t2 = t2d;
        sd = sdd;
#endif

        sp_2048_mul_d_45(sd, d, 1L << 11);
        sp_2048_mul_d_90(t1, a, 1L << 11);
        dv = sd[44];
        for (i=45; i>=0; i--) {
            t1[45 + i] += t1[45 + i - 1] >> 23;
            t1[45 + i - 1] &= 0x7fffff;
#ifndef WOLFSSL_SP_DIV_32
            d1 = t1[45 + i];
            d1 <<= 23;
            d1 += t1[45 + i - 1];
            r1 = (sp_digit)(d1 / dv);
#else
            r1 = sp_2048_div_word_45(t1[45 + i], t1[45 + i - 1], dv);
#endif

            sp_2048_mul_d_45(t2, sd, r1);
            (void)sp_2048_sub_45(&t1[i], &t1[i], t2);
            t1[45 + i] -= t2[45];
            t1[45 + i] += t1[45 + i - 1] >> 23;
            t1[45 + i - 1] &= 0x7fffff;
            r1 = (((-t1[45 + i]) << 23) - t1[45 + i - 1]) / dv;
            r1 -= t1[45 + i];
            sp_2048_mul_d_45(t2, sd, r1);
            (void)sp_2048_add_45(&t1[i], &t1[i], t2);
            t1[45 + i] += t1[45 + i - 1] >> 23;
            t1[45 + i - 1] &= 0x7fffff;
        }
        t1[45 - 1] += t1[45 - 2] >> 23;
        t1[45 - 2] &= 0x7fffff;
        r1 = t1[45 - 1] / dv;

        sp_2048_mul_d_45(t2, sd, r1);
        sp_2048_sub_45(t1, t1, t2);
        XMEMCPY(r, t1, sizeof(*r) * 2U * 45U);
        for (i=0; i<44; i++) {
            r[i+1] += r[i] >> 23;
            r[i] &= 0x7fffff;
        }
        sp_2048_cond_add_45(r, r, sd, 0 - ((r[44] < 0) ?
                    (sp_digit)1 : (sp_digit)0));

        sp_2048_norm_45(r);
        sp_2048_rshift_45(r, r, 11);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
}

/* Reduce a modulo m into r. (r = a mod m)
 *
 * r  A single precision number that is the reduced result.
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_2048_mod_45(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    return sp_2048_div_45(a, m, NULL, r);
}

/* Modular exponentiate a to the e mod m. (r = a^e mod m)
 *
 * r     A single precision number that is the result of the operation.
 * a     A single precision number being exponentiated.
 * e     A single precision number that is the exponent.
 * bits  The number of bits in the exponent.
 * m     A single precision number that is the modulus.
 * returns 0 on success and MEMORY_E on dynamic memory allocation failure.
 */
static int sp_2048_mod_exp_45(sp_digit* r, const sp_digit* a, const sp_digit* e, int bits,
    const sp_digit* m, int reduceA)
{
#ifdef WOLFSSL_SP_SMALL
#if !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[3 * 90];
#endif
    sp_digit* t[3];
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 3 * 45 * 2, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
        for (i=0; i<3; i++) {
#if !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + (i * 45 * 2);
#else
            t[i] = &td[i * 45 * 2];
#endif
            XMEMSET(t[i], 0, sizeof(sp_digit) * 45U * 2U);
        }

        sp_2048_mont_setup(m, &mp);
        sp_2048_mont_norm_45(norm, m);

        if (reduceA != 0) {
            err = sp_2048_mod_45(t[1], a, m);
        }
        else {
            XMEMCPY(t[1], a, sizeof(sp_digit) * 45U);
        }
    }
    if (err == MP_OKAY) {
        sp_2048_mul_45(t[1], t[1], norm);
        err = sp_2048_mod_45(t[1], t[1], m);
    }

    if (err == MP_OKAY) {
        i = bits / 23;
        c = bits % 23;
        n = e[i--] << (23 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1) {
                    break;
                }

                n = e[i--];
                c = 23;
            }

            y = (n >> 22) & 1;
            n <<= 1;

            sp_2048_mont_mul_45(t[y^1], t[0], t[1], m, mp);

            XMEMCPY(t[2], (void*)(((size_t)t[0] & addr_mask[y^1]) +
                                  ((size_t)t[1] & addr_mask[y])),
                                  sizeof(*t[2]) * 45 * 2);
            sp_2048_mont_sqr_45(t[2], t[2], m, mp);
            XMEMCPY((void*)(((size_t)t[0] & addr_mask[y^1]) +
                            ((size_t)t[1] & addr_mask[y])), t[2],
                            sizeof(*t[2]) * 45 * 2);
        }

        sp_2048_mont_reduce_45(t[0], m, mp);
        n = sp_2048_cmp_45(t[0], m);
        sp_2048_cond_sub_45(t[0], t[0], m, ((n < 0) ?
                    (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, t[0], sizeof(*r) * 45 * 2);

    }

#if !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#elif defined(WOLFSSL_SP_CACHE_RESISTANT)
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[3 * 90];
#endif
    sp_digit* t[3];
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#ifdef WOLFSSL_SMALL_STACK
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 3 * 45 * 2, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
        for (i=0; i<3; i++) {
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + (i * 45 * 2);
#else
            t[i] = &td[i * 45 * 2];
#endif
        }

        sp_2048_mont_setup(m, &mp);
        sp_2048_mont_norm_45(norm, m);

        if (reduceA != 0) {
            err = sp_2048_mod_45(t[1], a, m);
            if (err == MP_OKAY) {
                sp_2048_mul_45(t[1], t[1], norm);
                err = sp_2048_mod_45(t[1], t[1], m);
            }
        }
        else {
            sp_2048_mul_45(t[1], a, norm);
            err = sp_2048_mod_45(t[1], t[1], m);
        }
    }

    if (err == MP_OKAY) {
        i = bits / 23;
        c = bits % 23;
        n = e[i--] << (23 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1) {
                    break;
                }

                n = e[i--];
                c = 23;
            }

            y = (n >> 22) & 1;
            n <<= 1;

            sp_2048_mont_mul_45(t[y^1], t[0], t[1], m, mp);

            XMEMCPY(t[2], (void*)(((size_t)t[0] & addr_mask[y^1]) +
                                  ((size_t)t[1] & addr_mask[y])), 
                                  sizeof(*t[2]) * 45 * 2);
            sp_2048_mont_sqr_45(t[2], t[2], m, mp);
            XMEMCPY((void*)(((size_t)t[0] & addr_mask[y^1]) +
                            ((size_t)t[1] & addr_mask[y])), t[2], 
                            sizeof(*t[2]) * 45 * 2);
        }

        sp_2048_mont_reduce_45(t[0], m, mp);
        n = sp_2048_cmp_45(t[0], m);
        sp_2048_cond_sub_45(t[0], t[0], m, ((n < 0) ?
                    (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, t[0], sizeof(*r) * 45 * 2);
    }

#ifdef WOLFSSL_SMALL_STACK
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#else
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[(32 * 90) + 90];
#endif
    sp_digit* t[32];
    sp_digit* rt = NULL;
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * ((32 * 90) + 90), NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
        for (i=0; i<32; i++)
            t[i] = td + i * 90;
        rt = td + 2880;
#else
        for (i=0; i<32; i++)
            t[i] = &td[i * 90];
        rt = &td[2880];
#endif

        sp_2048_mont_setup(m, &mp);
        sp_2048_mont_norm_45(norm, m);

        if (reduceA != 0) {
            err = sp_2048_mod_45(t[1], a, m);
            if (err == MP_OKAY) {
                sp_2048_mul_45(t[1], t[1], norm);
                err = sp_2048_mod_45(t[1], t[1], m);
            }
        }
        else {
            sp_2048_mul_45(t[1], a, norm);
            err = sp_2048_mod_45(t[1], t[1], m);
        }
    }

    if (err == MP_OKAY) {
        sp_2048_mont_sqr_45(t[ 2], t[ 1], m, mp);
        sp_2048_mont_mul_45(t[ 3], t[ 2], t[ 1], m, mp);
        sp_2048_mont_sqr_45(t[ 4], t[ 2], m, mp);
        sp_2048_mont_mul_45(t[ 5], t[ 3], t[ 2], m, mp);
        sp_2048_mont_sqr_45(t[ 6], t[ 3], m, mp);
        sp_2048_mont_mul_45(t[ 7], t[ 4], t[ 3], m, mp);
        sp_2048_mont_sqr_45(t[ 8], t[ 4], m, mp);
        sp_2048_mont_mul_45(t[ 9], t[ 5], t[ 4], m, mp);
        sp_2048_mont_sqr_45(t[10], t[ 5], m, mp);
        sp_2048_mont_mul_45(t[11], t[ 6], t[ 5], m, mp);
        sp_2048_mont_sqr_45(t[12], t[ 6], m, mp);
        sp_2048_mont_mul_45(t[13], t[ 7], t[ 6], m, mp);
        sp_2048_mont_sqr_45(t[14], t[ 7], m, mp);
        sp_2048_mont_mul_45(t[15], t[ 8], t[ 7], m, mp);
        sp_2048_mont_sqr_45(t[16], t[ 8], m, mp);
        sp_2048_mont_mul_45(t[17], t[ 9], t[ 8], m, mp);
        sp_2048_mont_sqr_45(t[18], t[ 9], m, mp);
        sp_2048_mont_mul_45(t[19], t[10], t[ 9], m, mp);
        sp_2048_mont_sqr_45(t[20], t[10], m, mp);
        sp_2048_mont_mul_45(t[21], t[11], t[10], m, mp);
        sp_2048_mont_sqr_45(t[22], t[11], m, mp);
        sp_2048_mont_mul_45(t[23], t[12], t[11], m, mp);
        sp_2048_mont_sqr_45(t[24], t[12], m, mp);
        sp_2048_mont_mul_45(t[25], t[13], t[12], m, mp);
        sp_2048_mont_sqr_45(t[26], t[13], m, mp);
        sp_2048_mont_mul_45(t[27], t[14], t[13], m, mp);
        sp_2048_mont_sqr_45(t[28], t[14], m, mp);
        sp_2048_mont_mul_45(t[29], t[15], t[14], m, mp);
        sp_2048_mont_sqr_45(t[30], t[15], m, mp);
        sp_2048_mont_mul_45(t[31], t[16], t[15], m, mp);

        bits = ((bits + 4) / 5) * 5;
        i = ((bits + 22) / 23) - 1;
        c = bits % 23;
        if (c == 0) {
            c = 23;
        }
        if (i < 45) {
            n = e[i--] << (32 - c);
        }
        else {
            n = 0;
            i--;
        }
        if (c < 5) {
            n |= e[i--] << (9 - c);
            c += 23;
        }
        y = (n >> 27) & 0x1f;
        n <<= 5;
        c -= 5;
        XMEMCPY(rt, t[y], sizeof(sp_digit) * 90);
        while ((i >= 0) || (c >= 5)) {
            if (c < 5) {
                n |= e[i--] << (9 - c);
                c += 23;
            }
            y = (n >> 27) & 0x1f;
            n <<= 5;
            c -= 5;

            sp_2048_mont_sqr_45(rt, rt, m, mp);
            sp_2048_mont_sqr_45(rt, rt, m, mp);
            sp_2048_mont_sqr_45(rt, rt, m, mp);
            sp_2048_mont_sqr_45(rt, rt, m, mp);
            sp_2048_mont_sqr_45(rt, rt, m, mp);

            sp_2048_mont_mul_45(rt, rt, t[y], m, mp);
        }

        sp_2048_mont_reduce_45(rt, m, mp);
        n = sp_2048_cmp_45(rt, m);
        sp_2048_cond_sub_45(rt, rt, m, ((n < 0) ?
                   (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, rt, sizeof(sp_digit) * 90);
    }

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#endif
}

#endif /* (WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH) & !WOLFSSL_RSA_PUBLIC_ONLY */

/* r = 2^n mod m where n is the number of bits to reduce by.
 * Given m must be 2048 bits, just need to subtract.
 *
 * r  A single precision number.
 * m  A single precision number.
 */
static void sp_2048_mont_norm_90(sp_digit* r, const sp_digit* m)
{
    /* Set r = 2^n - 1. */
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=0; i<89; i++) {
        r[i] = 0x7fffff;
    }
#else
    int i;

    for (i = 0; i < 88; i += 8) {
        r[i + 0] = 0x7fffff;
        r[i + 1] = 0x7fffff;
        r[i + 2] = 0x7fffff;
        r[i + 3] = 0x7fffff;
        r[i + 4] = 0x7fffff;
        r[i + 5] = 0x7fffff;
        r[i + 6] = 0x7fffff;
        r[i + 7] = 0x7fffff;
    }
    r[88] = 0x7fffff;
#endif
    r[89] = 0x1L;

    /* r = (2^n - 1) mod n */
    (void)sp_2048_sub_90(r, r, m);

    /* Add one so r = 2^n mod m */
    r[0] += 1;
}

/* Compare a with b in constant time.
 *
 * a  A single precision integer.
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
static sp_digit sp_2048_cmp_90(const sp_digit* a, const sp_digit* b)
{
    sp_digit r = 0;
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=89; i>=0; i--) {
        r |= (a[i] - b[i]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#else
    int i;

    r |= (a[89] - b[89]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[88] - b[88]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    for (i = 80; i >= 0; i -= 8) {
        r |= (a[i + 7] - b[i + 7]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 6] - b[i + 6]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 5] - b[i + 5]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 4] - b[i + 4]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 3] - b[i + 3]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 2] - b[i + 2]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 1] - b[i + 1]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 0] - b[i + 0]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#endif /* WOLFSSL_SP_SMALL */

    return r;
}

/* Conditionally subtract b from a using the mask m.
 * m is -1 to subtract and 0 when not.
 *
 * r  A single precision number representing condition subtract result.
 * a  A single precision number to subtract from.
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
static void sp_2048_cond_sub_90(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 90; i++) {
        r[i] = a[i] - (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 88; i += 8) {
        r[i + 0] = a[i + 0] - (b[i + 0] & m);
        r[i + 1] = a[i + 1] - (b[i + 1] & m);
        r[i + 2] = a[i + 2] - (b[i + 2] & m);
        r[i + 3] = a[i + 3] - (b[i + 3] & m);
        r[i + 4] = a[i + 4] - (b[i + 4] & m);
        r[i + 5] = a[i + 5] - (b[i + 5] & m);
        r[i + 6] = a[i + 6] - (b[i + 6] & m);
        r[i + 7] = a[i + 7] - (b[i + 7] & m);
    }
    r[88] = a[88] - (b[88] & m);
    r[89] = a[89] - (b[89] & m);
#endif /* WOLFSSL_SP_SMALL */
}

/* Mul a by scalar b and add into r. (r += a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_2048_mul_add_90(sp_digit* r, const sp_digit* a,
        const sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 90; i++) {
        t += (tb * a[i]) + r[i];
        r[i] = t & 0x7fffff;
        t >>= 23;
    }
    r[90] += t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] += (sp_digit)(t[0] & 0x7fffff);
    for (i = 0; i < 88; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] += (sp_digit)((t[0] >> 23) + (t[1] & 0x7fffff));
        t[2] = tb * a[i+2];
        r[i+2] += (sp_digit)((t[1] >> 23) + (t[2] & 0x7fffff));
        t[3] = tb * a[i+3];
        r[i+3] += (sp_digit)((t[2] >> 23) + (t[3] & 0x7fffff));
        t[4] = tb * a[i+4];
        r[i+4] += (sp_digit)((t[3] >> 23) + (t[4] & 0x7fffff));
        t[5] = tb * a[i+5];
        r[i+5] += (sp_digit)((t[4] >> 23) + (t[5] & 0x7fffff));
        t[6] = tb * a[i+6];
        r[i+6] += (sp_digit)((t[5] >> 23) + (t[6] & 0x7fffff));
        t[7] = tb * a[i+7];
        r[i+7] += (sp_digit)((t[6] >> 23) + (t[7] & 0x7fffff));
        t[0] = tb * a[i+8];
        r[i+8] += (sp_digit)((t[7] >> 23) + (t[0] & 0x7fffff));
    }
    t[1] = tb * a[89]; r[89] += (sp_digit)((t[0] >> 23) + (t[1] & 0x7fffff));
    r[90] +=  (sp_digit)(t[1] >> 23);
#endif /* WOLFSSL_SP_SMALL */
}

/* Normalize the values in each word to 23.
 *
 * a  Array of sp_digit to normalize.
 */
static void sp_2048_norm_90(sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    for (i = 0; i < 89; i++) {
        a[i+1] += a[i] >> 23;
        a[i] &= 0x7fffff;
    }
#else
    int i;
    for (i = 0; i < 88; i += 8) {
        a[i+1] += a[i+0] >> 23; a[i+0] &= 0x7fffff;
        a[i+2] += a[i+1] >> 23; a[i+1] &= 0x7fffff;
        a[i+3] += a[i+2] >> 23; a[i+2] &= 0x7fffff;
        a[i+4] += a[i+3] >> 23; a[i+3] &= 0x7fffff;
        a[i+5] += a[i+4] >> 23; a[i+4] &= 0x7fffff;
        a[i+6] += a[i+5] >> 23; a[i+5] &= 0x7fffff;
        a[i+7] += a[i+6] >> 23; a[i+6] &= 0x7fffff;
        a[i+8] += a[i+7] >> 23; a[i+7] &= 0x7fffff;
        a[i+9] += a[i+8] >> 23; a[i+8] &= 0x7fffff;
    }
    a[88+1] += a[88] >> 23;
    a[88] &= 0x7fffff;
#endif
}

/* Shift the result in the high 2048 bits down to the bottom.
 *
 * r  A single precision number.
 * a  A single precision number.
 */
static void sp_2048_mont_shift_90(sp_digit* r, const sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    int64_t n = a[89] >> 1;
    n += ((int64_t)a[90]) << 22;

    for (i = 0; i < 89; i++) {
        r[i] = n & 0x7fffff;
        n >>= 23;
        n += ((int64_t)a[91 + i]) << 22;
    }
    r[89] = (sp_digit)n;
#else
    int i;
    int64_t n = a[89] >> 1;
    n += ((int64_t)a[90]) << 22;
    for (i = 0; i < 88; i += 8) {
        r[i + 0] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 91]) << 22;
        r[i + 1] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 92]) << 22;
        r[i + 2] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 93]) << 22;
        r[i + 3] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 94]) << 22;
        r[i + 4] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 95]) << 22;
        r[i + 5] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 96]) << 22;
        r[i + 6] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 97]) << 22;
        r[i + 7] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 98]) << 22;
    }
    r[88] = n & 0x7fffff; n >>= 23; n += ((int64_t)a[179]) << 22;
    r[89] = (sp_digit)n;
#endif /* WOLFSSL_SP_SMALL */
    XMEMSET(&r[90], 0, sizeof(*r) * 90U);
}

/* Reduce the number back to 2048 bits using Montgomery reduction.
 *
 * a   A single precision number to reduce in place.
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
static void sp_2048_mont_reduce_90(sp_digit* a, const sp_digit* m, sp_digit mp)
{
    int i;
    sp_digit mu;

    sp_2048_norm_90(a + 90);

#ifdef WOLFSSL_SP_DH
    if (mp != 1) {
        for (i=0; i<89; i++) {
            mu = (a[i] * mp) & 0x7fffff;
            sp_2048_mul_add_90(a+i, m, mu);
            a[i+1] += a[i] >> 23;
        }
        mu = (a[i] * mp) & 0x1L;
        sp_2048_mul_add_90(a+i, m, mu);
        a[i+1] += a[i] >> 23;
        a[i] &= 0x7fffff;
    }
    else {
        for (i=0; i<89; i++) {
            mu = a[i] & 0x7fffff;
            sp_2048_mul_add_90(a+i, m, mu);
            a[i+1] += a[i] >> 23;
        }
        mu = a[i] & 0x1L;
        sp_2048_mul_add_90(a+i, m, mu);
        a[i+1] += a[i] >> 23;
        a[i] &= 0x7fffff;
    }
#else
    for (i=0; i<89; i++) {
        mu = (a[i] * mp) & 0x7fffff;
        sp_2048_mul_add_90(a+i, m, mu);
        a[i+1] += a[i] >> 23;
    }
    mu = (a[i] * mp) & 0x1L;
    sp_2048_mul_add_90(a+i, m, mu);
    a[i+1] += a[i] >> 23;
    a[i] &= 0x7fffff;
#endif

    sp_2048_mont_shift_90(a, a);
    sp_2048_cond_sub_90(a, a, m, 0 - (((a[89] >> 1) > 0) ?
            (sp_digit)1 : (sp_digit)0));
    sp_2048_norm_90(a);
}

/* Multiply two Montogmery form numbers mod the modulus (prime).
 * (r = a * b mod m)
 *
 * r   Result of multiplication.
 * a   First number to multiply in Montogmery form.
 * b   Second number to multiply in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_2048_mont_mul_90(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit* m, sp_digit mp)
{
    sp_2048_mul_90(r, a, b);
    sp_2048_mont_reduce_90(r, m, mp);
}

/* Square the Montgomery form number. (r = a * a mod m)
 *
 * r   Result of squaring.
 * a   Number to square in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_2048_mont_sqr_90(sp_digit* r, const sp_digit* a,
        const sp_digit* m, sp_digit mp)
{
    sp_2048_sqr_90(r, a);
    sp_2048_mont_reduce_90(r, m, mp);
}

/* Multiply a by scalar b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_2048_mul_d_180(sp_digit* r, const sp_digit* a,
    sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 180; i++) {
        t += tb * a[i];
        r[i] = t & 0x7fffff;
        t >>= 23;
    }
    r[180] = (sp_digit)t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] = t[0] & 0x7fffff;
    for (i = 0; i < 176; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] = (sp_digit)(t[0] >> 23) + (t[1] & 0x7fffff);
        t[2] = tb * a[i+2];
        r[i+2] = (sp_digit)(t[1] >> 23) + (t[2] & 0x7fffff);
        t[3] = tb * a[i+3];
        r[i+3] = (sp_digit)(t[2] >> 23) + (t[3] & 0x7fffff);
        t[4] = tb * a[i+4];
        r[i+4] = (sp_digit)(t[3] >> 23) + (t[4] & 0x7fffff);
        t[5] = tb * a[i+5];
        r[i+5] = (sp_digit)(t[4] >> 23) + (t[5] & 0x7fffff);
        t[6] = tb * a[i+6];
        r[i+6] = (sp_digit)(t[5] >> 23) + (t[6] & 0x7fffff);
        t[7] = tb * a[i+7];
        r[i+7] = (sp_digit)(t[6] >> 23) + (t[7] & 0x7fffff);
        t[0] = tb * a[i+8];
        r[i+8] = (sp_digit)(t[7] >> 23) + (t[0] & 0x7fffff);
    }
    t[1] = tb * a[177];
    r[177] = (sp_digit)(t[0] >> 23) + (t[1] & 0x7fffff);
    t[2] = tb * a[178];
    r[178] = (sp_digit)(t[1] >> 23) + (t[2] & 0x7fffff);
    t[3] = tb * a[179];
    r[179] = (sp_digit)(t[2] >> 23) + (t[3] & 0x7fffff);
    r[180] =  (sp_digit)(t[3] >> 23);
#endif /* WOLFSSL_SP_SMALL */
}

/* Conditionally add a and b using the mask m.
 * m is -1 to add and 0 when not.
 *
 * r  A single precision number representing conditional add result.
 * a  A single precision number to add with.
 * b  A single precision number to add.
 * m  Mask value to apply.
 */
static void sp_2048_cond_add_90(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 90; i++) {
        r[i] = a[i] + (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 88; i += 8) {
        r[i + 0] = a[i + 0] + (b[i + 0] & m);
        r[i + 1] = a[i + 1] + (b[i + 1] & m);
        r[i + 2] = a[i + 2] + (b[i + 2] & m);
        r[i + 3] = a[i + 3] + (b[i + 3] & m);
        r[i + 4] = a[i + 4] + (b[i + 4] & m);
        r[i + 5] = a[i + 5] + (b[i + 5] & m);
        r[i + 6] = a[i + 6] + (b[i + 6] & m);
        r[i + 7] = a[i + 7] + (b[i + 7] & m);
    }
    r[88] = a[88] + (b[88] & m);
    r[89] = a[89] + (b[89] & m);
#endif /* WOLFSSL_SP_SMALL */
}

#ifdef WOLFSSL_SP_SMALL
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_sub_90(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 90; i++) {
        r[i] = a[i] - b[i];
    }

    return 0;
}

#endif
#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_2048_add_90(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 90; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#endif
SP_NOINLINE static void sp_2048_rshift_90(sp_digit* r, const sp_digit* a,
        byte n)
{
    int i;

#ifdef WOLFSSL_SP_SMALL
    for (i=0; i<89; i++) {
        r[i] = ((a[i] >> n) | (a[i + 1] << (23 - n))) & 0x7fffff;
    }
#else
    for (i=0; i<88; i += 8) {
        r[i+0] = ((a[i+0] >> n) | (a[i+1] << (23 - n))) & 0x7fffff;
        r[i+1] = ((a[i+1] >> n) | (a[i+2] << (23 - n))) & 0x7fffff;
        r[i+2] = ((a[i+2] >> n) | (a[i+3] << (23 - n))) & 0x7fffff;
        r[i+3] = ((a[i+3] >> n) | (a[i+4] << (23 - n))) & 0x7fffff;
        r[i+4] = ((a[i+4] >> n) | (a[i+5] << (23 - n))) & 0x7fffff;
        r[i+5] = ((a[i+5] >> n) | (a[i+6] << (23 - n))) & 0x7fffff;
        r[i+6] = ((a[i+6] >> n) | (a[i+7] << (23 - n))) & 0x7fffff;
        r[i+7] = ((a[i+7] >> n) | (a[i+8] << (23 - n))) & 0x7fffff;
    }
    r[88] = ((a[88] >> n) | (a[89] << (23 - n))) & 0x7fffff;
#endif
    r[89] = a[89] >> n;
}

#ifdef WOLFSSL_SP_DIV_32
static WC_INLINE sp_digit sp_2048_div_word_90(sp_digit d1, sp_digit d0,
    sp_digit dv)
{
    sp_digit d;
    sp_digit r;
    sp_digit t;

    /* All 23 bits from d1 and top 8 bits from d0. */
    d = (d1 << 8) | (d0 >> 15);
    r = d / dv;
    d -= r * dv;
    /* Up to 9 bits in r */
    /* Next 8 bits from d0. */
    r <<= 8;
    d <<= 8;
    d |= (d0 >> 7) & ((1 << 8) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 17 bits in r */
    /* Remaining 7 bits from d0. */
    r <<= 7;
    d <<= 7;
    d |= d0 & ((1 << 7) - 1);
    t = d / dv;
    r += t;

    return r;
}
#endif /* WOLFSSL_SP_DIV_32 */

/* Divide d in a and put remainder into r (m*d + r = a)
 * m is not calculated as it is not needed at this time.
 *
 * a  Nmber to be divided.
 * d  Number to divide with.
 * m  Multiplier result.
 * r  Remainder from the division.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_2048_div_90(const sp_digit* a, const sp_digit* d,
        const sp_digit* m, sp_digit* r)
{
    int i;
#ifndef WOLFSSL_SP_DIV_32
    int64_t d1;
#endif
    sp_digit dv;
    sp_digit r1;
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit t1d[180 + 1];
    sp_digit t2d[90 + 1];
    sp_digit sdd[90 + 1];
#endif
    sp_digit* t1;
    sp_digit* t2;
    sp_digit* sd;
    int err = MP_OKAY;

    (void)m;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * (4 * 90 + 3), NULL,
                                                       DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    (void)m;

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t1 = td;
        t2 = td + 180 + 1;
        sd = t2 + 90 + 1;
#else
        t1 = t1d;
        t2 = t2d;
        sd = sdd;
#endif

        sp_2048_mul_d_90(sd, d, 1L << 22);
        sp_2048_mul_d_180(t1, a, 1L << 22);
        dv = sd[89];
        for (i=90; i>=0; i--) {
            t1[90 + i] += t1[90 + i - 1] >> 23;
            t1[90 + i - 1] &= 0x7fffff;
#ifndef WOLFSSL_SP_DIV_32
            d1 = t1[90 + i];
            d1 <<= 23;
            d1 += t1[90 + i - 1];
            r1 = (sp_digit)(d1 / dv);
#else
            r1 = sp_2048_div_word_90(t1[90 + i], t1[90 + i - 1], dv);
#endif

            sp_2048_mul_d_90(t2, sd, r1);
            (void)sp_2048_sub_90(&t1[i], &t1[i], t2);
            t1[90 + i] -= t2[90];
            t1[90 + i] += t1[90 + i - 1] >> 23;
            t1[90 + i - 1] &= 0x7fffff;
            r1 = (((-t1[90 + i]) << 23) - t1[90 + i - 1]) / dv;
            r1 -= t1[90 + i];
            sp_2048_mul_d_90(t2, sd, r1);
            (void)sp_2048_add_90(&t1[i], &t1[i], t2);
            t1[90 + i] += t1[90 + i - 1] >> 23;
            t1[90 + i - 1] &= 0x7fffff;
        }
        t1[90 - 1] += t1[90 - 2] >> 23;
        t1[90 - 2] &= 0x7fffff;
        r1 = t1[90 - 1] / dv;

        sp_2048_mul_d_90(t2, sd, r1);
        sp_2048_sub_90(t1, t1, t2);
        XMEMCPY(r, t1, sizeof(*r) * 2U * 90U);
        for (i=0; i<89; i++) {
            r[i+1] += r[i] >> 23;
            r[i] &= 0x7fffff;
        }
        sp_2048_cond_add_90(r, r, sd, 0 - ((r[89] < 0) ?
                    (sp_digit)1 : (sp_digit)0));

        sp_2048_norm_90(r);
        sp_2048_rshift_90(r, r, 22);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
}

/* Reduce a modulo m into r. (r = a mod m)
 *
 * r  A single precision number that is the reduced result.
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_2048_mod_90(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    return sp_2048_div_90(a, m, NULL, r);
}

#if (defined(WOLFSSL_HAVE_SP_RSA) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)) || \
                                                     defined(WOLFSSL_HAVE_SP_DH)
/* Modular exponentiate a to the e mod m. (r = a^e mod m)
 *
 * r     A single precision number that is the result of the operation.
 * a     A single precision number being exponentiated.
 * e     A single precision number that is the exponent.
 * bits  The number of bits in the exponent.
 * m     A single precision number that is the modulus.
 * returns 0 on success and MEMORY_E on dynamic memory allocation failure.
 */
static int sp_2048_mod_exp_90(sp_digit* r, const sp_digit* a, const sp_digit* e, int bits,
    const sp_digit* m, int reduceA)
{
#ifdef WOLFSSL_SP_SMALL
#if !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[3 * 180];
#endif
    sp_digit* t[3];
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 3 * 90 * 2, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
        for (i=0; i<3; i++) {
#if !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + (i * 90 * 2);
#else
            t[i] = &td[i * 90 * 2];
#endif
            XMEMSET(t[i], 0, sizeof(sp_digit) * 90U * 2U);
        }

        sp_2048_mont_setup(m, &mp);
        sp_2048_mont_norm_90(norm, m);

        if (reduceA != 0) {
            err = sp_2048_mod_90(t[1], a, m);
        }
        else {
            XMEMCPY(t[1], a, sizeof(sp_digit) * 90U);
        }
    }
    if (err == MP_OKAY) {
        sp_2048_mul_90(t[1], t[1], norm);
        err = sp_2048_mod_90(t[1], t[1], m);
    }

    if (err == MP_OKAY) {
        i = bits / 23;
        c = bits % 23;
        n = e[i--] << (23 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1) {
                    break;
                }

                n = e[i--];
                c = 23;
            }

            y = (n >> 22) & 1;
            n <<= 1;

            sp_2048_mont_mul_90(t[y^1], t[0], t[1], m, mp);

            XMEMCPY(t[2], (void*)(((size_t)t[0] & addr_mask[y^1]) +
                                  ((size_t)t[1] & addr_mask[y])),
                                  sizeof(*t[2]) * 90 * 2);
            sp_2048_mont_sqr_90(t[2], t[2], m, mp);
            XMEMCPY((void*)(((size_t)t[0] & addr_mask[y^1]) +
                            ((size_t)t[1] & addr_mask[y])), t[2],
                            sizeof(*t[2]) * 90 * 2);
        }

        sp_2048_mont_reduce_90(t[0], m, mp);
        n = sp_2048_cmp_90(t[0], m);
        sp_2048_cond_sub_90(t[0], t[0], m, ((n < 0) ?
                    (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, t[0], sizeof(*r) * 90 * 2);

    }

#if !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#elif defined(WOLFSSL_SP_CACHE_RESISTANT)
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[3 * 180];
#endif
    sp_digit* t[3];
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#ifdef WOLFSSL_SMALL_STACK
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 3 * 90 * 2, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
        for (i=0; i<3; i++) {
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + (i * 90 * 2);
#else
            t[i] = &td[i * 90 * 2];
#endif
        }

        sp_2048_mont_setup(m, &mp);
        sp_2048_mont_norm_90(norm, m);

        if (reduceA != 0) {
            err = sp_2048_mod_90(t[1], a, m);
            if (err == MP_OKAY) {
                sp_2048_mul_90(t[1], t[1], norm);
                err = sp_2048_mod_90(t[1], t[1], m);
            }
        }
        else {
            sp_2048_mul_90(t[1], a, norm);
            err = sp_2048_mod_90(t[1], t[1], m);
        }
    }

    if (err == MP_OKAY) {
        i = bits / 23;
        c = bits % 23;
        n = e[i--] << (23 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1) {
                    break;
                }

                n = e[i--];
                c = 23;
            }

            y = (n >> 22) & 1;
            n <<= 1;

            sp_2048_mont_mul_90(t[y^1], t[0], t[1], m, mp);

            XMEMCPY(t[2], (void*)(((size_t)t[0] & addr_mask[y^1]) +
                                  ((size_t)t[1] & addr_mask[y])), 
                                  sizeof(*t[2]) * 90 * 2);
            sp_2048_mont_sqr_90(t[2], t[2], m, mp);
            XMEMCPY((void*)(((size_t)t[0] & addr_mask[y^1]) +
                            ((size_t)t[1] & addr_mask[y])), t[2], 
                            sizeof(*t[2]) * 90 * 2);
        }

        sp_2048_mont_reduce_90(t[0], m, mp);
        n = sp_2048_cmp_90(t[0], m);
        sp_2048_cond_sub_90(t[0], t[0], m, ((n < 0) ?
                    (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, t[0], sizeof(*r) * 90 * 2);
    }

#ifdef WOLFSSL_SMALL_STACK
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#else
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[(32 * 180) + 180];
#endif
    sp_digit* t[32];
    sp_digit* rt = NULL;
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * ((32 * 180) + 180), NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
        for (i=0; i<32; i++)
            t[i] = td + i * 180;
        rt = td + 5760;
#else
        for (i=0; i<32; i++)
            t[i] = &td[i * 180];
        rt = &td[5760];
#endif

        sp_2048_mont_setup(m, &mp);
        sp_2048_mont_norm_90(norm, m);

        if (reduceA != 0) {
            err = sp_2048_mod_90(t[1], a, m);
            if (err == MP_OKAY) {
                sp_2048_mul_90(t[1], t[1], norm);
                err = sp_2048_mod_90(t[1], t[1], m);
            }
        }
        else {
            sp_2048_mul_90(t[1], a, norm);
            err = sp_2048_mod_90(t[1], t[1], m);
        }
    }

    if (err == MP_OKAY) {
        sp_2048_mont_sqr_90(t[ 2], t[ 1], m, mp);
        sp_2048_mont_mul_90(t[ 3], t[ 2], t[ 1], m, mp);
        sp_2048_mont_sqr_90(t[ 4], t[ 2], m, mp);
        sp_2048_mont_mul_90(t[ 5], t[ 3], t[ 2], m, mp);
        sp_2048_mont_sqr_90(t[ 6], t[ 3], m, mp);
        sp_2048_mont_mul_90(t[ 7], t[ 4], t[ 3], m, mp);
        sp_2048_mont_sqr_90(t[ 8], t[ 4], m, mp);
        sp_2048_mont_mul_90(t[ 9], t[ 5], t[ 4], m, mp);
        sp_2048_mont_sqr_90(t[10], t[ 5], m, mp);
        sp_2048_mont_mul_90(t[11], t[ 6], t[ 5], m, mp);
        sp_2048_mont_sqr_90(t[12], t[ 6], m, mp);
        sp_2048_mont_mul_90(t[13], t[ 7], t[ 6], m, mp);
        sp_2048_mont_sqr_90(t[14], t[ 7], m, mp);
        sp_2048_mont_mul_90(t[15], t[ 8], t[ 7], m, mp);
        sp_2048_mont_sqr_90(t[16], t[ 8], m, mp);
        sp_2048_mont_mul_90(t[17], t[ 9], t[ 8], m, mp);
        sp_2048_mont_sqr_90(t[18], t[ 9], m, mp);
        sp_2048_mont_mul_90(t[19], t[10], t[ 9], m, mp);
        sp_2048_mont_sqr_90(t[20], t[10], m, mp);
        sp_2048_mont_mul_90(t[21], t[11], t[10], m, mp);
        sp_2048_mont_sqr_90(t[22], t[11], m, mp);
        sp_2048_mont_mul_90(t[23], t[12], t[11], m, mp);
        sp_2048_mont_sqr_90(t[24], t[12], m, mp);
        sp_2048_mont_mul_90(t[25], t[13], t[12], m, mp);
        sp_2048_mont_sqr_90(t[26], t[13], m, mp);
        sp_2048_mont_mul_90(t[27], t[14], t[13], m, mp);
        sp_2048_mont_sqr_90(t[28], t[14], m, mp);
        sp_2048_mont_mul_90(t[29], t[15], t[14], m, mp);
        sp_2048_mont_sqr_90(t[30], t[15], m, mp);
        sp_2048_mont_mul_90(t[31], t[16], t[15], m, mp);

        bits = ((bits + 4) / 5) * 5;
        i = ((bits + 22) / 23) - 1;
        c = bits % 23;
        if (c == 0) {
            c = 23;
        }
        if (i < 90) {
            n = e[i--] << (32 - c);
        }
        else {
            n = 0;
            i--;
        }
        if (c < 5) {
            n |= e[i--] << (9 - c);
            c += 23;
        }
        y = (n >> 27) & 0x1f;
        n <<= 5;
        c -= 5;
        XMEMCPY(rt, t[y], sizeof(sp_digit) * 180);
        while ((i >= 0) || (c >= 5)) {
            if (c < 5) {
                n |= e[i--] << (9 - c);
                c += 23;
            }
            y = (n >> 27) & 0x1f;
            n <<= 5;
            c -= 5;

            sp_2048_mont_sqr_90(rt, rt, m, mp);
            sp_2048_mont_sqr_90(rt, rt, m, mp);
            sp_2048_mont_sqr_90(rt, rt, m, mp);
            sp_2048_mont_sqr_90(rt, rt, m, mp);
            sp_2048_mont_sqr_90(rt, rt, m, mp);

            sp_2048_mont_mul_90(rt, rt, t[y], m, mp);
        }

        sp_2048_mont_reduce_90(rt, m, mp);
        n = sp_2048_cmp_90(rt, m);
        sp_2048_cond_sub_90(rt, rt, m, ((n < 0) ?
                   (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, rt, sizeof(sp_digit) * 180);
    }

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#endif
}
#endif /* (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) | */
       /* WOLFSSL_HAVE_SP_DH */

#ifdef WOLFSSL_HAVE_SP_RSA
/* RSA public key operation.
 *
 * in      Array of bytes representing the number to exponentiate, base.
 * inLen   Number of bytes in base.
 * em      Public exponent.
 * mm      Modulus.
 * out     Buffer to hold big-endian bytes of exponentiation result.
 *         Must be at least 256 bytes long.
 * outLen  Number of bytes in result.
 * returns 0 on success, MP_TO_E when the outLen is too small, MP_READ_E when
 * an array is too long and MEMORY_E when dynamic memory allocation fails.
 */
int sp_RsaPublic_2048(const byte* in, word32 inLen, const mp_int* em,
    const mp_int* mm, byte* out, word32* outLen)
{
#ifdef WOLFSSL_SP_SMALL
    sp_digit* d = NULL;
    sp_digit* a = NULL;
    sp_digit* m = NULL;
    sp_digit* r = NULL;
    sp_digit* norm = NULL;
    sp_digit e[1] = {0};
    sp_digit mp;
    int i;
    int err = MP_OKAY;

    if (*outLen < 256U) {
        err = MP_TO_E;
    }

    if (err == MP_OKAY) {
        if (mp_count_bits(em) > 23) {
            err = MP_READ_E;
        }
        if (inLen > 256U) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 2048) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 90 * 5, NULL,
                                                              DYNAMIC_TYPE_RSA);
        if (d == NULL)
            err = MEMORY_E;
    }

    if (err == MP_OKAY) {
        a = d;
        r = a + 90 * 2;
        m = r + 90 * 2;
        norm = r;

        sp_2048_from_bin(a, 90, in, inLen);
#if DIGIT_BIT >= 23
        e[0] = (sp_digit)em->dp[0];
#else
        e[0] = (sp_digit)em->dp[0];
        if (em->used > 1) {
            e[0] |= ((sp_digit)em->dp[1]) << DIGIT_BIT;
        }
#endif
        if (e[0] == 0) {
            err = MP_EXPTMOD_E;
        }
    }

    if (err == MP_OKAY) {
        sp_2048_from_mp(m, 90, mm);

        sp_2048_mont_setup(m, &mp);
        sp_2048_mont_norm_90(norm, m);
    }
    if (err == MP_OKAY) {
        sp_2048_mul_90(a, a, norm);
        err = sp_2048_mod_90(a, a, m);
    }
    if (err == MP_OKAY) {
        for (i=22; i>=0; i--) {
            if ((e[0] >> i) != 0) {
                break;
            }
        }

        XMEMCPY(r, a, sizeof(sp_digit) * 90 * 2);
        for (i--; i>=0; i--) {
            sp_2048_mont_sqr_90(r, r, m, mp);

            if (((e[0] >> i) & 1) == 1) {
                sp_2048_mont_mul_90(r, r, a, m, mp);
            }
        }
        sp_2048_mont_reduce_90(r, m, mp);
        mp = sp_2048_cmp_90(r, m);
        sp_2048_cond_sub_90(r, r, m, ((mp < 0) ?
                    (sp_digit)1 : (sp_digit)0)- 1);

        sp_2048_to_bin(r, out);
        *outLen = 256;
    }

    if (d != NULL) {
        XFREE(d, NULL, DYNAMIC_TYPE_RSA);
    }

    return err;
#else
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit ad[180];
    sp_digit md[90];
    sp_digit rd[180];
#else
    sp_digit* d = NULL;
#endif
    sp_digit* a = NULL;
    sp_digit* m = NULL;
    sp_digit* r = NULL;
    sp_digit e[1] = {0};
    int err = MP_OKAY;

    if (*outLen < 256U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (mp_count_bits(em) > 23) {
            err = MP_READ_E;
        }
        if (inLen > 256U) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 2048) {
            err = MP_READ_E;
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 90 * 5, NULL,
                                                              DYNAMIC_TYPE_RSA);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }

    if (err == MP_OKAY) {
        a = d;
        r = a + 90 * 2;
        m = r + 90 * 2;
    }
#else
    a = ad;
    m = md;
    r = rd;
#endif

    if (err == MP_OKAY) {
        sp_2048_from_bin(a, 90, in, inLen);
#if DIGIT_BIT >= 23
        e[0] = (sp_digit)em->dp[0];
#else
        e[0] = (sp_digit)em->dp[0];
        if (em->used > 1) {
            e[0] |= ((sp_digit)em->dp[1]) << DIGIT_BIT;
        }
#endif
        if (e[0] == 0) {
            err = MP_EXPTMOD_E;
        }
    }
    if (err == MP_OKAY) {
        sp_2048_from_mp(m, 90, mm);

        if (e[0] == 0x3) {
            sp_2048_sqr_90(r, a);
            err = sp_2048_mod_90(r, r, m);
            if (err == MP_OKAY) {
                sp_2048_mul_90(r, a, r);
                err = sp_2048_mod_90(r, r, m);
            }
        }
        else {
            sp_digit* norm = r;
            int i;
            sp_digit mp;

            sp_2048_mont_setup(m, &mp);
            sp_2048_mont_norm_90(norm, m);

            sp_2048_mul_90(a, a, norm);
            err = sp_2048_mod_90(a, a, m);

            if (err == MP_OKAY) {
                for (i=22; i>=0; i--) {
                    if ((e[0] >> i) != 0) {
                        break;
                    }
                }

                XMEMCPY(r, a, sizeof(sp_digit) * 180U);
                for (i--; i>=0; i--) {
                    sp_2048_mont_sqr_90(r, r, m, mp);

                    if (((e[0] >> i) & 1) == 1) {
                        sp_2048_mont_mul_90(r, r, a, m, mp);
                    }
                }
                sp_2048_mont_reduce_90(r, m, mp);
                mp = sp_2048_cmp_90(r, m);
                sp_2048_cond_sub_90(r, r, m, ((mp < 0) ?
                           (sp_digit)1 : (sp_digit)0) - 1);
            }
        }
    }

    if (err == MP_OKAY) {
        sp_2048_to_bin(r, out);
        *outLen = 256;
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL) {
        XFREE(d, NULL, DYNAMIC_TYPE_RSA);
    }
#endif

    return err;
#endif /* WOLFSSL_SP_SMALL */
}

#ifndef WOLFSSL_RSA_PUBLIC_ONLY
#if !defined(SP_RSA_PRIVATE_EXP_D) && !defined(RSA_LOW_MEM)
#endif /* !SP_RSA_PRIVATE_EXP_D & !RSA_LOW_MEM */
/* RSA private key operation.
 *
 * in      Array of bytes representing the number to exponentiate, base.
 * inLen   Number of bytes in base.
 * dm      Private exponent.
 * pm      First prime.
 * qm      Second prime.
 * dpm     First prime's CRT exponent.
 * dqm     Second prime's CRT exponent.
 * qim     Inverse of second prime mod p.
 * mm      Modulus.
 * out     Buffer to hold big-endian bytes of exponentiation result.
 *         Must be at least 256 bytes long.
 * outLen  Number of bytes in result.
 * returns 0 on success, MP_TO_E when the outLen is too small, MP_READ_E when
 * an array is too long and MEMORY_E when dynamic memory allocation fails.
 */
int sp_RsaPrivate_2048(const byte* in, word32 inLen, const mp_int* dm,
    const mp_int* pm, const mp_int* qm, const mp_int* dpm, const mp_int* dqm,
    const mp_int* qim, const mp_int* mm, byte* out, word32* outLen)
{
#if defined(SP_RSA_PRIVATE_EXP_D) || defined(RSA_LOW_MEM)
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* a = NULL;
    sp_digit* d = NULL;
    sp_digit* m = NULL;
    sp_digit* r = NULL;
    int err = MP_OKAY;

    (void)pm;
    (void)qm;
    (void)dpm;
    (void)dqm;
    (void)qim;

    if (*outLen < 256U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (mp_count_bits(dm) > 2048) {
           err = MP_READ_E;
        }
        if (inLen > 256) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 2048) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 90 * 4, NULL,
                                                              DYNAMIC_TYPE_RSA);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }
    if (err == MP_OKAY) {
        a = d + 90;
        m = a + 180;
        r = a;

        sp_2048_from_bin(a, 90, in, inLen);
        sp_2048_from_mp(d, 90, dm);
        sp_2048_from_mp(m, 90, mm);
        err = sp_2048_mod_exp_90(r, a, d, 2048, m, 0);
    }
    if (err == MP_OKAY) {
        sp_2048_to_bin(r, out);
        *outLen = 256;
    }

    if (d != NULL) {
        XMEMSET(d, 0, sizeof(sp_digit) * 90);
        XFREE(d, NULL, DYNAMIC_TYPE_RSA);
    }

    return err;
#else
    sp_digit a[180];
    sp_digit d[90];
    sp_digit m[90];
    sp_digit* r = a;
    int err = MP_OKAY;

    (void)pm;
    (void)qm;
    (void)dpm;
    (void)dqm;
    (void)qim;

    if (*outLen < 256U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (mp_count_bits(dm) > 2048) {
            err = MP_READ_E;
        }
        if (inLen > 256U) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 2048) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        sp_2048_from_bin(a, 90, in, inLen);
        sp_2048_from_mp(d, 90, dm);
        sp_2048_from_mp(m, 90, mm);
        err = sp_2048_mod_exp_90(r, a, d, 2048, m, 0);
    }

    if (err == MP_OKAY) {
        sp_2048_to_bin(r, out);
        *outLen = 256;
    }

    XMEMSET(d, 0, sizeof(sp_digit) * 90);

    return err;
#endif /* WOLFSSL_SP_SMALL | defined(WOLFSSL_SMALL_STACK) */
#else
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* t = NULL;
    sp_digit* a = NULL;
    sp_digit* p = NULL;
    sp_digit* q = NULL;
    sp_digit* dp = NULL;
    sp_digit* dq = NULL;
    sp_digit* qi = NULL;
    sp_digit* tmpa = NULL;
    sp_digit* tmpb = NULL;
    sp_digit* r = NULL;
    int err = MP_OKAY;

    (void)dm;
    (void)mm;

    if (*outLen < 256U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (inLen > 256) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 2048) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        t = (sp_digit*)XMALLOC(sizeof(sp_digit) * 45 * 11, NULL,
                                                              DYNAMIC_TYPE_RSA);
        if (t == NULL) {
            err = MEMORY_E;
        }
    }
    if (err == MP_OKAY) {
        a = t;
        p = a + 90 * 2;
        q = p + 45;
        qi = dq = dp = q + 45;
        tmpa = qi + 45;
        tmpb = tmpa + 90;

        r = t + 90;

        sp_2048_from_bin(a, 90, in, inLen);
        sp_2048_from_mp(p, 45, pm);
        sp_2048_from_mp(q, 45, qm);
        sp_2048_from_mp(dp, 45, dpm);
        err = sp_2048_mod_exp_45(tmpa, a, dp, 1024, p, 1);
    }
    if (err == MP_OKAY) {
        sp_2048_from_mp(dq, 45, dqm);
        err = sp_2048_mod_exp_45(tmpb, a, dq, 1024, q, 1);
    }
    if (err == MP_OKAY) {
        (void)sp_2048_sub_45(tmpa, tmpa, tmpb);
        sp_2048_cond_add_45(tmpa, tmpa, p, 0 - ((sp_int_digit)tmpa[44] >> 31));
        sp_2048_cond_add_45(tmpa, tmpa, p, 0 - ((sp_int_digit)tmpa[44] >> 31));

        sp_2048_from_mp(qi, 45, qim);
        sp_2048_mul_45(tmpa, tmpa, qi);
        err = sp_2048_mod_45(tmpa, tmpa, p);
    }

    if (err == MP_OKAY) {
        sp_2048_mul_45(tmpa, q, tmpa);
        (void)sp_2048_add_90(r, tmpb, tmpa);
        sp_2048_norm_90(r);

        sp_2048_to_bin(r, out);
        *outLen = 256;
    }

    if (t != NULL) {
        XMEMSET(t, 0, sizeof(sp_digit) * 45 * 11);
        XFREE(t, NULL, DYNAMIC_TYPE_RSA);
    }

    return err;
#else
    sp_digit a[90 * 2];
    sp_digit p[45];
    sp_digit q[45];
    sp_digit dp[45];
    sp_digit dq[45];
    sp_digit qi[45];
    sp_digit tmpa[90];
    sp_digit tmpb[90];
    sp_digit* r = a;
    int err = MP_OKAY;

    (void)dm;
    (void)mm;

    if (*outLen < 256U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (inLen > 256U) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 2048) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        sp_2048_from_bin(a, 90, in, inLen);
        sp_2048_from_mp(p, 45, pm);
        sp_2048_from_mp(q, 45, qm);
        sp_2048_from_mp(dp, 45, dpm);
        sp_2048_from_mp(dq, 45, dqm);
        sp_2048_from_mp(qi, 45, qim);

        err = sp_2048_mod_exp_45(tmpa, a, dp, 1024, p, 1);
    }
    if (err == MP_OKAY) {
        err = sp_2048_mod_exp_45(tmpb, a, dq, 1024, q, 1);
    }

    if (err == MP_OKAY) {
        (void)sp_2048_sub_45(tmpa, tmpa, tmpb);
        sp_2048_cond_add_45(tmpa, tmpa, p, 0 - ((sp_int_digit)tmpa[44] >> 31));
        sp_2048_cond_add_45(tmpa, tmpa, p, 0 - ((sp_int_digit)tmpa[44] >> 31));
        sp_2048_mul_45(tmpa, tmpa, qi);
        err = sp_2048_mod_45(tmpa, tmpa, p);
    }

    if (err == MP_OKAY) {
        sp_2048_mul_45(tmpa, tmpa, q);
        (void)sp_2048_add_90(r, tmpb, tmpa);
        sp_2048_norm_90(r);

        sp_2048_to_bin(r, out);
        *outLen = 256;
    }

    XMEMSET(tmpa, 0, sizeof(tmpa));
    XMEMSET(tmpb, 0, sizeof(tmpb));
    XMEMSET(p, 0, sizeof(p));
    XMEMSET(q, 0, sizeof(q));
    XMEMSET(dp, 0, sizeof(dp));
    XMEMSET(dq, 0, sizeof(dq));
    XMEMSET(qi, 0, sizeof(qi));

    return err;
#endif /* WOLFSSL_SP_SMALL | defined(WOLFSSL_SMALL_STACK) */
#endif /* SP_RSA_PRIVATE_EXP_D | RSA_LOW_MEM */
}

#endif /* !WOLFSSL_RSA_PUBLIC_ONLY */
#endif /* WOLFSSL_HAVE_SP_RSA */
#if defined(WOLFSSL_HAVE_SP_DH) || (defined(WOLFSSL_HAVE_SP_RSA) && \
                                              !defined(WOLFSSL_RSA_PUBLIC_ONLY))
/* Convert an array of sp_digit to an mp_int.
 *
 * a  A single precision integer.
 * r  A multi-precision integer.
 */
static int sp_2048_to_mp(const sp_digit* a, mp_int* r)
{
    int err;

    err = mp_grow(r, (2048 + DIGIT_BIT - 1) / DIGIT_BIT);
    if (err == MP_OKAY) { /*lint !e774 case where err is always MP_OKAY*/
#if DIGIT_BIT == 23
        XMEMCPY(r->dp, a, sizeof(sp_digit) * 90);
        r->used = 90;
        mp_clamp(r);
#elif DIGIT_BIT < 23
        int i;
        int j = 0;
        int s = 0;

        r->dp[0] = 0;
        for (i = 0; i < 90; i++) {
            r->dp[j] |= (mp_digit)(a[i] << s);
            r->dp[j] &= ((sp_digit)1 << DIGIT_BIT) - 1;
            s = DIGIT_BIT - s;
            r->dp[++j] = (mp_digit)(a[i] >> s);
            while (s + DIGIT_BIT <= 23) {
                s += DIGIT_BIT;
                r->dp[j++] &= ((sp_digit)1 << DIGIT_BIT) - 1;
                if (s == SP_WORD_SIZE) {
                    r->dp[j] = 0;
                }
                else {
                    r->dp[j] = (mp_digit)(a[i] >> s);
                }
            }
            s = 23 - s;
        }
        r->used = (2048 + DIGIT_BIT - 1) / DIGIT_BIT;
        mp_clamp(r);
#else
        int i;
        int j = 0;
        int s = 0;

        r->dp[0] = 0;
        for (i = 0; i < 90; i++) {
            r->dp[j] |= ((mp_digit)a[i]) << s;
            if (s + 23 >= DIGIT_BIT) {
    #if DIGIT_BIT != 32 && DIGIT_BIT != 64
                r->dp[j] &= ((sp_digit)1 << DIGIT_BIT) - 1;
    #endif
                s = DIGIT_BIT - s;
                r->dp[++j] = a[i] >> s;
                s = 23 - s;
            }
            else {
                s += 23;
            }
        }
        r->used = (2048 + DIGIT_BIT - 1) / DIGIT_BIT;
        mp_clamp(r);
#endif
    }

    return err;
}

/* Perform the modular exponentiation for Diffie-Hellman.
 *
 * base  Base. MP integer.
 * exp   Exponent. MP integer.
 * mod   Modulus. MP integer.
 * res   Result. MP integer.
 * returns 0 on success, MP_READ_E if there are too many bytes in an array
 * and MEMORY_E if memory allocation fails.
 */
int sp_ModExp_2048(const mp_int* base, const mp_int* exp, const mp_int* mod,
    mp_int* res)
{
#ifdef WOLFSSL_SP_SMALL
    int err = MP_OKAY;
    sp_digit* d = NULL;
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    int expBits = mp_count_bits(exp);

    if (mp_count_bits(base) > 2048) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expBits > 2048)) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (mp_count_bits(mod) != 2048)) {
        err = MP_READ_E;
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 90 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 90 * 2;
        m = e + 90;
        r = b;

        sp_2048_from_mp(b, 90, base);
        sp_2048_from_mp(e, 90, exp);
        sp_2048_from_mp(m, 90, mod);

        err = sp_2048_mod_exp_90(r, b, e, mp_count_bits(exp), m, 0);
    }

    if (err == MP_OKAY) {
        err = sp_2048_to_mp(r, res);
    }

    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 90U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
    return err;
#else
#ifndef WOLFSSL_SMALL_STACK
    sp_digit bd[180];
    sp_digit ed[90];
    sp_digit md[90];
#else
    sp_digit* d = NULL;
#endif
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    int err = MP_OKAY;
    int expBits = mp_count_bits(exp);

    if (mp_count_bits(base) > 2048) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expBits > 2048)) {
        err = MP_READ_E;
    }
    
    if ((err == MP_OKAY) && (mp_count_bits(mod) != 2048)) {
        err = MP_READ_E;
    }

#ifdef WOLFSSL_SMALL_STACK
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 90 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL)
            err = MEMORY_E;
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 90 * 2;
        m = e + 90;
        r = b;
    }
#else
    r = b = bd;
    e = ed;
    m = md;
#endif

    if (err == MP_OKAY) {
        sp_2048_from_mp(b, 90, base);
        sp_2048_from_mp(e, 90, exp);
        sp_2048_from_mp(m, 90, mod);

        err = sp_2048_mod_exp_90(r, b, e, expBits, m, 0);
    }

    if (err == MP_OKAY) {
        err = sp_2048_to_mp(r, res);
    }


#ifdef WOLFSSL_SMALL_STACK
    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 90U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
#else
    XMEMSET(e, 0, sizeof(sp_digit) * 90U);
#endif

    return err;
#endif
}

#ifdef WOLFSSL_HAVE_SP_DH

#ifdef HAVE_FFDHE_2048
SP_NOINLINE static void sp_2048_lshift_90(sp_digit* r, const sp_digit* a,
        byte n)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    r[90] = a[89] >> (23 - n);
    for (i=89; i>0; i--) {
        r[i] = ((a[i] << n) | (a[i-1] >> (23 - n))) & 0x7fffff;
    }
#else
    sp_int_digit s;
    sp_int_digit t;

    s = (sp_int_digit)a[89];
    r[90] = s >> (23U - n);
    s = (sp_int_digit)(a[89]); t = (sp_int_digit)(a[88]);
    r[89] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[88]); t = (sp_int_digit)(a[87]);
    r[88] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[87]); t = (sp_int_digit)(a[86]);
    r[87] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[86]); t = (sp_int_digit)(a[85]);
    r[86] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[85]); t = (sp_int_digit)(a[84]);
    r[85] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[84]); t = (sp_int_digit)(a[83]);
    r[84] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[83]); t = (sp_int_digit)(a[82]);
    r[83] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[82]); t = (sp_int_digit)(a[81]);
    r[82] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[81]); t = (sp_int_digit)(a[80]);
    r[81] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[80]); t = (sp_int_digit)(a[79]);
    r[80] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[79]); t = (sp_int_digit)(a[78]);
    r[79] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[78]); t = (sp_int_digit)(a[77]);
    r[78] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[77]); t = (sp_int_digit)(a[76]);
    r[77] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[76]); t = (sp_int_digit)(a[75]);
    r[76] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[75]); t = (sp_int_digit)(a[74]);
    r[75] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[74]); t = (sp_int_digit)(a[73]);
    r[74] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[73]); t = (sp_int_digit)(a[72]);
    r[73] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[72]); t = (sp_int_digit)(a[71]);
    r[72] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[71]); t = (sp_int_digit)(a[70]);
    r[71] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[70]); t = (sp_int_digit)(a[69]);
    r[70] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[69]); t = (sp_int_digit)(a[68]);
    r[69] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[68]); t = (sp_int_digit)(a[67]);
    r[68] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[67]); t = (sp_int_digit)(a[66]);
    r[67] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[66]); t = (sp_int_digit)(a[65]);
    r[66] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[65]); t = (sp_int_digit)(a[64]);
    r[65] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[64]); t = (sp_int_digit)(a[63]);
    r[64] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[63]); t = (sp_int_digit)(a[62]);
    r[63] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[62]); t = (sp_int_digit)(a[61]);
    r[62] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[61]); t = (sp_int_digit)(a[60]);
    r[61] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[60]); t = (sp_int_digit)(a[59]);
    r[60] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[59]); t = (sp_int_digit)(a[58]);
    r[59] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[58]); t = (sp_int_digit)(a[57]);
    r[58] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[57]); t = (sp_int_digit)(a[56]);
    r[57] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[56]); t = (sp_int_digit)(a[55]);
    r[56] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[55]); t = (sp_int_digit)(a[54]);
    r[55] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[54]); t = (sp_int_digit)(a[53]);
    r[54] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[53]); t = (sp_int_digit)(a[52]);
    r[53] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[52]); t = (sp_int_digit)(a[51]);
    r[52] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[51]); t = (sp_int_digit)(a[50]);
    r[51] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[50]); t = (sp_int_digit)(a[49]);
    r[50] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[49]); t = (sp_int_digit)(a[48]);
    r[49] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[48]); t = (sp_int_digit)(a[47]);
    r[48] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[47]); t = (sp_int_digit)(a[46]);
    r[47] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[46]); t = (sp_int_digit)(a[45]);
    r[46] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[45]); t = (sp_int_digit)(a[44]);
    r[45] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[44]); t = (sp_int_digit)(a[43]);
    r[44] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[43]); t = (sp_int_digit)(a[42]);
    r[43] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[42]); t = (sp_int_digit)(a[41]);
    r[42] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[41]); t = (sp_int_digit)(a[40]);
    r[41] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[40]); t = (sp_int_digit)(a[39]);
    r[40] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[39]); t = (sp_int_digit)(a[38]);
    r[39] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[38]); t = (sp_int_digit)(a[37]);
    r[38] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[37]); t = (sp_int_digit)(a[36]);
    r[37] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[36]); t = (sp_int_digit)(a[35]);
    r[36] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[35]); t = (sp_int_digit)(a[34]);
    r[35] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[34]); t = (sp_int_digit)(a[33]);
    r[34] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[33]); t = (sp_int_digit)(a[32]);
    r[33] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[32]); t = (sp_int_digit)(a[31]);
    r[32] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[31]); t = (sp_int_digit)(a[30]);
    r[31] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[30]); t = (sp_int_digit)(a[29]);
    r[30] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[29]); t = (sp_int_digit)(a[28]);
    r[29] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[28]); t = (sp_int_digit)(a[27]);
    r[28] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[27]); t = (sp_int_digit)(a[26]);
    r[27] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[26]); t = (sp_int_digit)(a[25]);
    r[26] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[25]); t = (sp_int_digit)(a[24]);
    r[25] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[24]); t = (sp_int_digit)(a[23]);
    r[24] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[23]); t = (sp_int_digit)(a[22]);
    r[23] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[22]); t = (sp_int_digit)(a[21]);
    r[22] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[21]); t = (sp_int_digit)(a[20]);
    r[21] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[20]); t = (sp_int_digit)(a[19]);
    r[20] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[19]); t = (sp_int_digit)(a[18]);
    r[19] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[18]); t = (sp_int_digit)(a[17]);
    r[18] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[17]); t = (sp_int_digit)(a[16]);
    r[17] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[16]); t = (sp_int_digit)(a[15]);
    r[16] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[15]); t = (sp_int_digit)(a[14]);
    r[15] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[14]); t = (sp_int_digit)(a[13]);
    r[14] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[13]); t = (sp_int_digit)(a[12]);
    r[13] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[12]); t = (sp_int_digit)(a[11]);
    r[12] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[11]); t = (sp_int_digit)(a[10]);
    r[11] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[10]); t = (sp_int_digit)(a[9]);
    r[10] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[9]); t = (sp_int_digit)(a[8]);
    r[9] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[8]); t = (sp_int_digit)(a[7]);
    r[8] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[7]); t = (sp_int_digit)(a[6]);
    r[7] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[6]); t = (sp_int_digit)(a[5]);
    r[6] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[5]); t = (sp_int_digit)(a[4]);
    r[5] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[4]); t = (sp_int_digit)(a[3]);
    r[4] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[3]); t = (sp_int_digit)(a[2]);
    r[3] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[2]); t = (sp_int_digit)(a[1]);
    r[2] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[1]); t = (sp_int_digit)(a[0]);
    r[1] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
#endif
    r[0] = (a[0] << n) & 0x7fffff;
}

/* Modular exponentiate 2 to the e mod m. (r = 2^e mod m)
 *
 * r     A single precision number that is the result of the operation.
 * e     A single precision number that is the exponent.
 * bits  The number of bits in the exponent.
 * m     A single precision number that is the modulus.
 * returns 0 on success and MEMORY_E on dynamic memory allocation failure.
 */
static int sp_2048_mod_exp_2_90(sp_digit* r, const sp_digit* e, int bits, const sp_digit* m)
{
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[271];
#endif
    sp_digit* norm;
    sp_digit* tmp;
    sp_digit mp = 1;
    sp_digit n;
    sp_digit o;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 271, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
        tmp  = td + 180;
        XMEMSET(td, 0, sizeof(sp_digit) * 271);
#else
        tmp  = &td[180];
        XMEMSET(td, 0, sizeof(td));
#endif

        sp_2048_mont_setup(m, &mp);
        sp_2048_mont_norm_90(norm, m);

        bits = ((bits + 3) / 4) * 4;
        i = ((bits + 22) / 23) - 1;
        c = bits % 23;
        if (c == 0) {
            c = 23;
        }
        if (i < 90) {
            n = e[i--] << (32 - c);
        }
        else {
            n = 0;
            i--;
        }
        if (c < 4) {
            n |= e[i--] << (9 - c);
            c += 23;
        }
        y = (n >> 28) & 0xf;
        n <<= 4;
        c -= 4;
        sp_2048_lshift_90(r, norm, y);
        while ((i >= 0) || (c >= 4)) {
            if (c < 4) {
                n |= e[i--] << (9 - c);
                c += 23;
            }
            y = (n >> 28) & 0xf;
            n <<= 4;
            c -= 4;

            sp_2048_mont_sqr_90(r, r, m, mp);
            sp_2048_mont_sqr_90(r, r, m, mp);
            sp_2048_mont_sqr_90(r, r, m, mp);
            sp_2048_mont_sqr_90(r, r, m, mp);

            sp_2048_lshift_90(r, r, y);
            sp_2048_mul_d_90(tmp, norm, (r[90] << 22) + (r[89] >> 1));
            r[90] = 0;
            r[89] &= 0x1L;
            (void)sp_2048_add_90(r, r, tmp);
            sp_2048_norm_90(r);
            o = sp_2048_cmp_90(r, m);
            sp_2048_cond_sub_90(r, r, m, ((o < 0) ?
                                          (sp_digit)1 : (sp_digit)0) - 1);
        }

        sp_2048_mont_reduce_90(r, m, mp);
        n = sp_2048_cmp_90(r, m);
        sp_2048_cond_sub_90(r, r, m, ((n < 0) ?
                                                (sp_digit)1 : (sp_digit)0) - 1);
    }

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
}

#endif /* HAVE_FFDHE_2048 */

/* Perform the modular exponentiation for Diffie-Hellman.
 *
 * base     Base.
 * exp      Array of bytes that is the exponent.
 * expLen   Length of data, in bytes, in exponent.
 * mod      Modulus.
 * out      Buffer to hold big-endian bytes of exponentiation result.
 *          Must be at least 256 bytes long.
 * outLen   Length, in bytes, of exponentiation result.
 * returns 0 on success, MP_READ_E if there are too many bytes in an array
 * and MEMORY_E if memory allocation fails.
 */
int sp_DhExp_2048(const mp_int* base, const byte* exp, word32 expLen,
    const mp_int* mod, byte* out, word32* outLen)
{
#ifdef WOLFSSL_SP_SMALL
    int err = MP_OKAY;
    sp_digit* d = NULL;
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    word32 i;

    if (mp_count_bits(base) > 2048) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expLen > 256U)) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (mp_count_bits(mod) != 2048)) {
        err = MP_READ_E;
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 90 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 90 * 2;
        m = e + 90;
        r = b;

        sp_2048_from_mp(b, 90, base);
        sp_2048_from_bin(e, 90, exp, expLen);
        sp_2048_from_mp(m, 90, mod);

    #ifdef HAVE_FFDHE_2048
        if (base->used == 1 && base->dp[0] == 2 &&
                ((m[89] << 15) | (m[88] >> 8)) == 0xffffL) {
            err = sp_2048_mod_exp_2_90(r, e, expLen * 8, m);
        }
        else
    #endif
            err = sp_2048_mod_exp_90(r, b, e, expLen * 8, m, 0);
    }

    if (err == MP_OKAY) {
        sp_2048_to_bin(r, out);
        *outLen = 256;
        for (i=0; i<256 && out[i] == 0; i++) {
            /* Search for first non-zero. */
        }
        *outLen -= i;
        XMEMMOVE(out, out + i, *outLen);
    }

    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 90U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
    return err;
#else
#ifndef WOLFSSL_SMALL_STACK
    sp_digit bd[180];
    sp_digit ed[90];
    sp_digit md[90];
#else
    sp_digit* d = NULL;
#endif
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    word32 i;
    int err = MP_OKAY;

    if (mp_count_bits(base) > 2048) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expLen > 256U)) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (mp_count_bits(mod) != 2048)) {
        err = MP_READ_E;
    }
#ifdef WOLFSSL_SMALL_STACK
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 90 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL)
            err = MEMORY_E;
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 90 * 2;
        m = e + 90;
        r = b;
    }
#else
    r = b = bd;
    e = ed;
    m = md;
#endif

    if (err == MP_OKAY) {
        sp_2048_from_mp(b, 90, base);
        sp_2048_from_bin(e, 90, exp, expLen);
        sp_2048_from_mp(m, 90, mod);

    #ifdef HAVE_FFDHE_2048
        if (base->used == 1 && base->dp[0] == 2U &&
                ((m[89] << 15) | (m[88] >> 8)) == 0xffffL) {
            err = sp_2048_mod_exp_2_90(r, e, expLen * 8U, m);
        }
        else {
    #endif
            err = sp_2048_mod_exp_90(r, b, e, expLen * 8U, m, 0);
    #ifdef HAVE_FFDHE_2048
        }
    #endif
    }

    if (err == MP_OKAY) {
        sp_2048_to_bin(r, out);
        *outLen = 256;
        for (i=0; i<256U && out[i] == 0U; i++) {
            /* Search for first non-zero. */
        }
        *outLen -= i;
        XMEMMOVE(out, out + i, *outLen);
    }

#ifdef WOLFSSL_SMALL_STACK
    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 90U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
#else
    XMEMSET(e, 0, sizeof(sp_digit) * 90U);
#endif

    return err;
#endif
}
#endif /* WOLFSSL_HAVE_SP_DH */

/* Perform the modular exponentiation for Diffie-Hellman.
 *
 * base  Base. MP integer.
 * exp   Exponent. MP integer.
 * mod   Modulus. MP integer.
 * res   Result. MP integer.
 * returns 0 on success, MP_READ_E if there are too many bytes in an array
 * and MEMORY_E if memory allocation fails.
 */
int sp_ModExp_1024(const mp_int* base, const mp_int* exp, const mp_int* mod,
    mp_int* res)
{
#ifdef WOLFSSL_SP_SMALL
    int err = MP_OKAY;
    sp_digit* d = NULL;
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    int expBits = mp_count_bits(exp);

    if (mp_count_bits(base) > 1024) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expBits > 1024)) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (mp_count_bits(mod) != 1024)) {
        err = MP_READ_E;
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 45 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 45 * 2;
        m = e + 45;
        r = b;

        sp_2048_from_mp(b, 45, base);
        sp_2048_from_mp(e, 45, exp);
        sp_2048_from_mp(m, 45, mod);

        err = sp_2048_mod_exp_45(r, b, e, mp_count_bits(exp), m, 0);
    }

    if (err == MP_OKAY) {
        XMEMSET(r + 45, 0, sizeof(*r) * 45U);
        err = sp_2048_to_mp(r, res);
    }

    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 45U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
    return err;
#else
#ifndef WOLFSSL_SMALL_STACK
    sp_digit bd[90];
    sp_digit ed[45];
    sp_digit md[45];
#else
    sp_digit* d = NULL;
#endif
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    int err = MP_OKAY;
    int expBits = mp_count_bits(exp);

    if (mp_count_bits(base) > 1024) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expBits > 1024)) {
        err = MP_READ_E;
    }
    
    if ((err == MP_OKAY) && (mp_count_bits(mod) != 1024)) {
        err = MP_READ_E;
    }

#ifdef WOLFSSL_SMALL_STACK
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 45 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL)
            err = MEMORY_E;
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 45 * 2;
        m = e + 45;
        r = b;
    }
#else
    r = b = bd;
    e = ed;
    m = md;
#endif

    if (err == MP_OKAY) {
        sp_2048_from_mp(b, 45, base);
        sp_2048_from_mp(e, 45, exp);
        sp_2048_from_mp(m, 45, mod);

        err = sp_2048_mod_exp_45(r, b, e, expBits, m, 0);
    }

    if (err == MP_OKAY) {
        XMEMSET(r + 45, 0, sizeof(*r) * 45U);
        err = sp_2048_to_mp(r, res);
    }


#ifdef WOLFSSL_SMALL_STACK
    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 45U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
#else
    XMEMSET(e, 0, sizeof(sp_digit) * 45U);
#endif

    return err;
#endif
}

#endif /* WOLFSSL_HAVE_SP_DH | (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) */

#endif /* !WOLFSSL_SP_NO_2048 */

#ifndef WOLFSSL_SP_NO_3072
/* Read big endian unsigned byte array into r.
 *
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  Byte array.
 * n  Number of bytes in array to read.
 */
static void sp_3072_from_bin(sp_digit* r, int size, const byte* a, int n)
{
    int i;
    int j = 0;
    word32 s = 0;

    r[0] = 0;
    for (i = n-1; i >= 0; i--) {
        r[j] |= (((sp_digit)a[i]) << s);
        if (s >= 15U) {
            r[j] &= 0x7fffff;
            s = 23U - s;
            if (j + 1 >= size) {
                break;
            }
            r[++j] = (sp_digit)a[i] >> s;
            s = 8U - s;
        }
        else {
            s += 8U;
        }
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
}

/* Convert an mp_int to an array of sp_digit.
 *
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  A multi-precision integer.
 */
static void sp_3072_from_mp(sp_digit* r, int size, const mp_int* a)
{
#if DIGIT_BIT == 23
    int j;

    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);

    for (j = a->used; j < size; j++) {
        r[j] = 0;
    }
#elif DIGIT_BIT > 23
    int i;
    int j = 0;
    word32 s = 0;

    r[0] = 0;
    for (i = 0; i < a->used && j < size; i++) {
        r[j] |= ((sp_digit)a->dp[i] << s);
        r[j] &= 0x7fffff;
        s = 23U - s;
        if (j + 1 >= size) {
            break;
        }
        /* lint allow cast of mismatch word32 and mp_digit */
        r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
        while ((s + 23U) <= (word32)DIGIT_BIT) {
            s += 23U;
            r[j] &= 0x7fffff;
            if (j + 1 >= size) {
                break;
            }
            if (s < (word32)DIGIT_BIT) {
                /* lint allow cast of mismatch word32 and mp_digit */
                r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
            }
            else {
                r[++j] = 0L;
            }
        }
        s = (word32)DIGIT_BIT - s;
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#else
    int i;
    int j = 0;
    int s = 0;

    r[0] = 0;
    for (i = 0; i < a->used && j < size; i++) {
        r[j] |= ((sp_digit)a->dp[i]) << s;
        if (s + DIGIT_BIT >= 23) {
            r[j] &= 0x7fffff;
            if (j + 1 >= size) {
                break;
            }
            s = 23 - s;
            if (s == DIGIT_BIT) {
                r[++j] = 0;
                s = 0;
            }
            else {
                r[++j] = a->dp[i] >> s;
                s = DIGIT_BIT - s;
            }
        }
        else {
            s += DIGIT_BIT;
        }
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#endif
}

/* Write r as big endian to byte array.
 * Fixed length number of bytes written: 384
 *
 * r  A single precision integer.
 * a  Byte array.
 */
static void sp_3072_to_bin(sp_digit* r, byte* a)
{
    int i;
    int j;
    int s = 0;
    int b;

    for (i=0; i<133; i++) {
        r[i+1] += r[i] >> 23;
        r[i] &= 0x7fffff;
    }
    j = 3072 / 8 - 1;
    a[j] = 0;
    for (i=0; i<134 && j>=0; i++) {
        b = 0;
        /* lint allow cast of mismatch sp_digit and int */
        a[j--] |= (byte)(r[i] << s); /*lint !e9033*/
        b += 8 - s;
        if (j < 0) {
            break;
        }
        while (b < 23) {
            a[j--] = (byte)(r[i] >> b);
            b += 8;
            if (j < 0) {
                break;
            }
        }
        s = 8 - (b - 23);
        if (j >= 0) {
            a[j] = 0;
        }
        if (s != 0) {
            j++;
        }
    }
}

#ifndef WOLFSSL_SP_SMALL
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_3072_mul_67(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int i;
    int j;
    int64_t t[134];

    XMEMSET(t, 0, sizeof(t));
    for (i=0; i<67; i++) {
        for (j=0; j<67; j++) {
            t[i+j] += ((int64_t)a[i]) * b[j];
        }
    }
    for (i=0; i<133; i++) {
        r[i] = t[i] & 0x7fffff;
        t[i+1] += t[i] >> 23;
    }
    r[133] = (sp_digit)t[133];
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_3072_sqr_67(sp_digit* r, const sp_digit* a)
{
    int i;
    int j;
    int64_t t[134];

    XMEMSET(t, 0, sizeof(t));
    for (i=0; i<67; i++) {
        for (j=0; j<i; j++) {
            t[i+j] += (((int64_t)a[i]) * a[j]) * 2;
        }
        t[i+i] += ((int64_t)a[i]) * a[i];
    }
    for (i=0; i<133; i++) {
        r[i] = t[i] & 0x7fffff;
        t[i+1] += t[i] >> 23;
    }
    r[133] = (sp_digit)t[133];
}

/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_3072_add_67(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 64; i += 8) {
        r[i + 0] = a[i + 0] + b[i + 0];
        r[i + 1] = a[i + 1] + b[i + 1];
        r[i + 2] = a[i + 2] + b[i + 2];
        r[i + 3] = a[i + 3] + b[i + 3];
        r[i + 4] = a[i + 4] + b[i + 4];
        r[i + 5] = a[i + 5] + b[i + 5];
        r[i + 6] = a[i + 6] + b[i + 6];
        r[i + 7] = a[i + 7] + b[i + 7];
    }
    r[64] = a[64] + b[64];
    r[65] = a[65] + b[65];
    r[66] = a[66] + b[66];

    return 0;
}

/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_3072_add_134(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 128; i += 8) {
        r[i + 0] = a[i + 0] + b[i + 0];
        r[i + 1] = a[i + 1] + b[i + 1];
        r[i + 2] = a[i + 2] + b[i + 2];
        r[i + 3] = a[i + 3] + b[i + 3];
        r[i + 4] = a[i + 4] + b[i + 4];
        r[i + 5] = a[i + 5] + b[i + 5];
        r[i + 6] = a[i + 6] + b[i + 6];
        r[i + 7] = a[i + 7] + b[i + 7];
    }
    r[128] = a[128] + b[128];
    r[129] = a[129] + b[129];
    r[130] = a[130] + b[130];
    r[131] = a[131] + b[131];
    r[132] = a[132] + b[132];
    r[133] = a[133] + b[133];

    return 0;
}

/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_3072_sub_134(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 128; i += 8) {
        r[i + 0] = a[i + 0] - b[i + 0];
        r[i + 1] = a[i + 1] - b[i + 1];
        r[i + 2] = a[i + 2] - b[i + 2];
        r[i + 3] = a[i + 3] - b[i + 3];
        r[i + 4] = a[i + 4] - b[i + 4];
        r[i + 5] = a[i + 5] - b[i + 5];
        r[i + 6] = a[i + 6] - b[i + 6];
        r[i + 7] = a[i + 7] - b[i + 7];
    }
    r[128] = a[128] - b[128];
    r[129] = a[129] - b[129];
    r[130] = a[130] - b[130];
    r[131] = a[131] - b[131];
    r[132] = a[132] - b[132];
    r[133] = a[133] - b[133];

    return 0;
}

/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_3072_mul_134(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    sp_digit* z0 = r;
    sp_digit z1[134];
    sp_digit* a1 = z1;
    sp_digit b1[67];
    sp_digit* z2 = r + 134;
    (void)sp_3072_add_67(a1, a, &a[67]);
    (void)sp_3072_add_67(b1, b, &b[67]);
    sp_3072_mul_67(z2, &a[67], &b[67]);
    sp_3072_mul_67(z0, a, b);
    sp_3072_mul_67(z1, a1, b1);
    (void)sp_3072_sub_134(z1, z1, z2);
    (void)sp_3072_sub_134(z1, z1, z0);
    (void)sp_3072_add_134(r + 67, r + 67, z1);
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_3072_sqr_134(sp_digit* r, const sp_digit* a)
{
    sp_digit* z0 = r;
    sp_digit z1[134];
    sp_digit* a1 = z1;
    sp_digit* z2 = r + 134;
    (void)sp_3072_add_67(a1, a, &a[67]);
    sp_3072_sqr_67(z2, &a[67]);
    sp_3072_sqr_67(z0, a);
    sp_3072_sqr_67(z1, a1);
    (void)sp_3072_sub_134(z1, z1, z2);
    (void)sp_3072_sub_134(z1, z1, z0);
    (void)sp_3072_add_134(r + 67, r + 67, z1);
}

#endif /* !WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_3072_add_134(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 134; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_3072_sub_134(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 134; i++) {
        r[i] = a[i] - b[i];
    }

    return 0;
}

#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_3072_mul_134(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[133]) * b[133];
    r[267] = (sp_digit)(c >> 23);
    c = (c & 0x7fffff) << 23;
    for (k = 265; k >= 0; k--) {
        for (i = 133; i >= 0; i--) {
            j = k - i;
            if (j >= 134) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * b[j];
        }
        r[k + 2] += c >> 46;
        r[k + 1] = (c >> 23) & 0x7fffff;
        c = (c & 0x7fffff) << 23;
    }
    r[0] = (sp_digit)(c >> 23);
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_3072_sqr_134(sp_digit* r, const sp_digit* a)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[133]) * a[133];
    r[267] = (sp_digit)(c >> 23);
    c = (c & 0x7fffff) << 23;
    for (k = 265; k >= 0; k--) {
        for (i = 133; i >= 0; i--) {
            j = k - i;
            if (j >= 134 || i <= j) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * a[j] * 2;
        }
        if (i == j) {
           c += ((int64_t)a[i]) * a[i];
        }

        r[k + 2] += c >> 46;
        r[k + 1] = (c >> 23) & 0x7fffff;
        c = (c & 0x7fffff) << 23;
    }
    r[0] = (sp_digit)(c >> 23);
}

#endif /* WOLFSSL_SP_SMALL */
#if (defined(WOLFSSL_HAVE_SP_RSA) || defined(WOLFSSL_HAVE_SP_DH)) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)
#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_3072_add_67(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 67; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_3072_sub_67(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 67; i++) {
        r[i] = a[i] - b[i];
    }

    return 0;
}

#else
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_3072_sub_67(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 64; i += 8) {
        r[i + 0] = a[i + 0] - b[i + 0];
        r[i + 1] = a[i + 1] - b[i + 1];
        r[i + 2] = a[i + 2] - b[i + 2];
        r[i + 3] = a[i + 3] - b[i + 3];
        r[i + 4] = a[i + 4] - b[i + 4];
        r[i + 5] = a[i + 5] - b[i + 5];
        r[i + 6] = a[i + 6] - b[i + 6];
        r[i + 7] = a[i + 7] - b[i + 7];
    }
    r[64] = a[64] - b[64];
    r[65] = a[65] - b[65];
    r[66] = a[66] - b[66];

    return 0;
}

#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_3072_mul_67(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[66]) * b[66];
    r[133] = (sp_digit)(c >> 23);
    c = (c & 0x7fffff) << 23;
    for (k = 131; k >= 0; k--) {
        for (i = 66; i >= 0; i--) {
            j = k - i;
            if (j >= 67) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * b[j];
        }
        r[k + 2] += c >> 46;
        r[k + 1] = (c >> 23) & 0x7fffff;
        c = (c & 0x7fffff) << 23;
    }
    r[0] = (sp_digit)(c >> 23);
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_3072_sqr_67(sp_digit* r, const sp_digit* a)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[66]) * a[66];
    r[133] = (sp_digit)(c >> 23);
    c = (c & 0x7fffff) << 23;
    for (k = 131; k >= 0; k--) {
        for (i = 66; i >= 0; i--) {
            j = k - i;
            if (j >= 67 || i <= j) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * a[j] * 2;
        }
        if (i == j) {
           c += ((int64_t)a[i]) * a[i];
        }

        r[k + 2] += c >> 46;
        r[k + 1] = (c >> 23) & 0x7fffff;
        c = (c & 0x7fffff) << 23;
    }
    r[0] = (sp_digit)(c >> 23);
}

#endif /* WOLFSSL_SP_SMALL */
#endif /* (WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH) & !WOLFSSL_RSA_PUBLIC_ONLY */

/* Caclulate the bottom digit of -1/a mod 2^n.
 *
 * a    A single precision number.
 * rho  Bottom word of inverse.
 */
static void sp_3072_mont_setup(const sp_digit* a, sp_digit* rho)
{
    sp_digit x;
    sp_digit b;

    b = a[0];
    x = (((b + 2) & 4) << 1) + b; /* here x*a==1 mod 2**4 */
    x *= 2 - b * x;               /* here x*a==1 mod 2**8 */
    x *= 2 - b * x;               /* here x*a==1 mod 2**16 */
    x *= 2 - b * x;               /* here x*a==1 mod 2**32 */
    x &= 0x7fffff;

    /* rho = -1/m mod b */
    *rho = (1L << 23) - x;
}

/* Multiply a by scalar b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_3072_mul_d_134(sp_digit* r, const sp_digit* a,
    sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 134; i++) {
        t += tb * a[i];
        r[i] = t & 0x7fffff;
        t >>= 23;
    }
    r[134] = (sp_digit)t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] = t[0] & 0x7fffff;
    for (i = 0; i < 128; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] = (sp_digit)(t[0] >> 23) + (t[1] & 0x7fffff);
        t[2] = tb * a[i+2];
        r[i+2] = (sp_digit)(t[1] >> 23) + (t[2] & 0x7fffff);
        t[3] = tb * a[i+3];
        r[i+3] = (sp_digit)(t[2] >> 23) + (t[3] & 0x7fffff);
        t[4] = tb * a[i+4];
        r[i+4] = (sp_digit)(t[3] >> 23) + (t[4] & 0x7fffff);
        t[5] = tb * a[i+5];
        r[i+5] = (sp_digit)(t[4] >> 23) + (t[5] & 0x7fffff);
        t[6] = tb * a[i+6];
        r[i+6] = (sp_digit)(t[5] >> 23) + (t[6] & 0x7fffff);
        t[7] = tb * a[i+7];
        r[i+7] = (sp_digit)(t[6] >> 23) + (t[7] & 0x7fffff);
        t[0] = tb * a[i+8];
        r[i+8] = (sp_digit)(t[7] >> 23) + (t[0] & 0x7fffff);
    }
    t[1] = tb * a[129];
    r[129] = (sp_digit)(t[0] >> 23) + (t[1] & 0x7fffff);
    t[2] = tb * a[130];
    r[130] = (sp_digit)(t[1] >> 23) + (t[2] & 0x7fffff);
    t[3] = tb * a[131];
    r[131] = (sp_digit)(t[2] >> 23) + (t[3] & 0x7fffff);
    t[4] = tb * a[132];
    r[132] = (sp_digit)(t[3] >> 23) + (t[4] & 0x7fffff);
    t[5] = tb * a[133];
    r[133] = (sp_digit)(t[4] >> 23) + (t[5] & 0x7fffff);
    r[134] =  (sp_digit)(t[5] >> 23);
#endif /* WOLFSSL_SP_SMALL */
}

#if (defined(WOLFSSL_HAVE_SP_RSA) || defined(WOLFSSL_HAVE_SP_DH)) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)
/* r = 2^n mod m where n is the number of bits to reduce by.
 * Given m must be 3072 bits, just need to subtract.
 *
 * r  A single precision number.
 * m  A single precision number.
 */
static void sp_3072_mont_norm_67(sp_digit* r, const sp_digit* m)
{
    /* Set r = 2^n - 1. */
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=0; i<66; i++) {
        r[i] = 0x7fffff;
    }
#else
    int i;

    for (i = 0; i < 64; i += 8) {
        r[i + 0] = 0x7fffff;
        r[i + 1] = 0x7fffff;
        r[i + 2] = 0x7fffff;
        r[i + 3] = 0x7fffff;
        r[i + 4] = 0x7fffff;
        r[i + 5] = 0x7fffff;
        r[i + 6] = 0x7fffff;
        r[i + 7] = 0x7fffff;
    }
    r[64] = 0x7fffff;
    r[65] = 0x7fffff;
#endif
    r[66] = 0x3ffffL;

    /* r = (2^n - 1) mod n */
    (void)sp_3072_sub_67(r, r, m);

    /* Add one so r = 2^n mod m */
    r[0] += 1;
}

/* Compare a with b in constant time.
 *
 * a  A single precision integer.
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
static sp_digit sp_3072_cmp_67(const sp_digit* a, const sp_digit* b)
{
    sp_digit r = 0;
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=66; i>=0; i--) {
        r |= (a[i] - b[i]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#else
    int i;

    r |= (a[66] - b[66]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[65] - b[65]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[64] - b[64]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    for (i = 56; i >= 0; i -= 8) {
        r |= (a[i + 7] - b[i + 7]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 6] - b[i + 6]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 5] - b[i + 5]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 4] - b[i + 4]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 3] - b[i + 3]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 2] - b[i + 2]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 1] - b[i + 1]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 0] - b[i + 0]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#endif /* WOLFSSL_SP_SMALL */

    return r;
}

/* Conditionally subtract b from a using the mask m.
 * m is -1 to subtract and 0 when not.
 *
 * r  A single precision number representing condition subtract result.
 * a  A single precision number to subtract from.
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
static void sp_3072_cond_sub_67(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 67; i++) {
        r[i] = a[i] - (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 64; i += 8) {
        r[i + 0] = a[i + 0] - (b[i + 0] & m);
        r[i + 1] = a[i + 1] - (b[i + 1] & m);
        r[i + 2] = a[i + 2] - (b[i + 2] & m);
        r[i + 3] = a[i + 3] - (b[i + 3] & m);
        r[i + 4] = a[i + 4] - (b[i + 4] & m);
        r[i + 5] = a[i + 5] - (b[i + 5] & m);
        r[i + 6] = a[i + 6] - (b[i + 6] & m);
        r[i + 7] = a[i + 7] - (b[i + 7] & m);
    }
    r[64] = a[64] - (b[64] & m);
    r[65] = a[65] - (b[65] & m);
    r[66] = a[66] - (b[66] & m);
#endif /* WOLFSSL_SP_SMALL */
}

/* Mul a by scalar b and add into r. (r += a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_3072_mul_add_67(sp_digit* r, const sp_digit* a,
        const sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 67; i++) {
        t += (tb * a[i]) + r[i];
        r[i] = t & 0x7fffff;
        t >>= 23;
    }
    r[67] += t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] += (sp_digit)(t[0] & 0x7fffff);
    for (i = 0; i < 64; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] += (sp_digit)((t[0] >> 23) + (t[1] & 0x7fffff));
        t[2] = tb * a[i+2];
        r[i+2] += (sp_digit)((t[1] >> 23) + (t[2] & 0x7fffff));
        t[3] = tb * a[i+3];
        r[i+3] += (sp_digit)((t[2] >> 23) + (t[3] & 0x7fffff));
        t[4] = tb * a[i+4];
        r[i+4] += (sp_digit)((t[3] >> 23) + (t[4] & 0x7fffff));
        t[5] = tb * a[i+5];
        r[i+5] += (sp_digit)((t[4] >> 23) + (t[5] & 0x7fffff));
        t[6] = tb * a[i+6];
        r[i+6] += (sp_digit)((t[5] >> 23) + (t[6] & 0x7fffff));
        t[7] = tb * a[i+7];
        r[i+7] += (sp_digit)((t[6] >> 23) + (t[7] & 0x7fffff));
        t[0] = tb * a[i+8];
        r[i+8] += (sp_digit)((t[7] >> 23) + (t[0] & 0x7fffff));
    }
    t[1] = tb * a[65]; r[65] += (sp_digit)((t[0] >> 23) + (t[1] & 0x7fffff));
    t[2] = tb * a[66]; r[66] += (sp_digit)((t[1] >> 23) + (t[2] & 0x7fffff));
    r[67] +=  (sp_digit)(t[2] >> 23);
#endif /* WOLFSSL_SP_SMALL */
}

/* Normalize the values in each word to 23.
 *
 * a  Array of sp_digit to normalize.
 */
static void sp_3072_norm_67(sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    for (i = 0; i < 66; i++) {
        a[i+1] += a[i] >> 23;
        a[i] &= 0x7fffff;
    }
#else
    int i;
    for (i = 0; i < 64; i += 8) {
        a[i+1] += a[i+0] >> 23; a[i+0] &= 0x7fffff;
        a[i+2] += a[i+1] >> 23; a[i+1] &= 0x7fffff;
        a[i+3] += a[i+2] >> 23; a[i+2] &= 0x7fffff;
        a[i+4] += a[i+3] >> 23; a[i+3] &= 0x7fffff;
        a[i+5] += a[i+4] >> 23; a[i+4] &= 0x7fffff;
        a[i+6] += a[i+5] >> 23; a[i+5] &= 0x7fffff;
        a[i+7] += a[i+6] >> 23; a[i+6] &= 0x7fffff;
        a[i+8] += a[i+7] >> 23; a[i+7] &= 0x7fffff;
        a[i+9] += a[i+8] >> 23; a[i+8] &= 0x7fffff;
    }
    a[64+1] += a[64] >> 23;
    a[64] &= 0x7fffff;
    a[65+1] += a[65] >> 23;
    a[65] &= 0x7fffff;
#endif
}

/* Shift the result in the high 1536 bits down to the bottom.
 *
 * r  A single precision number.
 * a  A single precision number.
 */
static void sp_3072_mont_shift_67(sp_digit* r, const sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    sp_digit n;
    sp_digit s;

    s = a[67];
    n = a[66] >> 18;
    for (i = 0; i < 66; i++) {
        n += (s & 0x7fffff) << 5;
        r[i] = n & 0x7fffff;
        n >>= 23;
        s = a[68 + i] + (s >> 23);
    }
    n += s << 5;
    r[66] = n;
#else
    sp_digit n;
    sp_digit s;
    int i;

    s = a[67]; n = a[66] >> 18;
    for (i = 0; i < 64; i += 8) {
        n += (s & 0x7fffff) << 5; r[i+0] = n & 0x7fffff;
        n >>= 23; s = a[i+68] + (s >> 23);
        n += (s & 0x7fffff) << 5; r[i+1] = n & 0x7fffff;
        n >>= 23; s = a[i+69] + (s >> 23);
        n += (s & 0x7fffff) << 5; r[i+2] = n & 0x7fffff;
        n >>= 23; s = a[i+70] + (s >> 23);
        n += (s & 0x7fffff) << 5; r[i+3] = n & 0x7fffff;
        n >>= 23; s = a[i+71] + (s >> 23);
        n += (s & 0x7fffff) << 5; r[i+4] = n & 0x7fffff;
        n >>= 23; s = a[i+72] + (s >> 23);
        n += (s & 0x7fffff) << 5; r[i+5] = n & 0x7fffff;
        n >>= 23; s = a[i+73] + (s >> 23);
        n += (s & 0x7fffff) << 5; r[i+6] = n & 0x7fffff;
        n >>= 23; s = a[i+74] + (s >> 23);
        n += (s & 0x7fffff) << 5; r[i+7] = n & 0x7fffff;
        n >>= 23; s = a[i+75] + (s >> 23);
    }
    n += (s & 0x7fffff) << 5; r[64] = n & 0x7fffff;
    n >>= 23; s = a[132] + (s >> 23);
    n += (s & 0x7fffff) << 5; r[65] = n & 0x7fffff;
    n >>= 23; s = a[133] + (s >> 23);
    n += s << 5;              r[66] = n;
#endif /* WOLFSSL_SP_SMALL */
    XMEMSET(&r[67], 0, sizeof(*r) * 67U);
}

/* Reduce the number back to 3072 bits using Montgomery reduction.
 *
 * a   A single precision number to reduce in place.
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
static void sp_3072_mont_reduce_67(sp_digit* a, const sp_digit* m, sp_digit mp)
{
    int i;
    sp_digit mu;

    sp_3072_norm_67(a + 67);

    for (i=0; i<66; i++) {
        mu = (a[i] * mp) & 0x7fffff;
        sp_3072_mul_add_67(a+i, m, mu);
        a[i+1] += a[i] >> 23;
    }
    mu = (a[i] * mp) & 0x3ffffL;
    sp_3072_mul_add_67(a+i, m, mu);
    a[i+1] += a[i] >> 23;
    a[i] &= 0x7fffff;

    sp_3072_mont_shift_67(a, a);
    sp_3072_cond_sub_67(a, a, m, 0 - (((a[66] >> 18) > 0) ?
            (sp_digit)1 : (sp_digit)0));
    sp_3072_norm_67(a);
}

/* Multiply two Montogmery form numbers mod the modulus (prime).
 * (r = a * b mod m)
 *
 * r   Result of multiplication.
 * a   First number to multiply in Montogmery form.
 * b   Second number to multiply in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_3072_mont_mul_67(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit* m, sp_digit mp)
{
    sp_3072_mul_67(r, a, b);
    sp_3072_mont_reduce_67(r, m, mp);
}

/* Square the Montgomery form number. (r = a * a mod m)
 *
 * r   Result of squaring.
 * a   Number to square in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_3072_mont_sqr_67(sp_digit* r, const sp_digit* a,
        const sp_digit* m, sp_digit mp)
{
    sp_3072_sqr_67(r, a);
    sp_3072_mont_reduce_67(r, m, mp);
}

/* Multiply a by scalar b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_3072_mul_d_67(sp_digit* r, const sp_digit* a,
    sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 67; i++) {
        t += tb * a[i];
        r[i] = t & 0x7fffff;
        t >>= 23;
    }
    r[67] = (sp_digit)t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] = t[0] & 0x7fffff;
    for (i = 0; i < 64; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] = (sp_digit)(t[0] >> 23) + (t[1] & 0x7fffff);
        t[2] = tb * a[i+2];
        r[i+2] = (sp_digit)(t[1] >> 23) + (t[2] & 0x7fffff);
        t[3] = tb * a[i+3];
        r[i+3] = (sp_digit)(t[2] >> 23) + (t[3] & 0x7fffff);
        t[4] = tb * a[i+4];
        r[i+4] = (sp_digit)(t[3] >> 23) + (t[4] & 0x7fffff);
        t[5] = tb * a[i+5];
        r[i+5] = (sp_digit)(t[4] >> 23) + (t[5] & 0x7fffff);
        t[6] = tb * a[i+6];
        r[i+6] = (sp_digit)(t[5] >> 23) + (t[6] & 0x7fffff);
        t[7] = tb * a[i+7];
        r[i+7] = (sp_digit)(t[6] >> 23) + (t[7] & 0x7fffff);
        t[0] = tb * a[i+8];
        r[i+8] = (sp_digit)(t[7] >> 23) + (t[0] & 0x7fffff);
    }
    t[1] = tb * a[65];
    r[65] = (sp_digit)(t[0] >> 23) + (t[1] & 0x7fffff);
    t[2] = tb * a[66];
    r[66] = (sp_digit)(t[1] >> 23) + (t[2] & 0x7fffff);
    r[67] =  (sp_digit)(t[2] >> 23);
#endif /* WOLFSSL_SP_SMALL */
}

/* Conditionally add a and b using the mask m.
 * m is -1 to add and 0 when not.
 *
 * r  A single precision number representing conditional add result.
 * a  A single precision number to add with.
 * b  A single precision number to add.
 * m  Mask value to apply.
 */
static void sp_3072_cond_add_67(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 67; i++) {
        r[i] = a[i] + (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 64; i += 8) {
        r[i + 0] = a[i + 0] + (b[i + 0] & m);
        r[i + 1] = a[i + 1] + (b[i + 1] & m);
        r[i + 2] = a[i + 2] + (b[i + 2] & m);
        r[i + 3] = a[i + 3] + (b[i + 3] & m);
        r[i + 4] = a[i + 4] + (b[i + 4] & m);
        r[i + 5] = a[i + 5] + (b[i + 5] & m);
        r[i + 6] = a[i + 6] + (b[i + 6] & m);
        r[i + 7] = a[i + 7] + (b[i + 7] & m);
    }
    r[64] = a[64] + (b[64] & m);
    r[65] = a[65] + (b[65] & m);
    r[66] = a[66] + (b[66] & m);
#endif /* WOLFSSL_SP_SMALL */
}

#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_3072_add_67(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 67; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#endif
#ifdef WOLFSSL_SP_DIV_32
static WC_INLINE sp_digit sp_3072_div_word_67(sp_digit d1, sp_digit d0,
    sp_digit dv)
{
    sp_digit d;
    sp_digit r;
    sp_digit t;

    /* All 23 bits from d1 and top 8 bits from d0. */
    d = (d1 << 8) | (d0 >> 15);
    r = d / dv;
    d -= r * dv;
    /* Up to 9 bits in r */
    /* Next 8 bits from d0. */
    r <<= 8;
    d <<= 8;
    d |= (d0 >> 7) & ((1 << 8) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 17 bits in r */
    /* Remaining 7 bits from d0. */
    r <<= 7;
    d <<= 7;
    d |= d0 & ((1 << 7) - 1);
    t = d / dv;
    r += t;

    return r;
}
#endif /* WOLFSSL_SP_DIV_32 */

/* Divide d in a and put remainder into r (m*d + r = a)
 * m is not calculated as it is not needed at this time.
 *
 * a  Number to be divided.
 * d  Number to divide with.
 * m  Multiplier result.
 * r  Remainder from the division.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_3072_div_67(const sp_digit* a, const sp_digit* d,
        const sp_digit* m, sp_digit* r)
{
    int i;
#ifndef WOLFSSL_SP_DIV_32
    int64_t d1;
#endif
    sp_digit dv;
    sp_digit r1;
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit t1d[134];
    sp_digit t2d[67 + 1];
#endif
    sp_digit* t1;
    sp_digit* t2;
    int err = MP_OKAY;

    (void)m;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * (3 * 67 + 1), NULL,
                                                       DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t1 = td;
        t2 = td + 2 * 67;
#else
        t1 = t1d;
        t2 = t2d;
#endif

        dv = d[66];
        XMEMCPY(t1, a, sizeof(*t1) * 2U * 67U);
        for (i=66; i>=0; i--) {
            t1[67 + i] += t1[67 + i - 1] >> 23;
            t1[67 + i - 1] &= 0x7fffff;
#ifndef WOLFSSL_SP_DIV_32
            d1 = t1[67 + i];
            d1 <<= 23;
            d1 += t1[67 + i - 1];
            r1 = (sp_digit)(d1 / dv);
#else
            r1 = sp_3072_div_word_67(t1[67 + i], t1[67 + i - 1], dv);
#endif

            sp_3072_mul_d_67(t2, d, r1);
            (void)sp_3072_sub_67(&t1[i], &t1[i], t2);
            t1[67 + i] -= t2[67];
            t1[67 + i] += t1[67 + i - 1] >> 23;
            t1[67 + i - 1] &= 0x7fffff;
            r1 = (((-t1[67 + i]) << 23) - t1[67 + i - 1]) / dv;
            r1++;
            sp_3072_mul_d_67(t2, d, r1);
            (void)sp_3072_add_67(&t1[i], &t1[i], t2);
            t1[67 + i] += t1[67 + i - 1] >> 23;
            t1[67 + i - 1] &= 0x7fffff;
        }
        t1[67 - 1] += t1[67 - 2] >> 23;
        t1[67 - 2] &= 0x7fffff;
        r1 = t1[67 - 1] / dv;

        sp_3072_mul_d_67(t2, d, r1);
        (void)sp_3072_sub_67(t1, t1, t2);
        XMEMCPY(r, t1, sizeof(*r) * 2U * 67U);
        for (i=0; i<66; i++) {
            r[i+1] += r[i] >> 23;
            r[i] &= 0x7fffff;
        }
        sp_3072_cond_add_67(r, r, d, 0 - ((r[66] < 0) ?
                    (sp_digit)1 : (sp_digit)0));
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
}

/* Reduce a modulo m into r. (r = a mod m)
 *
 * r  A single precision number that is the reduced result.
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_3072_mod_67(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    return sp_3072_div_67(a, m, NULL, r);
}

/* Modular exponentiate a to the e mod m. (r = a^e mod m)
 *
 * r     A single precision number that is the result of the operation.
 * a     A single precision number being exponentiated.
 * e     A single precision number that is the exponent.
 * bits  The number of bits in the exponent.
 * m     A single precision number that is the modulus.
 * returns 0 on success and MEMORY_E on dynamic memory allocation failure.
 */
static int sp_3072_mod_exp_67(sp_digit* r, const sp_digit* a, const sp_digit* e, int bits,
    const sp_digit* m, int reduceA)
{
#ifdef WOLFSSL_SP_SMALL
#if !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[3 * 134];
#endif
    sp_digit* t[3];
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 3 * 67 * 2, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
        for (i=0; i<3; i++) {
#if !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + (i * 67 * 2);
#else
            t[i] = &td[i * 67 * 2];
#endif
            XMEMSET(t[i], 0, sizeof(sp_digit) * 67U * 2U);
        }

        sp_3072_mont_setup(m, &mp);
        sp_3072_mont_norm_67(norm, m);

        if (reduceA != 0) {
            err = sp_3072_mod_67(t[1], a, m);
        }
        else {
            XMEMCPY(t[1], a, sizeof(sp_digit) * 67U);
        }
    }
    if (err == MP_OKAY) {
        sp_3072_mul_67(t[1], t[1], norm);
        err = sp_3072_mod_67(t[1], t[1], m);
    }

    if (err == MP_OKAY) {
        i = bits / 23;
        c = bits % 23;
        n = e[i--] << (23 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1) {
                    break;
                }

                n = e[i--];
                c = 23;
            }

            y = (n >> 22) & 1;
            n <<= 1;

            sp_3072_mont_mul_67(t[y^1], t[0], t[1], m, mp);

            XMEMCPY(t[2], (void*)(((size_t)t[0] & addr_mask[y^1]) +
                                  ((size_t)t[1] & addr_mask[y])),
                                  sizeof(*t[2]) * 67 * 2);
            sp_3072_mont_sqr_67(t[2], t[2], m, mp);
            XMEMCPY((void*)(((size_t)t[0] & addr_mask[y^1]) +
                            ((size_t)t[1] & addr_mask[y])), t[2],
                            sizeof(*t[2]) * 67 * 2);
        }

        sp_3072_mont_reduce_67(t[0], m, mp);
        n = sp_3072_cmp_67(t[0], m);
        sp_3072_cond_sub_67(t[0], t[0], m, ((n < 0) ?
                    (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, t[0], sizeof(*r) * 67 * 2);

    }

#if !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#elif defined(WOLFSSL_SP_CACHE_RESISTANT)
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[3 * 134];
#endif
    sp_digit* t[3];
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#ifdef WOLFSSL_SMALL_STACK
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 3 * 67 * 2, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
        for (i=0; i<3; i++) {
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + (i * 67 * 2);
#else
            t[i] = &td[i * 67 * 2];
#endif
        }

        sp_3072_mont_setup(m, &mp);
        sp_3072_mont_norm_67(norm, m);

        if (reduceA != 0) {
            err = sp_3072_mod_67(t[1], a, m);
            if (err == MP_OKAY) {
                sp_3072_mul_67(t[1], t[1], norm);
                err = sp_3072_mod_67(t[1], t[1], m);
            }
        }
        else {
            sp_3072_mul_67(t[1], a, norm);
            err = sp_3072_mod_67(t[1], t[1], m);
        }
    }

    if (err == MP_OKAY) {
        i = bits / 23;
        c = bits % 23;
        n = e[i--] << (23 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1) {
                    break;
                }

                n = e[i--];
                c = 23;
            }

            y = (n >> 22) & 1;
            n <<= 1;

            sp_3072_mont_mul_67(t[y^1], t[0], t[1], m, mp);

            XMEMCPY(t[2], (void*)(((size_t)t[0] & addr_mask[y^1]) +
                                  ((size_t)t[1] & addr_mask[y])), 
                                  sizeof(*t[2]) * 67 * 2);
            sp_3072_mont_sqr_67(t[2], t[2], m, mp);
            XMEMCPY((void*)(((size_t)t[0] & addr_mask[y^1]) +
                            ((size_t)t[1] & addr_mask[y])), t[2], 
                            sizeof(*t[2]) * 67 * 2);
        }

        sp_3072_mont_reduce_67(t[0], m, mp);
        n = sp_3072_cmp_67(t[0], m);
        sp_3072_cond_sub_67(t[0], t[0], m, ((n < 0) ?
                    (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, t[0], sizeof(*r) * 67 * 2);
    }

#ifdef WOLFSSL_SMALL_STACK
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#else
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[(32 * 134) + 134];
#endif
    sp_digit* t[32];
    sp_digit* rt = NULL;
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * ((32 * 134) + 134), NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
        for (i=0; i<32; i++)
            t[i] = td + i * 134;
        rt = td + 4288;
#else
        for (i=0; i<32; i++)
            t[i] = &td[i * 134];
        rt = &td[4288];
#endif

        sp_3072_mont_setup(m, &mp);
        sp_3072_mont_norm_67(norm, m);

        if (reduceA != 0) {
            err = sp_3072_mod_67(t[1], a, m);
            if (err == MP_OKAY) {
                sp_3072_mul_67(t[1], t[1], norm);
                err = sp_3072_mod_67(t[1], t[1], m);
            }
        }
        else {
            sp_3072_mul_67(t[1], a, norm);
            err = sp_3072_mod_67(t[1], t[1], m);
        }
    }

    if (err == MP_OKAY) {
        sp_3072_mont_sqr_67(t[ 2], t[ 1], m, mp);
        sp_3072_mont_mul_67(t[ 3], t[ 2], t[ 1], m, mp);
        sp_3072_mont_sqr_67(t[ 4], t[ 2], m, mp);
        sp_3072_mont_mul_67(t[ 5], t[ 3], t[ 2], m, mp);
        sp_3072_mont_sqr_67(t[ 6], t[ 3], m, mp);
        sp_3072_mont_mul_67(t[ 7], t[ 4], t[ 3], m, mp);
        sp_3072_mont_sqr_67(t[ 8], t[ 4], m, mp);
        sp_3072_mont_mul_67(t[ 9], t[ 5], t[ 4], m, mp);
        sp_3072_mont_sqr_67(t[10], t[ 5], m, mp);
        sp_3072_mont_mul_67(t[11], t[ 6], t[ 5], m, mp);
        sp_3072_mont_sqr_67(t[12], t[ 6], m, mp);
        sp_3072_mont_mul_67(t[13], t[ 7], t[ 6], m, mp);
        sp_3072_mont_sqr_67(t[14], t[ 7], m, mp);
        sp_3072_mont_mul_67(t[15], t[ 8], t[ 7], m, mp);
        sp_3072_mont_sqr_67(t[16], t[ 8], m, mp);
        sp_3072_mont_mul_67(t[17], t[ 9], t[ 8], m, mp);
        sp_3072_mont_sqr_67(t[18], t[ 9], m, mp);
        sp_3072_mont_mul_67(t[19], t[10], t[ 9], m, mp);
        sp_3072_mont_sqr_67(t[20], t[10], m, mp);
        sp_3072_mont_mul_67(t[21], t[11], t[10], m, mp);
        sp_3072_mont_sqr_67(t[22], t[11], m, mp);
        sp_3072_mont_mul_67(t[23], t[12], t[11], m, mp);
        sp_3072_mont_sqr_67(t[24], t[12], m, mp);
        sp_3072_mont_mul_67(t[25], t[13], t[12], m, mp);
        sp_3072_mont_sqr_67(t[26], t[13], m, mp);
        sp_3072_mont_mul_67(t[27], t[14], t[13], m, mp);
        sp_3072_mont_sqr_67(t[28], t[14], m, mp);
        sp_3072_mont_mul_67(t[29], t[15], t[14], m, mp);
        sp_3072_mont_sqr_67(t[30], t[15], m, mp);
        sp_3072_mont_mul_67(t[31], t[16], t[15], m, mp);

        bits = ((bits + 4) / 5) * 5;
        i = ((bits + 22) / 23) - 1;
        c = bits % 23;
        if (c == 0) {
            c = 23;
        }
        if (i < 67) {
            n = e[i--] << (32 - c);
        }
        else {
            n = 0;
            i--;
        }
        if (c < 5) {
            n |= e[i--] << (9 - c);
            c += 23;
        }
        y = (n >> 27) & 0x1f;
        n <<= 5;
        c -= 5;
        XMEMCPY(rt, t[y], sizeof(sp_digit) * 134);
        while ((i >= 0) || (c >= 5)) {
            if (c < 5) {
                n |= e[i--] << (9 - c);
                c += 23;
            }
            y = (n >> 27) & 0x1f;
            n <<= 5;
            c -= 5;

            sp_3072_mont_sqr_67(rt, rt, m, mp);
            sp_3072_mont_sqr_67(rt, rt, m, mp);
            sp_3072_mont_sqr_67(rt, rt, m, mp);
            sp_3072_mont_sqr_67(rt, rt, m, mp);
            sp_3072_mont_sqr_67(rt, rt, m, mp);

            sp_3072_mont_mul_67(rt, rt, t[y], m, mp);
        }

        sp_3072_mont_reduce_67(rt, m, mp);
        n = sp_3072_cmp_67(rt, m);
        sp_3072_cond_sub_67(rt, rt, m, ((n < 0) ?
                   (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, rt, sizeof(sp_digit) * 134);
    }

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#endif
}

#endif /* (WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH) & !WOLFSSL_RSA_PUBLIC_ONLY */

/* r = 2^n mod m where n is the number of bits to reduce by.
 * Given m must be 3072 bits, just need to subtract.
 *
 * r  A single precision number.
 * m  A single precision number.
 */
static void sp_3072_mont_norm_134(sp_digit* r, const sp_digit* m)
{
    /* Set r = 2^n - 1. */
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=0; i<133; i++) {
        r[i] = 0x7fffff;
    }
#else
    int i;

    for (i = 0; i < 128; i += 8) {
        r[i + 0] = 0x7fffff;
        r[i + 1] = 0x7fffff;
        r[i + 2] = 0x7fffff;
        r[i + 3] = 0x7fffff;
        r[i + 4] = 0x7fffff;
        r[i + 5] = 0x7fffff;
        r[i + 6] = 0x7fffff;
        r[i + 7] = 0x7fffff;
    }
    r[128] = 0x7fffff;
    r[129] = 0x7fffff;
    r[130] = 0x7fffff;
    r[131] = 0x7fffff;
    r[132] = 0x7fffff;
#endif
    r[133] = 0x1fffL;

    /* r = (2^n - 1) mod n */
    (void)sp_3072_sub_134(r, r, m);

    /* Add one so r = 2^n mod m */
    r[0] += 1;
}

/* Compare a with b in constant time.
 *
 * a  A single precision integer.
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
static sp_digit sp_3072_cmp_134(const sp_digit* a, const sp_digit* b)
{
    sp_digit r = 0;
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=133; i>=0; i--) {
        r |= (a[i] - b[i]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#else
    int i;

    r |= (a[133] - b[133]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[132] - b[132]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[131] - b[131]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[130] - b[130]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[129] - b[129]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[128] - b[128]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    for (i = 120; i >= 0; i -= 8) {
        r |= (a[i + 7] - b[i + 7]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 6] - b[i + 6]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 5] - b[i + 5]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 4] - b[i + 4]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 3] - b[i + 3]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 2] - b[i + 2]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 1] - b[i + 1]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 0] - b[i + 0]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#endif /* WOLFSSL_SP_SMALL */

    return r;
}

/* Conditionally subtract b from a using the mask m.
 * m is -1 to subtract and 0 when not.
 *
 * r  A single precision number representing condition subtract result.
 * a  A single precision number to subtract from.
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
static void sp_3072_cond_sub_134(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 134; i++) {
        r[i] = a[i] - (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 128; i += 8) {
        r[i + 0] = a[i + 0] - (b[i + 0] & m);
        r[i + 1] = a[i + 1] - (b[i + 1] & m);
        r[i + 2] = a[i + 2] - (b[i + 2] & m);
        r[i + 3] = a[i + 3] - (b[i + 3] & m);
        r[i + 4] = a[i + 4] - (b[i + 4] & m);
        r[i + 5] = a[i + 5] - (b[i + 5] & m);
        r[i + 6] = a[i + 6] - (b[i + 6] & m);
        r[i + 7] = a[i + 7] - (b[i + 7] & m);
    }
    r[128] = a[128] - (b[128] & m);
    r[129] = a[129] - (b[129] & m);
    r[130] = a[130] - (b[130] & m);
    r[131] = a[131] - (b[131] & m);
    r[132] = a[132] - (b[132] & m);
    r[133] = a[133] - (b[133] & m);
#endif /* WOLFSSL_SP_SMALL */
}

/* Mul a by scalar b and add into r. (r += a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_3072_mul_add_134(sp_digit* r, const sp_digit* a,
        const sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 134; i++) {
        t += (tb * a[i]) + r[i];
        r[i] = t & 0x7fffff;
        t >>= 23;
    }
    r[134] += t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] += (sp_digit)(t[0] & 0x7fffff);
    for (i = 0; i < 128; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] += (sp_digit)((t[0] >> 23) + (t[1] & 0x7fffff));
        t[2] = tb * a[i+2];
        r[i+2] += (sp_digit)((t[1] >> 23) + (t[2] & 0x7fffff));
        t[3] = tb * a[i+3];
        r[i+3] += (sp_digit)((t[2] >> 23) + (t[3] & 0x7fffff));
        t[4] = tb * a[i+4];
        r[i+4] += (sp_digit)((t[3] >> 23) + (t[4] & 0x7fffff));
        t[5] = tb * a[i+5];
        r[i+5] += (sp_digit)((t[4] >> 23) + (t[5] & 0x7fffff));
        t[6] = tb * a[i+6];
        r[i+6] += (sp_digit)((t[5] >> 23) + (t[6] & 0x7fffff));
        t[7] = tb * a[i+7];
        r[i+7] += (sp_digit)((t[6] >> 23) + (t[7] & 0x7fffff));
        t[0] = tb * a[i+8];
        r[i+8] += (sp_digit)((t[7] >> 23) + (t[0] & 0x7fffff));
    }
    t[1] = tb * a[129]; r[129] += (sp_digit)((t[0] >> 23) + (t[1] & 0x7fffff));
    t[2] = tb * a[130]; r[130] += (sp_digit)((t[1] >> 23) + (t[2] & 0x7fffff));
    t[3] = tb * a[131]; r[131] += (sp_digit)((t[2] >> 23) + (t[3] & 0x7fffff));
    t[4] = tb * a[132]; r[132] += (sp_digit)((t[3] >> 23) + (t[4] & 0x7fffff));
    t[5] = tb * a[133]; r[133] += (sp_digit)((t[4] >> 23) + (t[5] & 0x7fffff));
    r[134] +=  (sp_digit)(t[5] >> 23);
#endif /* WOLFSSL_SP_SMALL */
}

/* Normalize the values in each word to 23.
 *
 * a  Array of sp_digit to normalize.
 */
static void sp_3072_norm_134(sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    for (i = 0; i < 133; i++) {
        a[i+1] += a[i] >> 23;
        a[i] &= 0x7fffff;
    }
#else
    int i;
    for (i = 0; i < 128; i += 8) {
        a[i+1] += a[i+0] >> 23; a[i+0] &= 0x7fffff;
        a[i+2] += a[i+1] >> 23; a[i+1] &= 0x7fffff;
        a[i+3] += a[i+2] >> 23; a[i+2] &= 0x7fffff;
        a[i+4] += a[i+3] >> 23; a[i+3] &= 0x7fffff;
        a[i+5] += a[i+4] >> 23; a[i+4] &= 0x7fffff;
        a[i+6] += a[i+5] >> 23; a[i+5] &= 0x7fffff;
        a[i+7] += a[i+6] >> 23; a[i+6] &= 0x7fffff;
        a[i+8] += a[i+7] >> 23; a[i+7] &= 0x7fffff;
        a[i+9] += a[i+8] >> 23; a[i+8] &= 0x7fffff;
    }
    a[128+1] += a[128] >> 23;
    a[128] &= 0x7fffff;
    a[129+1] += a[129] >> 23;
    a[129] &= 0x7fffff;
    a[130+1] += a[130] >> 23;
    a[130] &= 0x7fffff;
    a[131+1] += a[131] >> 23;
    a[131] &= 0x7fffff;
    a[132+1] += a[132] >> 23;
    a[132] &= 0x7fffff;
#endif
}

/* Shift the result in the high 3072 bits down to the bottom.
 *
 * r  A single precision number.
 * a  A single precision number.
 */
static void sp_3072_mont_shift_134(sp_digit* r, const sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    int64_t n = a[133] >> 13;
    n += ((int64_t)a[134]) << 10;

    for (i = 0; i < 133; i++) {
        r[i] = n & 0x7fffff;
        n >>= 23;
        n += ((int64_t)a[135 + i]) << 10;
    }
    r[133] = (sp_digit)n;
#else
    int i;
    int64_t n = a[133] >> 13;
    n += ((int64_t)a[134]) << 10;
    for (i = 0; i < 128; i += 8) {
        r[i + 0] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 135]) << 10;
        r[i + 1] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 136]) << 10;
        r[i + 2] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 137]) << 10;
        r[i + 3] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 138]) << 10;
        r[i + 4] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 139]) << 10;
        r[i + 5] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 140]) << 10;
        r[i + 6] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 141]) << 10;
        r[i + 7] = n & 0x7fffff;
        n >>= 23; n += ((int64_t)a[i + 142]) << 10;
    }
    r[128] = n & 0x7fffff; n >>= 23; n += ((int64_t)a[263]) << 10;
    r[129] = n & 0x7fffff; n >>= 23; n += ((int64_t)a[264]) << 10;
    r[130] = n & 0x7fffff; n >>= 23; n += ((int64_t)a[265]) << 10;
    r[131] = n & 0x7fffff; n >>= 23; n += ((int64_t)a[266]) << 10;
    r[132] = n & 0x7fffff; n >>= 23; n += ((int64_t)a[267]) << 10;
    r[133] = (sp_digit)n;
#endif /* WOLFSSL_SP_SMALL */
    XMEMSET(&r[134], 0, sizeof(*r) * 134U);
}

/* Reduce the number back to 3072 bits using Montgomery reduction.
 *
 * a   A single precision number to reduce in place.
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
static void sp_3072_mont_reduce_134(sp_digit* a, const sp_digit* m, sp_digit mp)
{
    int i;
    sp_digit mu;

    sp_3072_norm_134(a + 134);

#ifdef WOLFSSL_SP_DH
    if (mp != 1) {
        for (i=0; i<133; i++) {
            mu = (a[i] * mp) & 0x7fffff;
            sp_3072_mul_add_134(a+i, m, mu);
            a[i+1] += a[i] >> 23;
        }
        mu = (a[i] * mp) & 0x1fffL;
        sp_3072_mul_add_134(a+i, m, mu);
        a[i+1] += a[i] >> 23;
        a[i] &= 0x7fffff;
    }
    else {
        for (i=0; i<133; i++) {
            mu = a[i] & 0x7fffff;
            sp_3072_mul_add_134(a+i, m, mu);
            a[i+1] += a[i] >> 23;
        }
        mu = a[i] & 0x1fffL;
        sp_3072_mul_add_134(a+i, m, mu);
        a[i+1] += a[i] >> 23;
        a[i] &= 0x7fffff;
    }
#else
    for (i=0; i<133; i++) {
        mu = (a[i] * mp) & 0x7fffff;
        sp_3072_mul_add_134(a+i, m, mu);
        a[i+1] += a[i] >> 23;
    }
    mu = (a[i] * mp) & 0x1fffL;
    sp_3072_mul_add_134(a+i, m, mu);
    a[i+1] += a[i] >> 23;
    a[i] &= 0x7fffff;
#endif

    sp_3072_mont_shift_134(a, a);
    sp_3072_cond_sub_134(a, a, m, 0 - (((a[133] >> 13) > 0) ?
            (sp_digit)1 : (sp_digit)0));
    sp_3072_norm_134(a);
}

/* Multiply two Montogmery form numbers mod the modulus (prime).
 * (r = a * b mod m)
 *
 * r   Result of multiplication.
 * a   First number to multiply in Montogmery form.
 * b   Second number to multiply in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_3072_mont_mul_134(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit* m, sp_digit mp)
{
    sp_3072_mul_134(r, a, b);
    sp_3072_mont_reduce_134(r, m, mp);
}

/* Square the Montgomery form number. (r = a * a mod m)
 *
 * r   Result of squaring.
 * a   Number to square in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_3072_mont_sqr_134(sp_digit* r, const sp_digit* a,
        const sp_digit* m, sp_digit mp)
{
    sp_3072_sqr_134(r, a);
    sp_3072_mont_reduce_134(r, m, mp);
}

/* Multiply a by scalar b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_3072_mul_d_268(sp_digit* r, const sp_digit* a,
    sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 268; i++) {
        t += tb * a[i];
        r[i] = t & 0x7fffff;
        t >>= 23;
    }
    r[268] = (sp_digit)t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] = t[0] & 0x7fffff;
    for (i = 0; i < 264; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] = (sp_digit)(t[0] >> 23) + (t[1] & 0x7fffff);
        t[2] = tb * a[i+2];
        r[i+2] = (sp_digit)(t[1] >> 23) + (t[2] & 0x7fffff);
        t[3] = tb * a[i+3];
        r[i+3] = (sp_digit)(t[2] >> 23) + (t[3] & 0x7fffff);
        t[4] = tb * a[i+4];
        r[i+4] = (sp_digit)(t[3] >> 23) + (t[4] & 0x7fffff);
        t[5] = tb * a[i+5];
        r[i+5] = (sp_digit)(t[4] >> 23) + (t[5] & 0x7fffff);
        t[6] = tb * a[i+6];
        r[i+6] = (sp_digit)(t[5] >> 23) + (t[6] & 0x7fffff);
        t[7] = tb * a[i+7];
        r[i+7] = (sp_digit)(t[6] >> 23) + (t[7] & 0x7fffff);
        t[0] = tb * a[i+8];
        r[i+8] = (sp_digit)(t[7] >> 23) + (t[0] & 0x7fffff);
    }
    t[1] = tb * a[265];
    r[265] = (sp_digit)(t[0] >> 23) + (t[1] & 0x7fffff);
    t[2] = tb * a[266];
    r[266] = (sp_digit)(t[1] >> 23) + (t[2] & 0x7fffff);
    t[3] = tb * a[267];
    r[267] = (sp_digit)(t[2] >> 23) + (t[3] & 0x7fffff);
    r[268] =  (sp_digit)(t[3] >> 23);
#endif /* WOLFSSL_SP_SMALL */
}

/* Conditionally add a and b using the mask m.
 * m is -1 to add and 0 when not.
 *
 * r  A single precision number representing conditional add result.
 * a  A single precision number to add with.
 * b  A single precision number to add.
 * m  Mask value to apply.
 */
static void sp_3072_cond_add_134(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 134; i++) {
        r[i] = a[i] + (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 128; i += 8) {
        r[i + 0] = a[i + 0] + (b[i + 0] & m);
        r[i + 1] = a[i + 1] + (b[i + 1] & m);
        r[i + 2] = a[i + 2] + (b[i + 2] & m);
        r[i + 3] = a[i + 3] + (b[i + 3] & m);
        r[i + 4] = a[i + 4] + (b[i + 4] & m);
        r[i + 5] = a[i + 5] + (b[i + 5] & m);
        r[i + 6] = a[i + 6] + (b[i + 6] & m);
        r[i + 7] = a[i + 7] + (b[i + 7] & m);
    }
    r[128] = a[128] + (b[128] & m);
    r[129] = a[129] + (b[129] & m);
    r[130] = a[130] + (b[130] & m);
    r[131] = a[131] + (b[131] & m);
    r[132] = a[132] + (b[132] & m);
    r[133] = a[133] + (b[133] & m);
#endif /* WOLFSSL_SP_SMALL */
}

#ifdef WOLFSSL_SP_SMALL
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_3072_sub_134(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 134; i++) {
        r[i] = a[i] - b[i];
    }

    return 0;
}

#endif
#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_3072_add_134(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 134; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#endif
SP_NOINLINE static void sp_3072_rshift_134(sp_digit* r, const sp_digit* a,
        byte n)
{
    int i;

#ifdef WOLFSSL_SP_SMALL
    for (i=0; i<133; i++) {
        r[i] = ((a[i] >> n) | (a[i + 1] << (23 - n))) & 0x7fffff;
    }
#else
    for (i=0; i<128; i += 8) {
        r[i+0] = ((a[i+0] >> n) | (a[i+1] << (23 - n))) & 0x7fffff;
        r[i+1] = ((a[i+1] >> n) | (a[i+2] << (23 - n))) & 0x7fffff;
        r[i+2] = ((a[i+2] >> n) | (a[i+3] << (23 - n))) & 0x7fffff;
        r[i+3] = ((a[i+3] >> n) | (a[i+4] << (23 - n))) & 0x7fffff;
        r[i+4] = ((a[i+4] >> n) | (a[i+5] << (23 - n))) & 0x7fffff;
        r[i+5] = ((a[i+5] >> n) | (a[i+6] << (23 - n))) & 0x7fffff;
        r[i+6] = ((a[i+6] >> n) | (a[i+7] << (23 - n))) & 0x7fffff;
        r[i+7] = ((a[i+7] >> n) | (a[i+8] << (23 - n))) & 0x7fffff;
    }
    r[128] = ((a[128] >> n) | (a[129] << (23 - n))) & 0x7fffff;
    r[129] = ((a[129] >> n) | (a[130] << (23 - n))) & 0x7fffff;
    r[130] = ((a[130] >> n) | (a[131] << (23 - n))) & 0x7fffff;
    r[131] = ((a[131] >> n) | (a[132] << (23 - n))) & 0x7fffff;
    r[132] = ((a[132] >> n) | (a[133] << (23 - n))) & 0x7fffff;
#endif
    r[133] = a[133] >> n;
}

#ifdef WOLFSSL_SP_DIV_32
static WC_INLINE sp_digit sp_3072_div_word_134(sp_digit d1, sp_digit d0,
    sp_digit dv)
{
    sp_digit d;
    sp_digit r;
    sp_digit t;

    /* All 23 bits from d1 and top 8 bits from d0. */
    d = (d1 << 8) | (d0 >> 15);
    r = d / dv;
    d -= r * dv;
    /* Up to 9 bits in r */
    /* Next 8 bits from d0. */
    r <<= 8;
    d <<= 8;
    d |= (d0 >> 7) & ((1 << 8) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 17 bits in r */
    /* Remaining 7 bits from d0. */
    r <<= 7;
    d <<= 7;
    d |= d0 & ((1 << 7) - 1);
    t = d / dv;
    r += t;

    return r;
}
#endif /* WOLFSSL_SP_DIV_32 */

/* Divide d in a and put remainder into r (m*d + r = a)
 * m is not calculated as it is not needed at this time.
 *
 * a  Nmber to be divided.
 * d  Number to divide with.
 * m  Multiplier result.
 * r  Remainder from the division.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_3072_div_134(const sp_digit* a, const sp_digit* d,
        const sp_digit* m, sp_digit* r)
{
    int i;
#ifndef WOLFSSL_SP_DIV_32
    int64_t d1;
#endif
    sp_digit dv;
    sp_digit r1;
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit t1d[268 + 1];
    sp_digit t2d[134 + 1];
    sp_digit sdd[134 + 1];
#endif
    sp_digit* t1;
    sp_digit* t2;
    sp_digit* sd;
    int err = MP_OKAY;

    (void)m;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * (4 * 134 + 3), NULL,
                                                       DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    (void)m;

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t1 = td;
        t2 = td + 268 + 1;
        sd = t2 + 134 + 1;
#else
        t1 = t1d;
        t2 = t2d;
        sd = sdd;
#endif

        sp_3072_mul_d_134(sd, d, 1L << 10);
        sp_3072_mul_d_268(t1, a, 1L << 10);
        dv = sd[133];
        for (i=134; i>=0; i--) {
            t1[134 + i] += t1[134 + i - 1] >> 23;
            t1[134 + i - 1] &= 0x7fffff;
#ifndef WOLFSSL_SP_DIV_32
            d1 = t1[134 + i];
            d1 <<= 23;
            d1 += t1[134 + i - 1];
            r1 = (sp_digit)(d1 / dv);
#else
            r1 = sp_3072_div_word_134(t1[134 + i], t1[134 + i - 1], dv);
#endif

            sp_3072_mul_d_134(t2, sd, r1);
            (void)sp_3072_sub_134(&t1[i], &t1[i], t2);
            t1[134 + i] -= t2[134];
            t1[134 + i] += t1[134 + i - 1] >> 23;
            t1[134 + i - 1] &= 0x7fffff;
            r1 = (((-t1[134 + i]) << 23) - t1[134 + i - 1]) / dv;
            r1 -= t1[134 + i];
            sp_3072_mul_d_134(t2, sd, r1);
            (void)sp_3072_add_134(&t1[i], &t1[i], t2);
            t1[134 + i] += t1[134 + i - 1] >> 23;
            t1[134 + i - 1] &= 0x7fffff;
        }
        t1[134 - 1] += t1[134 - 2] >> 23;
        t1[134 - 2] &= 0x7fffff;
        r1 = t1[134 - 1] / dv;

        sp_3072_mul_d_134(t2, sd, r1);
        sp_3072_sub_134(t1, t1, t2);
        XMEMCPY(r, t1, sizeof(*r) * 2U * 134U);
        for (i=0; i<133; i++) {
            r[i+1] += r[i] >> 23;
            r[i] &= 0x7fffff;
        }
        sp_3072_cond_add_134(r, r, sd, 0 - ((r[133] < 0) ?
                    (sp_digit)1 : (sp_digit)0));

        sp_3072_norm_134(r);
        sp_3072_rshift_134(r, r, 10);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
}

/* Reduce a modulo m into r. (r = a mod m)
 *
 * r  A single precision number that is the reduced result.
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_3072_mod_134(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    return sp_3072_div_134(a, m, NULL, r);
}

#if (defined(WOLFSSL_HAVE_SP_RSA) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)) || \
                                                     defined(WOLFSSL_HAVE_SP_DH)
/* Modular exponentiate a to the e mod m. (r = a^e mod m)
 *
 * r     A single precision number that is the result of the operation.
 * a     A single precision number being exponentiated.
 * e     A single precision number that is the exponent.
 * bits  The number of bits in the exponent.
 * m     A single precision number that is the modulus.
 * returns 0 on success and MEMORY_E on dynamic memory allocation failure.
 */
static int sp_3072_mod_exp_134(sp_digit* r, const sp_digit* a, const sp_digit* e, int bits,
    const sp_digit* m, int reduceA)
{
#ifdef WOLFSSL_SP_SMALL
#if !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[3 * 268];
#endif
    sp_digit* t[3];
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 3 * 134 * 2, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
        for (i=0; i<3; i++) {
#if !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + (i * 134 * 2);
#else
            t[i] = &td[i * 134 * 2];
#endif
            XMEMSET(t[i], 0, sizeof(sp_digit) * 134U * 2U);
        }

        sp_3072_mont_setup(m, &mp);
        sp_3072_mont_norm_134(norm, m);

        if (reduceA != 0) {
            err = sp_3072_mod_134(t[1], a, m);
        }
        else {
            XMEMCPY(t[1], a, sizeof(sp_digit) * 134U);
        }
    }
    if (err == MP_OKAY) {
        sp_3072_mul_134(t[1], t[1], norm);
        err = sp_3072_mod_134(t[1], t[1], m);
    }

    if (err == MP_OKAY) {
        i = bits / 23;
        c = bits % 23;
        n = e[i--] << (23 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1) {
                    break;
                }

                n = e[i--];
                c = 23;
            }

            y = (n >> 22) & 1;
            n <<= 1;

            sp_3072_mont_mul_134(t[y^1], t[0], t[1], m, mp);

            XMEMCPY(t[2], (void*)(((size_t)t[0] & addr_mask[y^1]) +
                                  ((size_t)t[1] & addr_mask[y])),
                                  sizeof(*t[2]) * 134 * 2);
            sp_3072_mont_sqr_134(t[2], t[2], m, mp);
            XMEMCPY((void*)(((size_t)t[0] & addr_mask[y^1]) +
                            ((size_t)t[1] & addr_mask[y])), t[2],
                            sizeof(*t[2]) * 134 * 2);
        }

        sp_3072_mont_reduce_134(t[0], m, mp);
        n = sp_3072_cmp_134(t[0], m);
        sp_3072_cond_sub_134(t[0], t[0], m, ((n < 0) ?
                    (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, t[0], sizeof(*r) * 134 * 2);

    }

#if !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#elif defined(WOLFSSL_SP_CACHE_RESISTANT)
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[3 * 268];
#endif
    sp_digit* t[3];
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#ifdef WOLFSSL_SMALL_STACK
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 3 * 134 * 2, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
        for (i=0; i<3; i++) {
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + (i * 134 * 2);
#else
            t[i] = &td[i * 134 * 2];
#endif
        }

        sp_3072_mont_setup(m, &mp);
        sp_3072_mont_norm_134(norm, m);

        if (reduceA != 0) {
            err = sp_3072_mod_134(t[1], a, m);
            if (err == MP_OKAY) {
                sp_3072_mul_134(t[1], t[1], norm);
                err = sp_3072_mod_134(t[1], t[1], m);
            }
        }
        else {
            sp_3072_mul_134(t[1], a, norm);
            err = sp_3072_mod_134(t[1], t[1], m);
        }
    }

    if (err == MP_OKAY) {
        i = bits / 23;
        c = bits % 23;
        n = e[i--] << (23 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1) {
                    break;
                }

                n = e[i--];
                c = 23;
            }

            y = (n >> 22) & 1;
            n <<= 1;

            sp_3072_mont_mul_134(t[y^1], t[0], t[1], m, mp);

            XMEMCPY(t[2], (void*)(((size_t)t[0] & addr_mask[y^1]) +
                                  ((size_t)t[1] & addr_mask[y])), 
                                  sizeof(*t[2]) * 134 * 2);
            sp_3072_mont_sqr_134(t[2], t[2], m, mp);
            XMEMCPY((void*)(((size_t)t[0] & addr_mask[y^1]) +
                            ((size_t)t[1] & addr_mask[y])), t[2], 
                            sizeof(*t[2]) * 134 * 2);
        }

        sp_3072_mont_reduce_134(t[0], m, mp);
        n = sp_3072_cmp_134(t[0], m);
        sp_3072_cond_sub_134(t[0], t[0], m, ((n < 0) ?
                    (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, t[0], sizeof(*r) * 134 * 2);
    }

#ifdef WOLFSSL_SMALL_STACK
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#else
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[(32 * 268) + 268];
#endif
    sp_digit* t[32];
    sp_digit* rt = NULL;
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * ((32 * 268) + 268), NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
        for (i=0; i<32; i++)
            t[i] = td + i * 268;
        rt = td + 8576;
#else
        for (i=0; i<32; i++)
            t[i] = &td[i * 268];
        rt = &td[8576];
#endif

        sp_3072_mont_setup(m, &mp);
        sp_3072_mont_norm_134(norm, m);

        if (reduceA != 0) {
            err = sp_3072_mod_134(t[1], a, m);
            if (err == MP_OKAY) {
                sp_3072_mul_134(t[1], t[1], norm);
                err = sp_3072_mod_134(t[1], t[1], m);
            }
        }
        else {
            sp_3072_mul_134(t[1], a, norm);
            err = sp_3072_mod_134(t[1], t[1], m);
        }
    }

    if (err == MP_OKAY) {
        sp_3072_mont_sqr_134(t[ 2], t[ 1], m, mp);
        sp_3072_mont_mul_134(t[ 3], t[ 2], t[ 1], m, mp);
        sp_3072_mont_sqr_134(t[ 4], t[ 2], m, mp);
        sp_3072_mont_mul_134(t[ 5], t[ 3], t[ 2], m, mp);
        sp_3072_mont_sqr_134(t[ 6], t[ 3], m, mp);
        sp_3072_mont_mul_134(t[ 7], t[ 4], t[ 3], m, mp);
        sp_3072_mont_sqr_134(t[ 8], t[ 4], m, mp);
        sp_3072_mont_mul_134(t[ 9], t[ 5], t[ 4], m, mp);
        sp_3072_mont_sqr_134(t[10], t[ 5], m, mp);
        sp_3072_mont_mul_134(t[11], t[ 6], t[ 5], m, mp);
        sp_3072_mont_sqr_134(t[12], t[ 6], m, mp);
        sp_3072_mont_mul_134(t[13], t[ 7], t[ 6], m, mp);
        sp_3072_mont_sqr_134(t[14], t[ 7], m, mp);
        sp_3072_mont_mul_134(t[15], t[ 8], t[ 7], m, mp);
        sp_3072_mont_sqr_134(t[16], t[ 8], m, mp);
        sp_3072_mont_mul_134(t[17], t[ 9], t[ 8], m, mp);
        sp_3072_mont_sqr_134(t[18], t[ 9], m, mp);
        sp_3072_mont_mul_134(t[19], t[10], t[ 9], m, mp);
        sp_3072_mont_sqr_134(t[20], t[10], m, mp);
        sp_3072_mont_mul_134(t[21], t[11], t[10], m, mp);
        sp_3072_mont_sqr_134(t[22], t[11], m, mp);
        sp_3072_mont_mul_134(t[23], t[12], t[11], m, mp);
        sp_3072_mont_sqr_134(t[24], t[12], m, mp);
        sp_3072_mont_mul_134(t[25], t[13], t[12], m, mp);
        sp_3072_mont_sqr_134(t[26], t[13], m, mp);
        sp_3072_mont_mul_134(t[27], t[14], t[13], m, mp);
        sp_3072_mont_sqr_134(t[28], t[14], m, mp);
        sp_3072_mont_mul_134(t[29], t[15], t[14], m, mp);
        sp_3072_mont_sqr_134(t[30], t[15], m, mp);
        sp_3072_mont_mul_134(t[31], t[16], t[15], m, mp);

        bits = ((bits + 4) / 5) * 5;
        i = ((bits + 22) / 23) - 1;
        c = bits % 23;
        if (c == 0) {
            c = 23;
        }
        if (i < 134) {
            n = e[i--] << (32 - c);
        }
        else {
            n = 0;
            i--;
        }
        if (c < 5) {
            n |= e[i--] << (9 - c);
            c += 23;
        }
        y = (n >> 27) & 0x1f;
        n <<= 5;
        c -= 5;
        XMEMCPY(rt, t[y], sizeof(sp_digit) * 268);
        while ((i >= 0) || (c >= 5)) {
            if (c < 5) {
                n |= e[i--] << (9 - c);
                c += 23;
            }
            y = (n >> 27) & 0x1f;
            n <<= 5;
            c -= 5;

            sp_3072_mont_sqr_134(rt, rt, m, mp);
            sp_3072_mont_sqr_134(rt, rt, m, mp);
            sp_3072_mont_sqr_134(rt, rt, m, mp);
            sp_3072_mont_sqr_134(rt, rt, m, mp);
            sp_3072_mont_sqr_134(rt, rt, m, mp);

            sp_3072_mont_mul_134(rt, rt, t[y], m, mp);
        }

        sp_3072_mont_reduce_134(rt, m, mp);
        n = sp_3072_cmp_134(rt, m);
        sp_3072_cond_sub_134(rt, rt, m, ((n < 0) ?
                   (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, rt, sizeof(sp_digit) * 268);
    }

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#endif
}
#endif /* (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) | */
       /* WOLFSSL_HAVE_SP_DH */

#ifdef WOLFSSL_HAVE_SP_RSA
/* RSA public key operation.
 *
 * in      Array of bytes representing the number to exponentiate, base.
 * inLen   Number of bytes in base.
 * em      Public exponent.
 * mm      Modulus.
 * out     Buffer to hold big-endian bytes of exponentiation result.
 *         Must be at least 384 bytes long.
 * outLen  Number of bytes in result.
 * returns 0 on success, MP_TO_E when the outLen is too small, MP_READ_E when
 * an array is too long and MEMORY_E when dynamic memory allocation fails.
 */
int sp_RsaPublic_3072(const byte* in, word32 inLen, const mp_int* em,
    const mp_int* mm, byte* out, word32* outLen)
{
#ifdef WOLFSSL_SP_SMALL
    sp_digit* d = NULL;
    sp_digit* a = NULL;
    sp_digit* m = NULL;
    sp_digit* r = NULL;
    sp_digit* norm = NULL;
    sp_digit e[1] = {0};
    sp_digit mp;
    int i;
    int err = MP_OKAY;

    if (*outLen < 384U) {
        err = MP_TO_E;
    }

    if (err == MP_OKAY) {
        if (mp_count_bits(em) > 23) {
            err = MP_READ_E;
        }
        if (inLen > 384U) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 3072) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 134 * 5, NULL,
                                                              DYNAMIC_TYPE_RSA);
        if (d == NULL)
            err = MEMORY_E;
    }

    if (err == MP_OKAY) {
        a = d;
        r = a + 134 * 2;
        m = r + 134 * 2;
        norm = r;

        sp_3072_from_bin(a, 134, in, inLen);
#if DIGIT_BIT >= 23
        e[0] = (sp_digit)em->dp[0];
#else
        e[0] = (sp_digit)em->dp[0];
        if (em->used > 1) {
            e[0] |= ((sp_digit)em->dp[1]) << DIGIT_BIT;
        }
#endif
        if (e[0] == 0) {
            err = MP_EXPTMOD_E;
        }
    }

    if (err == MP_OKAY) {
        sp_3072_from_mp(m, 134, mm);

        sp_3072_mont_setup(m, &mp);
        sp_3072_mont_norm_134(norm, m);
    }
    if (err == MP_OKAY) {
        sp_3072_mul_134(a, a, norm);
        err = sp_3072_mod_134(a, a, m);
    }
    if (err == MP_OKAY) {
        for (i=22; i>=0; i--) {
            if ((e[0] >> i) != 0) {
                break;
            }
        }

        XMEMCPY(r, a, sizeof(sp_digit) * 134 * 2);
        for (i--; i>=0; i--) {
            sp_3072_mont_sqr_134(r, r, m, mp);

            if (((e[0] >> i) & 1) == 1) {
                sp_3072_mont_mul_134(r, r, a, m, mp);
            }
        }
        sp_3072_mont_reduce_134(r, m, mp);
        mp = sp_3072_cmp_134(r, m);
        sp_3072_cond_sub_134(r, r, m, ((mp < 0) ?
                    (sp_digit)1 : (sp_digit)0)- 1);

        sp_3072_to_bin(r, out);
        *outLen = 384;
    }

    if (d != NULL) {
        XFREE(d, NULL, DYNAMIC_TYPE_RSA);
    }

    return err;
#else
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit ad[268];
    sp_digit md[134];
    sp_digit rd[268];
#else
    sp_digit* d = NULL;
#endif
    sp_digit* a = NULL;
    sp_digit* m = NULL;
    sp_digit* r = NULL;
    sp_digit e[1] = {0};
    int err = MP_OKAY;

    if (*outLen < 384U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (mp_count_bits(em) > 23) {
            err = MP_READ_E;
        }
        if (inLen > 384U) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 3072) {
            err = MP_READ_E;
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 134 * 5, NULL,
                                                              DYNAMIC_TYPE_RSA);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }

    if (err == MP_OKAY) {
        a = d;
        r = a + 134 * 2;
        m = r + 134 * 2;
    }
#else
    a = ad;
    m = md;
    r = rd;
#endif

    if (err == MP_OKAY) {
        sp_3072_from_bin(a, 134, in, inLen);
#if DIGIT_BIT >= 23
        e[0] = (sp_digit)em->dp[0];
#else
        e[0] = (sp_digit)em->dp[0];
        if (em->used > 1) {
            e[0] |= ((sp_digit)em->dp[1]) << DIGIT_BIT;
        }
#endif
        if (e[0] == 0) {
            err = MP_EXPTMOD_E;
        }
    }
    if (err == MP_OKAY) {
        sp_3072_from_mp(m, 134, mm);

        if (e[0] == 0x3) {
            sp_3072_sqr_134(r, a);
            err = sp_3072_mod_134(r, r, m);
            if (err == MP_OKAY) {
                sp_3072_mul_134(r, a, r);
                err = sp_3072_mod_134(r, r, m);
            }
        }
        else {
            sp_digit* norm = r;
            int i;
            sp_digit mp;

            sp_3072_mont_setup(m, &mp);
            sp_3072_mont_norm_134(norm, m);

            sp_3072_mul_134(a, a, norm);
            err = sp_3072_mod_134(a, a, m);

            if (err == MP_OKAY) {
                for (i=22; i>=0; i--) {
                    if ((e[0] >> i) != 0) {
                        break;
                    }
                }

                XMEMCPY(r, a, sizeof(sp_digit) * 268U);
                for (i--; i>=0; i--) {
                    sp_3072_mont_sqr_134(r, r, m, mp);

                    if (((e[0] >> i) & 1) == 1) {
                        sp_3072_mont_mul_134(r, r, a, m, mp);
                    }
                }
                sp_3072_mont_reduce_134(r, m, mp);
                mp = sp_3072_cmp_134(r, m);
                sp_3072_cond_sub_134(r, r, m, ((mp < 0) ?
                           (sp_digit)1 : (sp_digit)0) - 1);
            }
        }
    }

    if (err == MP_OKAY) {
        sp_3072_to_bin(r, out);
        *outLen = 384;
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL) {
        XFREE(d, NULL, DYNAMIC_TYPE_RSA);
    }
#endif

    return err;
#endif /* WOLFSSL_SP_SMALL */
}

#ifndef WOLFSSL_RSA_PUBLIC_ONLY
#if !defined(SP_RSA_PRIVATE_EXP_D) && !defined(RSA_LOW_MEM)
#endif /* !SP_RSA_PRIVATE_EXP_D & !RSA_LOW_MEM */
/* RSA private key operation.
 *
 * in      Array of bytes representing the number to exponentiate, base.
 * inLen   Number of bytes in base.
 * dm      Private exponent.
 * pm      First prime.
 * qm      Second prime.
 * dpm     First prime's CRT exponent.
 * dqm     Second prime's CRT exponent.
 * qim     Inverse of second prime mod p.
 * mm      Modulus.
 * out     Buffer to hold big-endian bytes of exponentiation result.
 *         Must be at least 384 bytes long.
 * outLen  Number of bytes in result.
 * returns 0 on success, MP_TO_E when the outLen is too small, MP_READ_E when
 * an array is too long and MEMORY_E when dynamic memory allocation fails.
 */
int sp_RsaPrivate_3072(const byte* in, word32 inLen, const mp_int* dm,
    const mp_int* pm, const mp_int* qm, const mp_int* dpm, const mp_int* dqm,
    const mp_int* qim, const mp_int* mm, byte* out, word32* outLen)
{
#if defined(SP_RSA_PRIVATE_EXP_D) || defined(RSA_LOW_MEM)
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* a = NULL;
    sp_digit* d = NULL;
    sp_digit* m = NULL;
    sp_digit* r = NULL;
    int err = MP_OKAY;

    (void)pm;
    (void)qm;
    (void)dpm;
    (void)dqm;
    (void)qim;

    if (*outLen < 384U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (mp_count_bits(dm) > 3072) {
           err = MP_READ_E;
        }
        if (inLen > 384) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 3072) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 134 * 4, NULL,
                                                              DYNAMIC_TYPE_RSA);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }
    if (err == MP_OKAY) {
        a = d + 134;
        m = a + 268;
        r = a;

        sp_3072_from_bin(a, 134, in, inLen);
        sp_3072_from_mp(d, 134, dm);
        sp_3072_from_mp(m, 134, mm);
        err = sp_3072_mod_exp_134(r, a, d, 3072, m, 0);
    }
    if (err == MP_OKAY) {
        sp_3072_to_bin(r, out);
        *outLen = 384;
    }

    if (d != NULL) {
        XMEMSET(d, 0, sizeof(sp_digit) * 134);
        XFREE(d, NULL, DYNAMIC_TYPE_RSA);
    }

    return err;
#else
    sp_digit a[268];
    sp_digit d[134];
    sp_digit m[134];
    sp_digit* r = a;
    int err = MP_OKAY;

    (void)pm;
    (void)qm;
    (void)dpm;
    (void)dqm;
    (void)qim;

    if (*outLen < 384U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (mp_count_bits(dm) > 3072) {
            err = MP_READ_E;
        }
        if (inLen > 384U) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 3072) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        sp_3072_from_bin(a, 134, in, inLen);
        sp_3072_from_mp(d, 134, dm);
        sp_3072_from_mp(m, 134, mm);
        err = sp_3072_mod_exp_134(r, a, d, 3072, m, 0);
    }

    if (err == MP_OKAY) {
        sp_3072_to_bin(r, out);
        *outLen = 384;
    }

    XMEMSET(d, 0, sizeof(sp_digit) * 134);

    return err;
#endif /* WOLFSSL_SP_SMALL | defined(WOLFSSL_SMALL_STACK) */
#else
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* t = NULL;
    sp_digit* a = NULL;
    sp_digit* p = NULL;
    sp_digit* q = NULL;
    sp_digit* dp = NULL;
    sp_digit* dq = NULL;
    sp_digit* qi = NULL;
    sp_digit* tmpa = NULL;
    sp_digit* tmpb = NULL;
    sp_digit* r = NULL;
    int err = MP_OKAY;

    (void)dm;
    (void)mm;

    if (*outLen < 384U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (inLen > 384) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 3072) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        t = (sp_digit*)XMALLOC(sizeof(sp_digit) * 67 * 11, NULL,
                                                              DYNAMIC_TYPE_RSA);
        if (t == NULL) {
            err = MEMORY_E;
        }
    }
    if (err == MP_OKAY) {
        a = t;
        p = a + 134 * 2;
        q = p + 67;
        qi = dq = dp = q + 67;
        tmpa = qi + 67;
        tmpb = tmpa + 134;

        r = t + 134;

        sp_3072_from_bin(a, 134, in, inLen);
        sp_3072_from_mp(p, 67, pm);
        sp_3072_from_mp(q, 67, qm);
        sp_3072_from_mp(dp, 67, dpm);
        err = sp_3072_mod_exp_67(tmpa, a, dp, 1536, p, 1);
    }
    if (err == MP_OKAY) {
        sp_3072_from_mp(dq, 67, dqm);
        err = sp_3072_mod_exp_67(tmpb, a, dq, 1536, q, 1);
    }
    if (err == MP_OKAY) {
        (void)sp_3072_sub_67(tmpa, tmpa, tmpb);
        sp_3072_cond_add_67(tmpa, tmpa, p, 0 - ((sp_int_digit)tmpa[66] >> 31));
        sp_3072_cond_add_67(tmpa, tmpa, p, 0 - ((sp_int_digit)tmpa[66] >> 31));

        sp_3072_from_mp(qi, 67, qim);
        sp_3072_mul_67(tmpa, tmpa, qi);
        err = sp_3072_mod_67(tmpa, tmpa, p);
    }

    if (err == MP_OKAY) {
        sp_3072_mul_67(tmpa, q, tmpa);
        (void)sp_3072_add_134(r, tmpb, tmpa);
        sp_3072_norm_134(r);

        sp_3072_to_bin(r, out);
        *outLen = 384;
    }

    if (t != NULL) {
        XMEMSET(t, 0, sizeof(sp_digit) * 67 * 11);
        XFREE(t, NULL, DYNAMIC_TYPE_RSA);
    }

    return err;
#else
    sp_digit a[134 * 2];
    sp_digit p[67];
    sp_digit q[67];
    sp_digit dp[67];
    sp_digit dq[67];
    sp_digit qi[67];
    sp_digit tmpa[134];
    sp_digit tmpb[134];
    sp_digit* r = a;
    int err = MP_OKAY;

    (void)dm;
    (void)mm;

    if (*outLen < 384U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (inLen > 384U) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 3072) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        sp_3072_from_bin(a, 134, in, inLen);
        sp_3072_from_mp(p, 67, pm);
        sp_3072_from_mp(q, 67, qm);
        sp_3072_from_mp(dp, 67, dpm);
        sp_3072_from_mp(dq, 67, dqm);
        sp_3072_from_mp(qi, 67, qim);

        err = sp_3072_mod_exp_67(tmpa, a, dp, 1536, p, 1);
    }
    if (err == MP_OKAY) {
        err = sp_3072_mod_exp_67(tmpb, a, dq, 1536, q, 1);
    }

    if (err == MP_OKAY) {
        (void)sp_3072_sub_67(tmpa, tmpa, tmpb);
        sp_3072_cond_add_67(tmpa, tmpa, p, 0 - ((sp_int_digit)tmpa[66] >> 31));
        sp_3072_cond_add_67(tmpa, tmpa, p, 0 - ((sp_int_digit)tmpa[66] >> 31));
        sp_3072_mul_67(tmpa, tmpa, qi);
        err = sp_3072_mod_67(tmpa, tmpa, p);
    }

    if (err == MP_OKAY) {
        sp_3072_mul_67(tmpa, tmpa, q);
        (void)sp_3072_add_134(r, tmpb, tmpa);
        sp_3072_norm_134(r);

        sp_3072_to_bin(r, out);
        *outLen = 384;
    }

    XMEMSET(tmpa, 0, sizeof(tmpa));
    XMEMSET(tmpb, 0, sizeof(tmpb));
    XMEMSET(p, 0, sizeof(p));
    XMEMSET(q, 0, sizeof(q));
    XMEMSET(dp, 0, sizeof(dp));
    XMEMSET(dq, 0, sizeof(dq));
    XMEMSET(qi, 0, sizeof(qi));

    return err;
#endif /* WOLFSSL_SP_SMALL | defined(WOLFSSL_SMALL_STACK) */
#endif /* SP_RSA_PRIVATE_EXP_D | RSA_LOW_MEM */
}

#endif /* !WOLFSSL_RSA_PUBLIC_ONLY */
#endif /* WOLFSSL_HAVE_SP_RSA */
#if defined(WOLFSSL_HAVE_SP_DH) || (defined(WOLFSSL_HAVE_SP_RSA) && \
                                              !defined(WOLFSSL_RSA_PUBLIC_ONLY))
/* Convert an array of sp_digit to an mp_int.
 *
 * a  A single precision integer.
 * r  A multi-precision integer.
 */
static int sp_3072_to_mp(const sp_digit* a, mp_int* r)
{
    int err;

    err = mp_grow(r, (3072 + DIGIT_BIT - 1) / DIGIT_BIT);
    if (err == MP_OKAY) { /*lint !e774 case where err is always MP_OKAY*/
#if DIGIT_BIT == 23
        XMEMCPY(r->dp, a, sizeof(sp_digit) * 134);
        r->used = 134;
        mp_clamp(r);
#elif DIGIT_BIT < 23
        int i;
        int j = 0;
        int s = 0;

        r->dp[0] = 0;
        for (i = 0; i < 134; i++) {
            r->dp[j] |= (mp_digit)(a[i] << s);
            r->dp[j] &= ((sp_digit)1 << DIGIT_BIT) - 1;
            s = DIGIT_BIT - s;
            r->dp[++j] = (mp_digit)(a[i] >> s);
            while (s + DIGIT_BIT <= 23) {
                s += DIGIT_BIT;
                r->dp[j++] &= ((sp_digit)1 << DIGIT_BIT) - 1;
                if (s == SP_WORD_SIZE) {
                    r->dp[j] = 0;
                }
                else {
                    r->dp[j] = (mp_digit)(a[i] >> s);
                }
            }
            s = 23 - s;
        }
        r->used = (3072 + DIGIT_BIT - 1) / DIGIT_BIT;
        mp_clamp(r);
#else
        int i;
        int j = 0;
        int s = 0;

        r->dp[0] = 0;
        for (i = 0; i < 134; i++) {
            r->dp[j] |= ((mp_digit)a[i]) << s;
            if (s + 23 >= DIGIT_BIT) {
    #if DIGIT_BIT != 32 && DIGIT_BIT != 64
                r->dp[j] &= ((sp_digit)1 << DIGIT_BIT) - 1;
    #endif
                s = DIGIT_BIT - s;
                r->dp[++j] = a[i] >> s;
                s = 23 - s;
            }
            else {
                s += 23;
            }
        }
        r->used = (3072 + DIGIT_BIT - 1) / DIGIT_BIT;
        mp_clamp(r);
#endif
    }

    return err;
}

/* Perform the modular exponentiation for Diffie-Hellman.
 *
 * base  Base. MP integer.
 * exp   Exponent. MP integer.
 * mod   Modulus. MP integer.
 * res   Result. MP integer.
 * returns 0 on success, MP_READ_E if there are too many bytes in an array
 * and MEMORY_E if memory allocation fails.
 */
int sp_ModExp_3072(const mp_int* base, const mp_int* exp, const mp_int* mod,
    mp_int* res)
{
#ifdef WOLFSSL_SP_SMALL
    int err = MP_OKAY;
    sp_digit* d = NULL;
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    int expBits = mp_count_bits(exp);

    if (mp_count_bits(base) > 3072) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expBits > 3072)) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (mp_count_bits(mod) != 3072)) {
        err = MP_READ_E;
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 134 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 134 * 2;
        m = e + 134;
        r = b;

        sp_3072_from_mp(b, 134, base);
        sp_3072_from_mp(e, 134, exp);
        sp_3072_from_mp(m, 134, mod);

        err = sp_3072_mod_exp_134(r, b, e, mp_count_bits(exp), m, 0);
    }

    if (err == MP_OKAY) {
        err = sp_3072_to_mp(r, res);
    }

    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 134U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
    return err;
#else
#ifndef WOLFSSL_SMALL_STACK
    sp_digit bd[268];
    sp_digit ed[134];
    sp_digit md[134];
#else
    sp_digit* d = NULL;
#endif
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    int err = MP_OKAY;
    int expBits = mp_count_bits(exp);

    if (mp_count_bits(base) > 3072) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expBits > 3072)) {
        err = MP_READ_E;
    }
    
    if ((err == MP_OKAY) && (mp_count_bits(mod) != 3072)) {
        err = MP_READ_E;
    }

#ifdef WOLFSSL_SMALL_STACK
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 134 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL)
            err = MEMORY_E;
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 134 * 2;
        m = e + 134;
        r = b;
    }
#else
    r = b = bd;
    e = ed;
    m = md;
#endif

    if (err == MP_OKAY) {
        sp_3072_from_mp(b, 134, base);
        sp_3072_from_mp(e, 134, exp);
        sp_3072_from_mp(m, 134, mod);

        err = sp_3072_mod_exp_134(r, b, e, expBits, m, 0);
    }

    if (err == MP_OKAY) {
        err = sp_3072_to_mp(r, res);
    }


#ifdef WOLFSSL_SMALL_STACK
    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 134U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
#else
    XMEMSET(e, 0, sizeof(sp_digit) * 134U);
#endif

    return err;
#endif
}

#ifdef WOLFSSL_HAVE_SP_DH

#ifdef HAVE_FFDHE_3072
SP_NOINLINE static void sp_3072_lshift_134(sp_digit* r, const sp_digit* a,
        byte n)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    r[134] = a[133] >> (23 - n);
    for (i=133; i>0; i--) {
        r[i] = ((a[i] << n) | (a[i-1] >> (23 - n))) & 0x7fffff;
    }
#else
    sp_int_digit s;
    sp_int_digit t;

    s = (sp_int_digit)a[133];
    r[134] = s >> (23U - n);
    s = (sp_int_digit)(a[133]); t = (sp_int_digit)(a[132]);
    r[133] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[132]); t = (sp_int_digit)(a[131]);
    r[132] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[131]); t = (sp_int_digit)(a[130]);
    r[131] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[130]); t = (sp_int_digit)(a[129]);
    r[130] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[129]); t = (sp_int_digit)(a[128]);
    r[129] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[128]); t = (sp_int_digit)(a[127]);
    r[128] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[127]); t = (sp_int_digit)(a[126]);
    r[127] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[126]); t = (sp_int_digit)(a[125]);
    r[126] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[125]); t = (sp_int_digit)(a[124]);
    r[125] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[124]); t = (sp_int_digit)(a[123]);
    r[124] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[123]); t = (sp_int_digit)(a[122]);
    r[123] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[122]); t = (sp_int_digit)(a[121]);
    r[122] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[121]); t = (sp_int_digit)(a[120]);
    r[121] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[120]); t = (sp_int_digit)(a[119]);
    r[120] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[119]); t = (sp_int_digit)(a[118]);
    r[119] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[118]); t = (sp_int_digit)(a[117]);
    r[118] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[117]); t = (sp_int_digit)(a[116]);
    r[117] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[116]); t = (sp_int_digit)(a[115]);
    r[116] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[115]); t = (sp_int_digit)(a[114]);
    r[115] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[114]); t = (sp_int_digit)(a[113]);
    r[114] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[113]); t = (sp_int_digit)(a[112]);
    r[113] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[112]); t = (sp_int_digit)(a[111]);
    r[112] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[111]); t = (sp_int_digit)(a[110]);
    r[111] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[110]); t = (sp_int_digit)(a[109]);
    r[110] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[109]); t = (sp_int_digit)(a[108]);
    r[109] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[108]); t = (sp_int_digit)(a[107]);
    r[108] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[107]); t = (sp_int_digit)(a[106]);
    r[107] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[106]); t = (sp_int_digit)(a[105]);
    r[106] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[105]); t = (sp_int_digit)(a[104]);
    r[105] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[104]); t = (sp_int_digit)(a[103]);
    r[104] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[103]); t = (sp_int_digit)(a[102]);
    r[103] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[102]); t = (sp_int_digit)(a[101]);
    r[102] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[101]); t = (sp_int_digit)(a[100]);
    r[101] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[100]); t = (sp_int_digit)(a[99]);
    r[100] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[99]); t = (sp_int_digit)(a[98]);
    r[99] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[98]); t = (sp_int_digit)(a[97]);
    r[98] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[97]); t = (sp_int_digit)(a[96]);
    r[97] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[96]); t = (sp_int_digit)(a[95]);
    r[96] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[95]); t = (sp_int_digit)(a[94]);
    r[95] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[94]); t = (sp_int_digit)(a[93]);
    r[94] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[93]); t = (sp_int_digit)(a[92]);
    r[93] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[92]); t = (sp_int_digit)(a[91]);
    r[92] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[91]); t = (sp_int_digit)(a[90]);
    r[91] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[90]); t = (sp_int_digit)(a[89]);
    r[90] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[89]); t = (sp_int_digit)(a[88]);
    r[89] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[88]); t = (sp_int_digit)(a[87]);
    r[88] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[87]); t = (sp_int_digit)(a[86]);
    r[87] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[86]); t = (sp_int_digit)(a[85]);
    r[86] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[85]); t = (sp_int_digit)(a[84]);
    r[85] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[84]); t = (sp_int_digit)(a[83]);
    r[84] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[83]); t = (sp_int_digit)(a[82]);
    r[83] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[82]); t = (sp_int_digit)(a[81]);
    r[82] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[81]); t = (sp_int_digit)(a[80]);
    r[81] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[80]); t = (sp_int_digit)(a[79]);
    r[80] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[79]); t = (sp_int_digit)(a[78]);
    r[79] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[78]); t = (sp_int_digit)(a[77]);
    r[78] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[77]); t = (sp_int_digit)(a[76]);
    r[77] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[76]); t = (sp_int_digit)(a[75]);
    r[76] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[75]); t = (sp_int_digit)(a[74]);
    r[75] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[74]); t = (sp_int_digit)(a[73]);
    r[74] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[73]); t = (sp_int_digit)(a[72]);
    r[73] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[72]); t = (sp_int_digit)(a[71]);
    r[72] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[71]); t = (sp_int_digit)(a[70]);
    r[71] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[70]); t = (sp_int_digit)(a[69]);
    r[70] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[69]); t = (sp_int_digit)(a[68]);
    r[69] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[68]); t = (sp_int_digit)(a[67]);
    r[68] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[67]); t = (sp_int_digit)(a[66]);
    r[67] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[66]); t = (sp_int_digit)(a[65]);
    r[66] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[65]); t = (sp_int_digit)(a[64]);
    r[65] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[64]); t = (sp_int_digit)(a[63]);
    r[64] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[63]); t = (sp_int_digit)(a[62]);
    r[63] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[62]); t = (sp_int_digit)(a[61]);
    r[62] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[61]); t = (sp_int_digit)(a[60]);
    r[61] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[60]); t = (sp_int_digit)(a[59]);
    r[60] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[59]); t = (sp_int_digit)(a[58]);
    r[59] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[58]); t = (sp_int_digit)(a[57]);
    r[58] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[57]); t = (sp_int_digit)(a[56]);
    r[57] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[56]); t = (sp_int_digit)(a[55]);
    r[56] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[55]); t = (sp_int_digit)(a[54]);
    r[55] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[54]); t = (sp_int_digit)(a[53]);
    r[54] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[53]); t = (sp_int_digit)(a[52]);
    r[53] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[52]); t = (sp_int_digit)(a[51]);
    r[52] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[51]); t = (sp_int_digit)(a[50]);
    r[51] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[50]); t = (sp_int_digit)(a[49]);
    r[50] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[49]); t = (sp_int_digit)(a[48]);
    r[49] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[48]); t = (sp_int_digit)(a[47]);
    r[48] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[47]); t = (sp_int_digit)(a[46]);
    r[47] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[46]); t = (sp_int_digit)(a[45]);
    r[46] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[45]); t = (sp_int_digit)(a[44]);
    r[45] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[44]); t = (sp_int_digit)(a[43]);
    r[44] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[43]); t = (sp_int_digit)(a[42]);
    r[43] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[42]); t = (sp_int_digit)(a[41]);
    r[42] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[41]); t = (sp_int_digit)(a[40]);
    r[41] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[40]); t = (sp_int_digit)(a[39]);
    r[40] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[39]); t = (sp_int_digit)(a[38]);
    r[39] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[38]); t = (sp_int_digit)(a[37]);
    r[38] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[37]); t = (sp_int_digit)(a[36]);
    r[37] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[36]); t = (sp_int_digit)(a[35]);
    r[36] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[35]); t = (sp_int_digit)(a[34]);
    r[35] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[34]); t = (sp_int_digit)(a[33]);
    r[34] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[33]); t = (sp_int_digit)(a[32]);
    r[33] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[32]); t = (sp_int_digit)(a[31]);
    r[32] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[31]); t = (sp_int_digit)(a[30]);
    r[31] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[30]); t = (sp_int_digit)(a[29]);
    r[30] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[29]); t = (sp_int_digit)(a[28]);
    r[29] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[28]); t = (sp_int_digit)(a[27]);
    r[28] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[27]); t = (sp_int_digit)(a[26]);
    r[27] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[26]); t = (sp_int_digit)(a[25]);
    r[26] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[25]); t = (sp_int_digit)(a[24]);
    r[25] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[24]); t = (sp_int_digit)(a[23]);
    r[24] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[23]); t = (sp_int_digit)(a[22]);
    r[23] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[22]); t = (sp_int_digit)(a[21]);
    r[22] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[21]); t = (sp_int_digit)(a[20]);
    r[21] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[20]); t = (sp_int_digit)(a[19]);
    r[20] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[19]); t = (sp_int_digit)(a[18]);
    r[19] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[18]); t = (sp_int_digit)(a[17]);
    r[18] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[17]); t = (sp_int_digit)(a[16]);
    r[17] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[16]); t = (sp_int_digit)(a[15]);
    r[16] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[15]); t = (sp_int_digit)(a[14]);
    r[15] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[14]); t = (sp_int_digit)(a[13]);
    r[14] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[13]); t = (sp_int_digit)(a[12]);
    r[13] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[12]); t = (sp_int_digit)(a[11]);
    r[12] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[11]); t = (sp_int_digit)(a[10]);
    r[11] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[10]); t = (sp_int_digit)(a[9]);
    r[10] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[9]); t = (sp_int_digit)(a[8]);
    r[9] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[8]); t = (sp_int_digit)(a[7]);
    r[8] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[7]); t = (sp_int_digit)(a[6]);
    r[7] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[6]); t = (sp_int_digit)(a[5]);
    r[6] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[5]); t = (sp_int_digit)(a[4]);
    r[5] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[4]); t = (sp_int_digit)(a[3]);
    r[4] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[3]); t = (sp_int_digit)(a[2]);
    r[3] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[2]); t = (sp_int_digit)(a[1]);
    r[2] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
    s = (sp_int_digit)(a[1]); t = (sp_int_digit)(a[0]);
    r[1] = ((s << n) | (t >> (23U - n))) & 0x7fffff;
#endif
    r[0] = (a[0] << n) & 0x7fffff;
}

/* Modular exponentiate 2 to the e mod m. (r = 2^e mod m)
 *
 * r     A single precision number that is the result of the operation.
 * e     A single precision number that is the exponent.
 * bits  The number of bits in the exponent.
 * m     A single precision number that is the modulus.
 * returns 0 on success and MEMORY_E on dynamic memory allocation failure.
 */
static int sp_3072_mod_exp_2_134(sp_digit* r, const sp_digit* e, int bits, const sp_digit* m)
{
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[403];
#endif
    sp_digit* norm;
    sp_digit* tmp;
    sp_digit mp = 1;
    sp_digit n;
    sp_digit o;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 403, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
        tmp  = td + 268;
        XMEMSET(td, 0, sizeof(sp_digit) * 403);
#else
        tmp  = &td[268];
        XMEMSET(td, 0, sizeof(td));
#endif

        sp_3072_mont_setup(m, &mp);
        sp_3072_mont_norm_134(norm, m);

        bits = ((bits + 3) / 4) * 4;
        i = ((bits + 22) / 23) - 1;
        c = bits % 23;
        if (c == 0) {
            c = 23;
        }
        if (i < 134) {
            n = e[i--] << (32 - c);
        }
        else {
            n = 0;
            i--;
        }
        if (c < 4) {
            n |= e[i--] << (9 - c);
            c += 23;
        }
        y = (n >> 28) & 0xf;
        n <<= 4;
        c -= 4;
        sp_3072_lshift_134(r, norm, y);
        while ((i >= 0) || (c >= 4)) {
            if (c < 4) {
                n |= e[i--] << (9 - c);
                c += 23;
            }
            y = (n >> 28) & 0xf;
            n <<= 4;
            c -= 4;

            sp_3072_mont_sqr_134(r, r, m, mp);
            sp_3072_mont_sqr_134(r, r, m, mp);
            sp_3072_mont_sqr_134(r, r, m, mp);
            sp_3072_mont_sqr_134(r, r, m, mp);

            sp_3072_lshift_134(r, r, y);
            sp_3072_mul_d_134(tmp, norm, (r[134] << 10) + (r[133] >> 13));
            r[134] = 0;
            r[133] &= 0x1fffL;
            (void)sp_3072_add_134(r, r, tmp);
            sp_3072_norm_134(r);
            o = sp_3072_cmp_134(r, m);
            sp_3072_cond_sub_134(r, r, m, ((o < 0) ?
                                          (sp_digit)1 : (sp_digit)0) - 1);
        }

        sp_3072_mont_reduce_134(r, m, mp);
        n = sp_3072_cmp_134(r, m);
        sp_3072_cond_sub_134(r, r, m, ((n < 0) ?
                                                (sp_digit)1 : (sp_digit)0) - 1);
    }

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
}

#endif /* HAVE_FFDHE_3072 */

/* Perform the modular exponentiation for Diffie-Hellman.
 *
 * base     Base.
 * exp      Array of bytes that is the exponent.
 * expLen   Length of data, in bytes, in exponent.
 * mod      Modulus.
 * out      Buffer to hold big-endian bytes of exponentiation result.
 *          Must be at least 384 bytes long.
 * outLen   Length, in bytes, of exponentiation result.
 * returns 0 on success, MP_READ_E if there are too many bytes in an array
 * and MEMORY_E if memory allocation fails.
 */
int sp_DhExp_3072(const mp_int* base, const byte* exp, word32 expLen,
    const mp_int* mod, byte* out, word32* outLen)
{
#ifdef WOLFSSL_SP_SMALL
    int err = MP_OKAY;
    sp_digit* d = NULL;
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    word32 i;

    if (mp_count_bits(base) > 3072) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expLen > 384U)) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (mp_count_bits(mod) != 3072)) {
        err = MP_READ_E;
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 134 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 134 * 2;
        m = e + 134;
        r = b;

        sp_3072_from_mp(b, 134, base);
        sp_3072_from_bin(e, 134, exp, expLen);
        sp_3072_from_mp(m, 134, mod);

    #ifdef HAVE_FFDHE_3072
        if (base->used == 1 && base->dp[0] == 2 &&
                ((m[133] << 3) | (m[132] >> 20)) == 0xffffL) {
            err = sp_3072_mod_exp_2_134(r, e, expLen * 8, m);
        }
        else
    #endif
            err = sp_3072_mod_exp_134(r, b, e, expLen * 8, m, 0);
    }

    if (err == MP_OKAY) {
        sp_3072_to_bin(r, out);
        *outLen = 384;
        for (i=0; i<384 && out[i] == 0; i++) {
            /* Search for first non-zero. */
        }
        *outLen -= i;
        XMEMMOVE(out, out + i, *outLen);
    }

    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 134U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
    return err;
#else
#ifndef WOLFSSL_SMALL_STACK
    sp_digit bd[268];
    sp_digit ed[134];
    sp_digit md[134];
#else
    sp_digit* d = NULL;
#endif
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    word32 i;
    int err = MP_OKAY;

    if (mp_count_bits(base) > 3072) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expLen > 384U)) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (mp_count_bits(mod) != 3072)) {
        err = MP_READ_E;
    }
#ifdef WOLFSSL_SMALL_STACK
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 134 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL)
            err = MEMORY_E;
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 134 * 2;
        m = e + 134;
        r = b;
    }
#else
    r = b = bd;
    e = ed;
    m = md;
#endif

    if (err == MP_OKAY) {
        sp_3072_from_mp(b, 134, base);
        sp_3072_from_bin(e, 134, exp, expLen);
        sp_3072_from_mp(m, 134, mod);

    #ifdef HAVE_FFDHE_3072
        if (base->used == 1 && base->dp[0] == 2U &&
                ((m[133] << 3) | (m[132] >> 20)) == 0xffffL) {
            err = sp_3072_mod_exp_2_134(r, e, expLen * 8U, m);
        }
        else {
    #endif
            err = sp_3072_mod_exp_134(r, b, e, expLen * 8U, m, 0);
    #ifdef HAVE_FFDHE_3072
        }
    #endif
    }

    if (err == MP_OKAY) {
        sp_3072_to_bin(r, out);
        *outLen = 384;
        for (i=0; i<384U && out[i] == 0U; i++) {
            /* Search for first non-zero. */
        }
        *outLen -= i;
        XMEMMOVE(out, out + i, *outLen);
    }

#ifdef WOLFSSL_SMALL_STACK
    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 134U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
#else
    XMEMSET(e, 0, sizeof(sp_digit) * 134U);
#endif

    return err;
#endif
}
#endif /* WOLFSSL_HAVE_SP_DH */

/* Perform the modular exponentiation for Diffie-Hellman.
 *
 * base  Base. MP integer.
 * exp   Exponent. MP integer.
 * mod   Modulus. MP integer.
 * res   Result. MP integer.
 * returns 0 on success, MP_READ_E if there are too many bytes in an array
 * and MEMORY_E if memory allocation fails.
 */
int sp_ModExp_1536(const mp_int* base, const mp_int* exp, const mp_int* mod,
    mp_int* res)
{
#ifdef WOLFSSL_SP_SMALL
    int err = MP_OKAY;
    sp_digit* d = NULL;
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    int expBits = mp_count_bits(exp);

    if (mp_count_bits(base) > 1536) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expBits > 1536)) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (mp_count_bits(mod) != 1536)) {
        err = MP_READ_E;
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 67 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 67 * 2;
        m = e + 67;
        r = b;

        sp_3072_from_mp(b, 67, base);
        sp_3072_from_mp(e, 67, exp);
        sp_3072_from_mp(m, 67, mod);

        err = sp_3072_mod_exp_67(r, b, e, mp_count_bits(exp), m, 0);
    }

    if (err == MP_OKAY) {
        XMEMSET(r + 67, 0, sizeof(*r) * 67U);
        err = sp_3072_to_mp(r, res);
    }

    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 67U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
    return err;
#else
#ifndef WOLFSSL_SMALL_STACK
    sp_digit bd[134];
    sp_digit ed[67];
    sp_digit md[67];
#else
    sp_digit* d = NULL;
#endif
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    int err = MP_OKAY;
    int expBits = mp_count_bits(exp);

    if (mp_count_bits(base) > 1536) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expBits > 1536)) {
        err = MP_READ_E;
    }
    
    if ((err == MP_OKAY) && (mp_count_bits(mod) != 1536)) {
        err = MP_READ_E;
    }

#ifdef WOLFSSL_SMALL_STACK
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 67 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL)
            err = MEMORY_E;
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 67 * 2;
        m = e + 67;
        r = b;
    }
#else
    r = b = bd;
    e = ed;
    m = md;
#endif

    if (err == MP_OKAY) {
        sp_3072_from_mp(b, 67, base);
        sp_3072_from_mp(e, 67, exp);
        sp_3072_from_mp(m, 67, mod);

        err = sp_3072_mod_exp_67(r, b, e, expBits, m, 0);
    }

    if (err == MP_OKAY) {
        XMEMSET(r + 67, 0, sizeof(*r) * 67U);
        err = sp_3072_to_mp(r, res);
    }


#ifdef WOLFSSL_SMALL_STACK
    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 67U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
#else
    XMEMSET(e, 0, sizeof(sp_digit) * 67U);
#endif

    return err;
#endif
}

#endif /* WOLFSSL_HAVE_SP_DH | (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) */

#endif /* !WOLFSSL_SP_NO_3072 */

#ifdef WOLFSSL_SP_4096
/* Read big endian unsigned byte array into r.
 *
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  Byte array.
 * n  Number of bytes in array to read.
 */
static void sp_4096_from_bin(sp_digit* r, int size, const byte* a, int n)
{
    int i;
    int j = 0;
    word32 s = 0;

    r[0] = 0;
    for (i = n-1; i >= 0; i--) {
        r[j] |= (((sp_digit)a[i]) << s);
        if (s >= 13U) {
            r[j] &= 0x1fffff;
            s = 21U - s;
            if (j + 1 >= size) {
                break;
            }
            r[++j] = (sp_digit)a[i] >> s;
            s = 8U - s;
        }
        else {
            s += 8U;
        }
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
}

/* Convert an mp_int to an array of sp_digit.
 *
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  A multi-precision integer.
 */
static void sp_4096_from_mp(sp_digit* r, int size, const mp_int* a)
{
#if DIGIT_BIT == 21
    int j;

    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);

    for (j = a->used; j < size; j++) {
        r[j] = 0;
    }
#elif DIGIT_BIT > 21
    int i;
    int j = 0;
    word32 s = 0;

    r[0] = 0;
    for (i = 0; i < a->used && j < size; i++) {
        r[j] |= ((sp_digit)a->dp[i] << s);
        r[j] &= 0x1fffff;
        s = 21U - s;
        if (j + 1 >= size) {
            break;
        }
        /* lint allow cast of mismatch word32 and mp_digit */
        r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
        while ((s + 21U) <= (word32)DIGIT_BIT) {
            s += 21U;
            r[j] &= 0x1fffff;
            if (j + 1 >= size) {
                break;
            }
            if (s < (word32)DIGIT_BIT) {
                /* lint allow cast of mismatch word32 and mp_digit */
                r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
            }
            else {
                r[++j] = 0L;
            }
        }
        s = (word32)DIGIT_BIT - s;
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#else
    int i;
    int j = 0;
    int s = 0;

    r[0] = 0;
    for (i = 0; i < a->used && j < size; i++) {
        r[j] |= ((sp_digit)a->dp[i]) << s;
        if (s + DIGIT_BIT >= 21) {
            r[j] &= 0x1fffff;
            if (j + 1 >= size) {
                break;
            }
            s = 21 - s;
            if (s == DIGIT_BIT) {
                r[++j] = 0;
                s = 0;
            }
            else {
                r[++j] = a->dp[i] >> s;
                s = DIGIT_BIT - s;
            }
        }
        else {
            s += DIGIT_BIT;
        }
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#endif
}

/* Write r as big endian to byte array.
 * Fixed length number of bytes written: 512
 *
 * r  A single precision integer.
 * a  Byte array.
 */
static void sp_4096_to_bin(sp_digit* r, byte* a)
{
    int i;
    int j;
    int s = 0;
    int b;

    for (i=0; i<195; i++) {
        r[i+1] += r[i] >> 21;
        r[i] &= 0x1fffff;
    }
    j = 4096 / 8 - 1;
    a[j] = 0;
    for (i=0; i<196 && j>=0; i++) {
        b = 0;
        /* lint allow cast of mismatch sp_digit and int */
        a[j--] |= (byte)(r[i] << s); /*lint !e9033*/
        b += 8 - s;
        if (j < 0) {
            break;
        }
        while (b < 21) {
            a[j--] = (byte)(r[i] >> b);
            b += 8;
            if (j < 0) {
                break;
            }
        }
        s = 8 - (b - 21);
        if (j >= 0) {
            a[j] = 0;
        }
        if (s != 0) {
            j++;
        }
    }
}

#ifndef WOLFSSL_SP_SMALL
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_4096_mul_49(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int i;
    int j;
    int64_t t[98];

    XMEMSET(t, 0, sizeof(t));
    for (i=0; i<49; i++) {
        for (j=0; j<49; j++) {
            t[i+j] += ((int64_t)a[i]) * b[j];
        }
    }
    for (i=0; i<97; i++) {
        r[i] = t[i] & 0x1fffff;
        t[i+1] += t[i] >> 21;
    }
    r[97] = (sp_digit)t[97];
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_4096_sqr_49(sp_digit* r, const sp_digit* a)
{
    int i;
    int j;
    int64_t t[98];

    XMEMSET(t, 0, sizeof(t));
    for (i=0; i<49; i++) {
        for (j=0; j<i; j++) {
            t[i+j] += (((int64_t)a[i]) * a[j]) * 2;
        }
        t[i+i] += ((int64_t)a[i]) * a[i];
    }
    for (i=0; i<97; i++) {
        r[i] = t[i] & 0x1fffff;
        t[i+1] += t[i] >> 21;
    }
    r[97] = (sp_digit)t[97];
}

/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_4096_add_49(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 48; i += 8) {
        r[i + 0] = a[i + 0] + b[i + 0];
        r[i + 1] = a[i + 1] + b[i + 1];
        r[i + 2] = a[i + 2] + b[i + 2];
        r[i + 3] = a[i + 3] + b[i + 3];
        r[i + 4] = a[i + 4] + b[i + 4];
        r[i + 5] = a[i + 5] + b[i + 5];
        r[i + 6] = a[i + 6] + b[i + 6];
        r[i + 7] = a[i + 7] + b[i + 7];
    }
    r[48] = a[48] + b[48];

    return 0;
}

/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_4096_add_98(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 96; i += 8) {
        r[i + 0] = a[i + 0] + b[i + 0];
        r[i + 1] = a[i + 1] + b[i + 1];
        r[i + 2] = a[i + 2] + b[i + 2];
        r[i + 3] = a[i + 3] + b[i + 3];
        r[i + 4] = a[i + 4] + b[i + 4];
        r[i + 5] = a[i + 5] + b[i + 5];
        r[i + 6] = a[i + 6] + b[i + 6];
        r[i + 7] = a[i + 7] + b[i + 7];
    }
    r[96] = a[96] + b[96];
    r[97] = a[97] + b[97];

    return 0;
}

/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_4096_sub_98(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 96; i += 8) {
        r[i + 0] = a[i + 0] - b[i + 0];
        r[i + 1] = a[i + 1] - b[i + 1];
        r[i + 2] = a[i + 2] - b[i + 2];
        r[i + 3] = a[i + 3] - b[i + 3];
        r[i + 4] = a[i + 4] - b[i + 4];
        r[i + 5] = a[i + 5] - b[i + 5];
        r[i + 6] = a[i + 6] - b[i + 6];
        r[i + 7] = a[i + 7] - b[i + 7];
    }
    r[96] = a[96] - b[96];
    r[97] = a[97] - b[97];

    return 0;
}

/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_4096_mul_98(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    sp_digit* z0 = r;
    sp_digit z1[98];
    sp_digit* a1 = z1;
    sp_digit b1[49];
    sp_digit* z2 = r + 98;
    (void)sp_4096_add_49(a1, a, &a[49]);
    (void)sp_4096_add_49(b1, b, &b[49]);
    sp_4096_mul_49(z2, &a[49], &b[49]);
    sp_4096_mul_49(z0, a, b);
    sp_4096_mul_49(z1, a1, b1);
    (void)sp_4096_sub_98(z1, z1, z2);
    (void)sp_4096_sub_98(z1, z1, z0);
    (void)sp_4096_add_98(r + 49, r + 49, z1);
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_4096_sqr_98(sp_digit* r, const sp_digit* a)
{
    sp_digit* z0 = r;
    sp_digit z1[98];
    sp_digit* a1 = z1;
    sp_digit* z2 = r + 98;
    (void)sp_4096_add_49(a1, a, &a[49]);
    sp_4096_sqr_49(z2, &a[49]);
    sp_4096_sqr_49(z0, a);
    sp_4096_sqr_49(z1, a1);
    (void)sp_4096_sub_98(z1, z1, z2);
    (void)sp_4096_sub_98(z1, z1, z0);
    (void)sp_4096_add_98(r + 49, r + 49, z1);
}

/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_4096_add_196(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 192; i += 8) {
        r[i + 0] = a[i + 0] + b[i + 0];
        r[i + 1] = a[i + 1] + b[i + 1];
        r[i + 2] = a[i + 2] + b[i + 2];
        r[i + 3] = a[i + 3] + b[i + 3];
        r[i + 4] = a[i + 4] + b[i + 4];
        r[i + 5] = a[i + 5] + b[i + 5];
        r[i + 6] = a[i + 6] + b[i + 6];
        r[i + 7] = a[i + 7] + b[i + 7];
    }
    r[192] = a[192] + b[192];
    r[193] = a[193] + b[193];
    r[194] = a[194] + b[194];
    r[195] = a[195] + b[195];

    return 0;
}

/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_4096_sub_196(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 192; i += 8) {
        r[i + 0] = a[i + 0] - b[i + 0];
        r[i + 1] = a[i + 1] - b[i + 1];
        r[i + 2] = a[i + 2] - b[i + 2];
        r[i + 3] = a[i + 3] - b[i + 3];
        r[i + 4] = a[i + 4] - b[i + 4];
        r[i + 5] = a[i + 5] - b[i + 5];
        r[i + 6] = a[i + 6] - b[i + 6];
        r[i + 7] = a[i + 7] - b[i + 7];
    }
    r[192] = a[192] - b[192];
    r[193] = a[193] - b[193];
    r[194] = a[194] - b[194];
    r[195] = a[195] - b[195];

    return 0;
}

/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_4096_mul_196(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    sp_digit* z0 = r;
    sp_digit z1[196];
    sp_digit* a1 = z1;
    sp_digit b1[98];
    sp_digit* z2 = r + 196;
    (void)sp_4096_add_98(a1, a, &a[98]);
    (void)sp_4096_add_98(b1, b, &b[98]);
    sp_4096_mul_98(z2, &a[98], &b[98]);
    sp_4096_mul_98(z0, a, b);
    sp_4096_mul_98(z1, a1, b1);
    (void)sp_4096_sub_196(z1, z1, z2);
    (void)sp_4096_sub_196(z1, z1, z0);
    (void)sp_4096_add_196(r + 98, r + 98, z1);
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_4096_sqr_196(sp_digit* r, const sp_digit* a)
{
    sp_digit* z0 = r;
    sp_digit z1[196];
    sp_digit* a1 = z1;
    sp_digit* z2 = r + 196;
    (void)sp_4096_add_98(a1, a, &a[98]);
    sp_4096_sqr_98(z2, &a[98]);
    sp_4096_sqr_98(z0, a);
    sp_4096_sqr_98(z1, a1);
    (void)sp_4096_sub_196(z1, z1, z2);
    (void)sp_4096_sub_196(z1, z1, z0);
    (void)sp_4096_add_196(r + 98, r + 98, z1);
}

#endif /* !WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_4096_add_196(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 196; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_4096_sub_196(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 196; i++) {
        r[i] = a[i] - b[i];
    }

    return 0;
}

#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_4096_mul_196(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[195]) * b[195];
    r[391] = (sp_digit)(c >> 21);
    c = (c & 0x1fffff) << 21;
    for (k = 389; k >= 0; k--) {
        for (i = 195; i >= 0; i--) {
            j = k - i;
            if (j >= 196) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * b[j];
        }
        r[k + 2] += c >> 42;
        r[k + 1] = (c >> 21) & 0x1fffff;
        c = (c & 0x1fffff) << 21;
    }
    r[0] = (sp_digit)(c >> 21);
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_4096_sqr_196(sp_digit* r, const sp_digit* a)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[195]) * a[195];
    r[391] = (sp_digit)(c >> 21);
    c = (c & 0x1fffff) << 21;
    for (k = 389; k >= 0; k--) {
        for (i = 195; i >= 0; i--) {
            j = k - i;
            if (j >= 196 || i <= j) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * a[j] * 2;
        }
        if (i == j) {
           c += ((int64_t)a[i]) * a[i];
        }

        r[k + 2] += c >> 42;
        r[k + 1] = (c >> 21) & 0x1fffff;
        c = (c & 0x1fffff) << 21;
    }
    r[0] = (sp_digit)(c >> 21);
}

#endif /* WOLFSSL_SP_SMALL */
#if (defined(WOLFSSL_HAVE_SP_RSA) || defined(WOLFSSL_HAVE_SP_DH)) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)
#if defined(WOLFSSL_HAVE_SP_RSA) && !defined(SP_RSA_PRIVATE_EXP_D)
#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_4096_add_98(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 98; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_4096_sub_98(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 98; i++) {
        r[i] = a[i] - b[i];
    }

    return 0;
}

#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_4096_mul_98(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[97]) * b[97];
    r[195] = (sp_digit)(c >> 21);
    c = (c & 0x1fffff) << 21;
    for (k = 193; k >= 0; k--) {
        for (i = 97; i >= 0; i--) {
            j = k - i;
            if (j >= 98) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * b[j];
        }
        r[k + 2] += c >> 42;
        r[k + 1] = (c >> 21) & 0x1fffff;
        c = (c & 0x1fffff) << 21;
    }
    r[0] = (sp_digit)(c >> 21);
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_4096_sqr_98(sp_digit* r, const sp_digit* a)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[97]) * a[97];
    r[195] = (sp_digit)(c >> 21);
    c = (c & 0x1fffff) << 21;
    for (k = 193; k >= 0; k--) {
        for (i = 97; i >= 0; i--) {
            j = k - i;
            if (j >= 98 || i <= j) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * a[j] * 2;
        }
        if (i == j) {
           c += ((int64_t)a[i]) * a[i];
        }

        r[k + 2] += c >> 42;
        r[k + 1] = (c >> 21) & 0x1fffff;
        c = (c & 0x1fffff) << 21;
    }
    r[0] = (sp_digit)(c >> 21);
}

#endif /* WOLFSSL_SP_SMALL */
#endif /* WOLFSSL_HAVE_SP_RSA & !SP_RSA_PRIVATE_EXP_D */
#endif /* (WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH) & !WOLFSSL_RSA_PUBLIC_ONLY */

/* Caclulate the bottom digit of -1/a mod 2^n.
 *
 * a    A single precision number.
 * rho  Bottom word of inverse.
 */
static void sp_4096_mont_setup(const sp_digit* a, sp_digit* rho)
{
    sp_digit x;
    sp_digit b;

    b = a[0];
    x = (((b + 2) & 4) << 1) + b; /* here x*a==1 mod 2**4 */
    x *= 2 - b * x;               /* here x*a==1 mod 2**8 */
    x *= 2 - b * x;               /* here x*a==1 mod 2**16 */
    x *= 2 - b * x;               /* here x*a==1 mod 2**32 */
    x &= 0x1fffff;

    /* rho = -1/m mod b */
    *rho = (1L << 21) - x;
}

/* Multiply a by scalar b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_4096_mul_d_196(sp_digit* r, const sp_digit* a,
    sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 196; i++) {
        t += tb * a[i];
        r[i] = t & 0x1fffff;
        t >>= 21;
    }
    r[196] = (sp_digit)t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] = t[0] & 0x1fffff;
    for (i = 0; i < 192; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] = (sp_digit)(t[0] >> 21) + (t[1] & 0x1fffff);
        t[2] = tb * a[i+2];
        r[i+2] = (sp_digit)(t[1] >> 21) + (t[2] & 0x1fffff);
        t[3] = tb * a[i+3];
        r[i+3] = (sp_digit)(t[2] >> 21) + (t[3] & 0x1fffff);
        t[4] = tb * a[i+4];
        r[i+4] = (sp_digit)(t[3] >> 21) + (t[4] & 0x1fffff);
        t[5] = tb * a[i+5];
        r[i+5] = (sp_digit)(t[4] >> 21) + (t[5] & 0x1fffff);
        t[6] = tb * a[i+6];
        r[i+6] = (sp_digit)(t[5] >> 21) + (t[6] & 0x1fffff);
        t[7] = tb * a[i+7];
        r[i+7] = (sp_digit)(t[6] >> 21) + (t[7] & 0x1fffff);
        t[0] = tb * a[i+8];
        r[i+8] = (sp_digit)(t[7] >> 21) + (t[0] & 0x1fffff);
    }
    t[1] = tb * a[193];
    r[193] = (sp_digit)(t[0] >> 21) + (t[1] & 0x1fffff);
    t[2] = tb * a[194];
    r[194] = (sp_digit)(t[1] >> 21) + (t[2] & 0x1fffff);
    t[3] = tb * a[195];
    r[195] = (sp_digit)(t[2] >> 21) + (t[3] & 0x1fffff);
    r[196] =  (sp_digit)(t[3] >> 21);
#endif /* WOLFSSL_SP_SMALL */
}

#if (defined(WOLFSSL_HAVE_SP_RSA) || defined(WOLFSSL_HAVE_SP_DH)) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)
#if defined(WOLFSSL_HAVE_SP_RSA) && !defined(SP_RSA_PRIVATE_EXP_D)
/* r = 2^n mod m where n is the number of bits to reduce by.
 * Given m must be 4096 bits, just need to subtract.
 *
 * r  A single precision number.
 * m  A single precision number.
 */
static void sp_4096_mont_norm_98(sp_digit* r, const sp_digit* m)
{
    /* Set r = 2^n - 1. */
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=0; i<97; i++) {
        r[i] = 0x1fffff;
    }
#else
    int i;

    for (i = 0; i < 96; i += 8) {
        r[i + 0] = 0x1fffff;
        r[i + 1] = 0x1fffff;
        r[i + 2] = 0x1fffff;
        r[i + 3] = 0x1fffff;
        r[i + 4] = 0x1fffff;
        r[i + 5] = 0x1fffff;
        r[i + 6] = 0x1fffff;
        r[i + 7] = 0x1fffff;
    }
    r[96] = 0x1fffff;
#endif
    r[97] = 0x7ffL;

    /* r = (2^n - 1) mod n */
    (void)sp_4096_sub_98(r, r, m);

    /* Add one so r = 2^n mod m */
    r[0] += 1;
}

/* Compare a with b in constant time.
 *
 * a  A single precision integer.
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
static sp_digit sp_4096_cmp_98(const sp_digit* a, const sp_digit* b)
{
    sp_digit r = 0;
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=97; i>=0; i--) {
        r |= (a[i] - b[i]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#else
    int i;

    r |= (a[97] - b[97]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[96] - b[96]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    for (i = 88; i >= 0; i -= 8) {
        r |= (a[i + 7] - b[i + 7]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 6] - b[i + 6]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 5] - b[i + 5]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 4] - b[i + 4]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 3] - b[i + 3]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 2] - b[i + 2]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 1] - b[i + 1]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 0] - b[i + 0]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#endif /* WOLFSSL_SP_SMALL */

    return r;
}

/* Conditionally subtract b from a using the mask m.
 * m is -1 to subtract and 0 when not.
 *
 * r  A single precision number representing condition subtract result.
 * a  A single precision number to subtract from.
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
static void sp_4096_cond_sub_98(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 98; i++) {
        r[i] = a[i] - (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 96; i += 8) {
        r[i + 0] = a[i + 0] - (b[i + 0] & m);
        r[i + 1] = a[i + 1] - (b[i + 1] & m);
        r[i + 2] = a[i + 2] - (b[i + 2] & m);
        r[i + 3] = a[i + 3] - (b[i + 3] & m);
        r[i + 4] = a[i + 4] - (b[i + 4] & m);
        r[i + 5] = a[i + 5] - (b[i + 5] & m);
        r[i + 6] = a[i + 6] - (b[i + 6] & m);
        r[i + 7] = a[i + 7] - (b[i + 7] & m);
    }
    r[96] = a[96] - (b[96] & m);
    r[97] = a[97] - (b[97] & m);
#endif /* WOLFSSL_SP_SMALL */
}

/* Mul a by scalar b and add into r. (r += a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_4096_mul_add_98(sp_digit* r, const sp_digit* a,
        const sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 98; i++) {
        t += (tb * a[i]) + r[i];
        r[i] = t & 0x1fffff;
        t >>= 21;
    }
    r[98] += t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] += (sp_digit)(t[0] & 0x1fffff);
    for (i = 0; i < 96; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] += (sp_digit)((t[0] >> 21) + (t[1] & 0x1fffff));
        t[2] = tb * a[i+2];
        r[i+2] += (sp_digit)((t[1] >> 21) + (t[2] & 0x1fffff));
        t[3] = tb * a[i+3];
        r[i+3] += (sp_digit)((t[2] >> 21) + (t[3] & 0x1fffff));
        t[4] = tb * a[i+4];
        r[i+4] += (sp_digit)((t[3] >> 21) + (t[4] & 0x1fffff));
        t[5] = tb * a[i+5];
        r[i+5] += (sp_digit)((t[4] >> 21) + (t[5] & 0x1fffff));
        t[6] = tb * a[i+6];
        r[i+6] += (sp_digit)((t[5] >> 21) + (t[6] & 0x1fffff));
        t[7] = tb * a[i+7];
        r[i+7] += (sp_digit)((t[6] >> 21) + (t[7] & 0x1fffff));
        t[0] = tb * a[i+8];
        r[i+8] += (sp_digit)((t[7] >> 21) + (t[0] & 0x1fffff));
    }
    t[1] = tb * a[97]; r[97] += (sp_digit)((t[0] >> 21) + (t[1] & 0x1fffff));
    r[98] +=  (sp_digit)(t[1] >> 21);
#endif /* WOLFSSL_SP_SMALL */
}

/* Normalize the values in each word to 21.
 *
 * a  Array of sp_digit to normalize.
 */
static void sp_4096_norm_98(sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    for (i = 0; i < 97; i++) {
        a[i+1] += a[i] >> 21;
        a[i] &= 0x1fffff;
    }
#else
    int i;
    for (i = 0; i < 96; i += 8) {
        a[i+1] += a[i+0] >> 21; a[i+0] &= 0x1fffff;
        a[i+2] += a[i+1] >> 21; a[i+1] &= 0x1fffff;
        a[i+3] += a[i+2] >> 21; a[i+2] &= 0x1fffff;
        a[i+4] += a[i+3] >> 21; a[i+3] &= 0x1fffff;
        a[i+5] += a[i+4] >> 21; a[i+4] &= 0x1fffff;
        a[i+6] += a[i+5] >> 21; a[i+5] &= 0x1fffff;
        a[i+7] += a[i+6] >> 21; a[i+6] &= 0x1fffff;
        a[i+8] += a[i+7] >> 21; a[i+7] &= 0x1fffff;
        a[i+9] += a[i+8] >> 21; a[i+8] &= 0x1fffff;
    }
    a[96+1] += a[96] >> 21;
    a[96] &= 0x1fffff;
#endif
}

/* Shift the result in the high 2048 bits down to the bottom.
 *
 * r  A single precision number.
 * a  A single precision number.
 */
static void sp_4096_mont_shift_98(sp_digit* r, const sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    int64_t n = a[97] >> 11;
    n += ((int64_t)a[98]) << 10;

    for (i = 0; i < 97; i++) {
        r[i] = n & 0x1fffff;
        n >>= 21;
        n += ((int64_t)a[99 + i]) << 10;
    }
    r[97] = (sp_digit)n;
#else
    int i;
    int64_t n = a[97] >> 11;
    n += ((int64_t)a[98]) << 10;
    for (i = 0; i < 96; i += 8) {
        r[i + 0] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 99]) << 10;
        r[i + 1] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 100]) << 10;
        r[i + 2] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 101]) << 10;
        r[i + 3] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 102]) << 10;
        r[i + 4] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 103]) << 10;
        r[i + 5] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 104]) << 10;
        r[i + 6] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 105]) << 10;
        r[i + 7] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 106]) << 10;
    }
    r[96] = n & 0x1fffff; n >>= 21; n += ((int64_t)a[195]) << 10;
    r[97] = (sp_digit)n;
#endif /* WOLFSSL_SP_SMALL */
    XMEMSET(&r[98], 0, sizeof(*r) * 98U);
}

/* Reduce the number back to 4096 bits using Montgomery reduction.
 *
 * a   A single precision number to reduce in place.
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
static void sp_4096_mont_reduce_98(sp_digit* a, const sp_digit* m, sp_digit mp)
{
    int i;
    sp_digit mu;

    sp_4096_norm_98(a + 98);

    for (i=0; i<97; i++) {
        mu = (a[i] * mp) & 0x1fffff;
        sp_4096_mul_add_98(a+i, m, mu);
        a[i+1] += a[i] >> 21;
    }
    mu = (a[i] * mp) & 0x7ffL;
    sp_4096_mul_add_98(a+i, m, mu);
    a[i+1] += a[i] >> 21;
    a[i] &= 0x1fffff;

    sp_4096_mont_shift_98(a, a);
    sp_4096_cond_sub_98(a, a, m, 0 - (((a[97] >> 11) > 0) ?
            (sp_digit)1 : (sp_digit)0));
    sp_4096_norm_98(a);
}

/* Multiply two Montogmery form numbers mod the modulus (prime).
 * (r = a * b mod m)
 *
 * r   Result of multiplication.
 * a   First number to multiply in Montogmery form.
 * b   Second number to multiply in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_4096_mont_mul_98(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit* m, sp_digit mp)
{
    sp_4096_mul_98(r, a, b);
    sp_4096_mont_reduce_98(r, m, mp);
}

/* Square the Montgomery form number. (r = a * a mod m)
 *
 * r   Result of squaring.
 * a   Number to square in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_4096_mont_sqr_98(sp_digit* r, const sp_digit* a,
        const sp_digit* m, sp_digit mp)
{
    sp_4096_sqr_98(r, a);
    sp_4096_mont_reduce_98(r, m, mp);
}

/* Multiply a by scalar b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_4096_mul_d_98(sp_digit* r, const sp_digit* a,
    sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 98; i++) {
        t += tb * a[i];
        r[i] = t & 0x1fffff;
        t >>= 21;
    }
    r[98] = (sp_digit)t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] = t[0] & 0x1fffff;
    for (i = 0; i < 96; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] = (sp_digit)(t[0] >> 21) + (t[1] & 0x1fffff);
        t[2] = tb * a[i+2];
        r[i+2] = (sp_digit)(t[1] >> 21) + (t[2] & 0x1fffff);
        t[3] = tb * a[i+3];
        r[i+3] = (sp_digit)(t[2] >> 21) + (t[3] & 0x1fffff);
        t[4] = tb * a[i+4];
        r[i+4] = (sp_digit)(t[3] >> 21) + (t[4] & 0x1fffff);
        t[5] = tb * a[i+5];
        r[i+5] = (sp_digit)(t[4] >> 21) + (t[5] & 0x1fffff);
        t[6] = tb * a[i+6];
        r[i+6] = (sp_digit)(t[5] >> 21) + (t[6] & 0x1fffff);
        t[7] = tb * a[i+7];
        r[i+7] = (sp_digit)(t[6] >> 21) + (t[7] & 0x1fffff);
        t[0] = tb * a[i+8];
        r[i+8] = (sp_digit)(t[7] >> 21) + (t[0] & 0x1fffff);
    }
    t[1] = tb * a[97];
    r[97] = (sp_digit)(t[0] >> 21) + (t[1] & 0x1fffff);
    r[98] =  (sp_digit)(t[1] >> 21);
#endif /* WOLFSSL_SP_SMALL */
}

/* Conditionally add a and b using the mask m.
 * m is -1 to add and 0 when not.
 *
 * r  A single precision number representing conditional add result.
 * a  A single precision number to add with.
 * b  A single precision number to add.
 * m  Mask value to apply.
 */
static void sp_4096_cond_add_98(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 98; i++) {
        r[i] = a[i] + (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 96; i += 8) {
        r[i + 0] = a[i + 0] + (b[i + 0] & m);
        r[i + 1] = a[i + 1] + (b[i + 1] & m);
        r[i + 2] = a[i + 2] + (b[i + 2] & m);
        r[i + 3] = a[i + 3] + (b[i + 3] & m);
        r[i + 4] = a[i + 4] + (b[i + 4] & m);
        r[i + 5] = a[i + 5] + (b[i + 5] & m);
        r[i + 6] = a[i + 6] + (b[i + 6] & m);
        r[i + 7] = a[i + 7] + (b[i + 7] & m);
    }
    r[96] = a[96] + (b[96] & m);
    r[97] = a[97] + (b[97] & m);
#endif /* WOLFSSL_SP_SMALL */
}

#ifdef WOLFSSL_SP_SMALL
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_4096_sub_98(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 98; i++) {
        r[i] = a[i] - b[i];
    }

    return 0;
}

#endif
#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_4096_add_98(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 98; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#endif
SP_NOINLINE static void sp_4096_rshift_98(sp_digit* r, const sp_digit* a,
        byte n)
{
    int i;

#ifdef WOLFSSL_SP_SMALL
    for (i=0; i<97; i++) {
        r[i] = ((a[i] >> n) | (a[i + 1] << (21 - n))) & 0x1fffff;
    }
#else
    for (i=0; i<96; i += 8) {
        r[i+0] = ((a[i+0] >> n) | (a[i+1] << (21 - n))) & 0x1fffff;
        r[i+1] = ((a[i+1] >> n) | (a[i+2] << (21 - n))) & 0x1fffff;
        r[i+2] = ((a[i+2] >> n) | (a[i+3] << (21 - n))) & 0x1fffff;
        r[i+3] = ((a[i+3] >> n) | (a[i+4] << (21 - n))) & 0x1fffff;
        r[i+4] = ((a[i+4] >> n) | (a[i+5] << (21 - n))) & 0x1fffff;
        r[i+5] = ((a[i+5] >> n) | (a[i+6] << (21 - n))) & 0x1fffff;
        r[i+6] = ((a[i+6] >> n) | (a[i+7] << (21 - n))) & 0x1fffff;
        r[i+7] = ((a[i+7] >> n) | (a[i+8] << (21 - n))) & 0x1fffff;
    }
    r[96] = ((a[96] >> n) | (a[97] << (21 - n))) & 0x1fffff;
#endif
    r[97] = a[97] >> n;
}

#ifdef WOLFSSL_SP_DIV_32
static WC_INLINE sp_digit sp_4096_div_word_98(sp_digit d1, sp_digit d0,
    sp_digit dv)
{
    sp_digit d;
    sp_digit r;
    sp_digit t;

    /* All 21 bits from d1 and top 10 bits from d0. */
    d = (d1 << 10) | (d0 >> 11);
    r = d / dv;
    d -= r * dv;
    /* Up to 11 bits in r */
    /* Next 10 bits from d0. */
    r <<= 10;
    d <<= 10;
    d |= (d0 >> 1) & ((1 << 10) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 21 bits in r */
    /* Remaining 1 bits from d0. */
    r <<= 1;
    d <<= 1;
    d |= d0 & ((1 << 1) - 1);
    t = d / dv;
    r += t;

    return r;
}
#endif /* WOLFSSL_SP_DIV_32 */

/* Divide d in a and put remainder into r (m*d + r = a)
 * m is not calculated as it is not needed at this time.
 *
 * a  Nmber to be divided.
 * d  Number to divide with.
 * m  Multiplier result.
 * r  Remainder from the division.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_4096_div_98(const sp_digit* a, const sp_digit* d,
        const sp_digit* m, sp_digit* r)
{
    int i;
#ifndef WOLFSSL_SP_DIV_32
    int64_t d1;
#endif
    sp_digit dv;
    sp_digit r1;
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit t1d[196 + 1];
    sp_digit t2d[98 + 1];
    sp_digit sdd[98 + 1];
#endif
    sp_digit* t1;
    sp_digit* t2;
    sp_digit* sd;
    int err = MP_OKAY;

    (void)m;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * (4 * 98 + 3), NULL,
                                                       DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    (void)m;

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t1 = td;
        t2 = td + 196 + 1;
        sd = t2 + 98 + 1;
#else
        t1 = t1d;
        t2 = t2d;
        sd = sdd;
#endif

        sp_4096_mul_d_98(sd, d, 1L << 10);
        sp_4096_mul_d_196(t1, a, 1L << 10);
        dv = sd[97];
        for (i=98; i>=0; i--) {
            t1[98 + i] += t1[98 + i - 1] >> 21;
            t1[98 + i - 1] &= 0x1fffff;
#ifndef WOLFSSL_SP_DIV_32
            d1 = t1[98 + i];
            d1 <<= 21;
            d1 += t1[98 + i - 1];
            r1 = (sp_digit)(d1 / dv);
#else
            r1 = sp_4096_div_word_98(t1[98 + i], t1[98 + i - 1], dv);
#endif

            sp_4096_mul_d_98(t2, sd, r1);
            (void)sp_4096_sub_98(&t1[i], &t1[i], t2);
            t1[98 + i] -= t2[98];
            t1[98 + i] += t1[98 + i - 1] >> 21;
            t1[98 + i - 1] &= 0x1fffff;
            r1 = (((-t1[98 + i]) << 21) - t1[98 + i - 1]) / dv;
            r1 -= t1[98 + i];
            sp_4096_mul_d_98(t2, sd, r1);
            (void)sp_4096_add_98(&t1[i], &t1[i], t2);
            t1[98 + i] += t1[98 + i - 1] >> 21;
            t1[98 + i - 1] &= 0x1fffff;
        }
        t1[98 - 1] += t1[98 - 2] >> 21;
        t1[98 - 2] &= 0x1fffff;
        r1 = t1[98 - 1] / dv;

        sp_4096_mul_d_98(t2, sd, r1);
        sp_4096_sub_98(t1, t1, t2);
        XMEMCPY(r, t1, sizeof(*r) * 2U * 98U);
        for (i=0; i<97; i++) {
            r[i+1] += r[i] >> 21;
            r[i] &= 0x1fffff;
        }
        sp_4096_cond_add_98(r, r, sd, 0 - ((r[97] < 0) ?
                    (sp_digit)1 : (sp_digit)0));

        sp_4096_norm_98(r);
        sp_4096_rshift_98(r, r, 10);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
}

/* Reduce a modulo m into r. (r = a mod m)
 *
 * r  A single precision number that is the reduced result.
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_4096_mod_98(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    return sp_4096_div_98(a, m, NULL, r);
}

/* Modular exponentiate a to the e mod m. (r = a^e mod m)
 *
 * r     A single precision number that is the result of the operation.
 * a     A single precision number being exponentiated.
 * e     A single precision number that is the exponent.
 * bits  The number of bits in the exponent.
 * m     A single precision number that is the modulus.
 * returns 0 on success and MEMORY_E on dynamic memory allocation failure.
 */
static int sp_4096_mod_exp_98(sp_digit* r, const sp_digit* a, const sp_digit* e, int bits,
    const sp_digit* m, int reduceA)
{
#ifdef WOLFSSL_SP_SMALL
#if !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[3 * 196];
#endif
    sp_digit* t[3];
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 3 * 98 * 2, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
        for (i=0; i<3; i++) {
#if !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + (i * 98 * 2);
#else
            t[i] = &td[i * 98 * 2];
#endif
            XMEMSET(t[i], 0, sizeof(sp_digit) * 98U * 2U);
        }

        sp_4096_mont_setup(m, &mp);
        sp_4096_mont_norm_98(norm, m);

        if (reduceA != 0) {
            err = sp_4096_mod_98(t[1], a, m);
        }
        else {
            XMEMCPY(t[1], a, sizeof(sp_digit) * 98U);
        }
    }
    if (err == MP_OKAY) {
        sp_4096_mul_98(t[1], t[1], norm);
        err = sp_4096_mod_98(t[1], t[1], m);
    }

    if (err == MP_OKAY) {
        i = bits / 21;
        c = bits % 21;
        n = e[i--] << (21 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1) {
                    break;
                }

                n = e[i--];
                c = 21;
            }

            y = (n >> 20) & 1;
            n <<= 1;

            sp_4096_mont_mul_98(t[y^1], t[0], t[1], m, mp);

            XMEMCPY(t[2], (void*)(((size_t)t[0] & addr_mask[y^1]) +
                                  ((size_t)t[1] & addr_mask[y])),
                                  sizeof(*t[2]) * 98 * 2);
            sp_4096_mont_sqr_98(t[2], t[2], m, mp);
            XMEMCPY((void*)(((size_t)t[0] & addr_mask[y^1]) +
                            ((size_t)t[1] & addr_mask[y])), t[2],
                            sizeof(*t[2]) * 98 * 2);
        }

        sp_4096_mont_reduce_98(t[0], m, mp);
        n = sp_4096_cmp_98(t[0], m);
        sp_4096_cond_sub_98(t[0], t[0], m, ((n < 0) ?
                    (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, t[0], sizeof(*r) * 98 * 2);

    }

#if !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#elif defined(WOLFSSL_SP_CACHE_RESISTANT)
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[3 * 196];
#endif
    sp_digit* t[3];
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#ifdef WOLFSSL_SMALL_STACK
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 3 * 98 * 2, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
        for (i=0; i<3; i++) {
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + (i * 98 * 2);
#else
            t[i] = &td[i * 98 * 2];
#endif
        }

        sp_4096_mont_setup(m, &mp);
        sp_4096_mont_norm_98(norm, m);

        if (reduceA != 0) {
            err = sp_4096_mod_98(t[1], a, m);
            if (err == MP_OKAY) {
                sp_4096_mul_98(t[1], t[1], norm);
                err = sp_4096_mod_98(t[1], t[1], m);
            }
        }
        else {
            sp_4096_mul_98(t[1], a, norm);
            err = sp_4096_mod_98(t[1], t[1], m);
        }
    }

    if (err == MP_OKAY) {
        i = bits / 21;
        c = bits % 21;
        n = e[i--] << (21 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1) {
                    break;
                }

                n = e[i--];
                c = 21;
            }

            y = (n >> 20) & 1;
            n <<= 1;

            sp_4096_mont_mul_98(t[y^1], t[0], t[1], m, mp);

            XMEMCPY(t[2], (void*)(((size_t)t[0] & addr_mask[y^1]) +
                                  ((size_t)t[1] & addr_mask[y])), 
                                  sizeof(*t[2]) * 98 * 2);
            sp_4096_mont_sqr_98(t[2], t[2], m, mp);
            XMEMCPY((void*)(((size_t)t[0] & addr_mask[y^1]) +
                            ((size_t)t[1] & addr_mask[y])), t[2], 
                            sizeof(*t[2]) * 98 * 2);
        }

        sp_4096_mont_reduce_98(t[0], m, mp);
        n = sp_4096_cmp_98(t[0], m);
        sp_4096_cond_sub_98(t[0], t[0], m, ((n < 0) ?
                    (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, t[0], sizeof(*r) * 98 * 2);
    }

#ifdef WOLFSSL_SMALL_STACK
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#else
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[(32 * 196) + 196];
#endif
    sp_digit* t[32];
    sp_digit* rt = NULL;
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * ((32 * 196) + 196), NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
        for (i=0; i<32; i++)
            t[i] = td + i * 196;
        rt = td + 6272;
#else
        for (i=0; i<32; i++)
            t[i] = &td[i * 196];
        rt = &td[6272];
#endif

        sp_4096_mont_setup(m, &mp);
        sp_4096_mont_norm_98(norm, m);

        if (reduceA != 0) {
            err = sp_4096_mod_98(t[1], a, m);
            if (err == MP_OKAY) {
                sp_4096_mul_98(t[1], t[1], norm);
                err = sp_4096_mod_98(t[1], t[1], m);
            }
        }
        else {
            sp_4096_mul_98(t[1], a, norm);
            err = sp_4096_mod_98(t[1], t[1], m);
        }
    }

    if (err == MP_OKAY) {
        sp_4096_mont_sqr_98(t[ 2], t[ 1], m, mp);
        sp_4096_mont_mul_98(t[ 3], t[ 2], t[ 1], m, mp);
        sp_4096_mont_sqr_98(t[ 4], t[ 2], m, mp);
        sp_4096_mont_mul_98(t[ 5], t[ 3], t[ 2], m, mp);
        sp_4096_mont_sqr_98(t[ 6], t[ 3], m, mp);
        sp_4096_mont_mul_98(t[ 7], t[ 4], t[ 3], m, mp);
        sp_4096_mont_sqr_98(t[ 8], t[ 4], m, mp);
        sp_4096_mont_mul_98(t[ 9], t[ 5], t[ 4], m, mp);
        sp_4096_mont_sqr_98(t[10], t[ 5], m, mp);
        sp_4096_mont_mul_98(t[11], t[ 6], t[ 5], m, mp);
        sp_4096_mont_sqr_98(t[12], t[ 6], m, mp);
        sp_4096_mont_mul_98(t[13], t[ 7], t[ 6], m, mp);
        sp_4096_mont_sqr_98(t[14], t[ 7], m, mp);
        sp_4096_mont_mul_98(t[15], t[ 8], t[ 7], m, mp);
        sp_4096_mont_sqr_98(t[16], t[ 8], m, mp);
        sp_4096_mont_mul_98(t[17], t[ 9], t[ 8], m, mp);
        sp_4096_mont_sqr_98(t[18], t[ 9], m, mp);
        sp_4096_mont_mul_98(t[19], t[10], t[ 9], m, mp);
        sp_4096_mont_sqr_98(t[20], t[10], m, mp);
        sp_4096_mont_mul_98(t[21], t[11], t[10], m, mp);
        sp_4096_mont_sqr_98(t[22], t[11], m, mp);
        sp_4096_mont_mul_98(t[23], t[12], t[11], m, mp);
        sp_4096_mont_sqr_98(t[24], t[12], m, mp);
        sp_4096_mont_mul_98(t[25], t[13], t[12], m, mp);
        sp_4096_mont_sqr_98(t[26], t[13], m, mp);
        sp_4096_mont_mul_98(t[27], t[14], t[13], m, mp);
        sp_4096_mont_sqr_98(t[28], t[14], m, mp);
        sp_4096_mont_mul_98(t[29], t[15], t[14], m, mp);
        sp_4096_mont_sqr_98(t[30], t[15], m, mp);
        sp_4096_mont_mul_98(t[31], t[16], t[15], m, mp);

        bits = ((bits + 4) / 5) * 5;
        i = ((bits + 20) / 21) - 1;
        c = bits % 21;
        if (c == 0) {
            c = 21;
        }
        if (i < 98) {
            n = e[i--] << (32 - c);
        }
        else {
            n = 0;
            i--;
        }
        if (c < 5) {
            n |= e[i--] << (11 - c);
            c += 21;
        }
        y = (n >> 27) & 0x1f;
        n <<= 5;
        c -= 5;
        XMEMCPY(rt, t[y], sizeof(sp_digit) * 196);
        while ((i >= 0) || (c >= 5)) {
            if (c < 5) {
                n |= e[i--] << (11 - c);
                c += 21;
            }
            y = (n >> 27) & 0x1f;
            n <<= 5;
            c -= 5;

            sp_4096_mont_sqr_98(rt, rt, m, mp);
            sp_4096_mont_sqr_98(rt, rt, m, mp);
            sp_4096_mont_sqr_98(rt, rt, m, mp);
            sp_4096_mont_sqr_98(rt, rt, m, mp);
            sp_4096_mont_sqr_98(rt, rt, m, mp);

            sp_4096_mont_mul_98(rt, rt, t[y], m, mp);
        }

        sp_4096_mont_reduce_98(rt, m, mp);
        n = sp_4096_cmp_98(rt, m);
        sp_4096_cond_sub_98(rt, rt, m, ((n < 0) ?
                   (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, rt, sizeof(sp_digit) * 196);
    }

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#endif
}

#endif /* WOLFSSL_HAVE_SP_RSA & !SP_RSA_PRIVATE_EXP_D */
#endif /* (WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH) & !WOLFSSL_RSA_PUBLIC_ONLY */

/* r = 2^n mod m where n is the number of bits to reduce by.
 * Given m must be 4096 bits, just need to subtract.
 *
 * r  A single precision number.
 * m  A single precision number.
 */
static void sp_4096_mont_norm_196(sp_digit* r, const sp_digit* m)
{
    /* Set r = 2^n - 1. */
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=0; i<195; i++) {
        r[i] = 0x1fffff;
    }
#else
    int i;

    for (i = 0; i < 192; i += 8) {
        r[i + 0] = 0x1fffff;
        r[i + 1] = 0x1fffff;
        r[i + 2] = 0x1fffff;
        r[i + 3] = 0x1fffff;
        r[i + 4] = 0x1fffff;
        r[i + 5] = 0x1fffff;
        r[i + 6] = 0x1fffff;
        r[i + 7] = 0x1fffff;
    }
    r[192] = 0x1fffff;
    r[193] = 0x1fffff;
    r[194] = 0x1fffff;
#endif
    r[195] = 0x1L;

    /* r = (2^n - 1) mod n */
    (void)sp_4096_sub_196(r, r, m);

    /* Add one so r = 2^n mod m */
    r[0] += 1;
}

/* Compare a with b in constant time.
 *
 * a  A single precision integer.
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
static sp_digit sp_4096_cmp_196(const sp_digit* a, const sp_digit* b)
{
    sp_digit r = 0;
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=195; i>=0; i--) {
        r |= (a[i] - b[i]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#else
    int i;

    r |= (a[195] - b[195]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[194] - b[194]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[193] - b[193]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[192] - b[192]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    for (i = 184; i >= 0; i -= 8) {
        r |= (a[i + 7] - b[i + 7]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 6] - b[i + 6]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 5] - b[i + 5]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 4] - b[i + 4]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 3] - b[i + 3]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 2] - b[i + 2]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 1] - b[i + 1]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 0] - b[i + 0]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#endif /* WOLFSSL_SP_SMALL */

    return r;
}

/* Conditionally subtract b from a using the mask m.
 * m is -1 to subtract and 0 when not.
 *
 * r  A single precision number representing condition subtract result.
 * a  A single precision number to subtract from.
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
static void sp_4096_cond_sub_196(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 196; i++) {
        r[i] = a[i] - (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 192; i += 8) {
        r[i + 0] = a[i + 0] - (b[i + 0] & m);
        r[i + 1] = a[i + 1] - (b[i + 1] & m);
        r[i + 2] = a[i + 2] - (b[i + 2] & m);
        r[i + 3] = a[i + 3] - (b[i + 3] & m);
        r[i + 4] = a[i + 4] - (b[i + 4] & m);
        r[i + 5] = a[i + 5] - (b[i + 5] & m);
        r[i + 6] = a[i + 6] - (b[i + 6] & m);
        r[i + 7] = a[i + 7] - (b[i + 7] & m);
    }
    r[192] = a[192] - (b[192] & m);
    r[193] = a[193] - (b[193] & m);
    r[194] = a[194] - (b[194] & m);
    r[195] = a[195] - (b[195] & m);
#endif /* WOLFSSL_SP_SMALL */
}

/* Mul a by scalar b and add into r. (r += a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_4096_mul_add_196(sp_digit* r, const sp_digit* a,
        const sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 196; i++) {
        t += (tb * a[i]) + r[i];
        r[i] = t & 0x1fffff;
        t >>= 21;
    }
    r[196] += t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] += (sp_digit)(t[0] & 0x1fffff);
    for (i = 0; i < 192; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] += (sp_digit)((t[0] >> 21) + (t[1] & 0x1fffff));
        t[2] = tb * a[i+2];
        r[i+2] += (sp_digit)((t[1] >> 21) + (t[2] & 0x1fffff));
        t[3] = tb * a[i+3];
        r[i+3] += (sp_digit)((t[2] >> 21) + (t[3] & 0x1fffff));
        t[4] = tb * a[i+4];
        r[i+4] += (sp_digit)((t[3] >> 21) + (t[4] & 0x1fffff));
        t[5] = tb * a[i+5];
        r[i+5] += (sp_digit)((t[4] >> 21) + (t[5] & 0x1fffff));
        t[6] = tb * a[i+6];
        r[i+6] += (sp_digit)((t[5] >> 21) + (t[6] & 0x1fffff));
        t[7] = tb * a[i+7];
        r[i+7] += (sp_digit)((t[6] >> 21) + (t[7] & 0x1fffff));
        t[0] = tb * a[i+8];
        r[i+8] += (sp_digit)((t[7] >> 21) + (t[0] & 0x1fffff));
    }
    t[1] = tb * a[193]; r[193] += (sp_digit)((t[0] >> 21) + (t[1] & 0x1fffff));
    t[2] = tb * a[194]; r[194] += (sp_digit)((t[1] >> 21) + (t[2] & 0x1fffff));
    t[3] = tb * a[195]; r[195] += (sp_digit)((t[2] >> 21) + (t[3] & 0x1fffff));
    r[196] +=  (sp_digit)(t[3] >> 21);
#endif /* WOLFSSL_SP_SMALL */
}

/* Normalize the values in each word to 21.
 *
 * a  Array of sp_digit to normalize.
 */
static void sp_4096_norm_196(sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    for (i = 0; i < 195; i++) {
        a[i+1] += a[i] >> 21;
        a[i] &= 0x1fffff;
    }
#else
    int i;
    for (i = 0; i < 192; i += 8) {
        a[i+1] += a[i+0] >> 21; a[i+0] &= 0x1fffff;
        a[i+2] += a[i+1] >> 21; a[i+1] &= 0x1fffff;
        a[i+3] += a[i+2] >> 21; a[i+2] &= 0x1fffff;
        a[i+4] += a[i+3] >> 21; a[i+3] &= 0x1fffff;
        a[i+5] += a[i+4] >> 21; a[i+4] &= 0x1fffff;
        a[i+6] += a[i+5] >> 21; a[i+5] &= 0x1fffff;
        a[i+7] += a[i+6] >> 21; a[i+6] &= 0x1fffff;
        a[i+8] += a[i+7] >> 21; a[i+7] &= 0x1fffff;
        a[i+9] += a[i+8] >> 21; a[i+8] &= 0x1fffff;
    }
    a[192+1] += a[192] >> 21;
    a[192] &= 0x1fffff;
    a[193+1] += a[193] >> 21;
    a[193] &= 0x1fffff;
    a[194+1] += a[194] >> 21;
    a[194] &= 0x1fffff;
#endif
}

/* Shift the result in the high 4096 bits down to the bottom.
 *
 * r  A single precision number.
 * a  A single precision number.
 */
static void sp_4096_mont_shift_196(sp_digit* r, const sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    int64_t n = a[195] >> 1;
    n += ((int64_t)a[196]) << 20;

    for (i = 0; i < 195; i++) {
        r[i] = n & 0x1fffff;
        n >>= 21;
        n += ((int64_t)a[197 + i]) << 20;
    }
    r[195] = (sp_digit)n;
#else
    int i;
    int64_t n = a[195] >> 1;
    n += ((int64_t)a[196]) << 20;
    for (i = 0; i < 192; i += 8) {
        r[i + 0] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 197]) << 20;
        r[i + 1] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 198]) << 20;
        r[i + 2] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 199]) << 20;
        r[i + 3] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 200]) << 20;
        r[i + 4] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 201]) << 20;
        r[i + 5] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 202]) << 20;
        r[i + 6] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 203]) << 20;
        r[i + 7] = n & 0x1fffff;
        n >>= 21; n += ((int64_t)a[i + 204]) << 20;
    }
    r[192] = n & 0x1fffff; n >>= 21; n += ((int64_t)a[389]) << 20;
    r[193] = n & 0x1fffff; n >>= 21; n += ((int64_t)a[390]) << 20;
    r[194] = n & 0x1fffff; n >>= 21; n += ((int64_t)a[391]) << 20;
    r[195] = (sp_digit)n;
#endif /* WOLFSSL_SP_SMALL */
    XMEMSET(&r[196], 0, sizeof(*r) * 196U);
}

/* Reduce the number back to 4096 bits using Montgomery reduction.
 *
 * a   A single precision number to reduce in place.
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
static void sp_4096_mont_reduce_196(sp_digit* a, const sp_digit* m, sp_digit mp)
{
    int i;
    sp_digit mu;

    sp_4096_norm_196(a + 196);

#ifdef WOLFSSL_SP_DH
    if (mp != 1) {
        for (i=0; i<195; i++) {
            mu = (a[i] * mp) & 0x1fffff;
            sp_4096_mul_add_196(a+i, m, mu);
            a[i+1] += a[i] >> 21;
        }
        mu = (a[i] * mp) & 0x1L;
        sp_4096_mul_add_196(a+i, m, mu);
        a[i+1] += a[i] >> 21;
        a[i] &= 0x1fffff;
    }
    else {
        for (i=0; i<195; i++) {
            mu = a[i] & 0x1fffff;
            sp_4096_mul_add_196(a+i, m, mu);
            a[i+1] += a[i] >> 21;
        }
        mu = a[i] & 0x1L;
        sp_4096_mul_add_196(a+i, m, mu);
        a[i+1] += a[i] >> 21;
        a[i] &= 0x1fffff;
    }
#else
    for (i=0; i<195; i++) {
        mu = (a[i] * mp) & 0x1fffff;
        sp_4096_mul_add_196(a+i, m, mu);
        a[i+1] += a[i] >> 21;
    }
    mu = (a[i] * mp) & 0x1L;
    sp_4096_mul_add_196(a+i, m, mu);
    a[i+1] += a[i] >> 21;
    a[i] &= 0x1fffff;
#endif

    sp_4096_mont_shift_196(a, a);
    sp_4096_cond_sub_196(a, a, m, 0 - (((a[195] >> 1) > 0) ?
            (sp_digit)1 : (sp_digit)0));
    sp_4096_norm_196(a);
}

/* Multiply two Montogmery form numbers mod the modulus (prime).
 * (r = a * b mod m)
 *
 * r   Result of multiplication.
 * a   First number to multiply in Montogmery form.
 * b   Second number to multiply in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_4096_mont_mul_196(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit* m, sp_digit mp)
{
    sp_4096_mul_196(r, a, b);
    sp_4096_mont_reduce_196(r, m, mp);
}

/* Square the Montgomery form number. (r = a * a mod m)
 *
 * r   Result of squaring.
 * a   Number to square in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_4096_mont_sqr_196(sp_digit* r, const sp_digit* a,
        const sp_digit* m, sp_digit mp)
{
    sp_4096_sqr_196(r, a);
    sp_4096_mont_reduce_196(r, m, mp);
}

/* Multiply a by scalar b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_4096_mul_d_392(sp_digit* r, const sp_digit* a,
    sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 392; i++) {
        t += tb * a[i];
        r[i] = t & 0x1fffff;
        t >>= 21;
    }
    r[392] = (sp_digit)t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] = t[0] & 0x1fffff;
    for (i = 0; i < 392; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] = (sp_digit)(t[0] >> 21) + (t[1] & 0x1fffff);
        t[2] = tb * a[i+2];
        r[i+2] = (sp_digit)(t[1] >> 21) + (t[2] & 0x1fffff);
        t[3] = tb * a[i+3];
        r[i+3] = (sp_digit)(t[2] >> 21) + (t[3] & 0x1fffff);
        t[4] = tb * a[i+4];
        r[i+4] = (sp_digit)(t[3] >> 21) + (t[4] & 0x1fffff);
        t[5] = tb * a[i+5];
        r[i+5] = (sp_digit)(t[4] >> 21) + (t[5] & 0x1fffff);
        t[6] = tb * a[i+6];
        r[i+6] = (sp_digit)(t[5] >> 21) + (t[6] & 0x1fffff);
        t[7] = tb * a[i+7];
        r[i+7] = (sp_digit)(t[6] >> 21) + (t[7] & 0x1fffff);
        t[0] = tb * a[i+8];
        r[i+8] = (sp_digit)(t[7] >> 21) + (t[0] & 0x1fffff);
    }
    r[392] =  (sp_digit)(t[7] >> 21);
#endif /* WOLFSSL_SP_SMALL */
}

/* Conditionally add a and b using the mask m.
 * m is -1 to add and 0 when not.
 *
 * r  A single precision number representing conditional add result.
 * a  A single precision number to add with.
 * b  A single precision number to add.
 * m  Mask value to apply.
 */
static void sp_4096_cond_add_196(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 196; i++) {
        r[i] = a[i] + (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 192; i += 8) {
        r[i + 0] = a[i + 0] + (b[i + 0] & m);
        r[i + 1] = a[i + 1] + (b[i + 1] & m);
        r[i + 2] = a[i + 2] + (b[i + 2] & m);
        r[i + 3] = a[i + 3] + (b[i + 3] & m);
        r[i + 4] = a[i + 4] + (b[i + 4] & m);
        r[i + 5] = a[i + 5] + (b[i + 5] & m);
        r[i + 6] = a[i + 6] + (b[i + 6] & m);
        r[i + 7] = a[i + 7] + (b[i + 7] & m);
    }
    r[192] = a[192] + (b[192] & m);
    r[193] = a[193] + (b[193] & m);
    r[194] = a[194] + (b[194] & m);
    r[195] = a[195] + (b[195] & m);
#endif /* WOLFSSL_SP_SMALL */
}

#ifdef WOLFSSL_SP_SMALL
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_4096_sub_196(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 196; i++) {
        r[i] = a[i] - b[i];
    }

    return 0;
}

#endif
#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_4096_add_196(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 196; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#endif
SP_NOINLINE static void sp_4096_rshift_196(sp_digit* r, const sp_digit* a,
        byte n)
{
    int i;

#ifdef WOLFSSL_SP_SMALL
    for (i=0; i<195; i++) {
        r[i] = ((a[i] >> n) | (a[i + 1] << (21 - n))) & 0x1fffff;
    }
#else
    for (i=0; i<192; i += 8) {
        r[i+0] = ((a[i+0] >> n) | (a[i+1] << (21 - n))) & 0x1fffff;
        r[i+1] = ((a[i+1] >> n) | (a[i+2] << (21 - n))) & 0x1fffff;
        r[i+2] = ((a[i+2] >> n) | (a[i+3] << (21 - n))) & 0x1fffff;
        r[i+3] = ((a[i+3] >> n) | (a[i+4] << (21 - n))) & 0x1fffff;
        r[i+4] = ((a[i+4] >> n) | (a[i+5] << (21 - n))) & 0x1fffff;
        r[i+5] = ((a[i+5] >> n) | (a[i+6] << (21 - n))) & 0x1fffff;
        r[i+6] = ((a[i+6] >> n) | (a[i+7] << (21 - n))) & 0x1fffff;
        r[i+7] = ((a[i+7] >> n) | (a[i+8] << (21 - n))) & 0x1fffff;
    }
    r[192] = ((a[192] >> n) | (a[193] << (21 - n))) & 0x1fffff;
    r[193] = ((a[193] >> n) | (a[194] << (21 - n))) & 0x1fffff;
    r[194] = ((a[194] >> n) | (a[195] << (21 - n))) & 0x1fffff;
#endif
    r[195] = a[195] >> n;
}

#ifdef WOLFSSL_SP_DIV_32
static WC_INLINE sp_digit sp_4096_div_word_196(sp_digit d1, sp_digit d0,
    sp_digit dv)
{
    sp_digit d;
    sp_digit r;
    sp_digit t;

    /* All 21 bits from d1 and top 10 bits from d0. */
    d = (d1 << 10) | (d0 >> 11);
    r = d / dv;
    d -= r * dv;
    /* Up to 11 bits in r */
    /* Next 10 bits from d0. */
    r <<= 10;
    d <<= 10;
    d |= (d0 >> 1) & ((1 << 10) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 21 bits in r */
    /* Remaining 1 bits from d0. */
    r <<= 1;
    d <<= 1;
    d |= d0 & ((1 << 1) - 1);
    t = d / dv;
    r += t;

    return r;
}
#endif /* WOLFSSL_SP_DIV_32 */

/* Divide d in a and put remainder into r (m*d + r = a)
 * m is not calculated as it is not needed at this time.
 *
 * a  Nmber to be divided.
 * d  Number to divide with.
 * m  Multiplier result.
 * r  Remainder from the division.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_4096_div_196(const sp_digit* a, const sp_digit* d,
        const sp_digit* m, sp_digit* r)
{
    int i;
#ifndef WOLFSSL_SP_DIV_32
    int64_t d1;
#endif
    sp_digit dv;
    sp_digit r1;
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit t1d[392 + 1];
    sp_digit t2d[196 + 1];
    sp_digit sdd[196 + 1];
#endif
    sp_digit* t1;
    sp_digit* t2;
    sp_digit* sd;
    int err = MP_OKAY;

    (void)m;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * (4 * 196 + 3), NULL,
                                                       DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    (void)m;

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t1 = td;
        t2 = td + 392 + 1;
        sd = t2 + 196 + 1;
#else
        t1 = t1d;
        t2 = t2d;
        sd = sdd;
#endif

        sp_4096_mul_d_196(sd, d, 1L << 20);
        sp_4096_mul_d_392(t1, a, 1L << 20);
        dv = sd[195];
        for (i=196; i>=0; i--) {
            t1[196 + i] += t1[196 + i - 1] >> 21;
            t1[196 + i - 1] &= 0x1fffff;
#ifndef WOLFSSL_SP_DIV_32
            d1 = t1[196 + i];
            d1 <<= 21;
            d1 += t1[196 + i - 1];
            r1 = (sp_digit)(d1 / dv);
#else
            r1 = sp_4096_div_word_196(t1[196 + i], t1[196 + i - 1], dv);
#endif

            sp_4096_mul_d_196(t2, sd, r1);
            (void)sp_4096_sub_196(&t1[i], &t1[i], t2);
            t1[196 + i] -= t2[196];
            t1[196 + i] += t1[196 + i - 1] >> 21;
            t1[196 + i - 1] &= 0x1fffff;
            r1 = (((-t1[196 + i]) << 21) - t1[196 + i - 1]) / dv;
            r1 -= t1[196 + i];
            sp_4096_mul_d_196(t2, sd, r1);
            (void)sp_4096_add_196(&t1[i], &t1[i], t2);
            t1[196 + i] += t1[196 + i - 1] >> 21;
            t1[196 + i - 1] &= 0x1fffff;
        }
        t1[196 - 1] += t1[196 - 2] >> 21;
        t1[196 - 2] &= 0x1fffff;
        r1 = t1[196 - 1] / dv;

        sp_4096_mul_d_196(t2, sd, r1);
        sp_4096_sub_196(t1, t1, t2);
        XMEMCPY(r, t1, sizeof(*r) * 2U * 196U);
        for (i=0; i<195; i++) {
            r[i+1] += r[i] >> 21;
            r[i] &= 0x1fffff;
        }
        sp_4096_cond_add_196(r, r, sd, 0 - ((r[195] < 0) ?
                    (sp_digit)1 : (sp_digit)0));

        sp_4096_norm_196(r);
        sp_4096_rshift_196(r, r, 20);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
}

/* Reduce a modulo m into r. (r = a mod m)
 *
 * r  A single precision number that is the reduced result.
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_4096_mod_196(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    return sp_4096_div_196(a, m, NULL, r);
}

#if (defined(WOLFSSL_HAVE_SP_RSA) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)) || \
                                                     defined(WOLFSSL_HAVE_SP_DH)
/* Modular exponentiate a to the e mod m. (r = a^e mod m)
 *
 * r     A single precision number that is the result of the operation.
 * a     A single precision number being exponentiated.
 * e     A single precision number that is the exponent.
 * bits  The number of bits in the exponent.
 * m     A single precision number that is the modulus.
 * returns 0 on success and MEMORY_E on dynamic memory allocation failure.
 */
static int sp_4096_mod_exp_196(sp_digit* r, const sp_digit* a, const sp_digit* e, int bits,
    const sp_digit* m, int reduceA)
{
#ifdef WOLFSSL_SP_SMALL
#if !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[3 * 392];
#endif
    sp_digit* t[3];
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 3 * 196 * 2, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
        for (i=0; i<3; i++) {
#if !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + (i * 196 * 2);
#else
            t[i] = &td[i * 196 * 2];
#endif
            XMEMSET(t[i], 0, sizeof(sp_digit) * 196U * 2U);
        }

        sp_4096_mont_setup(m, &mp);
        sp_4096_mont_norm_196(norm, m);

        if (reduceA != 0) {
            err = sp_4096_mod_196(t[1], a, m);
        }
        else {
            XMEMCPY(t[1], a, sizeof(sp_digit) * 196U);
        }
    }
    if (err == MP_OKAY) {
        sp_4096_mul_196(t[1], t[1], norm);
        err = sp_4096_mod_196(t[1], t[1], m);
    }

    if (err == MP_OKAY) {
        i = bits / 21;
        c = bits % 21;
        n = e[i--] << (21 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1) {
                    break;
                }

                n = e[i--];
                c = 21;
            }

            y = (n >> 20) & 1;
            n <<= 1;

            sp_4096_mont_mul_196(t[y^1], t[0], t[1], m, mp);

            XMEMCPY(t[2], (void*)(((size_t)t[0] & addr_mask[y^1]) +
                                  ((size_t)t[1] & addr_mask[y])),
                                  sizeof(*t[2]) * 196 * 2);
            sp_4096_mont_sqr_196(t[2], t[2], m, mp);
            XMEMCPY((void*)(((size_t)t[0] & addr_mask[y^1]) +
                            ((size_t)t[1] & addr_mask[y])), t[2],
                            sizeof(*t[2]) * 196 * 2);
        }

        sp_4096_mont_reduce_196(t[0], m, mp);
        n = sp_4096_cmp_196(t[0], m);
        sp_4096_cond_sub_196(t[0], t[0], m, ((n < 0) ?
                    (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, t[0], sizeof(*r) * 196 * 2);

    }

#if !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#elif defined(WOLFSSL_SP_CACHE_RESISTANT)
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[3 * 392];
#endif
    sp_digit* t[3];
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#ifdef WOLFSSL_SMALL_STACK
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 3 * 196 * 2, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
        for (i=0; i<3; i++) {
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
            t[i] = td + (i * 196 * 2);
#else
            t[i] = &td[i * 196 * 2];
#endif
        }

        sp_4096_mont_setup(m, &mp);
        sp_4096_mont_norm_196(norm, m);

        if (reduceA != 0) {
            err = sp_4096_mod_196(t[1], a, m);
            if (err == MP_OKAY) {
                sp_4096_mul_196(t[1], t[1], norm);
                err = sp_4096_mod_196(t[1], t[1], m);
            }
        }
        else {
            sp_4096_mul_196(t[1], a, norm);
            err = sp_4096_mod_196(t[1], t[1], m);
        }
    }

    if (err == MP_OKAY) {
        i = bits / 21;
        c = bits % 21;
        n = e[i--] << (21 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1) {
                    break;
                }

                n = e[i--];
                c = 21;
            }

            y = (n >> 20) & 1;
            n <<= 1;

            sp_4096_mont_mul_196(t[y^1], t[0], t[1], m, mp);

            XMEMCPY(t[2], (void*)(((size_t)t[0] & addr_mask[y^1]) +
                                  ((size_t)t[1] & addr_mask[y])), 
                                  sizeof(*t[2]) * 196 * 2);
            sp_4096_mont_sqr_196(t[2], t[2], m, mp);
            XMEMCPY((void*)(((size_t)t[0] & addr_mask[y^1]) +
                            ((size_t)t[1] & addr_mask[y])), t[2], 
                            sizeof(*t[2]) * 196 * 2);
        }

        sp_4096_mont_reduce_196(t[0], m, mp);
        n = sp_4096_cmp_196(t[0], m);
        sp_4096_cond_sub_196(t[0], t[0], m, ((n < 0) ?
                    (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, t[0], sizeof(*r) * 196 * 2);
    }

#ifdef WOLFSSL_SMALL_STACK
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#else
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[(32 * 392) + 392];
#endif
    sp_digit* t[32];
    sp_digit* rt = NULL;
    sp_digit* norm;
    sp_digit mp = 1;
    sp_digit n;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * ((32 * 392) + 392), NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
        for (i=0; i<32; i++)
            t[i] = td + i * 392;
        rt = td + 12544;
#else
        for (i=0; i<32; i++)
            t[i] = &td[i * 392];
        rt = &td[12544];
#endif

        sp_4096_mont_setup(m, &mp);
        sp_4096_mont_norm_196(norm, m);

        if (reduceA != 0) {
            err = sp_4096_mod_196(t[1], a, m);
            if (err == MP_OKAY) {
                sp_4096_mul_196(t[1], t[1], norm);
                err = sp_4096_mod_196(t[1], t[1], m);
            }
        }
        else {
            sp_4096_mul_196(t[1], a, norm);
            err = sp_4096_mod_196(t[1], t[1], m);
        }
    }

    if (err == MP_OKAY) {
        sp_4096_mont_sqr_196(t[ 2], t[ 1], m, mp);
        sp_4096_mont_mul_196(t[ 3], t[ 2], t[ 1], m, mp);
        sp_4096_mont_sqr_196(t[ 4], t[ 2], m, mp);
        sp_4096_mont_mul_196(t[ 5], t[ 3], t[ 2], m, mp);
        sp_4096_mont_sqr_196(t[ 6], t[ 3], m, mp);
        sp_4096_mont_mul_196(t[ 7], t[ 4], t[ 3], m, mp);
        sp_4096_mont_sqr_196(t[ 8], t[ 4], m, mp);
        sp_4096_mont_mul_196(t[ 9], t[ 5], t[ 4], m, mp);
        sp_4096_mont_sqr_196(t[10], t[ 5], m, mp);
        sp_4096_mont_mul_196(t[11], t[ 6], t[ 5], m, mp);
        sp_4096_mont_sqr_196(t[12], t[ 6], m, mp);
        sp_4096_mont_mul_196(t[13], t[ 7], t[ 6], m, mp);
        sp_4096_mont_sqr_196(t[14], t[ 7], m, mp);
        sp_4096_mont_mul_196(t[15], t[ 8], t[ 7], m, mp);
        sp_4096_mont_sqr_196(t[16], t[ 8], m, mp);
        sp_4096_mont_mul_196(t[17], t[ 9], t[ 8], m, mp);
        sp_4096_mont_sqr_196(t[18], t[ 9], m, mp);
        sp_4096_mont_mul_196(t[19], t[10], t[ 9], m, mp);
        sp_4096_mont_sqr_196(t[20], t[10], m, mp);
        sp_4096_mont_mul_196(t[21], t[11], t[10], m, mp);
        sp_4096_mont_sqr_196(t[22], t[11], m, mp);
        sp_4096_mont_mul_196(t[23], t[12], t[11], m, mp);
        sp_4096_mont_sqr_196(t[24], t[12], m, mp);
        sp_4096_mont_mul_196(t[25], t[13], t[12], m, mp);
        sp_4096_mont_sqr_196(t[26], t[13], m, mp);
        sp_4096_mont_mul_196(t[27], t[14], t[13], m, mp);
        sp_4096_mont_sqr_196(t[28], t[14], m, mp);
        sp_4096_mont_mul_196(t[29], t[15], t[14], m, mp);
        sp_4096_mont_sqr_196(t[30], t[15], m, mp);
        sp_4096_mont_mul_196(t[31], t[16], t[15], m, mp);

        bits = ((bits + 4) / 5) * 5;
        i = ((bits + 20) / 21) - 1;
        c = bits % 21;
        if (c == 0) {
            c = 21;
        }
        if (i < 196) {
            n = e[i--] << (32 - c);
        }
        else {
            n = 0;
            i--;
        }
        if (c < 5) {
            n |= e[i--] << (11 - c);
            c += 21;
        }
        y = (n >> 27) & 0x1f;
        n <<= 5;
        c -= 5;
        XMEMCPY(rt, t[y], sizeof(sp_digit) * 392);
        while ((i >= 0) || (c >= 5)) {
            if (c < 5) {
                n |= e[i--] << (11 - c);
                c += 21;
            }
            y = (n >> 27) & 0x1f;
            n <<= 5;
            c -= 5;

            sp_4096_mont_sqr_196(rt, rt, m, mp);
            sp_4096_mont_sqr_196(rt, rt, m, mp);
            sp_4096_mont_sqr_196(rt, rt, m, mp);
            sp_4096_mont_sqr_196(rt, rt, m, mp);
            sp_4096_mont_sqr_196(rt, rt, m, mp);

            sp_4096_mont_mul_196(rt, rt, t[y], m, mp);
        }

        sp_4096_mont_reduce_196(rt, m, mp);
        n = sp_4096_cmp_196(rt, m);
        sp_4096_cond_sub_196(rt, rt, m, ((n < 0) ?
                   (sp_digit)1 : (sp_digit)0) - 1);
        XMEMCPY(r, rt, sizeof(sp_digit) * 392);
    }

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
#endif
}
#endif /* (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) | */
       /* WOLFSSL_HAVE_SP_DH */

#ifdef WOLFSSL_HAVE_SP_RSA
/* RSA public key operation.
 *
 * in      Array of bytes representing the number to exponentiate, base.
 * inLen   Number of bytes in base.
 * em      Public exponent.
 * mm      Modulus.
 * out     Buffer to hold big-endian bytes of exponentiation result.
 *         Must be at least 512 bytes long.
 * outLen  Number of bytes in result.
 * returns 0 on success, MP_TO_E when the outLen is too small, MP_READ_E when
 * an array is too long and MEMORY_E when dynamic memory allocation fails.
 */
int sp_RsaPublic_4096(const byte* in, word32 inLen, const mp_int* em,
    const mp_int* mm, byte* out, word32* outLen)
{
#ifdef WOLFSSL_SP_SMALL
    sp_digit* d = NULL;
    sp_digit* a = NULL;
    sp_digit* m = NULL;
    sp_digit* r = NULL;
    sp_digit* norm = NULL;
    sp_digit e[1] = {0};
    sp_digit mp;
    int i;
    int err = MP_OKAY;

    if (*outLen < 512U) {
        err = MP_TO_E;
    }

    if (err == MP_OKAY) {
        if (mp_count_bits(em) > 21) {
            err = MP_READ_E;
        }
        if (inLen > 512U) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 4096) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 196 * 5, NULL,
                                                              DYNAMIC_TYPE_RSA);
        if (d == NULL)
            err = MEMORY_E;
    }

    if (err == MP_OKAY) {
        a = d;
        r = a + 196 * 2;
        m = r + 196 * 2;
        norm = r;

        sp_4096_from_bin(a, 196, in, inLen);
#if DIGIT_BIT >= 21
        e[0] = (sp_digit)em->dp[0];
#else
        e[0] = (sp_digit)em->dp[0];
        if (em->used > 1) {
            e[0] |= ((sp_digit)em->dp[1]) << DIGIT_BIT;
        }
#endif
        if (e[0] == 0) {
            err = MP_EXPTMOD_E;
        }
    }

    if (err == MP_OKAY) {
        sp_4096_from_mp(m, 196, mm);

        sp_4096_mont_setup(m, &mp);
        sp_4096_mont_norm_196(norm, m);
    }
    if (err == MP_OKAY) {
        sp_4096_mul_196(a, a, norm);
        err = sp_4096_mod_196(a, a, m);
    }
    if (err == MP_OKAY) {
        for (i=20; i>=0; i--) {
            if ((e[0] >> i) != 0) {
                break;
            }
        }

        XMEMCPY(r, a, sizeof(sp_digit) * 196 * 2);
        for (i--; i>=0; i--) {
            sp_4096_mont_sqr_196(r, r, m, mp);

            if (((e[0] >> i) & 1) == 1) {
                sp_4096_mont_mul_196(r, r, a, m, mp);
            }
        }
        sp_4096_mont_reduce_196(r, m, mp);
        mp = sp_4096_cmp_196(r, m);
        sp_4096_cond_sub_196(r, r, m, ((mp < 0) ?
                    (sp_digit)1 : (sp_digit)0)- 1);

        sp_4096_to_bin(r, out);
        *outLen = 512;
    }

    if (d != NULL) {
        XFREE(d, NULL, DYNAMIC_TYPE_RSA);
    }

    return err;
#else
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit ad[392];
    sp_digit md[196];
    sp_digit rd[392];
#else
    sp_digit* d = NULL;
#endif
    sp_digit* a = NULL;
    sp_digit* m = NULL;
    sp_digit* r = NULL;
    sp_digit e[1] = {0};
    int err = MP_OKAY;

    if (*outLen < 512U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (mp_count_bits(em) > 21) {
            err = MP_READ_E;
        }
        if (inLen > 512U) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 4096) {
            err = MP_READ_E;
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 196 * 5, NULL,
                                                              DYNAMIC_TYPE_RSA);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }

    if (err == MP_OKAY) {
        a = d;
        r = a + 196 * 2;
        m = r + 196 * 2;
    }
#else
    a = ad;
    m = md;
    r = rd;
#endif

    if (err == MP_OKAY) {
        sp_4096_from_bin(a, 196, in, inLen);
#if DIGIT_BIT >= 21
        e[0] = (sp_digit)em->dp[0];
#else
        e[0] = (sp_digit)em->dp[0];
        if (em->used > 1) {
            e[0] |= ((sp_digit)em->dp[1]) << DIGIT_BIT;
        }
#endif
        if (e[0] == 0) {
            err = MP_EXPTMOD_E;
        }
    }
    if (err == MP_OKAY) {
        sp_4096_from_mp(m, 196, mm);

        if (e[0] == 0x3) {
            sp_4096_sqr_196(r, a);
            err = sp_4096_mod_196(r, r, m);
            if (err == MP_OKAY) {
                sp_4096_mul_196(r, a, r);
                err = sp_4096_mod_196(r, r, m);
            }
        }
        else {
            sp_digit* norm = r;
            int i;
            sp_digit mp;

            sp_4096_mont_setup(m, &mp);
            sp_4096_mont_norm_196(norm, m);

            sp_4096_mul_196(a, a, norm);
            err = sp_4096_mod_196(a, a, m);

            if (err == MP_OKAY) {
                for (i=20; i>=0; i--) {
                    if ((e[0] >> i) != 0) {
                        break;
                    }
                }

                XMEMCPY(r, a, sizeof(sp_digit) * 392U);
                for (i--; i>=0; i--) {
                    sp_4096_mont_sqr_196(r, r, m, mp);

                    if (((e[0] >> i) & 1) == 1) {
                        sp_4096_mont_mul_196(r, r, a, m, mp);
                    }
                }
                sp_4096_mont_reduce_196(r, m, mp);
                mp = sp_4096_cmp_196(r, m);
                sp_4096_cond_sub_196(r, r, m, ((mp < 0) ?
                           (sp_digit)1 : (sp_digit)0) - 1);
            }
        }
    }

    if (err == MP_OKAY) {
        sp_4096_to_bin(r, out);
        *outLen = 512;
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL) {
        XFREE(d, NULL, DYNAMIC_TYPE_RSA);
    }
#endif

    return err;
#endif /* WOLFSSL_SP_SMALL */
}

#ifndef WOLFSSL_RSA_PUBLIC_ONLY
#if !defined(SP_RSA_PRIVATE_EXP_D) && !defined(RSA_LOW_MEM)
#endif /* !SP_RSA_PRIVATE_EXP_D & !RSA_LOW_MEM */
/* RSA private key operation.
 *
 * in      Array of bytes representing the number to exponentiate, base.
 * inLen   Number of bytes in base.
 * dm      Private exponent.
 * pm      First prime.
 * qm      Second prime.
 * dpm     First prime's CRT exponent.
 * dqm     Second prime's CRT exponent.
 * qim     Inverse of second prime mod p.
 * mm      Modulus.
 * out     Buffer to hold big-endian bytes of exponentiation result.
 *         Must be at least 512 bytes long.
 * outLen  Number of bytes in result.
 * returns 0 on success, MP_TO_E when the outLen is too small, MP_READ_E when
 * an array is too long and MEMORY_E when dynamic memory allocation fails.
 */
int sp_RsaPrivate_4096(const byte* in, word32 inLen, const mp_int* dm,
    const mp_int* pm, const mp_int* qm, const mp_int* dpm, const mp_int* dqm,
    const mp_int* qim, const mp_int* mm, byte* out, word32* outLen)
{
#if defined(SP_RSA_PRIVATE_EXP_D) || defined(RSA_LOW_MEM)
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* a = NULL;
    sp_digit* d = NULL;
    sp_digit* m = NULL;
    sp_digit* r = NULL;
    int err = MP_OKAY;

    (void)pm;
    (void)qm;
    (void)dpm;
    (void)dqm;
    (void)qim;

    if (*outLen < 512U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (mp_count_bits(dm) > 4096) {
           err = MP_READ_E;
        }
        if (inLen > 512) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 4096) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 196 * 4, NULL,
                                                              DYNAMIC_TYPE_RSA);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }
    if (err == MP_OKAY) {
        a = d + 196;
        m = a + 392;
        r = a;

        sp_4096_from_bin(a, 196, in, inLen);
        sp_4096_from_mp(d, 196, dm);
        sp_4096_from_mp(m, 196, mm);
        err = sp_4096_mod_exp_196(r, a, d, 4096, m, 0);
    }
    if (err == MP_OKAY) {
        sp_4096_to_bin(r, out);
        *outLen = 512;
    }

    if (d != NULL) {
        XMEMSET(d, 0, sizeof(sp_digit) * 196);
        XFREE(d, NULL, DYNAMIC_TYPE_RSA);
    }

    return err;
#else
    sp_digit a[392];
    sp_digit d[196];
    sp_digit m[196];
    sp_digit* r = a;
    int err = MP_OKAY;

    (void)pm;
    (void)qm;
    (void)dpm;
    (void)dqm;
    (void)qim;

    if (*outLen < 512U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (mp_count_bits(dm) > 4096) {
            err = MP_READ_E;
        }
        if (inLen > 512U) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 4096) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        sp_4096_from_bin(a, 196, in, inLen);
        sp_4096_from_mp(d, 196, dm);
        sp_4096_from_mp(m, 196, mm);
        err = sp_4096_mod_exp_196(r, a, d, 4096, m, 0);
    }

    if (err == MP_OKAY) {
        sp_4096_to_bin(r, out);
        *outLen = 512;
    }

    XMEMSET(d, 0, sizeof(sp_digit) * 196);

    return err;
#endif /* WOLFSSL_SP_SMALL | defined(WOLFSSL_SMALL_STACK) */
#else
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* t = NULL;
    sp_digit* a = NULL;
    sp_digit* p = NULL;
    sp_digit* q = NULL;
    sp_digit* dp = NULL;
    sp_digit* dq = NULL;
    sp_digit* qi = NULL;
    sp_digit* tmpa = NULL;
    sp_digit* tmpb = NULL;
    sp_digit* r = NULL;
    int err = MP_OKAY;

    (void)dm;
    (void)mm;

    if (*outLen < 512U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (inLen > 512) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 4096) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        t = (sp_digit*)XMALLOC(sizeof(sp_digit) * 98 * 11, NULL,
                                                              DYNAMIC_TYPE_RSA);
        if (t == NULL) {
            err = MEMORY_E;
        }
    }
    if (err == MP_OKAY) {
        a = t;
        p = a + 196 * 2;
        q = p + 98;
        qi = dq = dp = q + 98;
        tmpa = qi + 98;
        tmpb = tmpa + 196;

        r = t + 196;

        sp_4096_from_bin(a, 196, in, inLen);
        sp_4096_from_mp(p, 98, pm);
        sp_4096_from_mp(q, 98, qm);
        sp_4096_from_mp(dp, 98, dpm);
        err = sp_4096_mod_exp_98(tmpa, a, dp, 2048, p, 1);
    }
    if (err == MP_OKAY) {
        sp_4096_from_mp(dq, 98, dqm);
        err = sp_4096_mod_exp_98(tmpb, a, dq, 2048, q, 1);
    }
    if (err == MP_OKAY) {
        (void)sp_4096_sub_98(tmpa, tmpa, tmpb);
        sp_4096_cond_add_98(tmpa, tmpa, p, 0 - ((sp_int_digit)tmpa[97] >> 31));
        sp_4096_cond_add_98(tmpa, tmpa, p, 0 - ((sp_int_digit)tmpa[97] >> 31));

        sp_4096_from_mp(qi, 98, qim);
        sp_4096_mul_98(tmpa, tmpa, qi);
        err = sp_4096_mod_98(tmpa, tmpa, p);
    }

    if (err == MP_OKAY) {
        sp_4096_mul_98(tmpa, q, tmpa);
        (void)sp_4096_add_196(r, tmpb, tmpa);
        sp_4096_norm_196(r);

        sp_4096_to_bin(r, out);
        *outLen = 512;
    }

    if (t != NULL) {
        XMEMSET(t, 0, sizeof(sp_digit) * 98 * 11);
        XFREE(t, NULL, DYNAMIC_TYPE_RSA);
    }

    return err;
#else
    sp_digit a[196 * 2];
    sp_digit p[98];
    sp_digit q[98];
    sp_digit dp[98];
    sp_digit dq[98];
    sp_digit qi[98];
    sp_digit tmpa[196];
    sp_digit tmpb[196];
    sp_digit* r = a;
    int err = MP_OKAY;

    (void)dm;
    (void)mm;

    if (*outLen < 512U) {
        err = MP_TO_E;
    }
    if (err == MP_OKAY) {
        if (inLen > 512U) {
            err = MP_READ_E;
        }
        if (mp_count_bits(mm) != 4096) {
            err = MP_READ_E;
        }
    }

    if (err == MP_OKAY) {
        sp_4096_from_bin(a, 196, in, inLen);
        sp_4096_from_mp(p, 98, pm);
        sp_4096_from_mp(q, 98, qm);
        sp_4096_from_mp(dp, 98, dpm);
        sp_4096_from_mp(dq, 98, dqm);
        sp_4096_from_mp(qi, 98, qim);

        err = sp_4096_mod_exp_98(tmpa, a, dp, 2048, p, 1);
    }
    if (err == MP_OKAY) {
        err = sp_4096_mod_exp_98(tmpb, a, dq, 2048, q, 1);
    }

    if (err == MP_OKAY) {
        (void)sp_4096_sub_98(tmpa, tmpa, tmpb);
        sp_4096_cond_add_98(tmpa, tmpa, p, 0 - ((sp_int_digit)tmpa[97] >> 31));
        sp_4096_cond_add_98(tmpa, tmpa, p, 0 - ((sp_int_digit)tmpa[97] >> 31));
        sp_4096_mul_98(tmpa, tmpa, qi);
        err = sp_4096_mod_98(tmpa, tmpa, p);
    }

    if (err == MP_OKAY) {
        sp_4096_mul_98(tmpa, tmpa, q);
        (void)sp_4096_add_196(r, tmpb, tmpa);
        sp_4096_norm_196(r);

        sp_4096_to_bin(r, out);
        *outLen = 512;
    }

    XMEMSET(tmpa, 0, sizeof(tmpa));
    XMEMSET(tmpb, 0, sizeof(tmpb));
    XMEMSET(p, 0, sizeof(p));
    XMEMSET(q, 0, sizeof(q));
    XMEMSET(dp, 0, sizeof(dp));
    XMEMSET(dq, 0, sizeof(dq));
    XMEMSET(qi, 0, sizeof(qi));

    return err;
#endif /* WOLFSSL_SP_SMALL | defined(WOLFSSL_SMALL_STACK) */
#endif /* SP_RSA_PRIVATE_EXP_D | RSA_LOW_MEM */
}

#endif /* !WOLFSSL_RSA_PUBLIC_ONLY */
#endif /* WOLFSSL_HAVE_SP_RSA */
#if defined(WOLFSSL_HAVE_SP_DH) || (defined(WOLFSSL_HAVE_SP_RSA) && \
                                              !defined(WOLFSSL_RSA_PUBLIC_ONLY))
/* Convert an array of sp_digit to an mp_int.
 *
 * a  A single precision integer.
 * r  A multi-precision integer.
 */
static int sp_4096_to_mp(const sp_digit* a, mp_int* r)
{
    int err;

    err = mp_grow(r, (4096 + DIGIT_BIT - 1) / DIGIT_BIT);
    if (err == MP_OKAY) { /*lint !e774 case where err is always MP_OKAY*/
#if DIGIT_BIT == 21
        XMEMCPY(r->dp, a, sizeof(sp_digit) * 196);
        r->used = 196;
        mp_clamp(r);
#elif DIGIT_BIT < 21
        int i;
        int j = 0;
        int s = 0;

        r->dp[0] = 0;
        for (i = 0; i < 196; i++) {
            r->dp[j] |= (mp_digit)(a[i] << s);
            r->dp[j] &= ((sp_digit)1 << DIGIT_BIT) - 1;
            s = DIGIT_BIT - s;
            r->dp[++j] = (mp_digit)(a[i] >> s);
            while (s + DIGIT_BIT <= 21) {
                s += DIGIT_BIT;
                r->dp[j++] &= ((sp_digit)1 << DIGIT_BIT) - 1;
                if (s == SP_WORD_SIZE) {
                    r->dp[j] = 0;
                }
                else {
                    r->dp[j] = (mp_digit)(a[i] >> s);
                }
            }
            s = 21 - s;
        }
        r->used = (4096 + DIGIT_BIT - 1) / DIGIT_BIT;
        mp_clamp(r);
#else
        int i;
        int j = 0;
        int s = 0;

        r->dp[0] = 0;
        for (i = 0; i < 196; i++) {
            r->dp[j] |= ((mp_digit)a[i]) << s;
            if (s + 21 >= DIGIT_BIT) {
    #if DIGIT_BIT != 32 && DIGIT_BIT != 64
                r->dp[j] &= ((sp_digit)1 << DIGIT_BIT) - 1;
    #endif
                s = DIGIT_BIT - s;
                r->dp[++j] = a[i] >> s;
                s = 21 - s;
            }
            else {
                s += 21;
            }
        }
        r->used = (4096 + DIGIT_BIT - 1) / DIGIT_BIT;
        mp_clamp(r);
#endif
    }

    return err;
}

/* Perform the modular exponentiation for Diffie-Hellman.
 *
 * base  Base. MP integer.
 * exp   Exponent. MP integer.
 * mod   Modulus. MP integer.
 * res   Result. MP integer.
 * returns 0 on success, MP_READ_E if there are too many bytes in an array
 * and MEMORY_E if memory allocation fails.
 */
int sp_ModExp_4096(const mp_int* base, const mp_int* exp, const mp_int* mod,
    mp_int* res)
{
#ifdef WOLFSSL_SP_SMALL
    int err = MP_OKAY;
    sp_digit* d = NULL;
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    int expBits = mp_count_bits(exp);

    if (mp_count_bits(base) > 4096) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expBits > 4096)) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (mp_count_bits(mod) != 4096)) {
        err = MP_READ_E;
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 196 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 196 * 2;
        m = e + 196;
        r = b;

        sp_4096_from_mp(b, 196, base);
        sp_4096_from_mp(e, 196, exp);
        sp_4096_from_mp(m, 196, mod);

        err = sp_4096_mod_exp_196(r, b, e, mp_count_bits(exp), m, 0);
    }

    if (err == MP_OKAY) {
        err = sp_4096_to_mp(r, res);
    }

    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 196U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
    return err;
#else
#ifndef WOLFSSL_SMALL_STACK
    sp_digit bd[392];
    sp_digit ed[196];
    sp_digit md[196];
#else
    sp_digit* d = NULL;
#endif
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    int err = MP_OKAY;
    int expBits = mp_count_bits(exp);

    if (mp_count_bits(base) > 4096) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expBits > 4096)) {
        err = MP_READ_E;
    }
    
    if ((err == MP_OKAY) && (mp_count_bits(mod) != 4096)) {
        err = MP_READ_E;
    }

#ifdef WOLFSSL_SMALL_STACK
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 196 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL)
            err = MEMORY_E;
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 196 * 2;
        m = e + 196;
        r = b;
    }
#else
    r = b = bd;
    e = ed;
    m = md;
#endif

    if (err == MP_OKAY) {
        sp_4096_from_mp(b, 196, base);
        sp_4096_from_mp(e, 196, exp);
        sp_4096_from_mp(m, 196, mod);

        err = sp_4096_mod_exp_196(r, b, e, expBits, m, 0);
    }

    if (err == MP_OKAY) {
        err = sp_4096_to_mp(r, res);
    }


#ifdef WOLFSSL_SMALL_STACK
    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 196U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
#else
    XMEMSET(e, 0, sizeof(sp_digit) * 196U);
#endif

    return err;
#endif
}

#ifdef WOLFSSL_HAVE_SP_DH

#ifdef HAVE_FFDHE_4096
SP_NOINLINE static void sp_4096_lshift_196(sp_digit* r, const sp_digit* a,
        byte n)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    r[196] = a[195] >> (21 - n);
    for (i=195; i>0; i--) {
        r[i] = ((a[i] << n) | (a[i-1] >> (21 - n))) & 0x1fffff;
    }
#else
    sp_int_digit s;
    sp_int_digit t;

    s = (sp_int_digit)a[195];
    r[196] = s >> (21U - n);
    s = (sp_int_digit)(a[195]); t = (sp_int_digit)(a[194]);
    r[195] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[194]); t = (sp_int_digit)(a[193]);
    r[194] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[193]); t = (sp_int_digit)(a[192]);
    r[193] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[192]); t = (sp_int_digit)(a[191]);
    r[192] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[191]); t = (sp_int_digit)(a[190]);
    r[191] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[190]); t = (sp_int_digit)(a[189]);
    r[190] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[189]); t = (sp_int_digit)(a[188]);
    r[189] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[188]); t = (sp_int_digit)(a[187]);
    r[188] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[187]); t = (sp_int_digit)(a[186]);
    r[187] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[186]); t = (sp_int_digit)(a[185]);
    r[186] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[185]); t = (sp_int_digit)(a[184]);
    r[185] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[184]); t = (sp_int_digit)(a[183]);
    r[184] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[183]); t = (sp_int_digit)(a[182]);
    r[183] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[182]); t = (sp_int_digit)(a[181]);
    r[182] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[181]); t = (sp_int_digit)(a[180]);
    r[181] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[180]); t = (sp_int_digit)(a[179]);
    r[180] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[179]); t = (sp_int_digit)(a[178]);
    r[179] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[178]); t = (sp_int_digit)(a[177]);
    r[178] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[177]); t = (sp_int_digit)(a[176]);
    r[177] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[176]); t = (sp_int_digit)(a[175]);
    r[176] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[175]); t = (sp_int_digit)(a[174]);
    r[175] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[174]); t = (sp_int_digit)(a[173]);
    r[174] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[173]); t = (sp_int_digit)(a[172]);
    r[173] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[172]); t = (sp_int_digit)(a[171]);
    r[172] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[171]); t = (sp_int_digit)(a[170]);
    r[171] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[170]); t = (sp_int_digit)(a[169]);
    r[170] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[169]); t = (sp_int_digit)(a[168]);
    r[169] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[168]); t = (sp_int_digit)(a[167]);
    r[168] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[167]); t = (sp_int_digit)(a[166]);
    r[167] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[166]); t = (sp_int_digit)(a[165]);
    r[166] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[165]); t = (sp_int_digit)(a[164]);
    r[165] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[164]); t = (sp_int_digit)(a[163]);
    r[164] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[163]); t = (sp_int_digit)(a[162]);
    r[163] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[162]); t = (sp_int_digit)(a[161]);
    r[162] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[161]); t = (sp_int_digit)(a[160]);
    r[161] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[160]); t = (sp_int_digit)(a[159]);
    r[160] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[159]); t = (sp_int_digit)(a[158]);
    r[159] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[158]); t = (sp_int_digit)(a[157]);
    r[158] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[157]); t = (sp_int_digit)(a[156]);
    r[157] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[156]); t = (sp_int_digit)(a[155]);
    r[156] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[155]); t = (sp_int_digit)(a[154]);
    r[155] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[154]); t = (sp_int_digit)(a[153]);
    r[154] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[153]); t = (sp_int_digit)(a[152]);
    r[153] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[152]); t = (sp_int_digit)(a[151]);
    r[152] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[151]); t = (sp_int_digit)(a[150]);
    r[151] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[150]); t = (sp_int_digit)(a[149]);
    r[150] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[149]); t = (sp_int_digit)(a[148]);
    r[149] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[148]); t = (sp_int_digit)(a[147]);
    r[148] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[147]); t = (sp_int_digit)(a[146]);
    r[147] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[146]); t = (sp_int_digit)(a[145]);
    r[146] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[145]); t = (sp_int_digit)(a[144]);
    r[145] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[144]); t = (sp_int_digit)(a[143]);
    r[144] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[143]); t = (sp_int_digit)(a[142]);
    r[143] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[142]); t = (sp_int_digit)(a[141]);
    r[142] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[141]); t = (sp_int_digit)(a[140]);
    r[141] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[140]); t = (sp_int_digit)(a[139]);
    r[140] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[139]); t = (sp_int_digit)(a[138]);
    r[139] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[138]); t = (sp_int_digit)(a[137]);
    r[138] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[137]); t = (sp_int_digit)(a[136]);
    r[137] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[136]); t = (sp_int_digit)(a[135]);
    r[136] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[135]); t = (sp_int_digit)(a[134]);
    r[135] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[134]); t = (sp_int_digit)(a[133]);
    r[134] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[133]); t = (sp_int_digit)(a[132]);
    r[133] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[132]); t = (sp_int_digit)(a[131]);
    r[132] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[131]); t = (sp_int_digit)(a[130]);
    r[131] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[130]); t = (sp_int_digit)(a[129]);
    r[130] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[129]); t = (sp_int_digit)(a[128]);
    r[129] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[128]); t = (sp_int_digit)(a[127]);
    r[128] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[127]); t = (sp_int_digit)(a[126]);
    r[127] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[126]); t = (sp_int_digit)(a[125]);
    r[126] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[125]); t = (sp_int_digit)(a[124]);
    r[125] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[124]); t = (sp_int_digit)(a[123]);
    r[124] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[123]); t = (sp_int_digit)(a[122]);
    r[123] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[122]); t = (sp_int_digit)(a[121]);
    r[122] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[121]); t = (sp_int_digit)(a[120]);
    r[121] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[120]); t = (sp_int_digit)(a[119]);
    r[120] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[119]); t = (sp_int_digit)(a[118]);
    r[119] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[118]); t = (sp_int_digit)(a[117]);
    r[118] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[117]); t = (sp_int_digit)(a[116]);
    r[117] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[116]); t = (sp_int_digit)(a[115]);
    r[116] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[115]); t = (sp_int_digit)(a[114]);
    r[115] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[114]); t = (sp_int_digit)(a[113]);
    r[114] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[113]); t = (sp_int_digit)(a[112]);
    r[113] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[112]); t = (sp_int_digit)(a[111]);
    r[112] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[111]); t = (sp_int_digit)(a[110]);
    r[111] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[110]); t = (sp_int_digit)(a[109]);
    r[110] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[109]); t = (sp_int_digit)(a[108]);
    r[109] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[108]); t = (sp_int_digit)(a[107]);
    r[108] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[107]); t = (sp_int_digit)(a[106]);
    r[107] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[106]); t = (sp_int_digit)(a[105]);
    r[106] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[105]); t = (sp_int_digit)(a[104]);
    r[105] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[104]); t = (sp_int_digit)(a[103]);
    r[104] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[103]); t = (sp_int_digit)(a[102]);
    r[103] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[102]); t = (sp_int_digit)(a[101]);
    r[102] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[101]); t = (sp_int_digit)(a[100]);
    r[101] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[100]); t = (sp_int_digit)(a[99]);
    r[100] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[99]); t = (sp_int_digit)(a[98]);
    r[99] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[98]); t = (sp_int_digit)(a[97]);
    r[98] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[97]); t = (sp_int_digit)(a[96]);
    r[97] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[96]); t = (sp_int_digit)(a[95]);
    r[96] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[95]); t = (sp_int_digit)(a[94]);
    r[95] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[94]); t = (sp_int_digit)(a[93]);
    r[94] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[93]); t = (sp_int_digit)(a[92]);
    r[93] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[92]); t = (sp_int_digit)(a[91]);
    r[92] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[91]); t = (sp_int_digit)(a[90]);
    r[91] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[90]); t = (sp_int_digit)(a[89]);
    r[90] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[89]); t = (sp_int_digit)(a[88]);
    r[89] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[88]); t = (sp_int_digit)(a[87]);
    r[88] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[87]); t = (sp_int_digit)(a[86]);
    r[87] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[86]); t = (sp_int_digit)(a[85]);
    r[86] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[85]); t = (sp_int_digit)(a[84]);
    r[85] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[84]); t = (sp_int_digit)(a[83]);
    r[84] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[83]); t = (sp_int_digit)(a[82]);
    r[83] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[82]); t = (sp_int_digit)(a[81]);
    r[82] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[81]); t = (sp_int_digit)(a[80]);
    r[81] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[80]); t = (sp_int_digit)(a[79]);
    r[80] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[79]); t = (sp_int_digit)(a[78]);
    r[79] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[78]); t = (sp_int_digit)(a[77]);
    r[78] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[77]); t = (sp_int_digit)(a[76]);
    r[77] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[76]); t = (sp_int_digit)(a[75]);
    r[76] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[75]); t = (sp_int_digit)(a[74]);
    r[75] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[74]); t = (sp_int_digit)(a[73]);
    r[74] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[73]); t = (sp_int_digit)(a[72]);
    r[73] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[72]); t = (sp_int_digit)(a[71]);
    r[72] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[71]); t = (sp_int_digit)(a[70]);
    r[71] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[70]); t = (sp_int_digit)(a[69]);
    r[70] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[69]); t = (sp_int_digit)(a[68]);
    r[69] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[68]); t = (sp_int_digit)(a[67]);
    r[68] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[67]); t = (sp_int_digit)(a[66]);
    r[67] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[66]); t = (sp_int_digit)(a[65]);
    r[66] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[65]); t = (sp_int_digit)(a[64]);
    r[65] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[64]); t = (sp_int_digit)(a[63]);
    r[64] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[63]); t = (sp_int_digit)(a[62]);
    r[63] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[62]); t = (sp_int_digit)(a[61]);
    r[62] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[61]); t = (sp_int_digit)(a[60]);
    r[61] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[60]); t = (sp_int_digit)(a[59]);
    r[60] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[59]); t = (sp_int_digit)(a[58]);
    r[59] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[58]); t = (sp_int_digit)(a[57]);
    r[58] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[57]); t = (sp_int_digit)(a[56]);
    r[57] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[56]); t = (sp_int_digit)(a[55]);
    r[56] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[55]); t = (sp_int_digit)(a[54]);
    r[55] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[54]); t = (sp_int_digit)(a[53]);
    r[54] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[53]); t = (sp_int_digit)(a[52]);
    r[53] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[52]); t = (sp_int_digit)(a[51]);
    r[52] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[51]); t = (sp_int_digit)(a[50]);
    r[51] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[50]); t = (sp_int_digit)(a[49]);
    r[50] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[49]); t = (sp_int_digit)(a[48]);
    r[49] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[48]); t = (sp_int_digit)(a[47]);
    r[48] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[47]); t = (sp_int_digit)(a[46]);
    r[47] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[46]); t = (sp_int_digit)(a[45]);
    r[46] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[45]); t = (sp_int_digit)(a[44]);
    r[45] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[44]); t = (sp_int_digit)(a[43]);
    r[44] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[43]); t = (sp_int_digit)(a[42]);
    r[43] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[42]); t = (sp_int_digit)(a[41]);
    r[42] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[41]); t = (sp_int_digit)(a[40]);
    r[41] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[40]); t = (sp_int_digit)(a[39]);
    r[40] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[39]); t = (sp_int_digit)(a[38]);
    r[39] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[38]); t = (sp_int_digit)(a[37]);
    r[38] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[37]); t = (sp_int_digit)(a[36]);
    r[37] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[36]); t = (sp_int_digit)(a[35]);
    r[36] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[35]); t = (sp_int_digit)(a[34]);
    r[35] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[34]); t = (sp_int_digit)(a[33]);
    r[34] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[33]); t = (sp_int_digit)(a[32]);
    r[33] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[32]); t = (sp_int_digit)(a[31]);
    r[32] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[31]); t = (sp_int_digit)(a[30]);
    r[31] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[30]); t = (sp_int_digit)(a[29]);
    r[30] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[29]); t = (sp_int_digit)(a[28]);
    r[29] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[28]); t = (sp_int_digit)(a[27]);
    r[28] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[27]); t = (sp_int_digit)(a[26]);
    r[27] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[26]); t = (sp_int_digit)(a[25]);
    r[26] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[25]); t = (sp_int_digit)(a[24]);
    r[25] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[24]); t = (sp_int_digit)(a[23]);
    r[24] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[23]); t = (sp_int_digit)(a[22]);
    r[23] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[22]); t = (sp_int_digit)(a[21]);
    r[22] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[21]); t = (sp_int_digit)(a[20]);
    r[21] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[20]); t = (sp_int_digit)(a[19]);
    r[20] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[19]); t = (sp_int_digit)(a[18]);
    r[19] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[18]); t = (sp_int_digit)(a[17]);
    r[18] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[17]); t = (sp_int_digit)(a[16]);
    r[17] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[16]); t = (sp_int_digit)(a[15]);
    r[16] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[15]); t = (sp_int_digit)(a[14]);
    r[15] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[14]); t = (sp_int_digit)(a[13]);
    r[14] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[13]); t = (sp_int_digit)(a[12]);
    r[13] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[12]); t = (sp_int_digit)(a[11]);
    r[12] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[11]); t = (sp_int_digit)(a[10]);
    r[11] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[10]); t = (sp_int_digit)(a[9]);
    r[10] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[9]); t = (sp_int_digit)(a[8]);
    r[9] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[8]); t = (sp_int_digit)(a[7]);
    r[8] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[7]); t = (sp_int_digit)(a[6]);
    r[7] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[6]); t = (sp_int_digit)(a[5]);
    r[6] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[5]); t = (sp_int_digit)(a[4]);
    r[5] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[4]); t = (sp_int_digit)(a[3]);
    r[4] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[3]); t = (sp_int_digit)(a[2]);
    r[3] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[2]); t = (sp_int_digit)(a[1]);
    r[2] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
    s = (sp_int_digit)(a[1]); t = (sp_int_digit)(a[0]);
    r[1] = ((s << n) | (t >> (21U - n))) & 0x1fffff;
#endif
    r[0] = (a[0] << n) & 0x1fffff;
}

/* Modular exponentiate 2 to the e mod m. (r = 2^e mod m)
 *
 * r     A single precision number that is the result of the operation.
 * e     A single precision number that is the exponent.
 * bits  The number of bits in the exponent.
 * m     A single precision number that is the modulus.
 * returns 0 on success and MEMORY_E on dynamic memory allocation failure.
 */
static int sp_4096_mod_exp_2_196(sp_digit* r, const sp_digit* e, int bits, const sp_digit* m)
{
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit td[589];
#endif
    sp_digit* norm;
    sp_digit* tmp;
    sp_digit mp = 1;
    sp_digit n;
    sp_digit o;
    int i;
    int c;
    byte y;
    int err = MP_OKAY;

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * 589, NULL,
                            DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
        norm = td;
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
        tmp  = td + 392;
        XMEMSET(td, 0, sizeof(sp_digit) * 589);
#else
        tmp  = &td[392];
        XMEMSET(td, 0, sizeof(td));
#endif

        sp_4096_mont_setup(m, &mp);
        sp_4096_mont_norm_196(norm, m);

        bits = ((bits + 3) / 4) * 4;
        i = ((bits + 20) / 21) - 1;
        c = bits % 21;
        if (c == 0) {
            c = 21;
        }
        if (i < 196) {
            n = e[i--] << (32 - c);
        }
        else {
            n = 0;
            i--;
        }
        if (c < 4) {
            n |= e[i--] << (11 - c);
            c += 21;
        }
        y = (n >> 28) & 0xf;
        n <<= 4;
        c -= 4;
        sp_4096_lshift_196(r, norm, y);
        while ((i >= 0) || (c >= 4)) {
            if (c < 4) {
                n |= e[i--] << (11 - c);
                c += 21;
            }
            y = (n >> 28) & 0xf;
            n <<= 4;
            c -= 4;

            sp_4096_mont_sqr_196(r, r, m, mp);
            sp_4096_mont_sqr_196(r, r, m, mp);
            sp_4096_mont_sqr_196(r, r, m, mp);
            sp_4096_mont_sqr_196(r, r, m, mp);

            sp_4096_lshift_196(r, r, y);
            sp_4096_mul_d_196(tmp, norm, (r[196] << 20) + (r[195] >> 1));
            r[196] = 0;
            r[195] &= 0x1L;
            (void)sp_4096_add_196(r, r, tmp);
            sp_4096_norm_196(r);
            o = sp_4096_cmp_196(r, m);
            sp_4096_cond_sub_196(r, r, m, ((o < 0) ?
                                          (sp_digit)1 : (sp_digit)0) - 1);
        }

        sp_4096_mont_reduce_196(r, m, mp);
        n = sp_4096_cmp_196(r, m);
        sp_4096_cond_sub_196(r, r, m, ((n < 0) ?
                                                (sp_digit)1 : (sp_digit)0) - 1);
    }

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
}

#endif /* HAVE_FFDHE_4096 */

/* Perform the modular exponentiation for Diffie-Hellman.
 *
 * base     Base.
 * exp      Array of bytes that is the exponent.
 * expLen   Length of data, in bytes, in exponent.
 * mod      Modulus.
 * out      Buffer to hold big-endian bytes of exponentiation result.
 *          Must be at least 512 bytes long.
 * outLen   Length, in bytes, of exponentiation result.
 * returns 0 on success, MP_READ_E if there are too many bytes in an array
 * and MEMORY_E if memory allocation fails.
 */
int sp_DhExp_4096(const mp_int* base, const byte* exp, word32 expLen,
    const mp_int* mod, byte* out, word32* outLen)
{
#ifdef WOLFSSL_SP_SMALL
    int err = MP_OKAY;
    sp_digit* d = NULL;
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    word32 i;

    if (mp_count_bits(base) > 4096) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expLen > 512U)) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (mp_count_bits(mod) != 4096)) {
        err = MP_READ_E;
    }

    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 196 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 196 * 2;
        m = e + 196;
        r = b;

        sp_4096_from_mp(b, 196, base);
        sp_4096_from_bin(e, 196, exp, expLen);
        sp_4096_from_mp(m, 196, mod);

    #ifdef HAVE_FFDHE_4096
        if (base->used == 1 && base->dp[0] == 2 &&
                ((m[195] << 15) | (m[194] >> 6)) == 0xffffL) {
            err = sp_4096_mod_exp_2_196(r, e, expLen * 8, m);
        }
        else
    #endif
            err = sp_4096_mod_exp_196(r, b, e, expLen * 8, m, 0);
    }

    if (err == MP_OKAY) {
        sp_4096_to_bin(r, out);
        *outLen = 512;
        for (i=0; i<512 && out[i] == 0; i++) {
            /* Search for first non-zero. */
        }
        *outLen -= i;
        XMEMMOVE(out, out + i, *outLen);
    }

    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 196U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
    return err;
#else
#ifndef WOLFSSL_SMALL_STACK
    sp_digit bd[392];
    sp_digit ed[196];
    sp_digit md[196];
#else
    sp_digit* d = NULL;
#endif
    sp_digit* b;
    sp_digit* e;
    sp_digit* m;
    sp_digit* r;
    word32 i;
    int err = MP_OKAY;

    if (mp_count_bits(base) > 4096) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (expLen > 512U)) {
        err = MP_READ_E;
    }

    if ((err == MP_OKAY) && (mp_count_bits(mod) != 4096)) {
        err = MP_READ_E;
    }
#ifdef WOLFSSL_SMALL_STACK
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(*d) * 196 * 4, NULL, DYNAMIC_TYPE_DH);
        if (d == NULL)
            err = MEMORY_E;
    }

    if (err == MP_OKAY) {
        b = d;
        e = b + 196 * 2;
        m = e + 196;
        r = b;
    }
#else
    r = b = bd;
    e = ed;
    m = md;
#endif

    if (err == MP_OKAY) {
        sp_4096_from_mp(b, 196, base);
        sp_4096_from_bin(e, 196, exp, expLen);
        sp_4096_from_mp(m, 196, mod);

    #ifdef HAVE_FFDHE_4096
        if (base->used == 1 && base->dp[0] == 2U &&
                ((m[195] << 15) | (m[194] >> 6)) == 0xffffL) {
            err = sp_4096_mod_exp_2_196(r, e, expLen * 8U, m);
        }
        else {
    #endif
            err = sp_4096_mod_exp_196(r, b, e, expLen * 8U, m, 0);
    #ifdef HAVE_FFDHE_4096
        }
    #endif
    }

    if (err == MP_OKAY) {
        sp_4096_to_bin(r, out);
        *outLen = 512;
        for (i=0; i<512U && out[i] == 0U; i++) {
            /* Search for first non-zero. */
        }
        *outLen -= i;
        XMEMMOVE(out, out + i, *outLen);
    }

#ifdef WOLFSSL_SMALL_STACK
    if (d != NULL) {
        XMEMSET(e, 0, sizeof(sp_digit) * 196U);
        XFREE(d, NULL, DYNAMIC_TYPE_DH);
    }
#else
    XMEMSET(e, 0, sizeof(sp_digit) * 196U);
#endif

    return err;
#endif
}
#endif /* WOLFSSL_HAVE_SP_DH */

#endif /* WOLFSSL_HAVE_SP_DH | (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) */

#endif /* WOLFSSL_SP_4096 */

#endif /* WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH */
#ifdef WOLFSSL_HAVE_SP_ECC
#ifndef WOLFSSL_SP_NO_256

/* Point structure to use. */
typedef struct sp_point_256 {
    /* X ordinate of point. */
    sp_digit x[2 * 10];
    /* Y ordinate of point. */
    sp_digit y[2 * 10];
    /* Z ordinate of point. */
    sp_digit z[2 * 10];
    /* Indicates point is at infinity. */
    int infinity;
} sp_point_256;

#ifdef WOLFSSL_SP_SMALL
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_256_mul_10(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[9]) * b[9];
    r[19] = (sp_digit)(c >> 26);
    c = (c & 0x3ffffff) << 26;
    for (k = 17; k >= 0; k--) {
        for (i = 9; i >= 0; i--) {
            j = k - i;
            if (j >= 10) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * b[j];
        }
        r[k + 2] += c >> 52;
        r[k + 1] = (c >> 26) & 0x3ffffff;
        c = (c & 0x3ffffff) << 26;
    }
    r[0] = (sp_digit)(c >> 26);
}

#else
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_256_mul_10(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int64_t t0   = ((int64_t)a[ 0]) * b[ 0];
    int64_t t1   = ((int64_t)a[ 0]) * b[ 1]
                 + ((int64_t)a[ 1]) * b[ 0];
    int64_t t2   = ((int64_t)a[ 0]) * b[ 2]
                 + ((int64_t)a[ 1]) * b[ 1]
                 + ((int64_t)a[ 2]) * b[ 0];
    int64_t t3   = ((int64_t)a[ 0]) * b[ 3]
                 + ((int64_t)a[ 1]) * b[ 2]
                 + ((int64_t)a[ 2]) * b[ 1]
                 + ((int64_t)a[ 3]) * b[ 0];
    int64_t t4   = ((int64_t)a[ 0]) * b[ 4]
                 + ((int64_t)a[ 1]) * b[ 3]
                 + ((int64_t)a[ 2]) * b[ 2]
                 + ((int64_t)a[ 3]) * b[ 1]
                 + ((int64_t)a[ 4]) * b[ 0];
    int64_t t5   = ((int64_t)a[ 0]) * b[ 5]
                 + ((int64_t)a[ 1]) * b[ 4]
                 + ((int64_t)a[ 2]) * b[ 3]
                 + ((int64_t)a[ 3]) * b[ 2]
                 + ((int64_t)a[ 4]) * b[ 1]
                 + ((int64_t)a[ 5]) * b[ 0];
    int64_t t6   = ((int64_t)a[ 0]) * b[ 6]
                 + ((int64_t)a[ 1]) * b[ 5]
                 + ((int64_t)a[ 2]) * b[ 4]
                 + ((int64_t)a[ 3]) * b[ 3]
                 + ((int64_t)a[ 4]) * b[ 2]
                 + ((int64_t)a[ 5]) * b[ 1]
                 + ((int64_t)a[ 6]) * b[ 0];
    int64_t t7   = ((int64_t)a[ 0]) * b[ 7]
                 + ((int64_t)a[ 1]) * b[ 6]
                 + ((int64_t)a[ 2]) * b[ 5]
                 + ((int64_t)a[ 3]) * b[ 4]
                 + ((int64_t)a[ 4]) * b[ 3]
                 + ((int64_t)a[ 5]) * b[ 2]
                 + ((int64_t)a[ 6]) * b[ 1]
                 + ((int64_t)a[ 7]) * b[ 0];
    int64_t t8   = ((int64_t)a[ 0]) * b[ 8]
                 + ((int64_t)a[ 1]) * b[ 7]
                 + ((int64_t)a[ 2]) * b[ 6]
                 + ((int64_t)a[ 3]) * b[ 5]
                 + ((int64_t)a[ 4]) * b[ 4]
                 + ((int64_t)a[ 5]) * b[ 3]
                 + ((int64_t)a[ 6]) * b[ 2]
                 + ((int64_t)a[ 7]) * b[ 1]
                 + ((int64_t)a[ 8]) * b[ 0];
    int64_t t9   = ((int64_t)a[ 0]) * b[ 9]
                 + ((int64_t)a[ 1]) * b[ 8]
                 + ((int64_t)a[ 2]) * b[ 7]
                 + ((int64_t)a[ 3]) * b[ 6]
                 + ((int64_t)a[ 4]) * b[ 5]
                 + ((int64_t)a[ 5]) * b[ 4]
                 + ((int64_t)a[ 6]) * b[ 3]
                 + ((int64_t)a[ 7]) * b[ 2]
                 + ((int64_t)a[ 8]) * b[ 1]
                 + ((int64_t)a[ 9]) * b[ 0];
    int64_t t10  = ((int64_t)a[ 1]) * b[ 9]
                 + ((int64_t)a[ 2]) * b[ 8]
                 + ((int64_t)a[ 3]) * b[ 7]
                 + ((int64_t)a[ 4]) * b[ 6]
                 + ((int64_t)a[ 5]) * b[ 5]
                 + ((int64_t)a[ 6]) * b[ 4]
                 + ((int64_t)a[ 7]) * b[ 3]
                 + ((int64_t)a[ 8]) * b[ 2]
                 + ((int64_t)a[ 9]) * b[ 1];
    int64_t t11  = ((int64_t)a[ 2]) * b[ 9]
                 + ((int64_t)a[ 3]) * b[ 8]
                 + ((int64_t)a[ 4]) * b[ 7]
                 + ((int64_t)a[ 5]) * b[ 6]
                 + ((int64_t)a[ 6]) * b[ 5]
                 + ((int64_t)a[ 7]) * b[ 4]
                 + ((int64_t)a[ 8]) * b[ 3]
                 + ((int64_t)a[ 9]) * b[ 2];
    int64_t t12  = ((int64_t)a[ 3]) * b[ 9]
                 + ((int64_t)a[ 4]) * b[ 8]
                 + ((int64_t)a[ 5]) * b[ 7]
                 + ((int64_t)a[ 6]) * b[ 6]
                 + ((int64_t)a[ 7]) * b[ 5]
                 + ((int64_t)a[ 8]) * b[ 4]
                 + ((int64_t)a[ 9]) * b[ 3];
    int64_t t13  = ((int64_t)a[ 4]) * b[ 9]
                 + ((int64_t)a[ 5]) * b[ 8]
                 + ((int64_t)a[ 6]) * b[ 7]
                 + ((int64_t)a[ 7]) * b[ 6]
                 + ((int64_t)a[ 8]) * b[ 5]
                 + ((int64_t)a[ 9]) * b[ 4];
    int64_t t14  = ((int64_t)a[ 5]) * b[ 9]
                 + ((int64_t)a[ 6]) * b[ 8]
                 + ((int64_t)a[ 7]) * b[ 7]
                 + ((int64_t)a[ 8]) * b[ 6]
                 + ((int64_t)a[ 9]) * b[ 5];
    int64_t t15  = ((int64_t)a[ 6]) * b[ 9]
                 + ((int64_t)a[ 7]) * b[ 8]
                 + ((int64_t)a[ 8]) * b[ 7]
                 + ((int64_t)a[ 9]) * b[ 6];
    int64_t t16  = ((int64_t)a[ 7]) * b[ 9]
                 + ((int64_t)a[ 8]) * b[ 8]
                 + ((int64_t)a[ 9]) * b[ 7];
    int64_t t17  = ((int64_t)a[ 8]) * b[ 9]
                 + ((int64_t)a[ 9]) * b[ 8];
    int64_t t18  = ((int64_t)a[ 9]) * b[ 9];

    t1   += t0  >> 26; r[ 0] = t0  & 0x3ffffff;
    t2   += t1  >> 26; r[ 1] = t1  & 0x3ffffff;
    t3   += t2  >> 26; r[ 2] = t2  & 0x3ffffff;
    t4   += t3  >> 26; r[ 3] = t3  & 0x3ffffff;
    t5   += t4  >> 26; r[ 4] = t4  & 0x3ffffff;
    t6   += t5  >> 26; r[ 5] = t5  & 0x3ffffff;
    t7   += t6  >> 26; r[ 6] = t6  & 0x3ffffff;
    t8   += t7  >> 26; r[ 7] = t7  & 0x3ffffff;
    t9   += t8  >> 26; r[ 8] = t8  & 0x3ffffff;
    t10  += t9  >> 26; r[ 9] = t9  & 0x3ffffff;
    t11  += t10 >> 26; r[10] = t10 & 0x3ffffff;
    t12  += t11 >> 26; r[11] = t11 & 0x3ffffff;
    t13  += t12 >> 26; r[12] = t12 & 0x3ffffff;
    t14  += t13 >> 26; r[13] = t13 & 0x3ffffff;
    t15  += t14 >> 26; r[14] = t14 & 0x3ffffff;
    t16  += t15 >> 26; r[15] = t15 & 0x3ffffff;
    t17  += t16 >> 26; r[16] = t16 & 0x3ffffff;
    t18  += t17 >> 26; r[17] = t17 & 0x3ffffff;
    r[19] = (sp_digit)(t18 >> 26);
                       r[18] = t18 & 0x3ffffff;
}

#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_256_sqr_10(sp_digit* r, const sp_digit* a)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[9]) * a[9];
    r[19] = (sp_digit)(c >> 26);
    c = (c & 0x3ffffff) << 26;
    for (k = 17; k >= 0; k--) {
        for (i = 9; i >= 0; i--) {
            j = k - i;
            if (j >= 10 || i <= j) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * a[j] * 2;
        }
        if (i == j) {
           c += ((int64_t)a[i]) * a[i];
        }

        r[k + 2] += c >> 52;
        r[k + 1] = (c >> 26) & 0x3ffffff;
        c = (c & 0x3ffffff) << 26;
    }
    r[0] = (sp_digit)(c >> 26);
}

#else
/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_256_sqr_10(sp_digit* r, const sp_digit* a)
{
    int64_t t0   =  ((int64_t)a[ 0]) * a[ 0];
    int64_t t1   = (((int64_t)a[ 0]) * a[ 1]) * 2;
    int64_t t2   = (((int64_t)a[ 0]) * a[ 2]) * 2
                 +  ((int64_t)a[ 1]) * a[ 1];
    int64_t t3   = (((int64_t)a[ 0]) * a[ 3]
                 +  ((int64_t)a[ 1]) * a[ 2]) * 2;
    int64_t t4   = (((int64_t)a[ 0]) * a[ 4]
                 +  ((int64_t)a[ 1]) * a[ 3]) * 2
                 +  ((int64_t)a[ 2]) * a[ 2];
    int64_t t5   = (((int64_t)a[ 0]) * a[ 5]
                 +  ((int64_t)a[ 1]) * a[ 4]
                 +  ((int64_t)a[ 2]) * a[ 3]) * 2;
    int64_t t6   = (((int64_t)a[ 0]) * a[ 6]
                 +  ((int64_t)a[ 1]) * a[ 5]
                 +  ((int64_t)a[ 2]) * a[ 4]) * 2
                 +  ((int64_t)a[ 3]) * a[ 3];
    int64_t t7   = (((int64_t)a[ 0]) * a[ 7]
                 +  ((int64_t)a[ 1]) * a[ 6]
                 +  ((int64_t)a[ 2]) * a[ 5]
                 +  ((int64_t)a[ 3]) * a[ 4]) * 2;
    int64_t t8   = (((int64_t)a[ 0]) * a[ 8]
                 +  ((int64_t)a[ 1]) * a[ 7]
                 +  ((int64_t)a[ 2]) * a[ 6]
                 +  ((int64_t)a[ 3]) * a[ 5]) * 2
                 +  ((int64_t)a[ 4]) * a[ 4];
    int64_t t9   = (((int64_t)a[ 0]) * a[ 9]
                 +  ((int64_t)a[ 1]) * a[ 8]
                 +  ((int64_t)a[ 2]) * a[ 7]
                 +  ((int64_t)a[ 3]) * a[ 6]
                 +  ((int64_t)a[ 4]) * a[ 5]) * 2;
    int64_t t10  = (((int64_t)a[ 1]) * a[ 9]
                 +  ((int64_t)a[ 2]) * a[ 8]
                 +  ((int64_t)a[ 3]) * a[ 7]
                 +  ((int64_t)a[ 4]) * a[ 6]) * 2
                 +  ((int64_t)a[ 5]) * a[ 5];
    int64_t t11  = (((int64_t)a[ 2]) * a[ 9]
                 +  ((int64_t)a[ 3]) * a[ 8]
                 +  ((int64_t)a[ 4]) * a[ 7]
                 +  ((int64_t)a[ 5]) * a[ 6]) * 2;
    int64_t t12  = (((int64_t)a[ 3]) * a[ 9]
                 +  ((int64_t)a[ 4]) * a[ 8]
                 +  ((int64_t)a[ 5]) * a[ 7]) * 2
                 +  ((int64_t)a[ 6]) * a[ 6];
    int64_t t13  = (((int64_t)a[ 4]) * a[ 9]
                 +  ((int64_t)a[ 5]) * a[ 8]
                 +  ((int64_t)a[ 6]) * a[ 7]) * 2;
    int64_t t14  = (((int64_t)a[ 5]) * a[ 9]
                 +  ((int64_t)a[ 6]) * a[ 8]) * 2
                 +  ((int64_t)a[ 7]) * a[ 7];
    int64_t t15  = (((int64_t)a[ 6]) * a[ 9]
                 +  ((int64_t)a[ 7]) * a[ 8]) * 2;
    int64_t t16  = (((int64_t)a[ 7]) * a[ 9]) * 2
                 +  ((int64_t)a[ 8]) * a[ 8];
    int64_t t17  = (((int64_t)a[ 8]) * a[ 9]) * 2;
    int64_t t18  =  ((int64_t)a[ 9]) * a[ 9];

    t1   += t0  >> 26; r[ 0] = t0  & 0x3ffffff;
    t2   += t1  >> 26; r[ 1] = t1  & 0x3ffffff;
    t3   += t2  >> 26; r[ 2] = t2  & 0x3ffffff;
    t4   += t3  >> 26; r[ 3] = t3  & 0x3ffffff;
    t5   += t4  >> 26; r[ 4] = t4  & 0x3ffffff;
    t6   += t5  >> 26; r[ 5] = t5  & 0x3ffffff;
    t7   += t6  >> 26; r[ 6] = t6  & 0x3ffffff;
    t8   += t7  >> 26; r[ 7] = t7  & 0x3ffffff;
    t9   += t8  >> 26; r[ 8] = t8  & 0x3ffffff;
    t10  += t9  >> 26; r[ 9] = t9  & 0x3ffffff;
    t11  += t10 >> 26; r[10] = t10 & 0x3ffffff;
    t12  += t11 >> 26; r[11] = t11 & 0x3ffffff;
    t13  += t12 >> 26; r[12] = t12 & 0x3ffffff;
    t14  += t13 >> 26; r[13] = t13 & 0x3ffffff;
    t15  += t14 >> 26; r[14] = t14 & 0x3ffffff;
    t16  += t15 >> 26; r[15] = t15 & 0x3ffffff;
    t17  += t16 >> 26; r[16] = t16 & 0x3ffffff;
    t18  += t17 >> 26; r[17] = t17 & 0x3ffffff;
    r[19] = (sp_digit)(t18 >> 26);
                       r[18] = t18 & 0x3ffffff;
}

#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_256_add_10(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 10; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#else
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_256_add_10(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    r[ 0] = a[ 0] + b[ 0];
    r[ 1] = a[ 1] + b[ 1];
    r[ 2] = a[ 2] + b[ 2];
    r[ 3] = a[ 3] + b[ 3];
    r[ 4] = a[ 4] + b[ 4];
    r[ 5] = a[ 5] + b[ 5];
    r[ 6] = a[ 6] + b[ 6];
    r[ 7] = a[ 7] + b[ 7];
    r[ 8] = a[ 8] + b[ 8];
    r[ 9] = a[ 9] + b[ 9];

    return 0;
}

#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_256_sub_10(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 10; i++) {
        r[i] = a[i] - b[i];
    }

    return 0;
}

#else
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_256_sub_10(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    r[ 0] = a[ 0] - b[ 0];
    r[ 1] = a[ 1] - b[ 1];
    r[ 2] = a[ 2] - b[ 2];
    r[ 3] = a[ 3] - b[ 3];
    r[ 4] = a[ 4] - b[ 4];
    r[ 5] = a[ 5] - b[ 5];
    r[ 6] = a[ 6] - b[ 6];
    r[ 7] = a[ 7] - b[ 7];
    r[ 8] = a[ 8] - b[ 8];
    r[ 9] = a[ 9] - b[ 9];

    return 0;
}

#endif /* WOLFSSL_SP_SMALL */
/* The modulus (prime) of the curve P256. */
static const sp_digit p256_mod[10] = {
    0x3ffffff,0x3ffffff,0x3ffffff,0x003ffff,0x0000000,0x0000000,0x0000000,
    0x0000400,0x3ff0000,0x03fffff
};
/* The Montogmery normalizer for modulus of the curve P256. */
static const sp_digit p256_norm_mod[10] = {
    0x0000001,0x0000000,0x0000000,0x3fc0000,0x3ffffff,0x3ffffff,0x3ffffff,
    0x3fffbff,0x000ffff,0x0000000
};
/* The Montogmery multiplier for modulus of the curve P256. */
static const sp_digit p256_mp_mod = 0x000001;
#if defined(WOLFSSL_VALIDATE_ECC_KEYGEN) || defined(HAVE_ECC_SIGN) || \
                                            defined(HAVE_ECC_VERIFY)
/* The order of the curve P256. */
static const sp_digit p256_order[10] = {
    0x0632551,0x272b0bf,0x1e84f3b,0x2b69c5e,0x3bce6fa,0x3ffffff,0x3ffffff,
    0x00003ff,0x3ff0000,0x03fffff
};
#endif
/* The order of the curve P256 minus 2. */
static const sp_digit p256_order2[10] = {
    0x063254f,0x272b0bf,0x1e84f3b,0x2b69c5e,0x3bce6fa,0x3ffffff,0x3ffffff,
    0x00003ff,0x3ff0000,0x03fffff
};
#if defined(HAVE_ECC_SIGN) || defined(HAVE_ECC_VERIFY)
/* The Montogmery normalizer for order of the curve P256. */
static const sp_digit p256_norm_order[10] = {
    0x39cdaaf,0x18d4f40,0x217b0c4,0x14963a1,0x0431905,0x0000000,0x0000000,
    0x3fffc00,0x000ffff,0x0000000
};
#endif
#if defined(HAVE_ECC_SIGN) || defined(HAVE_ECC_VERIFY)
/* The Montogmery multiplier for order of the curve P256. */
static const sp_digit p256_mp_order = 0x200bc4f;
#endif
/* The base point of curve P256. */
static const sp_point_256 p256_base = {
    /* X ordinate */
    {
        0x098c296,0x04e5176,0x33a0f4a,0x204b7ac,0x277037d,0x0e9103c,0x3ce6e56,
        0x1091fe2,0x1f2e12c,0x01ac5f4,
        0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L
    },
    /* Y ordinate */
    {
        0x3bf51f5,0x1901a0d,0x1ececbb,0x15dacc5,0x22bce33,0x303e785,0x27eb4a7,
        0x1fe6e3b,0x2e2fe1a,0x013f8d0,
        0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L
    },
    /* Z ordinate */
    {
        0x0000001,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
        0x0000000,0x0000000,0x0000000,
        0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L
    },
    /* infinity */
    0
};
#if defined(HAVE_ECC_CHECK_KEY) || defined(HAVE_COMP_KEY)
static const sp_digit p256_b[10] = {
    0x3d2604b,0x38f0f89,0x30f63bc,0x2c3314e,0x0651d06,0x1a621af,0x2bbd557,
    0x24f9ecf,0x1d8aa3a,0x016b18d
};
#endif

/* Create a new point.
 *
 * heap  [in]   Buffer to allocate dynamic memory from.
 * sp    [in]   Data for point - only if not allocating.
 * p     [out]  New point.
 * returns MEMORY_E when dynamic memory allocation fails and 0 otherwise. 
 */
static int sp_256_point_new_ex_10(void* heap, sp_point_256* sp,
        sp_point_256** p)
{
    int ret = MP_OKAY;
    (void)heap;
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    (void)sp;
    *p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), heap, DYNAMIC_TYPE_ECC);
#else
    *p = sp;
#endif
    if (*p == NULL) {
        ret = MEMORY_E;
    }
    return ret;
}

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
/* Allocate memory for point and return error. */
#define sp_256_point_new_10(heap, sp, p) sp_256_point_new_ex_10((heap), NULL, &(p))
#else
/* Set pointer to data and return no error. */
#define sp_256_point_new_10(heap, sp, p) sp_256_point_new_ex_10((heap), &(sp), &(p))
#endif


/* Free the point.
 *
 * p      [in,out]  Point to free.
 * clear  [in]      Indicates whether to zeroize point.
 * heap   [in]      Buffer from which dynamic memory was allocate from.
 */
static void sp_256_point_free_10(sp_point_256* p, int clear, void* heap)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
/* If valid pointer then clear point data if requested and free data. */
    if (p != NULL) {
        if (clear != 0) {
            XMEMSET(p, 0, sizeof(*p));
        }
        XFREE(p, heap, DYNAMIC_TYPE_ECC);
    }
#else
/* Clear point data if requested. */
    if (clear != 0) {
        XMEMSET(p, 0, sizeof(*p));
    }
#endif
    (void)heap;
}

/* Convert an mp_int to an array of sp_digit.
 *
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  A multi-precision integer.
 */
static void sp_256_from_mp(sp_digit* r, int size, const mp_int* a)
{
#if DIGIT_BIT == 26
    int j;

    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);

    for (j = a->used; j < size; j++) {
        r[j] = 0;
    }
#elif DIGIT_BIT > 26
    int i;
    int j = 0;
    word32 s = 0;

    r[0] = 0;
    for (i = 0; i < a->used && j < size; i++) {
        r[j] |= ((sp_digit)a->dp[i] << s);
        r[j] &= 0x3ffffff;
        s = 26U - s;
        if (j + 1 >= size) {
            break;
        }
        /* lint allow cast of mismatch word32 and mp_digit */
        r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
        while ((s + 26U) <= (word32)DIGIT_BIT) {
            s += 26U;
            r[j] &= 0x3ffffff;
            if (j + 1 >= size) {
                break;
            }
            if (s < (word32)DIGIT_BIT) {
                /* lint allow cast of mismatch word32 and mp_digit */
                r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
            }
            else {
                r[++j] = 0L;
            }
        }
        s = (word32)DIGIT_BIT - s;
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#else
    int i;
    int j = 0;
    int s = 0;

    r[0] = 0;
    for (i = 0; i < a->used && j < size; i++) {
        r[j] |= ((sp_digit)a->dp[i]) << s;
        if (s + DIGIT_BIT >= 26) {
            r[j] &= 0x3ffffff;
            if (j + 1 >= size) {
                break;
            }
            s = 26 - s;
            if (s == DIGIT_BIT) {
                r[++j] = 0;
                s = 0;
            }
            else {
                r[++j] = a->dp[i] >> s;
                s = DIGIT_BIT - s;
            }
        }
        else {
            s += DIGIT_BIT;
        }
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#endif
}

/* Convert a point of type ecc_point to type sp_point_256.
 *
 * p   Point of type sp_point_256 (result).
 * pm  Point of type ecc_point.
 */
static void sp_256_point_from_ecc_point_10(sp_point_256* p,
        const ecc_point* pm)
{
    XMEMSET(p->x, 0, sizeof(p->x));
    XMEMSET(p->y, 0, sizeof(p->y));
    XMEMSET(p->z, 0, sizeof(p->z));
    sp_256_from_mp(p->x, 10, pm->x);
    sp_256_from_mp(p->y, 10, pm->y);
    sp_256_from_mp(p->z, 10, pm->z);
    p->infinity = 0;
}

/* Convert an array of sp_digit to an mp_int.
 *
 * a  A single precision integer.
 * r  A multi-precision integer.
 */
static int sp_256_to_mp(const sp_digit* a, mp_int* r)
{
    int err;

    err = mp_grow(r, (256 + DIGIT_BIT - 1) / DIGIT_BIT);
    if (err == MP_OKAY) { /*lint !e774 case where err is always MP_OKAY*/
#if DIGIT_BIT == 26
        XMEMCPY(r->dp, a, sizeof(sp_digit) * 10);
        r->used = 10;
        mp_clamp(r);
#elif DIGIT_BIT < 26
        int i;
        int j = 0;
        int s = 0;

        r->dp[0] = 0;
        for (i = 0; i < 10; i++) {
            r->dp[j] |= (mp_digit)(a[i] << s);
            r->dp[j] &= ((sp_digit)1 << DIGIT_BIT) - 1;
            s = DIGIT_BIT - s;
            r->dp[++j] = (mp_digit)(a[i] >> s);
            while (s + DIGIT_BIT <= 26) {
                s += DIGIT_BIT;
                r->dp[j++] &= ((sp_digit)1 << DIGIT_BIT) - 1;
                if (s == SP_WORD_SIZE) {
                    r->dp[j] = 0;
                }
                else {
                    r->dp[j] = (mp_digit)(a[i] >> s);
                }
            }
            s = 26 - s;
        }
        r->used = (256 + DIGIT_BIT - 1) / DIGIT_BIT;
        mp_clamp(r);
#else
        int i;
        int j = 0;
        int s = 0;

        r->dp[0] = 0;
        for (i = 0; i < 10; i++) {
            r->dp[j] |= ((mp_digit)a[i]) << s;
            if (s + 26 >= DIGIT_BIT) {
    #if DIGIT_BIT != 32 && DIGIT_BIT != 64
                r->dp[j] &= ((sp_digit)1 << DIGIT_BIT) - 1;
    #endif
                s = DIGIT_BIT - s;
                r->dp[++j] = a[i] >> s;
                s = 26 - s;
            }
            else {
                s += 26;
            }
        }
        r->used = (256 + DIGIT_BIT - 1) / DIGIT_BIT;
        mp_clamp(r);
#endif
    }

    return err;
}

/* Convert a point of type sp_point_256 to type ecc_point.
 *
 * p   Point of type sp_point_256.
 * pm  Point of type ecc_point (result).
 * returns MEMORY_E when allocation of memory in ecc_point fails otherwise
 * MP_OKAY.
 */
static int sp_256_point_to_ecc_point_10(const sp_point_256* p, ecc_point* pm)
{
    int err;

    err = sp_256_to_mp(p->x, pm->x);
    if (err == MP_OKAY) {
        err = sp_256_to_mp(p->y, pm->y);
    }
    if (err == MP_OKAY) {
        err = sp_256_to_mp(p->z, pm->z);
    }

    return err;
}

#define sp_256_mont_reduce_order_10         sp_256_mont_reduce_10

/* Compare a with b in constant time.
 *
 * a  A single precision integer.
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
static sp_digit sp_256_cmp_10(const sp_digit* a, const sp_digit* b)
{
    sp_digit r = 0;
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=9; i>=0; i--) {
        r |= (a[i] - b[i]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#else
    r |= (a[ 9] - b[ 9]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 8] - b[ 8]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 7] - b[ 7]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 6] - b[ 6]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 5] - b[ 5]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 4] - b[ 4]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 3] - b[ 3]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 2] - b[ 2]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 1] - b[ 1]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 0] - b[ 0]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
#endif /* WOLFSSL_SP_SMALL */

    return r;
}

/* Conditionally subtract b from a using the mask m.
 * m is -1 to subtract and 0 when not.
 *
 * r  A single precision number representing condition subtract result.
 * a  A single precision number to subtract from.
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
static void sp_256_cond_sub_10(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 10; i++) {
        r[i] = a[i] - (b[i] & m);
    }
#else
    r[ 0] = a[ 0] - (b[ 0] & m);
    r[ 1] = a[ 1] - (b[ 1] & m);
    r[ 2] = a[ 2] - (b[ 2] & m);
    r[ 3] = a[ 3] - (b[ 3] & m);
    r[ 4] = a[ 4] - (b[ 4] & m);
    r[ 5] = a[ 5] - (b[ 5] & m);
    r[ 6] = a[ 6] - (b[ 6] & m);
    r[ 7] = a[ 7] - (b[ 7] & m);
    r[ 8] = a[ 8] - (b[ 8] & m);
    r[ 9] = a[ 9] - (b[ 9] & m);
#endif /* WOLFSSL_SP_SMALL */
}

/* Mul a by scalar b and add into r. (r += a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_256_mul_add_10(sp_digit* r, const sp_digit* a,
        const sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 10; i++) {
        t += (tb * a[i]) + r[i];
        r[i] = t & 0x3ffffff;
        t >>= 26;
    }
    r[10] += t;
#else
    int64_t tb = b;
    int64_t t[10];

    t[ 0] = tb * a[ 0];
    t[ 1] = tb * a[ 1];
    t[ 2] = tb * a[ 2];
    t[ 3] = tb * a[ 3];
    t[ 4] = tb * a[ 4];
    t[ 5] = tb * a[ 5];
    t[ 6] = tb * a[ 6];
    t[ 7] = tb * a[ 7];
    t[ 8] = tb * a[ 8];
    t[ 9] = tb * a[ 9];
    r[ 0] += (sp_digit)                 (t[ 0] & 0x3ffffff);
    r[ 1] += (sp_digit)((t[ 0] >> 26) + (t[ 1] & 0x3ffffff));
    r[ 2] += (sp_digit)((t[ 1] >> 26) + (t[ 2] & 0x3ffffff));
    r[ 3] += (sp_digit)((t[ 2] >> 26) + (t[ 3] & 0x3ffffff));
    r[ 4] += (sp_digit)((t[ 3] >> 26) + (t[ 4] & 0x3ffffff));
    r[ 5] += (sp_digit)((t[ 4] >> 26) + (t[ 5] & 0x3ffffff));
    r[ 6] += (sp_digit)((t[ 5] >> 26) + (t[ 6] & 0x3ffffff));
    r[ 7] += (sp_digit)((t[ 6] >> 26) + (t[ 7] & 0x3ffffff));
    r[ 8] += (sp_digit)((t[ 7] >> 26) + (t[ 8] & 0x3ffffff));
    r[ 9] += (sp_digit)((t[ 8] >> 26) + (t[ 9] & 0x3ffffff));
    r[10] += (sp_digit) (t[ 9] >> 26);
#endif /* WOLFSSL_SP_SMALL */
}

/* Normalize the values in each word to 26.
 *
 * a  Array of sp_digit to normalize.
 */
static void sp_256_norm_10(sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    for (i = 0; i < 9; i++) {
        a[i+1] += a[i] >> 26;
        a[i] &= 0x3ffffff;
    }
#else
    a[1] += a[0] >> 26; a[0] &= 0x3ffffff;
    a[2] += a[1] >> 26; a[1] &= 0x3ffffff;
    a[3] += a[2] >> 26; a[2] &= 0x3ffffff;
    a[4] += a[3] >> 26; a[3] &= 0x3ffffff;
    a[5] += a[4] >> 26; a[4] &= 0x3ffffff;
    a[6] += a[5] >> 26; a[5] &= 0x3ffffff;
    a[7] += a[6] >> 26; a[6] &= 0x3ffffff;
    a[8] += a[7] >> 26; a[7] &= 0x3ffffff;
    a[9] += a[8] >> 26; a[8] &= 0x3ffffff;
#endif
}

/* Shift the result in the high 256 bits down to the bottom.
 *
 * r  A single precision number.
 * a  A single precision number.
 */
static void sp_256_mont_shift_10(sp_digit* r, const sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    sp_digit n;
    sp_digit s;

    s = a[10];
    n = a[9] >> 22;
    for (i = 0; i < 9; i++) {
        n += (s & 0x3ffffff) << 4;
        r[i] = n & 0x3ffffff;
        n >>= 26;
        s = a[11 + i] + (s >> 26);
    }
    n += s << 4;
    r[9] = n;
#else
    sp_digit n;
    sp_digit s;

    s = a[10]; n = a[9] >> 22;
    n += (s & 0x3ffffff) << 4; r[ 0] = n & 0x3ffffff;
    n >>= 26; s = a[11] + (s >> 26);
    n += (s & 0x3ffffff) << 4; r[ 1] = n & 0x3ffffff;
    n >>= 26; s = a[12] + (s >> 26);
    n += (s & 0x3ffffff) << 4; r[ 2] = n & 0x3ffffff;
    n >>= 26; s = a[13] + (s >> 26);
    n += (s & 0x3ffffff) << 4; r[ 3] = n & 0x3ffffff;
    n >>= 26; s = a[14] + (s >> 26);
    n += (s & 0x3ffffff) << 4; r[ 4] = n & 0x3ffffff;
    n >>= 26; s = a[15] + (s >> 26);
    n += (s & 0x3ffffff) << 4; r[ 5] = n & 0x3ffffff;
    n >>= 26; s = a[16] + (s >> 26);
    n += (s & 0x3ffffff) << 4; r[ 6] = n & 0x3ffffff;
    n >>= 26; s = a[17] + (s >> 26);
    n += (s & 0x3ffffff) << 4; r[ 7] = n & 0x3ffffff;
    n >>= 26; s = a[18] + (s >> 26);
    n += (s & 0x3ffffff) << 4; r[ 8] = n & 0x3ffffff;
    n >>= 26; s = a[19] + (s >> 26);
    n += s << 4;              r[ 9] = n;
#endif /* WOLFSSL_SP_SMALL */
    XMEMSET(&r[10], 0, sizeof(*r) * 10U);
}

/* Reduce the number back to 256 bits using Montgomery reduction.
 *
 * a   A single precision number to reduce in place.
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
static void sp_256_mont_reduce_10(sp_digit* a, const sp_digit* m, sp_digit mp)
{
    int i;
    sp_digit mu;

    if (mp != 1) {
        for (i=0; i<9; i++) {
            mu = (a[i] * mp) & 0x3ffffff;
            sp_256_mul_add_10(a+i, m, mu);
            a[i+1] += a[i] >> 26;
        }
        mu = (a[i] * mp) & 0x3fffffL;
        sp_256_mul_add_10(a+i, m, mu);
        a[i+1] += a[i] >> 26;
        a[i] &= 0x3ffffff;
    }
    else {
        for (i=0; i<9; i++) {
            mu = a[i] & 0x3ffffff;
            sp_256_mul_add_10(a+i, p256_mod, mu);
            a[i+1] += a[i] >> 26;
        }
        mu = a[i] & 0x3fffffL;
        sp_256_mul_add_10(a+i, p256_mod, mu);
        a[i+1] += a[i] >> 26;
        a[i] &= 0x3ffffff;
    }

    sp_256_mont_shift_10(a, a);
    sp_256_cond_sub_10(a, a, m, 0 - (((a[9] >> 22) > 0) ?
            (sp_digit)1 : (sp_digit)0));
    sp_256_norm_10(a);
}

/* Multiply two Montogmery form numbers mod the modulus (prime).
 * (r = a * b mod m)
 *
 * r   Result of multiplication.
 * a   First number to multiply in Montogmery form.
 * b   Second number to multiply in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_256_mont_mul_10(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit* m, sp_digit mp)
{
    sp_256_mul_10(r, a, b);
    sp_256_mont_reduce_10(r, m, mp);
}

/* Square the Montgomery form number. (r = a * a mod m)
 *
 * r   Result of squaring.
 * a   Number to square in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_256_mont_sqr_10(sp_digit* r, const sp_digit* a,
        const sp_digit* m, sp_digit mp)
{
    sp_256_sqr_10(r, a);
    sp_256_mont_reduce_10(r, m, mp);
}

#if !defined(WOLFSSL_SP_SMALL) || defined(HAVE_COMP_KEY)
/* Square the Montgomery form number a number of times. (r = a ^ n mod m)
 *
 * r   Result of squaring.
 * a   Number to square in Montogmery form.
 * n   Number of times to square.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_256_mont_sqr_n_10(sp_digit* r, const sp_digit* a, int n,
        const sp_digit* m, sp_digit mp)
{
    sp_256_mont_sqr_10(r, a, m, mp);
    for (; n > 1; n--) {
        sp_256_mont_sqr_10(r, r, m, mp);
    }
}

#endif /* !WOLFSSL_SP_SMALL | HAVE_COMP_KEY */
#ifdef WOLFSSL_SP_SMALL
/* Mod-2 for the P256 curve. */
static const uint32_t p256_mod_minus_2[8] = {
    0xfffffffdU,0xffffffffU,0xffffffffU,0x00000000U,0x00000000U,0x00000000U,
    0x00000001U,0xffffffffU
};
#endif /* !WOLFSSL_SP_SMALL */

/* Invert the number, in Montgomery form, modulo the modulus (prime) of the
 * P256 curve. (r = 1 / a mod m)
 *
 * r   Inverse result.
 * a   Number to invert.
 * td  Temporary data.
 */
static void sp_256_mont_inv_10(sp_digit* r, const sp_digit* a, sp_digit* td)
{
#ifdef WOLFSSL_SP_SMALL
    sp_digit* t = td;
    int i;

    XMEMCPY(t, a, sizeof(sp_digit) * 10);
    for (i=254; i>=0; i--) {
        sp_256_mont_sqr_10(t, t, p256_mod, p256_mp_mod);
        if (p256_mod_minus_2[i / 32] & ((sp_digit)1 << (i % 32)))
            sp_256_mont_mul_10(t, t, a, p256_mod, p256_mp_mod);
    }
    XMEMCPY(r, t, sizeof(sp_digit) * 10);
#else
    sp_digit* t1 = td;
    sp_digit* t2 = td + 2 * 10;
    sp_digit* t3 = td + 4 * 10;
    /* 0x2 */
    sp_256_mont_sqr_10(t1, a, p256_mod, p256_mp_mod);
    /* 0x3 */
    sp_256_mont_mul_10(t2, t1, a, p256_mod, p256_mp_mod);
    /* 0xc */
    sp_256_mont_sqr_n_10(t1, t2, 2, p256_mod, p256_mp_mod);
    /* 0xd */
    sp_256_mont_mul_10(t3, t1, a, p256_mod, p256_mp_mod);
    /* 0xf */
    sp_256_mont_mul_10(t2, t2, t1, p256_mod, p256_mp_mod);
    /* 0xf0 */
    sp_256_mont_sqr_n_10(t1, t2, 4, p256_mod, p256_mp_mod);
    /* 0xfd */
    sp_256_mont_mul_10(t3, t3, t1, p256_mod, p256_mp_mod);
    /* 0xff */
    sp_256_mont_mul_10(t2, t2, t1, p256_mod, p256_mp_mod);
    /* 0xff00 */
    sp_256_mont_sqr_n_10(t1, t2, 8, p256_mod, p256_mp_mod);
    /* 0xfffd */
    sp_256_mont_mul_10(t3, t3, t1, p256_mod, p256_mp_mod);
    /* 0xffff */
    sp_256_mont_mul_10(t2, t2, t1, p256_mod, p256_mp_mod);
    /* 0xffff0000 */
    sp_256_mont_sqr_n_10(t1, t2, 16, p256_mod, p256_mp_mod);
    /* 0xfffffffd */
    sp_256_mont_mul_10(t3, t3, t1, p256_mod, p256_mp_mod);
    /* 0xffffffff */
    sp_256_mont_mul_10(t2, t2, t1, p256_mod, p256_mp_mod);
    /* 0xffffffff00000000 */
    sp_256_mont_sqr_n_10(t1, t2, 32, p256_mod, p256_mp_mod);
    /* 0xffffffffffffffff */
    sp_256_mont_mul_10(t2, t2, t1, p256_mod, p256_mp_mod);
    /* 0xffffffff00000001 */
    sp_256_mont_mul_10(r, t1, a, p256_mod, p256_mp_mod);
    /* 0xffffffff000000010000000000000000000000000000000000000000 */
    sp_256_mont_sqr_n_10(r, r, 160, p256_mod, p256_mp_mod);
    /* 0xffffffff00000001000000000000000000000000ffffffffffffffff */
    sp_256_mont_mul_10(r, r, t2, p256_mod, p256_mp_mod);
    /* 0xffffffff00000001000000000000000000000000ffffffffffffffff00000000 */
    sp_256_mont_sqr_n_10(r, r, 32, p256_mod, p256_mp_mod);
    /* 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffd */
    sp_256_mont_mul_10(r, r, t3, p256_mod, p256_mp_mod);
#endif /* WOLFSSL_SP_SMALL */
}

/* Map the Montgomery form projective coordinate point to an affine point.
 *
 * r  Resulting affine coordinate point.
 * p  Montgomery form projective coordinate point.
 * t  Temporary ordinate data.
 */
static void sp_256_map_10(sp_point_256* r, const sp_point_256* p,
        sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*10;
    int32_t n;

    sp_256_mont_inv_10(t1, p->z, t + 2*10);

    sp_256_mont_sqr_10(t2, t1, p256_mod, p256_mp_mod);
    sp_256_mont_mul_10(t1, t2, t1, p256_mod, p256_mp_mod);

    /* x /= z^2 */
    sp_256_mont_mul_10(r->x, p->x, t2, p256_mod, p256_mp_mod);
    XMEMSET(r->x + 10, 0, sizeof(r->x) / 2U);
    sp_256_mont_reduce_10(r->x, p256_mod, p256_mp_mod);
    /* Reduce x to less than modulus */
    n = sp_256_cmp_10(r->x, p256_mod);
    sp_256_cond_sub_10(r->x, r->x, p256_mod, 0 - ((n >= 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_256_norm_10(r->x);

    /* y /= z^3 */
    sp_256_mont_mul_10(r->y, p->y, t1, p256_mod, p256_mp_mod);
    XMEMSET(r->y + 10, 0, sizeof(r->y) / 2U);
    sp_256_mont_reduce_10(r->y, p256_mod, p256_mp_mod);
    /* Reduce y to less than modulus */
    n = sp_256_cmp_10(r->y, p256_mod);
    sp_256_cond_sub_10(r->y, r->y, p256_mod, 0 - ((n >= 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_256_norm_10(r->y);

    XMEMSET(r->z, 0, sizeof(r->z));
    r->z[0] = 1;

}

/* Add two Montgomery form numbers (r = a + b % m).
 *
 * r   Result of addition.
 * a   First number to add in Montogmery form.
 * b   Second number to add in Montogmery form.
 * m   Modulus (prime).
 */
static void sp_256_mont_add_10(sp_digit* r, const sp_digit* a, const sp_digit* b,
        const sp_digit* m)
{
    (void)sp_256_add_10(r, a, b);
    sp_256_norm_10(r);
    sp_256_cond_sub_10(r, r, m, 0 - (((r[9] >> 22) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_256_norm_10(r);
}

/* Double a Montgomery form number (r = a + a % m).
 *
 * r   Result of doubling.
 * a   Number to double in Montogmery form.
 * m   Modulus (prime).
 */
static void sp_256_mont_dbl_10(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    (void)sp_256_add_10(r, a, a);
    sp_256_norm_10(r);
    sp_256_cond_sub_10(r, r, m, 0 - (((r[9] >> 22) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_256_norm_10(r);
}

/* Triple a Montgomery form number (r = a + a + a % m).
 *
 * r   Result of Tripling.
 * a   Number to triple in Montogmery form.
 * m   Modulus (prime).
 */
static void sp_256_mont_tpl_10(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    (void)sp_256_add_10(r, a, a);
    sp_256_norm_10(r);
    sp_256_cond_sub_10(r, r, m, 0 - (((r[9] >> 22) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_256_norm_10(r);
    (void)sp_256_add_10(r, r, a);
    sp_256_norm_10(r);
    sp_256_cond_sub_10(r, r, m, 0 - (((r[9] >> 22) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_256_norm_10(r);
}

/* Conditionally add a and b using the mask m.
 * m is -1 to add and 0 when not.
 *
 * r  A single precision number representing conditional add result.
 * a  A single precision number to add with.
 * b  A single precision number to add.
 * m  Mask value to apply.
 */
static void sp_256_cond_add_10(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 10; i++) {
        r[i] = a[i] + (b[i] & m);
    }
#else
    r[ 0] = a[ 0] + (b[ 0] & m);
    r[ 1] = a[ 1] + (b[ 1] & m);
    r[ 2] = a[ 2] + (b[ 2] & m);
    r[ 3] = a[ 3] + (b[ 3] & m);
    r[ 4] = a[ 4] + (b[ 4] & m);
    r[ 5] = a[ 5] + (b[ 5] & m);
    r[ 6] = a[ 6] + (b[ 6] & m);
    r[ 7] = a[ 7] + (b[ 7] & m);
    r[ 8] = a[ 8] + (b[ 8] & m);
    r[ 9] = a[ 9] + (b[ 9] & m);
#endif /* WOLFSSL_SP_SMALL */
}

/* Subtract two Montgomery form numbers (r = a - b % m).
 *
 * r   Result of subtration.
 * a   Number to subtract from in Montogmery form.
 * b   Number to subtract with in Montogmery form.
 * m   Modulus (prime).
 */
static void sp_256_mont_sub_10(sp_digit* r, const sp_digit* a, const sp_digit* b,
        const sp_digit* m)
{
    (void)sp_256_sub_10(r, a, b);
    sp_256_cond_add_10(r, r, m, r[9] >> 22);
    sp_256_norm_10(r);
}

/* Shift number left one bit.
 * Bottom bit is lost.
 *
 * r  Result of shift.
 * a  Number to shift.
 */
SP_NOINLINE static void sp_256_rshift1_10(sp_digit* r, const sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=0; i<9; i++) {
        r[i] = (a[i] >> 1) + ((a[i + 1] << 25) & 0x3ffffff);
    }
#else
    r[0] = (a[0] >> 1) + ((a[1] << 25) & 0x3ffffff);
    r[1] = (a[1] >> 1) + ((a[2] << 25) & 0x3ffffff);
    r[2] = (a[2] >> 1) + ((a[3] << 25) & 0x3ffffff);
    r[3] = (a[3] >> 1) + ((a[4] << 25) & 0x3ffffff);
    r[4] = (a[4] >> 1) + ((a[5] << 25) & 0x3ffffff);
    r[5] = (a[5] >> 1) + ((a[6] << 25) & 0x3ffffff);
    r[6] = (a[6] >> 1) + ((a[7] << 25) & 0x3ffffff);
    r[7] = (a[7] >> 1) + ((a[8] << 25) & 0x3ffffff);
    r[8] = (a[8] >> 1) + ((a[9] << 25) & 0x3ffffff);
#endif
    r[9] = a[9] >> 1;
}

/* Divide the number by 2 mod the modulus (prime). (r = a / 2 % m)
 *
 * r  Result of division by 2.
 * a  Number to divide.
 * m  Modulus (prime).
 */
static void sp_256_div2_10(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    sp_256_cond_add_10(r, a, m, 0 - (a[0] & 1));
    sp_256_norm_10(r);
    sp_256_rshift1_10(r, r);
}

/* Double the Montgomery form projective point p.
 *
 * r  Result of doubling point.
 * p  Point to double.
 * t  Temporary ordinate data.
 */
#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_256_proj_point_dbl_10_ctx {
    int state;
    sp_digit* t1;
    sp_digit* t2;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;
} sp_256_proj_point_dbl_10_ctx;

static int sp_256_proj_point_dbl_10_nb(sp_ecc_ctx_t* sp_ctx, sp_point_256* r, const sp_point_256* p, sp_digit* t)
{
    int err = FP_WOULDBLOCK;
    sp_256_proj_point_dbl_10_ctx* ctx = (sp_256_proj_point_dbl_10_ctx*)sp_ctx->data;

    typedef char ctx_size_test[sizeof(sp_256_proj_point_dbl_10_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    switch (ctx->state) {
    case 0:
        ctx->t1 = t;
        ctx->t2 = t + 2*10;
        ctx->x = r->x;
        ctx->y = r->y;
        ctx->z = r->z;

        /* Put infinity into result. */
        if (r != p) {
            r->infinity = p->infinity;
        }
        ctx->state = 1;
        break;
    case 1:
        /* T1 = Z * Z */
        sp_256_mont_sqr_10(ctx->t1, p->z, p256_mod, p256_mp_mod);
        ctx->state = 2;
        break;
    case 2:
        /* Z = Y * Z */
        sp_256_mont_mul_10(ctx->z, p->y, p->z, p256_mod, p256_mp_mod);
        ctx->state = 3;
        break;
    case 3:
        /* Z = 2Z */
        sp_256_mont_dbl_10(ctx->z, ctx->z, p256_mod);
        ctx->state = 4;
        break;
    case 4:
        /* T2 = X - T1 */
        sp_256_mont_sub_10(ctx->t2, p->x, ctx->t1, p256_mod);
        ctx->state = 5;
        break;
    case 5:
        /* T1 = X + T1 */
        sp_256_mont_add_10(ctx->t1, p->x, ctx->t1, p256_mod);
        ctx->state = 6;
        break;
    case 6:
        /* T2 = T1 * T2 */
        sp_256_mont_mul_10(ctx->t2, ctx->t1, ctx->t2, p256_mod, p256_mp_mod);
        ctx->state = 7;
        break;
    case 7:
        /* T1 = 3T2 */
        sp_256_mont_tpl_10(ctx->t1, ctx->t2, p256_mod);
        ctx->state = 8;
        break;
    case 8:
        /* Y = 2Y */
        sp_256_mont_dbl_10(ctx->y, p->y, p256_mod);
        ctx->state = 9;
        break;
    case 9:
        /* Y = Y * Y */
        sp_256_mont_sqr_10(ctx->y, ctx->y, p256_mod, p256_mp_mod);
        ctx->state = 10;
        break;
    case 10:
        /* T2 = Y * Y */
        sp_256_mont_sqr_10(ctx->t2, ctx->y, p256_mod, p256_mp_mod);
        ctx->state = 11;
        break;
    case 11:
        /* T2 = T2/2 */
        sp_256_div2_10(ctx->t2, ctx->t2, p256_mod);
        ctx->state = 12;
        break;
    case 12:
        /* Y = Y * X */
        sp_256_mont_mul_10(ctx->y, ctx->y, p->x, p256_mod, p256_mp_mod);
        ctx->state = 13;
        break;
    case 13:
        /* X = T1 * T1 */
        sp_256_mont_sqr_10(ctx->x, ctx->t1, p256_mod, p256_mp_mod);
        ctx->state = 14;
        break;
    case 14:
        /* X = X - Y */
        sp_256_mont_sub_10(ctx->x, ctx->x, ctx->y, p256_mod);
        ctx->state = 15;
        break;
    case 15:
        /* X = X - Y */
        sp_256_mont_sub_10(ctx->x, ctx->x, ctx->y, p256_mod);
        ctx->state = 16;
        break;
    case 16:
        /* Y = Y - X */
        sp_256_mont_sub_10(ctx->y, ctx->y, ctx->x, p256_mod);
        ctx->state = 17;
        break;
    case 17:
        /* Y = Y * T1 */
        sp_256_mont_mul_10(ctx->y, ctx->y, ctx->t1, p256_mod, p256_mp_mod);
        ctx->state = 18;
        break;
    case 18:
        /* Y = Y - T2 */
        sp_256_mont_sub_10(ctx->y, ctx->y, ctx->t2, p256_mod);
        ctx->state = 19;
        /* fall-through */
    case 19:
        err = MP_OKAY;
        break;
    }

    if (err == MP_OKAY && ctx->state != 19) {
        err = FP_WOULDBLOCK;
    }

    return err;
}
#endif /* WOLFSSL_SP_NONBLOCK */

static void sp_256_proj_point_dbl_10(sp_point_256* r,
        const sp_point_256* p, sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*10;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;

    x = r->x;
    y = r->y;
    z = r->z;
    /* Put infinity into result. */
    if (r != p) {
        r->infinity = p->infinity;
    }

    /* T1 = Z * Z */
    sp_256_mont_sqr_10(t1, p->z, p256_mod, p256_mp_mod);
    /* Z = Y * Z */
    sp_256_mont_mul_10(z, p->y, p->z, p256_mod, p256_mp_mod);
    /* Z = 2Z */
    sp_256_mont_dbl_10(z, z, p256_mod);
    /* T2 = X - T1 */
    sp_256_mont_sub_10(t2, p->x, t1, p256_mod);
    /* T1 = X + T1 */
    sp_256_mont_add_10(t1, p->x, t1, p256_mod);
    /* T2 = T1 * T2 */
    sp_256_mont_mul_10(t2, t1, t2, p256_mod, p256_mp_mod);
    /* T1 = 3T2 */
    sp_256_mont_tpl_10(t1, t2, p256_mod);
    /* Y = 2Y */
    sp_256_mont_dbl_10(y, p->y, p256_mod);
    /* Y = Y * Y */
    sp_256_mont_sqr_10(y, y, p256_mod, p256_mp_mod);
    /* T2 = Y * Y */
    sp_256_mont_sqr_10(t2, y, p256_mod, p256_mp_mod);
    /* T2 = T2/2 */
    sp_256_div2_10(t2, t2, p256_mod);
    /* Y = Y * X */
    sp_256_mont_mul_10(y, y, p->x, p256_mod, p256_mp_mod);
    /* X = T1 * T1 */
    sp_256_mont_sqr_10(x, t1, p256_mod, p256_mp_mod);
    /* X = X - Y */
    sp_256_mont_sub_10(x, x, y, p256_mod);
    /* X = X - Y */
    sp_256_mont_sub_10(x, x, y, p256_mod);
    /* Y = Y - X */
    sp_256_mont_sub_10(y, y, x, p256_mod);
    /* Y = Y * T1 */
    sp_256_mont_mul_10(y, y, t1, p256_mod, p256_mp_mod);
    /* Y = Y - T2 */
    sp_256_mont_sub_10(y, y, t2, p256_mod);
}

/* Compare two numbers to determine if they are equal.
 * Constant time implementation.
 *
 * a  First number to compare.
 * b  Second number to compare.
 * returns 1 when equal and 0 otherwise.
 */
static int sp_256_cmp_equal_10(const sp_digit* a, const sp_digit* b)
{
    return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2]) | (a[3] ^ b[3]) |
            (a[4] ^ b[4]) | (a[5] ^ b[5]) | (a[6] ^ b[6]) | (a[7] ^ b[7]) |
            (a[8] ^ b[8]) | (a[9] ^ b[9])) == 0;
}

/* Add two Montgomery form projective points.
 *
 * r  Result of addition.
 * p  First point to add.
 * q  Second point to add.
 * t  Temporary ordinate data.
 */

#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_256_proj_point_add_10_ctx {
    int state;
    sp_256_proj_point_dbl_10_ctx dbl_ctx;
    const sp_point_256* ap[2];
    sp_point_256* rp[2];
    sp_digit* t1;
    sp_digit* t2;
    sp_digit* t3;
    sp_digit* t4;
    sp_digit* t5;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;
} sp_256_proj_point_add_10_ctx;

static int sp_256_proj_point_add_10_nb(sp_ecc_ctx_t* sp_ctx, sp_point_256* r, 
    const sp_point_256* p, const sp_point_256* q, sp_digit* t)
{
    int err = FP_WOULDBLOCK;
    sp_256_proj_point_add_10_ctx* ctx = (sp_256_proj_point_add_10_ctx*)sp_ctx->data;

    /* Ensure only the first point is the same as the result. */
    if (q == r) {
        const sp_point_256* a = p;
        p = q;
        q = a;
    }

    typedef char ctx_size_test[sizeof(sp_256_proj_point_add_10_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    switch (ctx->state) {
    case 0: /* INIT */
        ctx->t1 = t;
        ctx->t2 = t + 2*10;
        ctx->t3 = t + 4*10;
        ctx->t4 = t + 6*10;
        ctx->t5 = t + 8*10;

        ctx->state = 1;
        break;
    case 1:
        /* Check double */
        (void)sp_256_sub_10(ctx->t1, p256_mod, q->y);
        sp_256_norm_10(ctx->t1);
        if ((sp_256_cmp_equal_10(p->x, q->x) & sp_256_cmp_equal_10(p->z, q->z) &
            (sp_256_cmp_equal_10(p->y, q->y) | sp_256_cmp_equal_10(p->y, ctx->t1))) != 0)
        {
            XMEMSET(&ctx->dbl_ctx, 0, sizeof(ctx->dbl_ctx));
            ctx->state = 2;
        }
        else {
            ctx->state = 3;
        }
        break;
    case 2:
        err = sp_256_proj_point_dbl_10_nb((sp_ecc_ctx_t*)&ctx->dbl_ctx, r, p, t);
        if (err == MP_OKAY)
            ctx->state = 27; /* done */
        break;
    case 3:
    {
        int i;
        ctx->rp[0] = r;

        /*lint allow cast to different type of pointer*/
        ctx->rp[1] = (sp_point_256*)t; /*lint !e9087 !e740*/
        XMEMSET(ctx->rp[1], 0, sizeof(sp_point_256));
        ctx->x = ctx->rp[p->infinity | q->infinity]->x;
        ctx->y = ctx->rp[p->infinity | q->infinity]->y;
        ctx->z = ctx->rp[p->infinity | q->infinity]->z;

        ctx->ap[0] = p;
        ctx->ap[1] = q;
        for (i=0; i<10; i++) {
            r->x[i] = ctx->ap[p->infinity]->x[i];
        }
        for (i=0; i<10; i++) {
            r->y[i] = ctx->ap[p->infinity]->y[i];
        }
        for (i=0; i<10; i++) {
            r->z[i] = ctx->ap[p->infinity]->z[i];
        }
        r->infinity = ctx->ap[p->infinity]->infinity;

        ctx->state = 4;
        break;
    }
    case 4:
        /* U1 = X1*Z2^2 */
        sp_256_mont_sqr_10(ctx->t1, q->z, p256_mod, p256_mp_mod);
        ctx->state = 5;
        break;
    case 5:
        sp_256_mont_mul_10(ctx->t3, ctx->t1, q->z, p256_mod, p256_mp_mod);
        ctx->state = 6;
        break;
    case 6:
        sp_256_mont_mul_10(ctx->t1, ctx->t1, ctx->x, p256_mod, p256_mp_mod);
        ctx->state = 7;
        break;
    case 7:
        /* U2 = X2*Z1^2 */
        sp_256_mont_sqr_10(ctx->t2, ctx->z, p256_mod, p256_mp_mod);
        ctx->state = 8;
        break;
    case 8:
        sp_256_mont_mul_10(ctx->t4, ctx->t2, ctx->z, p256_mod, p256_mp_mod);
        ctx->state = 9;
        break;
    case 9:
        sp_256_mont_mul_10(ctx->t2, ctx->t2, q->x, p256_mod, p256_mp_mod);
        ctx->state = 10;
        break;
    case 10:
        /* S1 = Y1*Z2^3 */
        sp_256_mont_mul_10(ctx->t3, ctx->t3, ctx->y, p256_mod, p256_mp_mod);
        ctx->state = 11;
        break;
    case 11:
        /* S2 = Y2*Z1^3 */
        sp_256_mont_mul_10(ctx->t4, ctx->t4, q->y, p256_mod, p256_mp_mod);
        ctx->state = 12;
        break;
    case 12:
        /* H = U2 - U1 */
        sp_256_mont_sub_10(ctx->t2, ctx->t2, ctx->t1, p256_mod);
        ctx->state = 13;
        break;
    case 13:
        /* R = S2 - S1 */
        sp_256_mont_sub_10(ctx->t4, ctx->t4, ctx->t3, p256_mod);
        ctx->state = 14;
        break;
    case 14:
        /* Z3 = H*Z1*Z2 */
        sp_256_mont_mul_10(ctx->z, ctx->z, q->z, p256_mod, p256_mp_mod);
        ctx->state = 15;
        break;
    case 15:
        sp_256_mont_mul_10(ctx->z, ctx->z, ctx->t2, p256_mod, p256_mp_mod);
        ctx->state = 16;
        break;
    case 16:
        /* X3 = R^2 - H^3 - 2*U1*H^2 */
        sp_256_mont_sqr_10(ctx->x, ctx->t4, p256_mod, p256_mp_mod);
        ctx->state = 17;
        break;
    case 17:
        sp_256_mont_sqr_10(ctx->t5, ctx->t2, p256_mod, p256_mp_mod);
        ctx->state = 18;
        break;
    case 18:
        sp_256_mont_mul_10(ctx->y, ctx->t1, ctx->t5, p256_mod, p256_mp_mod);
        ctx->state = 19;
        break;
    case 19:
        sp_256_mont_mul_10(ctx->t5, ctx->t5, ctx->t2, p256_mod, p256_mp_mod);
        ctx->state = 20;
        break;
    case 20:
        sp_256_mont_sub_10(ctx->x, ctx->x, ctx->t5, p256_mod);
        ctx->state = 21;
        break;
    case 21:
        sp_256_mont_dbl_10(ctx->t1, ctx->y, p256_mod);
        ctx->state = 22;
        break;
    case 22:
        sp_256_mont_sub_10(ctx->x, ctx->x, ctx->t1, p256_mod);
        ctx->state = 23;
        break;
    case 23:
        /* Y3 = R*(U1*H^2 - X3) - S1*H^3 */
        sp_256_mont_sub_10(ctx->y, ctx->y, ctx->x, p256_mod);
        ctx->state = 24;
        break;
    case 24:
        sp_256_mont_mul_10(ctx->y, ctx->y, ctx->t4, p256_mod, p256_mp_mod);
        ctx->state = 25;
        break;
    case 25:
        sp_256_mont_mul_10(ctx->t5, ctx->t5, ctx->t3, p256_mod, p256_mp_mod);
        ctx->state = 26;
        break;
    case 26:
        sp_256_mont_sub_10(ctx->y, ctx->y, ctx->t5, p256_mod);
        ctx->state = 27;
        /* fall-through */
    case 27:
        err = MP_OKAY;
        break;
    }

    if (err == MP_OKAY && ctx->state != 27) {
        err = FP_WOULDBLOCK;
    }
    return err;
}
#endif /* WOLFSSL_SP_NONBLOCK */

static void sp_256_proj_point_add_10(sp_point_256* r,
        const sp_point_256* p, const sp_point_256* q, sp_digit* t)
{
    const sp_point_256* ap[2];
    sp_point_256* rp[2];
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*10;
    sp_digit* t3 = t + 4*10;
    sp_digit* t4 = t + 6*10;
    sp_digit* t5 = t + 8*10;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;
    int i;

    /* Ensure only the first point is the same as the result. */
    if (q == r) {
        const sp_point_256* a = p;
        p = q;
        q = a;
    }

    /* Check double */
    (void)sp_256_sub_10(t1, p256_mod, q->y);
    sp_256_norm_10(t1);
    if ((sp_256_cmp_equal_10(p->x, q->x) & sp_256_cmp_equal_10(p->z, q->z) &
        (sp_256_cmp_equal_10(p->y, q->y) | sp_256_cmp_equal_10(p->y, t1))) != 0) {
        sp_256_proj_point_dbl_10(r, p, t);
    }
    else {
        rp[0] = r;

        /*lint allow cast to different type of pointer*/
        rp[1] = (sp_point_256*)t; /*lint !e9087 !e740*/
        XMEMSET(rp[1], 0, sizeof(sp_point_256));
        x = rp[p->infinity | q->infinity]->x;
        y = rp[p->infinity | q->infinity]->y;
        z = rp[p->infinity | q->infinity]->z;

        ap[0] = p;
        ap[1] = q;
        for (i=0; i<10; i++) {
            r->x[i] = ap[p->infinity]->x[i];
        }
        for (i=0; i<10; i++) {
            r->y[i] = ap[p->infinity]->y[i];
        }
        for (i=0; i<10; i++) {
            r->z[i] = ap[p->infinity]->z[i];
        }
        r->infinity = ap[p->infinity]->infinity;

        /* U1 = X1*Z2^2 */
        sp_256_mont_sqr_10(t1, q->z, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(t3, t1, q->z, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(t1, t1, x, p256_mod, p256_mp_mod);
        /* U2 = X2*Z1^2 */
        sp_256_mont_sqr_10(t2, z, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(t4, t2, z, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(t2, t2, q->x, p256_mod, p256_mp_mod);
        /* S1 = Y1*Z2^3 */
        sp_256_mont_mul_10(t3, t3, y, p256_mod, p256_mp_mod);
        /* S2 = Y2*Z1^3 */
        sp_256_mont_mul_10(t4, t4, q->y, p256_mod, p256_mp_mod);
        /* H = U2 - U1 */
        sp_256_mont_sub_10(t2, t2, t1, p256_mod);
        /* R = S2 - S1 */
        sp_256_mont_sub_10(t4, t4, t3, p256_mod);
        /* Z3 = H*Z1*Z2 */
        sp_256_mont_mul_10(z, z, q->z, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(z, z, t2, p256_mod, p256_mp_mod);
        /* X3 = R^2 - H^3 - 2*U1*H^2 */
        sp_256_mont_sqr_10(x, t4, p256_mod, p256_mp_mod);
        sp_256_mont_sqr_10(t5, t2, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(y, t1, t5, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(t5, t5, t2, p256_mod, p256_mp_mod);
        sp_256_mont_sub_10(x, x, t5, p256_mod);
        sp_256_mont_dbl_10(t1, y, p256_mod);
        sp_256_mont_sub_10(x, x, t1, p256_mod);
        /* Y3 = R*(U1*H^2 - X3) - S1*H^3 */
        sp_256_mont_sub_10(y, y, x, p256_mod);
        sp_256_mont_mul_10(y, y, t4, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(t5, t5, t3, p256_mod, p256_mp_mod);
        sp_256_mont_sub_10(y, y, t5, p256_mod);
    }
}

/* Multiply a number by Montogmery normalizer mod modulus (prime).
 *
 * r  The resulting Montgomery form number.
 * a  The number to convert.
 * m  The modulus (prime).
 * returns MEMORY_E when memory allocation fails and MP_OKAY otherwise.
 */
static int sp_256_mod_mul_norm_10(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    int64_t* td;
#else
    int64_t td[8];
    int64_t a32d[8];
#endif
    int64_t* t;
    int64_t* a32;
    int64_t o;
    int err = MP_OKAY;

    (void)m;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (int64_t*)XMALLOC(sizeof(int64_t) * 2 * 8, NULL, DYNAMIC_TYPE_ECC);
    if (td == NULL) {
        return MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t = td;
        a32 = td + 8;
#else
        t = td;
        a32 = a32d;
#endif

        a32[0] = a[0];
        a32[0] |= a[1] << 26U;
        a32[0] &= 0xffffffffL;
        a32[1] = (a[1] >> 6);
        a32[1] |= a[2] << 20U;
        a32[1] &= 0xffffffffL;
        a32[2] = (a[2] >> 12);
        a32[2] |= a[3] << 14U;
        a32[2] &= 0xffffffffL;
        a32[3] = (a[3] >> 18);
        a32[3] |= a[4] << 8U;
        a32[3] &= 0xffffffffL;
        a32[4] = (a[4] >> 24);
        a32[4] |= a[5] << 2U;
        a32[4] |= a[6] << 28U;
        a32[4] &= 0xffffffffL;
        a32[5] = (a[6] >> 4);
        a32[5] |= a[7] << 22U;
        a32[5] &= 0xffffffffL;
        a32[6] = (a[7] >> 10);
        a32[6] |= a[8] << 16U;
        a32[6] &= 0xffffffffL;
        a32[7] = (a[8] >> 16);
        a32[7] |= a[9] << 10U;
        a32[7] &= 0xffffffffL;

        /*  1  1  0 -1 -1 -1 -1  0 */
        t[0] = 0 + a32[0] + a32[1] - a32[3] - a32[4] - a32[5] - a32[6];
        /*  0  1  1  0 -1 -1 -1 -1 */
        t[1] = 0 + a32[1] + a32[2] - a32[4] - a32[5] - a32[6] - a32[7];
        /*  0  0  1  1  0 -1 -1 -1 */
        t[2] = 0 + a32[2] + a32[3] - a32[5] - a32[6] - a32[7];
        /* -1 -1  0  2  2  1  0 -1 */
        t[3] = 0 - a32[0] - a32[1] + 2 * a32[3] + 2 * a32[4] + a32[5] - a32[7];
        /*  0 -1 -1  0  2  2  1  0 */
        t[4] = 0 - a32[1] - a32[2] + 2 * a32[4] + 2 * a32[5] + a32[6];
        /*  0  0 -1 -1  0  2  2  1 */
        t[5] = 0 - a32[2] - a32[3] + 2 * a32[5] + 2 * a32[6] + a32[7];
        /* -1 -1  0  0  0  1  3  2 */
        t[6] = 0 - a32[0] - a32[1] + a32[5] + 3 * a32[6] + 2 * a32[7];
        /*  1  0 -1 -1 -1 -1  0  3 */
        t[7] = 0 + a32[0] - a32[2] - a32[3] - a32[4] - a32[5] + 3 * a32[7];

        t[1] += t[0] >> 32U; t[0] &= 0xffffffffL;
        t[2] += t[1] >> 32U; t[1] &= 0xffffffffL;
        t[3] += t[2] >> 32U; t[2] &= 0xffffffffL;
        t[4] += t[3] >> 32U; t[3] &= 0xffffffffL;
        t[5] += t[4] >> 32U; t[4] &= 0xffffffffL;
        t[6] += t[5] >> 32U; t[5] &= 0xffffffffL;
        t[7] += t[6] >> 32U; t[6] &= 0xffffffffL;
        o     = t[7] >> 32U; t[7] &= 0xffffffffL;
        t[0] += o;
        t[3] -= o;
        t[6] -= o;
        t[7] += o;
        t[1] += t[0] >> 32U; t[0] &= 0xffffffffL;
        t[2] += t[1] >> 32U; t[1] &= 0xffffffffL;
        t[3] += t[2] >> 32U; t[2] &= 0xffffffffL;
        t[4] += t[3] >> 32U; t[3] &= 0xffffffffL;
        t[5] += t[4] >> 32U; t[4] &= 0xffffffffL;
        t[6] += t[5] >> 32U; t[5] &= 0xffffffffL;
        t[7] += t[6] >> 32U; t[6] &= 0xffffffffL;

        r[0] = (sp_digit)(t[0]) & 0x3ffffffL;
        r[1] = (sp_digit)(t[0] >> 26U);
        r[1] |= t[1] << 6U;
        r[1] &= 0x3ffffffL;
        r[2] = (sp_digit)(t[1] >> 20U);
        r[2] |= t[2] << 12U;
        r[2] &= 0x3ffffffL;
        r[3] = (sp_digit)(t[2] >> 14U);
        r[3] |= t[3] << 18U;
        r[3] &= 0x3ffffffL;
        r[4] = (sp_digit)(t[3] >> 8U);
        r[4] |= t[4] << 24U;
        r[4] &= 0x3ffffffL;
        r[5] = (sp_digit)(t[4] >> 2U) & 0x3ffffffL;
        r[6] = (sp_digit)(t[4] >> 28U);
        r[6] |= t[5] << 4U;
        r[6] &= 0x3ffffffL;
        r[7] = (sp_digit)(t[5] >> 22U);
        r[7] |= t[6] << 10U;
        r[7] &= 0x3ffffffL;
        r[8] = (sp_digit)(t[6] >> 16U);
        r[8] |= t[7] << 16U;
        r[8] &= 0x3ffffffL;
        r[9] = (sp_digit)(t[7] >> 10U);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_ECC);
    }
#endif

    return err;
}

#ifdef WOLFSSL_SP_SMALL
/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * Small implementation using add and double that is cache attack resistant but
 * allocates memory rather than use large stacks.
 * 256 adds and doubles.
 *
 * r     Resulting point.
 * g     Point to multiply.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */

#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_256_ecc_mulmod_10_ctx {
    int state;
    union {
        sp_256_proj_point_dbl_10_ctx dbl_ctx;
        sp_256_proj_point_add_10_ctx add_ctx;
    };
    sp_point_256 t[3];
    sp_digit tmp[2 * 10 * 5];
    sp_digit n;
    int i;
    int c;
    int y;
} sp_256_ecc_mulmod_10_ctx;

static int sp_256_ecc_mulmod_10_nb(sp_ecc_ctx_t* sp_ctx, sp_point_256* r, 
    const sp_point_256* g, const sp_digit* k, int map, void* heap)
{
    int err = FP_WOULDBLOCK;
    sp_256_ecc_mulmod_10_ctx* ctx = (sp_256_ecc_mulmod_10_ctx*)sp_ctx->data;

    typedef char ctx_size_test[sizeof(sp_256_ecc_mulmod_10_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    switch (ctx->state) {
    case 0: /* INIT */
        XMEMSET(ctx->t, 0, sizeof(sp_point_256) * 3);
        ctx->i = 9;
        ctx->c = 22;
        ctx->n = k[ctx->i--] << (26 - ctx->c);

        /* t[0] = {0, 0, 1} * norm */
        ctx->t[0].infinity = 1;
        ctx->state = 1;
        break;
    case 1: /* T1X */
        /* t[1] = {g->x, g->y, g->z} * norm */
        err = sp_256_mod_mul_norm_10(ctx->t[1].x, g->x, p256_mod);
        ctx->state = 2;
        break;
    case 2: /* T1Y */
        err = sp_256_mod_mul_norm_10(ctx->t[1].y, g->y, p256_mod);
        ctx->state = 3;
        break;
    case 3: /* T1Z */
        err = sp_256_mod_mul_norm_10(ctx->t[1].z, g->z, p256_mod);
        ctx->state = 4;
        break;
    case 4: /* ADDPREP */
        if (ctx->c == 0) {
            if (ctx->i == -1) {
                ctx->state = 7;
                break;
            }

            ctx->n = k[ctx->i--];
            ctx->c = 26;
        }
        ctx->y = (ctx->n >> 25) & 1;
        ctx->n <<= 1;
        XMEMSET(&ctx->add_ctx, 0, sizeof(ctx->add_ctx));
        ctx->state = 5;
        break;
    case 5: /* ADD */
        err = sp_256_proj_point_add_10_nb((sp_ecc_ctx_t*)&ctx->add_ctx, 
            &ctx->t[ctx->y^1], &ctx->t[0], &ctx->t[1], ctx->tmp);
        if (err == MP_OKAY) {
            XMEMCPY(&ctx->t[2], (void*)(((size_t)&ctx->t[0] & addr_mask[ctx->y^1]) +
                                        ((size_t)&ctx->t[1] & addr_mask[ctx->y])),
                    sizeof(sp_point_256));
            XMEMSET(&ctx->dbl_ctx, 0, sizeof(ctx->dbl_ctx));
            ctx->state = 6;
        }
        break;
    case 6: /* DBL */
        err = sp_256_proj_point_dbl_10_nb((sp_ecc_ctx_t*)&ctx->dbl_ctx, &ctx->t[2], 
            &ctx->t[2], ctx->tmp);
        if (err == MP_OKAY) {
            XMEMCPY((void*)(((size_t)&ctx->t[0] & addr_mask[ctx->y^1]) +
                            ((size_t)&ctx->t[1] & addr_mask[ctx->y])), &ctx->t[2],
                    sizeof(sp_point_256));
            ctx->state = 4;
            ctx->c--;
        }
        break;
    case 7: /* MAP */
        if (map != 0) {
            sp_256_map_10(r, &ctx->t[0], ctx->tmp);
        }
        else {
            XMEMCPY(r, &ctx->t[0], sizeof(sp_point_256));
        }
        err = MP_OKAY;
        break;
    }

    if (err == MP_OKAY && ctx->state != 7) {
        err = FP_WOULDBLOCK;
    }
    if (err != FP_WOULDBLOCK) {
        ForceZero(ctx->tmp, sizeof(ctx->tmp));
        ForceZero(ctx->t, sizeof(ctx->t));
    }

    (void)heap;

    return err;
}

#endif /* WOLFSSL_SP_NONBLOCK */

static int sp_256_ecc_mulmod_10(sp_point_256* r, const sp_point_256* g,
        const sp_digit* k, int map, void* heap)
{
#ifdef WOLFSSL_SP_NO_MALLOC
    sp_point_256 t[3];
    sp_digit tmp[2 * 10 * 5];
#else
    sp_point_256* t;
    sp_digit* tmp;
#endif
    sp_digit n;
    int i;
    int c;
    int y;
    int err = MP_OKAY;

    (void)heap;

#ifndef WOLFSSL_SP_NO_MALLOC
    t = (sp_point_256*)XMALLOC(sizeof(sp_point_256) * 3, heap, DYNAMIC_TYPE_ECC);
    if (t == NULL)
        err = MEMORY_E;
    tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 10 * 5, heap,
                                                              DYNAMIC_TYPE_ECC);
    if (tmp == NULL)
        err = MEMORY_E;
#endif

    if (err == MP_OKAY) {
        XMEMSET(t, 0, sizeof(sp_point_256) * 3);

        /* t[0] = {0, 0, 1} * norm */
        t[0].infinity = 1;
        /* t[1] = {g->x, g->y, g->z} * norm */
        err = sp_256_mod_mul_norm_10(t[1].x, g->x, p256_mod);
    }
    if (err == MP_OKAY)
        err = sp_256_mod_mul_norm_10(t[1].y, g->y, p256_mod);
    if (err == MP_OKAY)
        err = sp_256_mod_mul_norm_10(t[1].z, g->z, p256_mod);

    if (err == MP_OKAY) {
        i = 9;
        c = 22;
        n = k[i--] << (26 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1)
                    break;

                n = k[i--];
                c = 26;
            }

            y = (n >> 25) & 1;
            n <<= 1;

            sp_256_proj_point_add_10(&t[y^1], &t[0], &t[1], tmp);

            XMEMCPY(&t[2], (void*)(((size_t)&t[0] & addr_mask[y^1]) +
                                   ((size_t)&t[1] & addr_mask[y])),
                    sizeof(sp_point_256));
            sp_256_proj_point_dbl_10(&t[2], &t[2], tmp);
            XMEMCPY((void*)(((size_t)&t[0] & addr_mask[y^1]) +
                            ((size_t)&t[1] & addr_mask[y])), &t[2],
                    sizeof(sp_point_256));
        }

        if (map != 0) {
            sp_256_map_10(r, &t[0], tmp);
        }
        else {
            XMEMCPY(r, &t[0], sizeof(sp_point_256));
        }
    }

#ifndef WOLFSSL_SP_NO_MALLOC
    if (tmp != NULL) {
        XMEMSET(tmp, 0, sizeof(sp_digit) * 2 * 10 * 5);
        XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
    }
    if (t != NULL) {
        XMEMSET(t, 0, sizeof(sp_point_256) * 3);
        XFREE(t, NULL, DYNAMIC_TYPE_ECC);
    }
#else
    ForceZero(tmp, sizeof(tmp));
    ForceZero(t, sizeof(t));
#endif

    return err;
}

#elif defined(WOLFSSL_SP_CACHE_RESISTANT)
/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * Small implementation using add and double that is cache attack resistant
 * that uses large stack.
 * 256 adds and doubles.
 *
 * r     Resulting point.
 * g     Point to multiply.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_256_ecc_mulmod_10(sp_point_256* r, const sp_point_256* g,
        const sp_digit* k, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_256 t[3];
    sp_digit tmp[2 * 10 * 5];
#else
    sp_point_256* t;
    sp_digit* tmp;
#endif
    sp_digit n;
    int i;
    int c;
    int y;
    int err = MP_OKAY;

    (void)heap;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    t = (sp_point_256*)XMALLOC(sizeof(*t) * 3, heap, DYNAMIC_TYPE_ECC);
    if (t == NULL)
        err = MEMORY_E;
    tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 10 * 5, heap,
                             DYNAMIC_TYPE_ECC);
    if (tmp == NULL)
        err = MEMORY_E;
#endif

    if (err == MP_OKAY) {
        /* t[0] = {0, 0, 1} * norm */
        XMEMSET(&t[0], 0, sizeof(t[0]));
        t[0].infinity = 1;
        /* t[1] = {g->x, g->y, g->z} * norm */
        t[1].infinity = 0;
        err = sp_256_mod_mul_norm_10(t[1].x, g->x, p256_mod);
    }
    if (err == MP_OKAY)
        err = sp_256_mod_mul_norm_10(t[1].y, g->y, p256_mod);
    if (err == MP_OKAY)
        err = sp_256_mod_mul_norm_10(t[1].z, g->z, p256_mod);

    if (err == MP_OKAY) {
        i = 9;
        c = 22;
        n = k[i--] << (26 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1)
                    break;

                n = k[i--];
                c = 26;
            }

            y = (n >> 25) & 1;
            n <<= 1;

            sp_256_proj_point_add_10(&t[y^1], &t[0], &t[1], tmp);

            XMEMCPY(&t[2], (void*)(((size_t)&t[0] & addr_mask[y^1]) +
                                 ((size_t)&t[1] & addr_mask[y])), sizeof(t[2]));
            sp_256_proj_point_dbl_10(&t[2], &t[2], tmp);
            XMEMCPY((void*)(((size_t)&t[0] & addr_mask[y^1]) +
                          ((size_t)&t[1] & addr_mask[y])), &t[2], sizeof(t[2]));
        }

        if (map != 0) {
            sp_256_map_10(r, &t[0], tmp);
        }
        else {
            XMEMCPY(r, &t[0], sizeof(sp_point_256));
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (tmp != NULL) {
        XMEMSET(tmp, 0, sizeof(sp_digit) * 2 * 10 * 5);
        XFREE(tmp, heap, DYNAMIC_TYPE_ECC);
    }
    if (t != NULL) {
        XMEMSET(t, 0, sizeof(sp_point_256) * 3);
        XFREE(t, heap, DYNAMIC_TYPE_ECC);
    }
#else
    ForceZero(tmp, sizeof(tmp));
    ForceZero(t, sizeof(t));
#endif

    return err;
}

#else
/* A table entry for pre-computed points. */
typedef struct sp_table_entry_256 {
    sp_digit x[10];
    sp_digit y[10];
} sp_table_entry_256;

/* Conditionally copy a into r using the mask m.
 * m is -1 to copy and 0 when not.
 *
 * r  A single precision number to copy over.
 * a  A single precision number to copy.
 * m  Mask value to apply.
 */
static void sp_256_cond_copy_10(sp_digit* r, const sp_digit* a, const sp_digit m)
{
    sp_digit t[10];
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 10; i++) {
        t[i] = r[i] ^ a[i];
    }
    for (i = 0; i < 10; i++) {
        r[i] ^= t[i] & m;
    }
#else
    t[ 0] = r[ 0] ^ a[ 0];
    t[ 1] = r[ 1] ^ a[ 1];
    t[ 2] = r[ 2] ^ a[ 2];
    t[ 3] = r[ 3] ^ a[ 3];
    t[ 4] = r[ 4] ^ a[ 4];
    t[ 5] = r[ 5] ^ a[ 5];
    t[ 6] = r[ 6] ^ a[ 6];
    t[ 7] = r[ 7] ^ a[ 7];
    t[ 8] = r[ 8] ^ a[ 8];
    t[ 9] = r[ 9] ^ a[ 9];
    r[ 0] ^= t[ 0] & m;
    r[ 1] ^= t[ 1] & m;
    r[ 2] ^= t[ 2] & m;
    r[ 3] ^= t[ 3] & m;
    r[ 4] ^= t[ 4] & m;
    r[ 5] ^= t[ 5] & m;
    r[ 6] ^= t[ 6] & m;
    r[ 7] ^= t[ 7] & m;
    r[ 8] ^= t[ 8] & m;
    r[ 9] ^= t[ 9] & m;
#endif /* WOLFSSL_SP_SMALL */
}

/* Double the Montgomery form projective point p a number of times.
 *
 * r  Result of repeated doubling of point.
 * p  Point to double.
 * n  Number of times to double
 * t  Temporary ordinate data.
 */
static void sp_256_proj_point_dbl_n_10(sp_point_256* p, int n,
        sp_digit* t)
{
    sp_digit* w = t;
    sp_digit* a = t + 2*10;
    sp_digit* b = t + 4*10;
    sp_digit* t1 = t + 6*10;
    sp_digit* t2 = t + 8*10;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;

    x = p->x;
    y = p->y;
    z = p->z;

    /* Y = 2*Y */
    sp_256_mont_dbl_10(y, y, p256_mod);
    /* W = Z^4 */
    sp_256_mont_sqr_10(w, z, p256_mod, p256_mp_mod);
    sp_256_mont_sqr_10(w, w, p256_mod, p256_mp_mod);

#ifndef WOLFSSL_SP_SMALL
    while (--n > 0)
#else
    while (--n >= 0)
#endif
    {
        /* A = 3*(X^2 - W) */
        sp_256_mont_sqr_10(t1, x, p256_mod, p256_mp_mod);
        sp_256_mont_sub_10(t1, t1, w, p256_mod);
        sp_256_mont_tpl_10(a, t1, p256_mod);
        /* B = X*Y^2 */
        sp_256_mont_sqr_10(t1, y, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(b, t1, x, p256_mod, p256_mp_mod);
        /* X = A^2 - 2B */
        sp_256_mont_sqr_10(x, a, p256_mod, p256_mp_mod);
        sp_256_mont_dbl_10(t2, b, p256_mod);
        sp_256_mont_sub_10(x, x, t2, p256_mod);
        /* Z = Z*Y */
        sp_256_mont_mul_10(z, z, y, p256_mod, p256_mp_mod);
        /* t2 = Y^4 */
        sp_256_mont_sqr_10(t1, t1, p256_mod, p256_mp_mod);
#ifdef WOLFSSL_SP_SMALL
        if (n != 0)
        {
#endif
            /* W = W*Y^4 */
            sp_256_mont_mul_10(w, w, t1, p256_mod, p256_mp_mod);
#ifdef WOLFSSL_SP_SMALL
        }
#endif
        /* y = 2*A*(B - X) - Y^4 */
        sp_256_mont_sub_10(y, b, x, p256_mod);
        sp_256_mont_mul_10(y, y, a, p256_mod, p256_mp_mod);
        sp_256_mont_dbl_10(y, y, p256_mod);
        sp_256_mont_sub_10(y, y, t1, p256_mod);
    }
#ifndef WOLFSSL_SP_SMALL
    /* A = 3*(X^2 - W) */
    sp_256_mont_sqr_10(t1, x, p256_mod, p256_mp_mod);
    sp_256_mont_sub_10(t1, t1, w, p256_mod);
    sp_256_mont_tpl_10(a, t1, p256_mod);
    /* B = X*Y^2 */
    sp_256_mont_sqr_10(t1, y, p256_mod, p256_mp_mod);
    sp_256_mont_mul_10(b, t1, x, p256_mod, p256_mp_mod);
    /* X = A^2 - 2B */
    sp_256_mont_sqr_10(x, a, p256_mod, p256_mp_mod);
    sp_256_mont_dbl_10(t2, b, p256_mod);
    sp_256_mont_sub_10(x, x, t2, p256_mod);
    /* Z = Z*Y */
    sp_256_mont_mul_10(z, z, y, p256_mod, p256_mp_mod);
    /* t2 = Y^4 */
    sp_256_mont_sqr_10(t1, t1, p256_mod, p256_mp_mod);
    /* y = 2*A*(B - X) - Y^4 */
    sp_256_mont_sub_10(y, b, x, p256_mod);
    sp_256_mont_mul_10(y, y, a, p256_mod, p256_mp_mod);
    sp_256_mont_dbl_10(y, y, p256_mod);
    sp_256_mont_sub_10(y, y, t1, p256_mod);
#endif
    /* Y = Y/2 */
    sp_256_div2_10(y, y, p256_mod);
}

/* Double the Montgomery form projective point p a number of times.
 *
 * r  Result of repeated doubling of point.
 * p  Point to double.
 * n  Number of times to double
 * t  Temporary ordinate data.
 */
static void sp_256_proj_point_dbl_n_store_10(sp_point_256* r,
        const sp_point_256* p, int n, int m, sp_digit* t)
{
    sp_digit* w = t;
    sp_digit* a = t + 2*10;
    sp_digit* b = t + 4*10;
    sp_digit* t1 = t + 6*10;
    sp_digit* t2 = t + 8*10;
    sp_digit* x = r[2*m].x;
    sp_digit* y = r[(1<<n)*m].y;
    sp_digit* z = r[2*m].z;
    int i;

    for (i=0; i<10; i++) {
        x[i] = p->x[i];
    }
    for (i=0; i<10; i++) {
        y[i] = p->y[i];
    }
    for (i=0; i<10; i++) {
        z[i] = p->z[i];
    }

    /* Y = 2*Y */
    sp_256_mont_dbl_10(y, y, p256_mod);
    /* W = Z^4 */
    sp_256_mont_sqr_10(w, z, p256_mod, p256_mp_mod);
    sp_256_mont_sqr_10(w, w, p256_mod, p256_mp_mod);
    for (i=1; i<=n; i++) {
        /* A = 3*(X^2 - W) */
        sp_256_mont_sqr_10(t1, x, p256_mod, p256_mp_mod);
        sp_256_mont_sub_10(t1, t1, w, p256_mod);
        sp_256_mont_tpl_10(a, t1, p256_mod);
        /* B = X*Y^2 */
        sp_256_mont_sqr_10(t2, y, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(b, t2, x, p256_mod, p256_mp_mod);
        x = r[(1<<i)*m].x;
        /* X = A^2 - 2B */
        sp_256_mont_sqr_10(x, a, p256_mod, p256_mp_mod);
        sp_256_mont_dbl_10(t1, b, p256_mod);
        sp_256_mont_sub_10(x, x, t1, p256_mod);
        /* Z = Z*Y */
        sp_256_mont_mul_10(r[(1<<i)*m].z, z, y, p256_mod, p256_mp_mod);
        z = r[(1<<i)*m].z;
        /* t2 = Y^4 */
        sp_256_mont_sqr_10(t2, t2, p256_mod, p256_mp_mod);
        if (i != n) {
            /* W = W*Y^4 */
            sp_256_mont_mul_10(w, w, t2, p256_mod, p256_mp_mod);
        }
        /* y = 2*A*(B - X) - Y^4 */
        sp_256_mont_sub_10(y, b, x, p256_mod);
        sp_256_mont_mul_10(y, y, a, p256_mod, p256_mp_mod);
        sp_256_mont_dbl_10(y, y, p256_mod);
        sp_256_mont_sub_10(y, y, t2, p256_mod);

        /* Y = Y/2 */
        sp_256_div2_10(r[(1<<i)*m].y, y, p256_mod);
        r[(1<<i)*m].infinity = 0;
    }
}

/* Add two Montgomery form projective points.
 *
 * ra  Result of addition.
 * rs  Result of subtraction.
 * p   First point to add.
 * q   Second point to add.
 * t   Temporary ordinate data.
 */
static void sp_256_proj_point_add_sub_10(sp_point_256* ra,
        sp_point_256* rs, const sp_point_256* p, const sp_point_256* q,
        sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*10;
    sp_digit* t3 = t + 4*10;
    sp_digit* t4 = t + 6*10;
    sp_digit* t5 = t + 8*10;
    sp_digit* t6 = t + 10*10;
    sp_digit* x = ra->x;
    sp_digit* y = ra->y;
    sp_digit* z = ra->z;
    sp_digit* xs = rs->x;
    sp_digit* ys = rs->y;
    sp_digit* zs = rs->z;


    XMEMCPY(x, p->x, sizeof(p->x) / 2);
    XMEMCPY(y, p->y, sizeof(p->y) / 2);
    XMEMCPY(z, p->z, sizeof(p->z) / 2);
    ra->infinity = 0;
    rs->infinity = 0;

    /* U1 = X1*Z2^2 */
    sp_256_mont_sqr_10(t1, q->z, p256_mod, p256_mp_mod);
    sp_256_mont_mul_10(t3, t1, q->z, p256_mod, p256_mp_mod);
    sp_256_mont_mul_10(t1, t1, x, p256_mod, p256_mp_mod);
    /* U2 = X2*Z1^2 */
    sp_256_mont_sqr_10(t2, z, p256_mod, p256_mp_mod);
    sp_256_mont_mul_10(t4, t2, z, p256_mod, p256_mp_mod);
    sp_256_mont_mul_10(t2, t2, q->x, p256_mod, p256_mp_mod);
    /* S1 = Y1*Z2^3 */
    sp_256_mont_mul_10(t3, t3, y, p256_mod, p256_mp_mod);
    /* S2 = Y2*Z1^3 */
    sp_256_mont_mul_10(t4, t4, q->y, p256_mod, p256_mp_mod);
    /* H = U2 - U1 */
    sp_256_mont_sub_10(t2, t2, t1, p256_mod);
    /* RS = S2 + S1 */
    sp_256_mont_add_10(t6, t4, t3, p256_mod);
    /* R = S2 - S1 */
    sp_256_mont_sub_10(t4, t4, t3, p256_mod);
    /* Z3 = H*Z1*Z2 */
    /* ZS = H*Z1*Z2 */
    sp_256_mont_mul_10(z, z, q->z, p256_mod, p256_mp_mod);
    sp_256_mont_mul_10(z, z, t2, p256_mod, p256_mp_mod);
    XMEMCPY(zs, z, sizeof(p->z)/2);
    /* X3 = R^2 - H^3 - 2*U1*H^2 */
    /* XS = RS^2 - H^3 - 2*U1*H^2 */
    sp_256_mont_sqr_10(x, t4, p256_mod, p256_mp_mod);
    sp_256_mont_sqr_10(xs, t6, p256_mod, p256_mp_mod);
    sp_256_mont_sqr_10(t5, t2, p256_mod, p256_mp_mod);
    sp_256_mont_mul_10(y, t1, t5, p256_mod, p256_mp_mod);
    sp_256_mont_mul_10(t5, t5, t2, p256_mod, p256_mp_mod);
    sp_256_mont_sub_10(x, x, t5, p256_mod);
    sp_256_mont_sub_10(xs, xs, t5, p256_mod);
    sp_256_mont_dbl_10(t1, y, p256_mod);
    sp_256_mont_sub_10(x, x, t1, p256_mod);
    sp_256_mont_sub_10(xs, xs, t1, p256_mod);
    /* Y3 = R*(U1*H^2 - X3) - S1*H^3 */
    /* YS = -RS*(U1*H^2 - XS) - S1*H^3 */
    sp_256_mont_sub_10(ys, y, xs, p256_mod);
    sp_256_mont_sub_10(y, y, x, p256_mod);
    sp_256_mont_mul_10(y, y, t4, p256_mod, p256_mp_mod);
    sp_256_sub_10(t6, p256_mod, t6);
    sp_256_mont_mul_10(ys, ys, t6, p256_mod, p256_mp_mod);
    sp_256_mont_mul_10(t5, t5, t3, p256_mod, p256_mp_mod);
    sp_256_mont_sub_10(y, y, t5, p256_mod);
    sp_256_mont_sub_10(ys, ys, t5, p256_mod);
}

/* Structure used to describe recoding of scalar multiplication. */
typedef struct ecc_recode_256 {
    /* Index into pre-computation table. */
    uint8_t i;
    /* Use the negative of the point. */
    uint8_t neg;
} ecc_recode_256;

/* The index into pre-computation table to use. */
static const uint8_t recode_index_10_6[66] = {
     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
    32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17,
    16, 15, 14, 13, 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,
     0,  1,
};

/* Whether to negate y-ordinate. */
static const uint8_t recode_neg_10_6[66] = {
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
     0,  0,
};

/* Recode the scalar for multiplication using pre-computed values and
 * subtraction.
 *
 * k  Scalar to multiply by.
 * v  Vector of operations to perform.
 */
static void sp_256_ecc_recode_6_10(const sp_digit* k, ecc_recode_256* v)
{
    int i;
    int j;
    uint8_t y;
    int carry = 0;
    int o;
    sp_digit n;

    j = 0;
    n = k[j];
    o = 0;
    for (i=0; i<43; i++) {
        y = (uint8_t)n;
        if (o + 6 < 26) {
            y &= 0x3f;
            n >>= 6;
            o += 6;
        }
        else if (o + 6 == 26) {
            n >>= 6;
            if (++j < 10)
                n = k[j];
            o = 0;
        }
        else if (++j < 10) {
            n = k[j];
            y |= (n << (26 - o)) & 0x3f;
            o -= 20;
            n >>= o;
        }

        y += (uint8_t)carry;
        v[i].i = recode_index_10_6[y];
        v[i].neg = recode_neg_10_6[y];
        carry = (y >> 6) + v[i].neg;
    }
}

/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * r     Resulting point.
 * g     Point to multiply.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_256_ecc_mulmod_win_add_sub_10(sp_point_256* r,
        const sp_point_256* g, const sp_digit* k, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_256 td[33];
    sp_point_256 rtd;
    sp_point_256 pd;
    sp_digit tmpd[2 * 10 * 6];
#endif
    sp_point_256* t;
    sp_point_256* rt;
    sp_point_256* p = NULL;
    sp_digit* tmp;
    sp_digit* negy;
    int i;
    ecc_recode_256 v[43];
    int err;

    (void)heap;

    err = sp_256_point_new_10(heap, rtd, rt);
    if (err == MP_OKAY)
        err = sp_256_point_new_10(heap, pd, p);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    t = (sp_point_256*)XMALLOC(sizeof(sp_point_256) * 33, heap, DYNAMIC_TYPE_ECC);
    if (t == NULL)
        err = MEMORY_E;
    tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 10 * 6, heap,
                             DYNAMIC_TYPE_ECC);
    if (tmp == NULL)
        err = MEMORY_E;
#else
    t = td;
    tmp = tmpd;
#endif


    if (err == MP_OKAY) {
        /* t[0] = {0, 0, 1} * norm */
        XMEMSET(&t[0], 0, sizeof(t[0]));
        t[0].infinity = 1;
        /* t[1] = {g->x, g->y, g->z} * norm */
        err = sp_256_mod_mul_norm_10(t[1].x, g->x, p256_mod);
    }
    if (err == MP_OKAY) {
        err = sp_256_mod_mul_norm_10(t[1].y, g->y, p256_mod);
    }
    if (err == MP_OKAY) {
        err = sp_256_mod_mul_norm_10(t[1].z, g->z, p256_mod);
    }

    if (err == MP_OKAY) {
        t[1].infinity = 0;
        /* t[2] ... t[32]  */
        sp_256_proj_point_dbl_n_store_10(t, &t[ 1], 5, 1, tmp);
        sp_256_proj_point_add_10(&t[ 3], &t[ 2], &t[ 1], tmp);
        sp_256_proj_point_dbl_10(&t[ 6], &t[ 3], tmp);
        sp_256_proj_point_add_sub_10(&t[ 7], &t[ 5], &t[ 6], &t[ 1], tmp);
        sp_256_proj_point_dbl_10(&t[10], &t[ 5], tmp);
        sp_256_proj_point_add_sub_10(&t[11], &t[ 9], &t[10], &t[ 1], tmp);
        sp_256_proj_point_dbl_10(&t[12], &t[ 6], tmp);
        sp_256_proj_point_dbl_10(&t[14], &t[ 7], tmp);
        sp_256_proj_point_add_sub_10(&t[15], &t[13], &t[14], &t[ 1], tmp);
        sp_256_proj_point_dbl_10(&t[18], &t[ 9], tmp);
        sp_256_proj_point_add_sub_10(&t[19], &t[17], &t[18], &t[ 1], tmp);
        sp_256_proj_point_dbl_10(&t[20], &t[10], tmp);
        sp_256_proj_point_dbl_10(&t[22], &t[11], tmp);
        sp_256_proj_point_add_sub_10(&t[23], &t[21], &t[22], &t[ 1], tmp);
        sp_256_proj_point_dbl_10(&t[24], &t[12], tmp);
        sp_256_proj_point_dbl_10(&t[26], &t[13], tmp);
        sp_256_proj_point_add_sub_10(&t[27], &t[25], &t[26], &t[ 1], tmp);
        sp_256_proj_point_dbl_10(&t[28], &t[14], tmp);
        sp_256_proj_point_dbl_10(&t[30], &t[15], tmp);
        sp_256_proj_point_add_sub_10(&t[31], &t[29], &t[30], &t[ 1], tmp);

        negy = t[0].y;

        sp_256_ecc_recode_6_10(k, v);

        i = 42;
        XMEMCPY(rt, &t[v[i].i], sizeof(sp_point_256));
        for (--i; i>=0; i--) {
            sp_256_proj_point_dbl_n_10(rt, 6, tmp);

            XMEMCPY(p, &t[v[i].i], sizeof(sp_point_256));
            sp_256_sub_10(negy, p256_mod, p->y);
            sp_256_norm_10(negy);
            sp_256_cond_copy_10(p->y, negy, (sp_digit)0 - v[i].neg);
            sp_256_proj_point_add_10(rt, rt, p, tmp);
        }

        if (map != 0) {
            sp_256_map_10(r, rt, tmp);
        }
        else {
            XMEMCPY(r, rt, sizeof(sp_point_256));
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (t != NULL)
        XFREE(t, heap, DYNAMIC_TYPE_ECC);
    if (tmp != NULL)
        XFREE(tmp, heap, DYNAMIC_TYPE_ECC);
#endif
    sp_256_point_free_10(p, 0, heap);
    sp_256_point_free_10(rt, 0, heap);

    return err;
}

#ifdef FP_ECC
#endif /* FP_ECC */
/* Add two Montgomery form projective points. The second point has a q value of
 * one.
 * Only the first point can be the same pointer as the result point.
 *
 * r  Result of addition.
 * p  First point to add.
 * q  Second point to add.
 * t  Temporary ordinate data.
 */
static void sp_256_proj_point_add_qz1_10(sp_point_256* r, const sp_point_256* p,
        const sp_point_256* q, sp_digit* t)
{
    const sp_point_256* ap[2];
    sp_point_256* rp[2];
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*10;
    sp_digit* t3 = t + 4*10;
    sp_digit* t4 = t + 6*10;
    sp_digit* t5 = t + 8*10;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;
    int i;

    /* Check double */
    (void)sp_256_sub_10(t1, p256_mod, q->y);
    sp_256_norm_10(t1);
    if ((sp_256_cmp_equal_10(p->x, q->x) & sp_256_cmp_equal_10(p->z, q->z) &
        (sp_256_cmp_equal_10(p->y, q->y) | sp_256_cmp_equal_10(p->y, t1))) != 0) {
        sp_256_proj_point_dbl_10(r, p, t);
    }
    else {
        rp[0] = r;

        /*lint allow cast to different type of pointer*/
        rp[1] = (sp_point_256*)t; /*lint !e9087 !e740*/
        XMEMSET(rp[1], 0, sizeof(sp_point_256));
        x = rp[p->infinity | q->infinity]->x;
        y = rp[p->infinity | q->infinity]->y;
        z = rp[p->infinity | q->infinity]->z;

        ap[0] = p;
        ap[1] = q;
        for (i=0; i<10; i++) {
            r->x[i] = ap[p->infinity]->x[i];
        }
        for (i=0; i<10; i++) {
            r->y[i] = ap[p->infinity]->y[i];
        }
        for (i=0; i<10; i++) {
            r->z[i] = ap[p->infinity]->z[i];
        }
        r->infinity = ap[p->infinity]->infinity;

        /* U2 = X2*Z1^2 */
        sp_256_mont_sqr_10(t2, z, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(t4, t2, z, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(t2, t2, q->x, p256_mod, p256_mp_mod);
        /* S2 = Y2*Z1^3 */
        sp_256_mont_mul_10(t4, t4, q->y, p256_mod, p256_mp_mod);
        /* H = U2 - X1 */
        sp_256_mont_sub_10(t2, t2, x, p256_mod);
        /* R = S2 - Y1 */
        sp_256_mont_sub_10(t4, t4, y, p256_mod);
        /* Z3 = H*Z1 */
        sp_256_mont_mul_10(z, z, t2, p256_mod, p256_mp_mod);
        /* X3 = R^2 - H^3 - 2*X1*H^2 */
        sp_256_mont_sqr_10(t1, t4, p256_mod, p256_mp_mod);
        sp_256_mont_sqr_10(t5, t2, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(t3, x, t5, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(t5, t5, t2, p256_mod, p256_mp_mod);
        sp_256_mont_sub_10(x, t1, t5, p256_mod);
        sp_256_mont_dbl_10(t1, t3, p256_mod);
        sp_256_mont_sub_10(x, x, t1, p256_mod);
        /* Y3 = R*(X1*H^2 - X3) - Y1*H^3 */
        sp_256_mont_sub_10(t3, t3, x, p256_mod);
        sp_256_mont_mul_10(t3, t3, t4, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(t5, t5, y, p256_mod, p256_mp_mod);
        sp_256_mont_sub_10(y, t3, t5, p256_mod);
    }
}

#ifdef FP_ECC
/* Convert the projective point to affine.
 * Ordinates are in Montgomery form.
 *
 * a  Point to convert.
 * t  Temporary data.
 */
static void sp_256_proj_to_affine_10(sp_point_256* a, sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2 * 10;
    sp_digit* tmp = t + 4 * 10;

    sp_256_mont_inv_10(t1, a->z, tmp);

    sp_256_mont_sqr_10(t2, t1, p256_mod, p256_mp_mod);
    sp_256_mont_mul_10(t1, t2, t1, p256_mod, p256_mp_mod);

    sp_256_mont_mul_10(a->x, a->x, t2, p256_mod, p256_mp_mod);
    sp_256_mont_mul_10(a->y, a->y, t1, p256_mod, p256_mp_mod);
    XMEMCPY(a->z, p256_norm_mod, sizeof(p256_norm_mod));
}

/* Generate the pre-computed table of points for the base point.
 *
 * width = 8
 * 256 entries
 * 32 bits between
 *
 * a      The base point.
 * table  Place to store generated point data.
 * tmp    Temporary data.
 * heap  Heap to use for allocation.
 */
static int sp_256_gen_stripe_table_10(const sp_point_256* a,
        sp_table_entry_256* table, sp_digit* tmp, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_256 td;
    sp_point_256 s1d;
    sp_point_256 s2d;
#endif
    sp_point_256* t;
    sp_point_256* s1 = NULL;
    sp_point_256* s2 = NULL;
    int i;
    int j;
    int err;

    (void)heap;

    err = sp_256_point_new_10(heap, td, t);
    if (err == MP_OKAY) {
        err = sp_256_point_new_10(heap, s1d, s1);
    }
    if (err == MP_OKAY) {
        err = sp_256_point_new_10(heap, s2d, s2);
    }

    if (err == MP_OKAY) {
        err = sp_256_mod_mul_norm_10(t->x, a->x, p256_mod);
    }
    if (err == MP_OKAY) {
        err = sp_256_mod_mul_norm_10(t->y, a->y, p256_mod);
    }
    if (err == MP_OKAY) {
        err = sp_256_mod_mul_norm_10(t->z, a->z, p256_mod);
    }
    if (err == MP_OKAY) {
        t->infinity = 0;
        sp_256_proj_to_affine_10(t, tmp);

        XMEMCPY(s1->z, p256_norm_mod, sizeof(p256_norm_mod));
        s1->infinity = 0;
        XMEMCPY(s2->z, p256_norm_mod, sizeof(p256_norm_mod));
        s2->infinity = 0;

        /* table[0] = {0, 0, infinity} */
        XMEMSET(&table[0], 0, sizeof(sp_table_entry_256));
        /* table[1] = Affine version of 'a' in Montgomery form */
        XMEMCPY(table[1].x, t->x, sizeof(table->x));
        XMEMCPY(table[1].y, t->y, sizeof(table->y));

        for (i=1; i<8; i++) {
            sp_256_proj_point_dbl_n_10(t, 32, tmp);
            sp_256_proj_to_affine_10(t, tmp);
            XMEMCPY(table[1<<i].x, t->x, sizeof(table->x));
            XMEMCPY(table[1<<i].y, t->y, sizeof(table->y));
        }

        for (i=1; i<8; i++) {
            XMEMCPY(s1->x, table[1<<i].x, sizeof(table->x));
            XMEMCPY(s1->y, table[1<<i].y, sizeof(table->y));
            for (j=(1<<i)+1; j<(1<<(i+1)); j++) {
                XMEMCPY(s2->x, table[j-(1<<i)].x, sizeof(table->x));
                XMEMCPY(s2->y, table[j-(1<<i)].y, sizeof(table->y));
                sp_256_proj_point_add_qz1_10(t, s1, s2, tmp);
                sp_256_proj_to_affine_10(t, tmp);
                XMEMCPY(table[j].x, t->x, sizeof(table->x));
                XMEMCPY(table[j].y, t->y, sizeof(table->y));
            }
        }
    }

    sp_256_point_free_10(s2, 0, heap);
    sp_256_point_free_10(s1, 0, heap);
    sp_256_point_free_10( t, 0, heap);

    return err;
}

#endif /* FP_ECC */
/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * Stripe implementation.
 * Pre-generated: 2^0, 2^32, ...
 * Pre-generated: products of all combinations of above.
 * 8 doubles and adds (with qz=1)
 *
 * r     Resulting point.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_256_ecc_mulmod_stripe_10(sp_point_256* r,
        const sp_point_256* g, const sp_table_entry_256* table,
        const sp_digit* k, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_256 rtd;
    sp_point_256 pd;
    sp_digit td[2 * 10 * 5];
#endif
    sp_point_256* rt;
    sp_point_256* p = NULL;
    sp_digit* t;
    int i;
    int j;
    int y;
    int x;
    int err;

    (void)g;
    (void)heap;


    err = sp_256_point_new_10(heap, rtd, rt);
    if (err == MP_OKAY) {
        err = sp_256_point_new_10(heap, pd, p);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    t = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 10 * 5, heap,
                           DYNAMIC_TYPE_ECC);
    if (t == NULL) {
        err = MEMORY_E;
    }
#else
    t = td;
#endif

    if (err == MP_OKAY) {
        XMEMCPY(p->z, p256_norm_mod, sizeof(p256_norm_mod));
        XMEMCPY(rt->z, p256_norm_mod, sizeof(p256_norm_mod));

        y = 0;
        x = 31;
        for (j = 0; j < 8; j++) {
            y |= ((k[x / 26] >> (x % 26)) & 1) << j;
            x += 32;
        }
        XMEMCPY(rt->x, table[y].x, sizeof(table[y].x));
        XMEMCPY(rt->y, table[y].y, sizeof(table[y].y));
        rt->infinity = !y;
        for (i = 30; i >= 0; i--) {
            y = 0;
            x = i;
            for (j=0; j<8; j++) {
                y |= ((k[x / 26] >> (x % 26)) & 1) << j;
                x += 32;
            }

            sp_256_proj_point_dbl_10(rt, rt, t);
            XMEMCPY(p->x, table[y].x, sizeof(table[y].x));
            XMEMCPY(p->y, table[y].y, sizeof(table[y].y));
            p->infinity = !y;
            sp_256_proj_point_add_qz1_10(rt, rt, p, t);
        }

        if (map != 0) {
            sp_256_map_10(r, rt, t);
        }
        else {
            XMEMCPY(r, rt, sizeof(sp_point_256));
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (t != NULL) {
        XFREE(t, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_256_point_free_10(p, 0, heap);
    sp_256_point_free_10(rt, 0, heap);

    return err;
}

#ifdef FP_ECC
#ifndef FP_ENTRIES
    #define FP_ENTRIES 16
#endif

/* Cache entry - holds precomputation tables for a point. */
typedef struct sp_cache_256_t {
    /* X ordinate of point that table was generated from. */
    sp_digit x[10];
    /* Y ordinate of point that table was generated from. */
    sp_digit y[10];
    /* Precomputation table for point. */
    sp_table_entry_256 table[256];
    /* Count of entries in table. */
    uint32_t cnt;
    /* Point and table set in entry. */
    int set;
} sp_cache_256_t;

/* Cache of tables. */
static THREAD_LS_T sp_cache_256_t sp_cache_256[FP_ENTRIES];
/* Index of last entry in cache. */
static THREAD_LS_T int sp_cache_256_last = -1;
/* Cache has been initialized. */
static THREAD_LS_T int sp_cache_256_inited = 0;

#ifndef HAVE_THREAD_LS
    static volatile int initCacheMutex_256 = 0;
    static wolfSSL_Mutex sp_cache_256_lock;
#endif

/* Get the cache entry for the point.
 *
 * g      [in]   Point scalar multipling.
 * cache  [out]  Cache table to use.
 */
static void sp_ecc_get_cache_256(const sp_point_256* g,
        sp_cache_256_t** cache)
{
    int i;
    int j;
    uint32_t least;

    if (sp_cache_256_inited == 0) {
        for (i=0; i<FP_ENTRIES; i++) {
            sp_cache_256[i].set = 0;
        }
        sp_cache_256_inited = 1;
    }

    /* Compare point with those in cache. */
    for (i=0; i<FP_ENTRIES; i++) {
        if (!sp_cache_256[i].set)
            continue;

        if (sp_256_cmp_equal_10(g->x, sp_cache_256[i].x) &
                           sp_256_cmp_equal_10(g->y, sp_cache_256[i].y)) {
            sp_cache_256[i].cnt++;
            break;
        }
    }

    /* No match. */
    if (i == FP_ENTRIES) {
        /* Find empty entry. */
        i = (sp_cache_256_last + 1) % FP_ENTRIES;
        for (; i != sp_cache_256_last; i=(i+1)%FP_ENTRIES) {
            if (!sp_cache_256[i].set) {
                break;
            }
        }

        /* Evict least used. */
        if (i == sp_cache_256_last) {
            least = sp_cache_256[0].cnt;
            for (j=1; j<FP_ENTRIES; j++) {
                if (sp_cache_256[j].cnt < least) {
                    i = j;
                    least = sp_cache_256[i].cnt;
                }
            }
        }

        XMEMCPY(sp_cache_256[i].x, g->x, sizeof(sp_cache_256[i].x));
        XMEMCPY(sp_cache_256[i].y, g->y, sizeof(sp_cache_256[i].y));
        sp_cache_256[i].set = 1;
        sp_cache_256[i].cnt = 1;
    }

    *cache = &sp_cache_256[i];
    sp_cache_256_last = i;
}
#endif /* FP_ECC */

/* Multiply the base point of P256 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * r     Resulting point.
 * g     Point to multiply.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_256_ecc_mulmod_10(sp_point_256* r, const sp_point_256* g,
        const sp_digit* k, int map, void* heap)
{
#ifndef FP_ECC
    return sp_256_ecc_mulmod_win_add_sub_10(r, g, k, map, heap);
#else
    sp_digit tmp[2 * 10 * 5];
    sp_cache_256_t* cache;
    int err = MP_OKAY;

#ifndef HAVE_THREAD_LS
    if (initCacheMutex_256 == 0) {
         wc_InitMutex(&sp_cache_256_lock);
         initCacheMutex_256 = 1;
    }
    if (wc_LockMutex(&sp_cache_256_lock) != 0)
       err = BAD_MUTEX_E;
#endif /* HAVE_THREAD_LS */

    if (err == MP_OKAY) {
        sp_ecc_get_cache_256(g, &cache);
        if (cache->cnt == 2)
            sp_256_gen_stripe_table_10(g, cache->table, tmp, heap);

#ifndef HAVE_THREAD_LS
        wc_UnLockMutex(&sp_cache_256_lock);
#endif /* HAVE_THREAD_LS */

        if (cache->cnt < 2) {
            err = sp_256_ecc_mulmod_win_add_sub_10(r, g, k, map, heap);
        }
        else {
            err = sp_256_ecc_mulmod_stripe_10(r, g, cache->table, k,
                    map, heap);
        }
    }

    return err;
#endif
}

#endif
/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * km    Scalar to multiply by.
 * p     Point to multiply.
 * r     Resulting point.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_mulmod_256(const mp_int* km, const ecc_point* gm, ecc_point* r,
    int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_256 p;
    sp_digit kd[10];
#endif
    sp_point_256* point;
    sp_digit* k = NULL;
    int err = MP_OKAY;

    err = sp_256_point_new_10(heap, p, point);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * 10, heap,
                                                              DYNAMIC_TYPE_ECC);
        if (k == NULL)
            err = MEMORY_E;
    }
#else
    k = kd;
#endif
    if (err == MP_OKAY) {
        sp_256_from_mp(k, 10, km);
        sp_256_point_from_ecc_point_10(point, gm);

            err = sp_256_ecc_mulmod_10(point, point, k, map, heap);
    }
    if (err == MP_OKAY) {
        err = sp_256_point_to_ecc_point_10(point, r);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_256_point_free_10(point, 0, heap);

    return err;
}

/* Multiply the point by the scalar, add point a and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * km      Scalar to multiply by.
 * p       Point to multiply.
 * am      Point to add to scalar mulitply result.
 * inMont  Point to add is in montogmery form.
 * r       Resulting point.
 * map     Indicates whether to convert result to affine.
 * heap    Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_mulmod_add_256(const mp_int* km, const ecc_point* gm,
    const ecc_point* am, int inMont, ecc_point* r, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_256 p;
    sp_point_256 a;
    sp_digit kd[10];
    sp_digit t[10 * 2 * 5];
#endif
    sp_point_256* point;
    sp_point_256* addP = NULL;
    sp_digit* k = NULL;
    sp_digit* tmp = NULL;
    int err = MP_OKAY;

    err = sp_256_point_new_10(heap, p, point);
    if (err == MP_OKAY) {
        err = sp_256_point_new_10(heap, a, addP);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * (10 + 10 * 2 * 5), heap, DYNAMIC_TYPE_ECC);
        if (k == NULL) {
            err = MEMORY_E;
        }
        else {
            tmp = k + 10;
        }
    }
#else
    k = kd;
    tmp = t;
#endif
    if (err == MP_OKAY) {
        sp_256_from_mp(k, 10, km);
        sp_256_point_from_ecc_point_10(point, gm);
        sp_256_point_from_ecc_point_10(addP, am);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_256_mod_mul_norm_10(addP->x, addP->x, p256_mod);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_256_mod_mul_norm_10(addP->y, addP->y, p256_mod);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_256_mod_mul_norm_10(addP->z, addP->z, p256_mod);
    }
    if (err == MP_OKAY) {
            err = sp_256_ecc_mulmod_10(point, point, k, 0, heap);
    }
    if (err == MP_OKAY) {
            sp_256_proj_point_add_10(point, point, addP, tmp);

        if (map) {
            sp_256_map_10(point, point, tmp);
        }

        err = sp_256_point_to_ecc_point_10(point, r);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_256_point_free_10(addP, 0, heap);
    sp_256_point_free_10(point, 0, heap);

    return err;
}

#ifdef WOLFSSL_SP_SMALL
/* Multiply the base point of P256 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * r     Resulting point.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_256_ecc_mulmod_base_10(sp_point_256* r, const sp_digit* k,
        int map, void* heap)
{
    /* No pre-computed values. */
    return sp_256_ecc_mulmod_10(r, &p256_base, k, map, heap);
}

#elif defined(WOLFSSL_SP_CACHE_RESISTANT)
/* Multiply the base point of P256 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * r     Resulting point.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_256_ecc_mulmod_base_10(sp_point_256* r, const sp_digit* k,
        int map, void* heap)
{
    /* No pre-computed values. */
    return sp_256_ecc_mulmod_10(r, &p256_base, k, map, heap);
}

#else
/* Striping precomputation table.
 * 8 points combined into a table of 256 points.
 * Distance of 32 between points.
 */
static const sp_table_entry_256 p256_table[256] = {
    /* 0 */
    { { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    /* 1 */
    { { 0x0a9143c,0x1cc3506,0x360179e,0x3f17fb6,0x075ba95,0x1d88944,
        0x3b732b7,0x15719e7,0x376a537,0x0062417 },
      { 0x295560a,0x094d5f3,0x245cddf,0x392e867,0x18b4ab8,0x3487cc9,
        0x288688d,0x176174b,0x3182588,0x0215c7f } },
    /* 2 */
    { { 0x147519a,0x2218090,0x32f0202,0x2b09acd,0x0d0981e,0x1e17af2,
        0x14a7caa,0x163a6a7,0x10ddbdf,0x03654f1 },
      { 0x1590f8f,0x0d8733f,0x09179d6,0x1ad139b,0x372e962,0x0bad933,
        0x1961102,0x223cdff,0x37e9eb2,0x0218fae } },
    /* 3 */
    { { 0x0db6485,0x1ad88d7,0x2f97785,0x288bc28,0x3808f0e,0x3df8c02,
        0x28d9544,0x20280f9,0x055b5ff,0x00001d8 },
      { 0x38d2010,0x13ae6e0,0x308a763,0x2ecc90d,0x254014f,0x10a9981,
        0x247d398,0x0fb8383,0x3613437,0x020c21d } },
    /* 4 */
    { { 0x2a0d2bb,0x08bf145,0x34994f9,0x1b06988,0x30d5cc1,0x1f18b22,
        0x01cf3a5,0x199fe49,0x161fd1b,0x00bd79a },
      { 0x1a01797,0x171c2fd,0x21925c1,0x1358255,0x23d20b4,0x1c7f6d4,
        0x111b370,0x03dec12,0x1168d6f,0x03d923e } },
    /* 5 */
    { { 0x137bbbc,0x19a11f8,0x0bec9e5,0x27a29a8,0x3e43446,0x275cd18,
        0x0427617,0x00056c7,0x285133d,0x016af80 },
      { 0x04c7dab,0x2a0df30,0x0c0792a,0x1310c98,0x3573d9f,0x239b30d,
        0x1315627,0x1ce0c32,0x25b6b6f,0x0252edc } },
    /* 6 */
    { { 0x20f141c,0x26d23dc,0x3c74bbf,0x334b7d6,0x06199b3,0x0441171,
        0x3f61294,0x313bf70,0x3cb2f7d,0x03375ae },
      { 0x2f436fd,0x19c02fa,0x26becca,0x1b6e64c,0x26f647f,0x053c948,
        0x0fa7920,0x397d830,0x2bd4bda,0x028d86f } },
    /* 7 */
    { { 0x17c13c7,0x2895616,0x03e128a,0x17d42df,0x1c38d63,0x0f02747,
        0x039aecf,0x0a4b01c,0x209c4b5,0x02e84b2 },
      { 0x1f91dfd,0x023e916,0x07fb9e4,0x19b3ba8,0x13af43b,0x35e02ca,
        0x0eb0899,0x3bd2c7b,0x19d701f,0x014faee } },
    /* 8 */
    { { 0x0e63d34,0x1fb8c6c,0x0fab4fe,0x1caa795,0x0f46005,0x179ed69,
        0x093334d,0x120c701,0x39206d5,0x021627e },
      { 0x183553a,0x03d7319,0x09e5aa7,0x12b8959,0x2087909,0x0011194,
        0x1045071,0x0713f32,0x16d0254,0x03aec1a } },
    /* 9 */
    { { 0x01647c5,0x1b2856b,0x1799461,0x11f133d,0x0b8127d,0x1937eeb,
        0x266aa37,0x1f68f71,0x0cbd1b2,0x03aca08 },
      { 0x287e008,0x1be361a,0x38f3940,0x276488d,0x2d87dfa,0x0333b2c,
        0x2d2e428,0x368755b,0x09b55a7,0x007ca0a } },
    /* 10 */
    { { 0x389da99,0x2a8300e,0x0022abb,0x27ae0a1,0x0a6f2d7,0x207017a,
        0x047862b,0x1358c9e,0x35905e5,0x00cde92 },
      { 0x1f7794a,0x1d40348,0x3f613c6,0x2ddf5b5,0x0207005,0x133f5ba,
        0x1a37810,0x3ef5829,0x0d5f4c2,0x0035978 } },
    /* 11 */
    { { 0x1275d38,0x026efad,0x2358d9d,0x1142f82,0x14268a7,0x1cfac99,
        0x362ff49,0x288cbc1,0x24252f4,0x0308f68 },
      { 0x394520c,0x06e13c2,0x178e5da,0x18ec16f,0x1096667,0x134a7a8,
        0x0dcb869,0x33fc4e9,0x38cc790,0x006778e } },
    /* 12 */
    { { 0x2c5fe04,0x29c5b09,0x1bdb183,0x02ceee8,0x03b28de,0x132dc4b,
        0x32c586a,0x32ff5d0,0x3d491fc,0x038d372 },
      { 0x2a58403,0x2351aea,0x3a53b40,0x21a0ba5,0x39a6974,0x1aaaa2b,
        0x3901273,0x03dfe78,0x3447b4e,0x039d907 } },
    /* 13 */
    { { 0x364ba59,0x14e5077,0x02fc7d7,0x3b02c09,0x1d33f10,0x0560616,
        0x06dfc6a,0x15efd3c,0x357052a,0x01284b7 },
      { 0x039dbd0,0x18ce3e5,0x3e1fbfa,0x352f794,0x0d3c24b,0x07c6cc5,
        0x1e4ffa2,0x3a91bf5,0x293bb5b,0x01abd6a } },
    /* 14 */
    { { 0x0c91999,0x02da644,0x0491da1,0x100a960,0x00a24b4,0x2330824,
        0x0094b4b,0x1004cf8,0x35a66a4,0x017f8d1 },
      { 0x13e7b4b,0x232af7e,0x391ab0f,0x069f08f,0x3292b50,0x3479898,
        0x2889aec,0x2a4590b,0x308ecfe,0x02d5138 } },
    /* 15 */
    { { 0x2ddfdce,0x231ba45,0x39e6647,0x19be245,0x12c3291,0x35399f8,
        0x0d6e764,0x3082d3a,0x2bda6b0,0x0382dac },
      { 0x37efb57,0x04b7cae,0x00070d3,0x379e431,0x01aac0d,0x1e6f251,
        0x0336ad6,0x0ddd3e4,0x3de25a6,0x01c7008 } },
    /* 16 */
    { { 0x3e20925,0x230912f,0x286762a,0x30e3f73,0x391c19a,0x34e1c18,
        0x16a5d5d,0x093d96a,0x3d421d3,0x0187561 },
      { 0x37173ea,0x19ce8a8,0x0b65e87,0x0214dde,0x2238480,0x16ead0f,
        0x38441e0,0x3bef843,0x2124621,0x03e847f } },
    /* 17 */
    { { 0x0b19ffd,0x247cacb,0x3c231c8,0x16ec648,0x201ba8d,0x2b172a3,
        0x103d678,0x2fb72db,0x04c1f13,0x0161bac },
      { 0x3e8ed09,0x171b949,0x2de20c3,0x0f06067,0x21e81a3,0x1b194be,
        0x0fd6c05,0x13c449e,0x0087086,0x006756b } },
    /* 18 */
    { { 0x09a4e1f,0x27d604c,0x00741e9,0x06fa49c,0x0ab7de7,0x3f4a348,
        0x25ef0be,0x158fc9a,0x33f7f9c,0x039f001 },
      { 0x2f59f76,0x3598e83,0x30501f6,0x15083f2,0x0669b3b,0x29980b5,
        0x0c1f7a7,0x0f02b02,0x0fec65b,0x0382141 } },
    /* 19 */
    { { 0x031b3ca,0x23da368,0x2d66f09,0x27b9b69,0x06d1cab,0x13c91ba,
        0x3d81fa9,0x25ad16f,0x0825b09,0x01e3c06 },
      { 0x225787f,0x3bf790e,0x2c9bb7e,0x0347732,0x28016f8,0x0d6ff0d,
        0x2a4877b,0x1d1e833,0x3b87e94,0x010e9dc } },
    /* 20 */
    { { 0x2b533d5,0x1ddcd34,0x1dc0625,0x3da86f7,0x3673b8a,0x1e7b0a4,
        0x3e7c9aa,0x19ac55d,0x251c3b2,0x02edb79 },
      { 0x25259b3,0x24c0ead,0x3480e7e,0x34f40e9,0x3d6a0af,0x2cf3f09,
        0x2c83d19,0x2e66f16,0x19a5d18,0x0182d18 } },
    /* 21 */
    { { 0x2e5aa1c,0x28e3846,0x3658bd6,0x0ad279c,0x1b8b765,0x397e1fb,
        0x130014e,0x3ff342c,0x3b2aeeb,0x02743c9 },
      { 0x2730a55,0x0918c5e,0x083aca9,0x0bf76ef,0x19c955b,0x300669c,
        0x01dfe0a,0x312341f,0x26d356e,0x0091295 } },
    /* 22 */
    { { 0x2cf1f96,0x00e52ba,0x271c6db,0x2a40930,0x19f2122,0x0b2f4ee,
        0x26ac1b8,0x3bda498,0x0873581,0x0117963 },
      { 0x38f9dbc,0x3d1e768,0x2040d3f,0x11ba222,0x3a8aaf1,0x1b82fb5,
        0x1adfb24,0x2de9251,0x21cc1e4,0x0301038 } },
    /* 23 */
    { { 0x38117b6,0x2bc001b,0x1433847,0x3fdce8d,0x3651969,0x3651d7a,
        0x2b35761,0x1bb1d20,0x097682c,0x00737d7 },
      { 0x1f04839,0x1dd6d04,0x16987db,0x3d12378,0x17dbeac,0x1c2cc86,
        0x121dd1b,0x3fcf6ca,0x1f8a92d,0x00119d5 } },
    /* 24 */
    { { 0x0e8ffcd,0x2b174af,0x1a82cc8,0x22cbf98,0x30d53c4,0x080b5b1,
        0x3161727,0x297cfdb,0x2113b83,0x0011b97 },
      { 0x0007f01,0x23fd936,0x3183e7b,0x0496bd0,0x07fb1ef,0x178680f,
        0x1c5ea63,0x0016c11,0x2c3303d,0x01b8041 } },
    /* 25 */
    { { 0x0dd73b1,0x1cd6122,0x10d948c,0x23e657b,0x3767070,0x15a8aad,
        0x385ea8c,0x33c7ce0,0x0ede901,0x0110965 },
      { 0x2d4b65b,0x2a8b244,0x0c37f8f,0x0ee5b24,0x394c234,0x3a5e347,
        0x26e4a15,0x39a3b4c,0x2514c2e,0x029e5be } },
    /* 26 */
    { { 0x23addd7,0x3ed8120,0x13b3359,0x20f959a,0x09e2a61,0x32fcf20,
        0x05b78e3,0x19ba7e2,0x1a9c697,0x0392b4b },
      { 0x2048a61,0x3dfd0a3,0x19a0357,0x233024b,0x3082d19,0x00fb63b,
        0x3a1af4c,0x1450ff0,0x046c37b,0x0317a50 } },
    /* 27 */
    { { 0x3e75f9e,0x294e30a,0x3a78476,0x3a32c48,0x36fd1a9,0x0427012,
        0x1e4df0b,0x11d1f61,0x1afdb46,0x018ca0f },
      { 0x2f2df15,0x0a33dee,0x27f4ce7,0x1542b66,0x3e592c4,0x20d2f30,
        0x3226ade,0x2a4e3ea,0x1ab1981,0x01a2f46 } },
    /* 28 */
    { { 0x087d659,0x3ab5446,0x305ac08,0x3d2cd64,0x33374d5,0x3f9d3f8,
        0x186981c,0x37f5a5a,0x2f53c6f,0x01254a4 },
      { 0x2cec896,0x1e32786,0x04844a8,0x043b16d,0x3d964b2,0x1935829,
        0x16f7e26,0x1a0dd9a,0x30d2603,0x003b1d4 } },
    /* 29 */
    { { 0x12687bb,0x04e816b,0x21fa2da,0x1abccb8,0x3a1f83b,0x375181e,
        0x0f5ef51,0x0fc2ce4,0x3a66486,0x003d881 },
      { 0x3138233,0x1f8eec3,0x2718bd6,0x1b09caa,0x2dd66b9,0x1bb222b,
        0x1004072,0x1b73e3b,0x07208ed,0x03fc36c } },
    /* 30 */
    { { 0x095d553,0x3e84053,0x0a8a749,0x3f575a0,0x3a44052,0x3ced59b,
        0x3b4317f,0x03a8c60,0x13c8874,0x00c4ed4 },
      { 0x0d11549,0x0b8ab02,0x221cb40,0x02ed37b,0x2071ee1,0x1fc8c83,
        0x3987dd4,0x27e049a,0x0f986f1,0x00b4eaf } },
    /* 31 */
    { { 0x15581a2,0x2214060,0x11af4c2,0x1598c88,0x19a0a6d,0x32acba6,
        0x3a7a0f0,0x2337c66,0x210ded9,0x0300dbe },
      { 0x1fbd009,0x3822eb0,0x181629a,0x2401b45,0x30b68b1,0x2e78363,
        0x2b32779,0x006530b,0x2c4b6d4,0x029aca8 } },
    /* 32 */
    { { 0x13549cf,0x0f943db,0x265ed43,0x1bfeb35,0x06f3369,0x3847f2d,
        0x1bfdacc,0x26181a5,0x252af7c,0x02043b8 },
      { 0x159bb2c,0x143f85c,0x357b654,0x2f9d62c,0x2f7dfbe,0x1a7fa9c,
        0x057e74d,0x05d14ac,0x17a9273,0x035215c } },
    /* 33 */
    { { 0x0cb5a98,0x106a2bc,0x10bf117,0x24c7cc4,0x3d3da8f,0x2ce0ab7,
        0x14e2cba,0x1813866,0x1a72f9a,0x01a9811 },
      { 0x2b2411d,0x3034fe8,0x16e0170,0x0f9443a,0x0be0eb8,0x2196cf3,
        0x0c9f738,0x15e40ef,0x0faf9e1,0x034f917 } },
    /* 34 */
    { { 0x03f7669,0x3da6efa,0x3d6bce1,0x209ca1d,0x109f8ae,0x09109e3,
        0x08ae543,0x3067255,0x1dee3c2,0x0081dd5 },
      { 0x3ef1945,0x358765b,0x28c387b,0x3bec4b4,0x218813c,0x0b7d92a,
        0x3cd1d67,0x2c0367e,0x2e57154,0x0123717 } },
    /* 35 */
    { { 0x3e5a199,0x1e42ffd,0x0bb7123,0x33e6273,0x1e0efb8,0x294671e,
        0x3a2bfe0,0x3d11709,0x2eddff6,0x03cbec2 },
      { 0x0b5025f,0x0255d7c,0x1f2241c,0x35d03ea,0x0550543,0x202fef4,
        0x23c8ad3,0x354963e,0x015db28,0x0284fa4 } },
    /* 36 */
    { { 0x2b65cbc,0x1e8d428,0x0226f9f,0x1c8a919,0x10b04b9,0x08fc1e8,
        0x1ce241e,0x149bc99,0x2b01497,0x00afc35 },
      { 0x3216fb7,0x1374fd2,0x226ad3d,0x19fef76,0x0f7d7b8,0x1c21417,
        0x37b83f6,0x3a27eba,0x25a162f,0x010aa52 } },
    /* 37 */
    { { 0x2adf191,0x1ab42fa,0x28d7584,0x2409689,0x20f8a48,0x253707d,
        0x2030504,0x378f7a1,0x169c65e,0x00b0b76 },
      { 0x3849c17,0x085c764,0x10dd6d0,0x2e87689,0x1460488,0x30e9521,
        0x10c7063,0x1b6f120,0x21f42c5,0x03d0dfe } },
    /* 38 */
    { { 0x20f7dab,0x035c512,0x29ac6aa,0x24c5ddb,0x20f0497,0x17ce5e1,
        0x00a050f,0x1eaa14b,0x3335470,0x02abd16 },
      { 0x18d364a,0x0df0cf0,0x316585e,0x018f925,0x0d40b9b,0x17b1511,
        0x1716811,0x1caf3d0,0x10df4f2,0x0337d8c } },
    /* 39 */
    { { 0x2a8b7ef,0x0f188e3,0x2287747,0x06216f0,0x008e935,0x2f6a38d,
        0x1567722,0x0bfc906,0x0bada9e,0x03c3402 },
      { 0x014d3b1,0x099c749,0x2a76291,0x216c067,0x3b37549,0x14ef2f6,
        0x21b96d4,0x1ee2d71,0x2f5ca88,0x016f570 } },
    /* 40 */
    { { 0x09a3154,0x3d1a7bd,0x2e9aef0,0x255b8ac,0x03e85a5,0x2a492a7,
        0x2aec1ea,0x11c6516,0x3c8a09e,0x02a84b7 },
      { 0x1f69f1d,0x09c89d3,0x1e7326f,0x0b28bfd,0x0e0e4c8,0x1ea7751,
        0x18ce73b,0x2a406e7,0x273e48c,0x01b00db } },
    /* 41 */
    { { 0x36e3138,0x2b84a83,0x345a5cf,0x00096b4,0x16966ef,0x159caf1,
        0x13c64b4,0x2f89226,0x25896af,0x00a4bfd },
      { 0x2213402,0x1435117,0x09fed52,0x09d0e4b,0x0f6580e,0x2871cba,
        0x3b397fd,0x1c9d825,0x090311b,0x0191383 } },
    /* 42 */
    { { 0x07153f0,0x1087869,0x18c9e1e,0x1e64810,0x2b86c3b,0x0175d9c,
        0x3dce877,0x269de4e,0x393cab7,0x03c96b9 },
      { 0x1869d0c,0x06528db,0x02641f3,0x209261b,0x29d55c8,0x25ba517,
        0x3b5ea30,0x028f927,0x25313db,0x00e6e39 } },
    /* 43 */
    { { 0x2fd2e59,0x150802d,0x098f377,0x19a4957,0x135e2c0,0x38a95ce,
        0x1ab21a0,0x36c1b67,0x32f0f19,0x00e448b },
      { 0x3cad53c,0x3387800,0x17e3cfb,0x03f9970,0x3225b2c,0x2a84e1d,
        0x3af1d29,0x3fe35ca,0x2f8ce80,0x0237a02 } },
    /* 44 */
    { { 0x07bbb76,0x3aa3648,0x2758afb,0x1f085e0,0x1921c7e,0x3010dac,
        0x22b74b1,0x230137e,0x1062e36,0x021c652 },
      { 0x3993df5,0x24a2ee8,0x126ab5f,0x2d7cecf,0x0639d75,0x16d5414,
        0x1aa78a8,0x3f78404,0x26a5b74,0x03f0c57 } },
    /* 45 */
    { { 0x0d6ecfa,0x3f506ba,0x3f86561,0x3d86bb1,0x15f8c44,0x2491d07,
        0x052a7b4,0x2422261,0x3adee38,0x039b529 },
      { 0x193c75d,0x14bb451,0x1162605,0x293749c,0x370a70d,0x2e8b1f6,
        0x2ede937,0x2b95f4a,0x39a9be2,0x00d77eb } },
    /* 46 */
    { { 0x2736636,0x15bf36a,0x2b7e6b9,0x25eb8b2,0x209f51d,0x3cd2659,
        0x10bf410,0x034afec,0x3d71c83,0x0076971 },
      { 0x0ce6825,0x07920cf,0x3c3b5c4,0x23fe55c,0x015ad11,0x08c0dae,
        0x0552c7f,0x2e75a8a,0x0fddbf4,0x01c1df0 } },
    /* 47 */
    { { 0x2b9661c,0x0ffe351,0x3d71bf6,0x1ac34b3,0x3a1dfd3,0x211fe3d,
        0x33e140a,0x3f9100d,0x32ee50e,0x014ea18 },
      { 0x16d8051,0x1bfda1a,0x068a097,0x2571d3d,0x1daec0c,0x39389af,
        0x194dc35,0x3f3058a,0x36d34e1,0x000a329 } },
    /* 48 */
    { { 0x09877ee,0x351f73f,0x0002d11,0x0420074,0x2c8b362,0x130982d,
        0x02c1175,0x3c11b40,0x0d86962,0x001305f },
      { 0x0daddf5,0x2f4252c,0x15c06d9,0x1d49339,0x1bea235,0x0b680ed,
        0x3356e67,0x1d1d198,0x1e9fed9,0x03dee93 } },
    /* 49 */
    { { 0x3e1263f,0x2fe8d3a,0x3ce6d0d,0x0d5c6b9,0x3557637,0x0a9bd48,
        0x0405538,0x0710749,0x2005213,0x038c7e5 },
      { 0x26b6ec6,0x2e485ba,0x3c44d1b,0x0b9cf0b,0x037a1d1,0x27428a5,
        0x0e7eac8,0x351ef04,0x259ce34,0x02a8e98 } },
    /* 50 */
    { { 0x2f3dcd3,0x3e77d4d,0x3360fbc,0x1434afd,0x36ceded,0x3d413d6,
        0x1710fad,0x36bb924,0x1627e79,0x008e637 },
      { 0x109569e,0x1c168db,0x3769cf4,0x2ed4527,0x0ea0619,0x17d80d3,
        0x1c03773,0x18843fe,0x1b21c04,0x015c5fd } },
    /* 51 */
    { { 0x1dd895e,0x08a7248,0x04519fe,0x001030a,0x18e5185,0x358dfb3,
        0x13d2391,0x0a37be8,0x0560e3c,0x019828b },
      { 0x27fcbd0,0x2a22bb5,0x30969cc,0x1e03aa7,0x1c84724,0x0ba4ad3,
        0x32f4817,0x0914cca,0x14c4f52,0x01893b9 } },
    /* 52 */
    { { 0x097eccc,0x1273936,0x00aa095,0x364fe62,0x04d49d1,0x10e9f08,
        0x3c24230,0x3ef01c8,0x2fb92bd,0x013ce4a },
      { 0x1e44fd9,0x27e3e9f,0x2156696,0x3915ecc,0x0b66cfb,0x1a3af0f,
        0x2fa8033,0x0e6736c,0x177ccdb,0x0228f9e } },
    /* 53 */
    { { 0x2c4b125,0x06207c1,0x0a8cdde,0x003db8f,0x1ae34e3,0x31e84fa,
        0x2999de5,0x11013bd,0x02370c2,0x00e2234 },
      { 0x0f91081,0x200d591,0x1504762,0x1857c05,0x23d9fcf,0x0cb34db,
        0x27edc86,0x08cd860,0x2471810,0x029798b } },
    /* 54 */
    { { 0x3acd6c8,0x097b8cb,0x3c661a8,0x15152f2,0x1699c63,0x237e64c,
        0x23edf79,0x16b7033,0x0e6466a,0x00b11da },
      { 0x0a64bc9,0x1bfe324,0x1f5cb34,0x08391de,0x0630a60,0x3017a21,
        0x09d064b,0x14a8365,0x041f9e6,0x01ed799 } },
    /* 55 */
    { { 0x128444a,0x2508b07,0x2a39216,0x362f84d,0x2e996c5,0x2c31ff3,
        0x07afe5f,0x1d1288e,0x3cb0c8d,0x02e2bdc },
      { 0x38b86fd,0x3a0ea8c,0x1cff5fd,0x1629629,0x3fee3f1,0x02b250c,
        0x2e8f6f2,0x0225727,0x15f7f3f,0x0280d8e } },
    /* 56 */
    { { 0x10f7770,0x0f1aee8,0x0e248c7,0x20684a8,0x3a6f16d,0x06f0ae7,
        0x0df6825,0x2d4cc40,0x301875f,0x012f8da },
      { 0x3b56dbb,0x1821ba7,0x24f8922,0x22c1f9e,0x0306fef,0x1b54bc8,
        0x2ccc056,0x00303ba,0x2871bdc,0x0232f26 } },
    /* 57 */
    { { 0x0dac4ab,0x0625730,0x3112e13,0x101c4bf,0x3a874a4,0x2873b95,
        0x32ae7c6,0x0d7e18c,0x13e0c08,0x01139d5 },
      { 0x334002d,0x00fffdd,0x025c6d5,0x22c2cd1,0x19d35cb,0x3a1ce2d,
        0x3702760,0x3f06257,0x03a5eb8,0x011c29a } },
    /* 58 */
    { { 0x0513482,0x1d87724,0x276a81b,0x0a807a4,0x3028720,0x339cc20,
        0x2441ee0,0x31bbf36,0x290c63d,0x0059041 },
      { 0x106a2ed,0x0d2819b,0x100bf50,0x114626c,0x1dd4d77,0x2e08632,
        0x14ae72a,0x2ed3f64,0x1fd7abc,0x035cd1e } },
    /* 59 */
    { { 0x2d4c6e5,0x3bec596,0x104d7ed,0x23d6c1b,0x0262cf0,0x15d72c5,
        0x2d5bb18,0x199ac4b,0x1e30771,0x020591a },
      { 0x21e291e,0x2e75e55,0x1661d7a,0x08b0778,0x3eb9daf,0x0d78144,
        0x1827eb1,0x0fe73d2,0x123f0dd,0x0028db7 } },
    /* 60 */
    { { 0x1d5533c,0x34cb1d0,0x228f098,0x27a1a11,0x17c5f5a,0x0d26f44,
        0x2228ade,0x2c460e6,0x3d6fdba,0x038cc77 },
      { 0x3cc6ed8,0x02ada1a,0x260e510,0x2f7bde8,0x37160c3,0x33a1435,
        0x23d9a7b,0x0ce2641,0x02a492e,0x034ed1e } },
    /* 61 */
    { { 0x3821f90,0x26dba3c,0x3aada14,0x3b59bad,0x292edd9,0x2804c45,
        0x3669531,0x296f42e,0x35a4c86,0x01ca049 },
      { 0x3ff47e5,0x2163df4,0x2441503,0x2f18405,0x15e1616,0x37f66ec,
        0x30f11a7,0x141658a,0x27ece14,0x00b018b } },
    /* 62 */
    { { 0x159ac2e,0x3e65bc0,0x2713a76,0x0db2f6c,0x3281e77,0x2391811,
        0x16d2880,0x1fbc4ab,0x1f92c4e,0x00a0a8d },
      { 0x0ce5cd2,0x152c7b0,0x02299c3,0x3244de7,0x2cf99ef,0x3a0b047,
        0x2caf383,0x0aaf664,0x113554d,0x031c735 } },
    /* 63 */
    { { 0x1b578f4,0x177a702,0x3a7a488,0x1638ebf,0x31884e2,0x2460bc7,
        0x36b1b75,0x3ce8e3d,0x340cf47,0x03143d9 },
      { 0x34b68ea,0x12b7ccd,0x1fe2a9c,0x08da659,0x0a406f3,0x1694c14,
        0x06a2228,0x16370be,0x3a72129,0x02e7b2c } },
    /* 64 */
    { { 0x0f8b16a,0x21043bd,0x266a56f,0x3fb11ec,0x197241a,0x36721f0,
        0x006b8e6,0x2ac6c29,0x202cd42,0x0200fcf },
      { 0x0dbec69,0x0c26a01,0x105f7f0,0x3dceeeb,0x3a83b85,0x363865f,
        0x097273a,0x2b70718,0x00e5067,0x03025d1 } },
    /* 65 */
    { { 0x379ab34,0x295bcb0,0x38d1846,0x22e1077,0x3a8ee06,0x1db1a3b,
        0x3144591,0x07cc080,0x2d5915f,0x03c6bcc },
      { 0x175bd50,0x0dd4c57,0x27bc99c,0x2ebdcbd,0x3837cff,0x235dc8f,
        0x13a4184,0x0722c18,0x130e2d4,0x008f43c } },
    /* 66 */
    { { 0x01500d9,0x2adbb7d,0x2da8857,0x397f2fa,0x10d890a,0x25c9654,
        0x3e86488,0x3eb754b,0x1d6c0a3,0x02c0a23 },
      { 0x10bcb08,0x083cc19,0x2e16853,0x04da575,0x271af63,0x2626a9d,
        0x3520a7b,0x32348c7,0x24ff408,0x03ff4dc } },
    /* 67 */
    { { 0x058e6cb,0x1a3992d,0x1d28539,0x080c5e9,0x2992dad,0x2a9d7d5,
        0x14ae0b7,0x09b7ce0,0x34ad78c,0x03d5643 },
      { 0x30ba55a,0x092f4f3,0x0bae0fc,0x12831de,0x20fc472,0x20ed9d2,
        0x29864f6,0x1288073,0x254f6f7,0x00635b6 } },
    /* 68 */
    { { 0x1be5a2b,0x0f88975,0x33c6ed9,0x20d64d3,0x06fe799,0x0989bff,
        0x1409262,0x085a90c,0x0d97990,0x0142eed },
      { 0x17ec63e,0x06471b9,0x0db2378,0x1006077,0x265422c,0x08db83d,
        0x28099b0,0x1270d06,0x11801fe,0x00ac400 } },
    /* 69 */
    { { 0x3391593,0x22d7166,0x30fcfc6,0x2896609,0x3c385f5,0x066b72e,
        0x04f3aad,0x2b831c5,0x19983fb,0x0375562 },
      { 0x0b82ff4,0x222e39d,0x34c993b,0x101c79c,0x2d2e03c,0x0f00c8a,
        0x3a9eaf4,0x1810669,0x151149d,0x039b931 } },
    /* 70 */
    { { 0x29af288,0x1956ec7,0x293155f,0x193deb6,0x1647e1a,0x2ca0839,
        0x297e4bc,0x15bfd0d,0x1b107ed,0x0147803 },
      { 0x31c327e,0x05a6e1d,0x02ad43d,0x02d2a5b,0x129cdb2,0x37ad1de,
        0x3d51f53,0x245df01,0x2414982,0x0388bd0 } },
    /* 71 */
    { { 0x35f1abb,0x17a3d18,0x0874cd4,0x2d5a14e,0x17edc0c,0x16a00d3,
        0x072c1fb,0x1232725,0x33d52dc,0x03dc24d },
      { 0x0af30d6,0x259aeea,0x369c401,0x12bc4de,0x295bf5f,0x0d8711f,
        0x26162a9,0x16c44e5,0x288e727,0x02f54b4 } },
    /* 72 */
    { { 0x05fa877,0x1571ea7,0x3d48ab1,0x1c9f4e8,0x017dad6,0x0f46276,
        0x343f9e7,0x1de990f,0x0e4c8aa,0x028343e },
      { 0x094f92d,0x3abf633,0x1b3a0bb,0x2f83137,0x0d818c8,0x20bae85,
        0x0c65f8b,0x1a8008b,0x0c7946d,0x0295b1e } },
    /* 73 */
    { { 0x1d09529,0x08e46c3,0x1fcf296,0x298f6b7,0x1803e0e,0x2d6fd20,
        0x37351f5,0x0d9e8b1,0x1f8731a,0x0362fbf },
      { 0x00157f4,0x06750bf,0x2650ab9,0x35ffb23,0x2f51cae,0x0b522c2,
        0x39cb400,0x191e337,0x0a5ce9f,0x021529a } },
    /* 74 */
    { { 0x3506ea5,0x17d9ed8,0x0d66dc3,0x22693f8,0x19286c4,0x3a57353,
        0x101d3bf,0x1aa54fc,0x20b9884,0x0172b3a },
      { 0x0eac44d,0x37d8327,0x1c3aa90,0x3d0d534,0x23db29a,0x3576eaf,
        0x1d3de8a,0x3bea423,0x11235e4,0x039260b } },
    /* 75 */
    { { 0x34cd55e,0x01288b0,0x1132231,0x2cc9a03,0x358695b,0x3e87650,
        0x345afa1,0x01267ec,0x3f616b2,0x02011ad },
      { 0x0e7d098,0x0d6078e,0x0b70b53,0x237d1bc,0x0d7f61e,0x132de31,
        0x1ea9ea4,0x2bd54c3,0x27b9082,0x03ac5f2 } },
    /* 76 */
    { { 0x2a145b9,0x06d661d,0x31ec175,0x03f06f1,0x3a5cf6b,0x249c56e,
        0x2035653,0x384c74f,0x0bafab5,0x0025ec0 },
      { 0x25f69e1,0x1b23a55,0x1199aa6,0x16ad6f9,0x077e8f7,0x293f661,
        0x33ba11d,0x3327980,0x07bafdb,0x03e571d } },
    /* 77 */
    { { 0x2bae45e,0x3c074ef,0x2955558,0x3c312f1,0x2a8ebe9,0x2f193f1,
        0x3705b1d,0x360deba,0x01e566e,0x00d4498 },
      { 0x21161cd,0x1bc787e,0x2f87933,0x3553197,0x1328ab8,0x093c879,
        0x17eee27,0x2adad1d,0x1236068,0x003be5c } },
    /* 78 */
    { { 0x0ca4226,0x2633dd5,0x2c8e025,0x0e3e190,0x05eede1,0x1a385e4,
        0x163f744,0x2f25522,0x1333b4f,0x03f05b6 },
      { 0x3c800ca,0x1becc79,0x2daabe9,0x0c499e2,0x1138063,0x3fcfa2d,
        0x2244976,0x1e85cf5,0x2f1b95d,0x0053292 } },
    /* 79 */
    { { 0x12f81d5,0x1dc6eaf,0x11967a4,0x1a407df,0x31a5f9d,0x2b67241,
        0x18bef7c,0x08c7762,0x063f59c,0x01015ec },
      { 0x1c05c0a,0x360bfa2,0x1f85bff,0x1bc7703,0x3e4911c,0x0d685b6,
        0x2fccaea,0x02c4cef,0x164f133,0x0070ed7 } },
    /* 80 */
    { { 0x0ec21fe,0x052ffa0,0x3e825fe,0x1ab0956,0x3f6ce11,0x3d29759,
        0x3c5a072,0x18ebe62,0x148db7e,0x03eb49c },
      { 0x1ab05b3,0x02dab0a,0x1ae690c,0x0f13894,0x137a9a8,0x0aab79f,
        0x3dc875c,0x06a1029,0x1e39f0e,0x01dce1f } },
    /* 81 */
    { { 0x16c0dd7,0x3b31269,0x2c741e9,0x3611821,0x2a5cffc,0x1416bb3,
        0x3a1408f,0x311fa3d,0x1c0bef0,0x02cdee1 },
      { 0x00e6a8f,0x1adb933,0x0f23359,0x2fdace2,0x2fd6d4b,0x0e73bd3,
        0x2453fac,0x0a356ae,0x2c8f9f6,0x02704d6 } },
    /* 82 */
    { { 0x0e35743,0x28c80a1,0x0def32a,0x2c6168f,0x1320d6a,0x37c6606,
        0x21b1761,0x2147ee0,0x21fc433,0x015c84d },
      { 0x1fc9168,0x36cda9c,0x003c1f0,0x1cd7971,0x15f98ba,0x1ef363d,
        0x0ca87e3,0x046f7d9,0x3c9e6bb,0x0372eb0 } },
    /* 83 */
    { { 0x118cbe2,0x3665a11,0x304ef01,0x062727a,0x3d242fc,0x11ffbaf,
        0x3663c7e,0x1a189c9,0x09e2d62,0x02e3072 },
      { 0x0e1d569,0x162f772,0x0cd051a,0x322df62,0x3563809,0x047cc7a,
        0x027fd9f,0x08b509b,0x3da2f94,0x01748ee } },
    /* 84 */
    { { 0x1c8f8be,0x31ca525,0x22bf0a1,0x200efcd,0x02961c4,0x3d8f52b,
        0x018403d,0x3a40279,0x1cb91ec,0x030427e },
      { 0x0945705,0x0257416,0x05c0c2d,0x25b77ae,0x3b9083d,0x2901126,
        0x292b8d7,0x07b8611,0x04f2eee,0x026f0cd } },
    /* 85 */
    { { 0x2913074,0x2b8d590,0x02b10d5,0x09d2295,0x255491b,0x0c41cca,
        0x1ca665b,0x133051a,0x1525f1a,0x00a5647 },
      { 0x04f983f,0x3d6daee,0x04e1e76,0x1067d7e,0x1be7eef,0x02ea862,
        0x00d4968,0x0ccb048,0x11f18ef,0x018dd95 } },
    /* 86 */
    { { 0x22976cc,0x17c5395,0x2c38bda,0x3983bc4,0x222bca3,0x332a614,
        0x3a30646,0x261eaef,0x1c808e2,0x02f6de7 },
      { 0x306a772,0x32d7272,0x2dcefd2,0x2abf94d,0x038f475,0x30ad76e,
        0x23e0227,0x3052b0a,0x001add3,0x023ba18 } },
    /* 87 */
    { { 0x0ade873,0x25a6069,0x248ccbe,0x13713ee,0x17ee9aa,0x28152e9,
        0x2e28995,0x2a92cb3,0x17a6f77,0x024b947 },
      { 0x190a34d,0x2ebea1c,0x1ed1948,0x16fdaf4,0x0d698f7,0x32bc451,
        0x0ee6e30,0x2aaab40,0x06f0a56,0x01460be } },
    /* 88 */
    { { 0x24cc99c,0x1884b1e,0x1ca1fba,0x1a0f9b6,0x2ff609b,0x2b26316,
        0x3b27cb5,0x29bc976,0x35d4073,0x024772a },
      { 0x3575a70,0x1b30f57,0x07fa01b,0x0e5be36,0x20cb361,0x26605cd,
        0x1d4e8c8,0x13cac59,0x2db9797,0x005e833 } },
    /* 89 */
    { { 0x36c8d3a,0x1878a81,0x124b388,0x0e4843e,0x1701aad,0x0ea0d76,
        0x10eae41,0x37d0653,0x36c7f4c,0x00ba338 },
      { 0x37a862b,0x1cf6ac0,0x08fa912,0x2dd8393,0x101ba9b,0x0eebcb7,
        0x2453883,0x1a3cfe5,0x2cb34f6,0x03d3331 } },
    /* 90 */
    { { 0x1f79687,0x3d4973c,0x281544e,0x2564bbe,0x17c5954,0x171e34a,
        0x231741a,0x3cf2784,0x0889a0d,0x02b036d },
      { 0x301747f,0x3f1c477,0x1f1386b,0x163bc5f,0x1592b93,0x332daed,
        0x080e4f5,0x1d28b96,0x26194c9,0x0256992 } },
    /* 91 */
    { { 0x15a4c93,0x07bf6b0,0x114172c,0x1ce0961,0x140269b,0x1b2c2eb,
        0x0dfb1c1,0x019ddaa,0x0ba2921,0x008c795 },
      { 0x2e6d2dc,0x37e45e2,0x2918a70,0x0fce444,0x34d6aa6,0x396dc88,
        0x27726b5,0x0c787d8,0x032d8a7,0x02ac2f8 } },
    /* 92 */
    { { 0x1131f2d,0x2b43a63,0x3101097,0x38cec13,0x0637f09,0x17a69d2,
        0x086196d,0x299e46b,0x0802cf6,0x03c6f32 },
      { 0x0daacb4,0x1a4503a,0x100925c,0x15583d9,0x23c4e40,0x1de4de9,
        0x1cc8fc4,0x2c9c564,0x0695aeb,0x02145a5 } },
    /* 93 */
    { { 0x1dcf593,0x17050fc,0x3e3bde3,0x0a6c062,0x178202b,0x2f7674f,
        0x0dadc29,0x15763a7,0x1d2daad,0x023d9f6 },
      { 0x081ea5f,0x045959d,0x190c841,0x3a78d31,0x0e7d2dd,0x1414fea,
        0x1d43f40,0x22d77ff,0x2b9c072,0x03e115c } },
    /* 94 */
    { { 0x3af71c9,0x29e9c65,0x25655e1,0x111e9cd,0x3a14494,0x3875418,
        0x34ae070,0x0b06686,0x310616b,0x03b7b89 },
      { 0x1734121,0x00d3d44,0x29f0b2f,0x1552897,0x31cac6e,0x1030bb3,
        0x0148f3a,0x35fd237,0x29b44eb,0x027f49f } },
    /* 95 */
    { { 0x2e2cb16,0x1d962bd,0x19b63cc,0x0b3f964,0x3e3eb7d,0x1a35560,
        0x0c58161,0x3ce1d6a,0x3b6958f,0x029030b },
      { 0x2dcc158,0x3b1583f,0x30568c9,0x31957c8,0x27ad804,0x28c1f84,
        0x3967049,0x37b3f64,0x3b87dc6,0x0266f26 } },
    /* 96 */
    { { 0x27dafc6,0x2548764,0x0d1984a,0x1a57027,0x252c1fb,0x24d9b77,
        0x1581a0f,0x1f99276,0x10ba16d,0x026af88 },
      { 0x0915220,0x2be1292,0x16c6480,0x1a93760,0x2fa7317,0x1a07296,
        0x1539871,0x112c31f,0x25787f3,0x01e2070 } },
    /* 97 */
    { { 0x0bcf3ff,0x266d478,0x34f6933,0x31449fd,0x00d02cb,0x340765a,
        0x3465a2d,0x225023e,0x319a30e,0x00579b8 },
      { 0x20e05f4,0x35b834f,0x0404646,0x3710d62,0x3fad7bd,0x13e1434,
        0x21c7d1c,0x1cb3af9,0x2cf1911,0x003957e } },
    /* 98 */
    { { 0x0787564,0x36601be,0x1ce67e9,0x084c7a1,0x21a3317,0x2067a35,
        0x0158cab,0x195ddac,0x1766fe9,0x035cf42 },
      { 0x2b7206e,0x20d0947,0x3b42424,0x03f1862,0x0a51929,0x38c2948,
        0x0bb8595,0x2942d77,0x3748f15,0x0249428 } },
    /* 99 */
    { { 0x2577410,0x3c23e2f,0x28c6caf,0x00d41de,0x0fd408a,0x30298e9,
        0x363289e,0x2302fc7,0x082c1cc,0x01dd050 },
      { 0x30991cd,0x103e9ba,0x029605a,0x19927f7,0x0c1ca08,0x0c93f50,
        0x28a3c7b,0x082e4e9,0x34d12eb,0x0232c13 } },
    /* 100 */
    { { 0x106171c,0x0b4155a,0x0c3fb1c,0x336c090,0x19073e9,0x2241a10,
        0x0e6b4fd,0x0ed476e,0x1ef4712,0x039390a },
      { 0x0ec36f4,0x3754f0e,0x2a270b8,0x007fd2d,0x0f9d2dc,0x1e6a692,
        0x066e078,0x1954974,0x2ff3c6e,0x00def28 } },
    /* 101 */
    { { 0x3562470,0x0b8f1f7,0x0ac94cd,0x28b0259,0x244f272,0x031e4ef,
        0x2d5df98,0x2c8a9f1,0x2dc3002,0x016644f },
      { 0x350592a,0x0e6a0d5,0x1e027a1,0x2039e0f,0x399e01d,0x2817593,
        0x0c0375e,0x3889b3e,0x24ab013,0x010de1b } },
    /* 102 */
    { { 0x256b5a6,0x0ac3b67,0x28f9ff3,0x29b67f1,0x30750d9,0x25e11a9,
        0x15e8455,0x279ebb0,0x298b7e7,0x0218e32 },
      { 0x2fc24b2,0x2b82582,0x28f22f5,0x2bd36b3,0x305398e,0x3b2e9e3,
        0x365dd0a,0x29bc0ed,0x36a7b3a,0x007b374 } },
    /* 103 */
    { { 0x05ff2f3,0x2b3589b,0x29785d3,0x300a1ce,0x0a2d516,0x0844355,
        0x14c9fad,0x3ccb6b6,0x385d459,0x0361743 },
      { 0x0b11da3,0x002e344,0x18c49f7,0x0c29e0c,0x1d2c22c,0x08237b3,
        0x2988f49,0x0f18955,0x1c3b4ed,0x02813c6 } },
    /* 104 */
    { { 0x17f93bd,0x249323b,0x11f6087,0x174e4bd,0x3cb64ac,0x086dc6b,
        0x2e330a8,0x142c1f2,0x2ea5c09,0x024acbb },
      { 0x1b6e235,0x3132521,0x00f085a,0x2a4a4db,0x1ab2ca4,0x0142224,
        0x3aa6b3e,0x09db203,0x2215834,0x007b9e0 } },
    /* 105 */
    { { 0x23e79f7,0x28b8039,0x1906a60,0x2cbce67,0x1f590e7,0x181f027,
        0x21054a6,0x3854240,0x2d857a6,0x03cfcb3 },
      { 0x10d9b55,0x1443cfc,0x2648200,0x2b36190,0x09d2fcf,0x22f439f,
        0x231aa7e,0x3884395,0x0543da3,0x003d5a9 } },
    /* 106 */
    { { 0x043e0df,0x06ffe84,0x3e6d5b2,0x3327001,0x26c74b6,0x12a145e,
        0x256ec0d,0x3898c69,0x3411969,0x02f63c5 },
      { 0x2b7494a,0x2eee1af,0x38388a9,0x1bd17ce,0x21567d4,0x13969e6,
        0x3a12a7a,0x3e8277d,0x03530cc,0x00b4687 } },
    /* 107 */
    { { 0x06508da,0x38e04d4,0x15a7192,0x312875e,0x3336180,0x2a6512c,
        0x1b59497,0x2e91b37,0x25eb91f,0x02841e9 },
      { 0x394d639,0x0747143,0x37d7e6d,0x1d62962,0x08b4af3,0x34df287,
        0x3c5584b,0x26bc869,0x20af87a,0x0060f5d } },
    /* 108 */
    { { 0x1de59a4,0x1a5c443,0x2f8729d,0x01c3a2f,0x0f1ad8d,0x3cbaf9e,
        0x1b49634,0x35d508a,0x39dc269,0x0075105 },
      { 0x390d30e,0x37033e0,0x110cb32,0x14c37a0,0x20a3b27,0x2f00ce6,
        0x2f1dc52,0x34988c6,0x0c29606,0x01dc7e7 } },
    /* 109 */
    { { 0x1040739,0x24f9de1,0x2939999,0x2e6009a,0x244539d,0x17e3f09,
        0x00f6f2f,0x1c63b3d,0x2310362,0x019109e },
      { 0x1428aa8,0x3cb61e1,0x09a84f4,0x0ffafed,0x07b7adc,0x08f406b,
        0x1b2c6df,0x035b480,0x3496ae9,0x012766d } },
    /* 110 */
    { { 0x35d1099,0x2362f10,0x1a08cc7,0x13a3a34,0x12adbcd,0x32da290,
        0x02e2a02,0x151140b,0x01b3f60,0x0240df6 },
      { 0x34c7b61,0x2eb09c1,0x172e7cd,0x2ad5eff,0x2fe2031,0x25b54d4,
        0x0cec965,0x18e7187,0x26a7cc0,0x00230f7 } },
    /* 111 */
    { { 0x2d552ab,0x374083d,0x01f120f,0x2601736,0x156baff,0x04d44a4,
        0x3b7c3e9,0x1acbc1b,0x0424579,0x031a425 },
      { 0x1231bd1,0x0eba710,0x020517b,0x21d7316,0x21eac6e,0x275a848,
        0x0837abf,0x0eb0082,0x302cafe,0x00fe8f6 } },
    /* 112 */
    { { 0x1058880,0x28f9941,0x03f2d75,0x3bd90e5,0x17da365,0x2ac9249,
        0x07861cf,0x023fd05,0x1b0fdb8,0x031712f },
      { 0x272b56b,0x04f8d2c,0x043a735,0x25446e4,0x1c8327e,0x221125a,
        0x0ce37df,0x2dad7f6,0x39446c2,0x00b55b6 } },
    /* 113 */
    { { 0x346ac6b,0x05e0bff,0x2425246,0x0981e8b,0x1d19f79,0x2692378,
        0x3ea3c40,0x2e90beb,0x19de503,0x003d5af },
      { 0x05cda49,0x353b44d,0x299d137,0x3f205bc,0x2821158,0x3ad0d00,
        0x06a54aa,0x2d7c79f,0x39d1173,0x01000ee } },
    /* 114 */
    { { 0x0803387,0x3a06268,0x14043b8,0x3d4e72f,0x1ece115,0x0a1dfc8,
        0x17208dd,0x0be790a,0x122a07f,0x014dd95 },
      { 0x0a4182d,0x202886a,0x1f79a49,0x1e8c867,0x0a2bbd0,0x28668b5,
        0x0d0a2e1,0x115259d,0x3586c5d,0x01e815b } },
    /* 115 */
    { { 0x18a2a47,0x2c95627,0x2773646,0x1230f7c,0x15b5829,0x2fc354e,
        0x2c000ea,0x099d547,0x2f17a1a,0x01df520 },
      { 0x3853948,0x06f6561,0x3feeb8a,0x2f5b3ef,0x3a6f817,0x01a0791,
        0x2ec0578,0x2c392ad,0x12b2b38,0x0104540 } },
    /* 116 */
    { { 0x1e28ced,0x0fc3d1b,0x2c473c7,0x1826c4f,0x21d5da7,0x39718e4,
        0x38ce9e6,0x0251986,0x172fbea,0x0337c11 },
      { 0x053c3b0,0x0f162db,0x043c1cb,0x04111ee,0x297fe3c,0x32e5e03,
        0x2b8ae12,0x0c427ec,0x1da9738,0x03b9c0f } },
    /* 117 */
    { { 0x357e43a,0x054503f,0x11b8345,0x34ec6e0,0x2d44660,0x3d0ae61,
        0x3b5dff8,0x33884ac,0x09da162,0x00a82b6 },
      { 0x3c277ba,0x129a51a,0x027664e,0x1530507,0x0c788c9,0x2afd89d,
        0x1aa64cc,0x1196450,0x367ac2b,0x0358b42 } },
    /* 118 */
    { { 0x0054ac4,0x1761ecb,0x378839c,0x167c9f7,0x2570058,0x0604a35,
        0x37cbf3b,0x0909bb7,0x3f2991c,0x02ce688 },
      { 0x0b16ae5,0x212857c,0x351b952,0x2c684db,0x30c6a05,0x09c01e0,
        0x23c137f,0x1331475,0x092c067,0x0013b40 } },
    /* 119 */
    { { 0x2e90393,0x0617466,0x24e61f4,0x0a528f5,0x03047b4,0x2153f05,
        0x0001a69,0x30e1eb8,0x3c10177,0x0282a47 },
      { 0x22c831e,0x28fc06b,0x3e16ff0,0x208adc9,0x0bb76ae,0x28c1d6d,
        0x12c8a15,0x031063c,0x1889ed2,0x002133e } },
    /* 120 */
    { { 0x0a6becf,0x14277bf,0x3328d98,0x201f7fe,0x12fceae,0x1de3a2e,
        0x0a15c44,0x3ddf976,0x1b273ab,0x0355e55 },
      { 0x1b5d4f1,0x369e78c,0x3a1c210,0x12cf3e9,0x3aa52f0,0x309f082,
        0x112089d,0x107c753,0x24202d1,0x023853a } },
    /* 121 */
    { { 0x2897042,0x140d17c,0x2c4aeed,0x07d0d00,0x18d0533,0x22f7ec8,
        0x19c194c,0x3456323,0x2372aa4,0x0165f86 },
      { 0x30bd68c,0x1fb06b3,0x0945032,0x372ac09,0x06d4be0,0x27f8fa1,
        0x1c8d7ac,0x137a96e,0x236199b,0x0328fc0 } },
    /* 122 */
    { { 0x170bd20,0x2842d58,0x1de7592,0x3c5b4fd,0x20ea897,0x12cab78,
        0x363ff14,0x01f928c,0x17e309c,0x02f79ff },
      { 0x0f5432c,0x2edb4ae,0x044b516,0x32f810d,0x2210dc1,0x23e56d6,
        0x301e6ff,0x34660f6,0x10e0a7d,0x02d88eb } },
    /* 123 */
    { { 0x0c7b65b,0x2f59d58,0x2289a75,0x2408e92,0x1ab8c55,0x1ec99e5,
        0x220fd0d,0x04defe0,0x24658ec,0x035aa8b },
      { 0x138bb85,0x2f002d4,0x295c10a,0x08760ce,0x28c31d1,0x1c0a8cb,
        0x0ff00b1,0x144eac9,0x2e02dcc,0x0044598 } },
    /* 124 */
    { { 0x3b42b87,0x050057b,0x0dff781,0x1c06db1,0x1bd9f5d,0x1f5f04a,
        0x2cccd7a,0x143e19b,0x1cb94b7,0x036cfb8 },
      { 0x34837cf,0x3cf6c3c,0x0d4fb26,0x22ee55e,0x1e7eed1,0x315995f,
        0x2cdf937,0x1a96574,0x0425220,0x0221a99 } },
    /* 125 */
    { { 0x1b569ea,0x0d33ed9,0x19c13c2,0x107dc84,0x2200111,0x0569867,
        0x2dc85da,0x05ef22e,0x0eb018a,0x029c33d },
      { 0x04a6a65,0x3e5eba3,0x378f224,0x09c04d0,0x036e5cf,0x3df8258,
        0x3a609e4,0x1eddef8,0x2abd174,0x02a91dc } },
    /* 126 */
    { { 0x2a60cc0,0x1d84c5e,0x115f676,0x1840da0,0x2c79163,0x2f06ed6,
        0x198bb4b,0x3e5d37b,0x1dc30fa,0x018469b },
      { 0x15ee47a,0x1e32f30,0x16a530e,0x2093836,0x02e8962,0x3767b62,
        0x335adf3,0x27220db,0x2f81642,0x0173ffe } },
    /* 127 */
    { { 0x37a99cd,0x1533fe6,0x05a1c0d,0x27610f1,0x17bf3b9,0x0b1ce78,
        0x0a908f6,0x265300e,0x3237dc1,0x01b969a },
      { 0x3a5db77,0x2d15382,0x0d63ef8,0x1feb3d8,0x0b7b880,0x19820de,
        0x11c0c67,0x2af3396,0x38d242d,0x0120688 } },
    /* 128 */
    { { 0x1d0b34a,0x05ef00d,0x00a7e34,0x1ae0c9f,0x1440b38,0x300d8b4,
        0x37262da,0x3e50e3e,0x14ce0cd,0x00b1044 },
      { 0x195a0b1,0x173bc6b,0x03622ba,0x2a19f55,0x1c09b37,0x07921b2,
        0x16cdd20,0x24a5c9b,0x2bf42ff,0x00811de } },
    /* 129 */
    { { 0x0d65dbf,0x145cf06,0x1ad82f7,0x038ce7b,0x077bf94,0x33c4007,
        0x22d26bd,0x25ad9c0,0x09ac773,0x02b1990 },
      { 0x2261cc3,0x2ecdbf1,0x3e908b0,0x3246439,0x0213f7b,0x1179b04,
        0x01cebaa,0x0be1595,0x175cc12,0x033a39a } },
    /* 130 */
    { { 0x00a67d2,0x086d06f,0x248a0f1,0x0291134,0x362d476,0x166d1cd,
        0x044f1d6,0x2d2a038,0x365250b,0x0023f78 },
      { 0x08bf287,0x3b0f6a1,0x1d6eace,0x20b4cda,0x2c2a621,0x0912520,
        0x02dfdc9,0x1b35cd6,0x3d2565d,0x00bdf8b } },
    /* 131 */
    { { 0x3770fa7,0x2e4b6f0,0x03f9ae4,0x170de41,0x1095e8d,0x1dd845c,
        0x334e9d1,0x00ab953,0x12e9077,0x03196fa },
      { 0x2fd0a40,0x228c0fd,0x384b275,0x38ef339,0x3e7d822,0x3e5d9ef,
        0x24f5854,0x0ece9eb,0x247d119,0x012ffe3 } },
    /* 132 */
    { { 0x0ff1480,0x07487c0,0x1b16cd4,0x1f41d53,0x22ab8fb,0x2f83cfa,
        0x01d2efb,0x259f6b2,0x2e65772,0x00f9392 },
      { 0x05303e6,0x23cdb4f,0x23977e1,0x12e4898,0x03bd999,0x0c930f0,
        0x170e261,0x180a27b,0x2fd58ec,0x014e22b } },
    /* 133 */
    { { 0x25d7713,0x0c5fad7,0x09daad1,0x3b9d779,0x109b985,0x1d3ec98,
        0x35bc4fc,0x2f838cb,0x0d14f75,0x0173e42 },
      { 0x2657b12,0x10d4423,0x19e6760,0x296e5bb,0x2bfd421,0x25c3330,
        0x29f51f8,0x0338838,0x24060f0,0x029a62e } },
    /* 134 */
    { { 0x3748fec,0x2c5a1bb,0x2cf973d,0x289fa74,0x3e6e755,0x38997bf,
        0x0b6544c,0x2b6358c,0x38a7aeb,0x02c50bb },
      { 0x3d5770a,0x06be7c5,0x012fad3,0x19cb2cd,0x266af3b,0x3ccd677,
        0x160d1bd,0x141d5af,0x2965851,0x034625a } },
    /* 135 */
    { { 0x3c41c08,0x255eacc,0x22e1ec5,0x2b151a3,0x087de94,0x311cbdb,
        0x016b73a,0x368e462,0x20b7981,0x0099ec3 },
      { 0x262b988,0x1539763,0x21e76e5,0x15445b4,0x1d8ddc7,0x34a9be6,
        0x10faf03,0x24e4d18,0x07aa111,0x02d538a } },
    /* 136 */
    { { 0x38a876b,0x048ad45,0x04b40a0,0x3fc2144,0x251ff96,0x13ca7dd,
        0x0b31ab1,0x3539814,0x28b5f87,0x0212aec },
      { 0x270790a,0x350e7e0,0x346bd5e,0x276178f,0x22d6cb5,0x3078884,
        0x355c1b6,0x15901d7,0x3671765,0x03950db } },
    /* 137 */
    { { 0x286e8d5,0x2409788,0x13be53f,0x2d21911,0x0353c95,0x10238e8,
        0x32f5bde,0x3a67b60,0x28b5b9c,0x001013d },
      { 0x381e8e5,0x0cef7a9,0x2f5bcad,0x06058f0,0x33cdf50,0x04672a8,
        0x1769600,0x31c055d,0x3df0ac1,0x00e9098 } },
    /* 138 */
    { { 0x2eb596d,0x197b326,0x12b4c29,0x39c08f2,0x101ea03,0x3804e58,
        0x04b4b62,0x28d9d1c,0x13f905e,0x0032a3f },
      { 0x11b2b61,0x08e9095,0x0d06925,0x270e43f,0x21eb7a8,0x0e4a98f,
        0x31d2be0,0x030cf9f,0x2644ddb,0x025b728 } },
    /* 139 */
    { { 0x07510af,0x2ed0e8e,0x2a01203,0x2a2a68d,0x0846fea,0x3e540de,
        0x3a57702,0x1677348,0x2123aad,0x010d8f8 },
      { 0x0246a47,0x0e871d0,0x124dca4,0x34b9577,0x2b362b8,0x363ebe5,
        0x3086045,0x26313e6,0x15cd8bb,0x0210384 } },
    /* 140 */
    { { 0x023e8a7,0x0817884,0x3a0bf12,0x3376371,0x3c808a8,0x18e9777,
        0x12a2721,0x35b538a,0x2bd30de,0x017835a },
      { 0x0fc0f64,0x1c8709f,0x2d8807a,0x0743957,0x242eec0,0x347e76c,
        0x27bef91,0x289689a,0x0f42945,0x01f7a92 } },
    /* 141 */
    { { 0x1060a81,0x3dbc739,0x1615abd,0x1cbe3e5,0x3e79f9c,0x1ab09a2,
        0x136c540,0x05b473f,0x2beebfd,0x02af0a8 },
      { 0x3e2eac7,0x19be474,0x04668ac,0x18f4b74,0x36f10ba,0x0a0b4c6,
        0x10e3770,0x3bf059e,0x3946c7e,0x013a8d4 } },
    /* 142 */
    { { 0x266309d,0x28be354,0x1a3eed8,0x3020651,0x10a51c6,0x1e31770,
        0x0af45a5,0x3ff0f3b,0x2891c94,0x00e9db9 },
      { 0x17b0d0f,0x33a291f,0x0a5f9aa,0x25a3d61,0x2963ace,0x39a5fef,
        0x230c724,0x1919146,0x10a465e,0x02084a8 } },
    /* 143 */
    { { 0x3ab8caa,0x31870f3,0x2390ef7,0x2103850,0x218eb8e,0x3a5ccf2,
        0x1dff677,0x2c59334,0x371599c,0x02a9f2a },
      { 0x0837bd1,0x3249cef,0x35d702f,0x3430dab,0x1c06407,0x108f692,
        0x221292f,0x05f0c5d,0x073fe06,0x01038e0 } },
    /* 144 */
    { { 0x3bf9b7c,0x2020929,0x30d0f4f,0x080fef8,0x3365d23,0x1f3e738,
        0x3e53209,0x1549afe,0x300b305,0x038d811 },
      { 0x0c6c2c7,0x2e6445b,0x3ee64dc,0x022e932,0x0726837,0x0deb67b,
        0x1ed4346,0x3857f73,0x277a3de,0x01950b5 } },
    /* 145 */
    { { 0x36c377a,0x0adb41e,0x08be3f3,0x11e40d1,0x36cb038,0x036a2bd,
        0x3dd3a82,0x1bc875b,0x2ee09bb,0x02994d2 },
      { 0x035facf,0x05e0344,0x07e630a,0x0ce772d,0x335e55a,0x111fce4,
        0x250fe1c,0x3bc89ba,0x32fdc9a,0x03cf2d9 } },
    /* 146 */
    { { 0x355fd83,0x1c67f8e,0x1d10eb3,0x1b21d77,0x0e0d7a4,0x173a9e1,
        0x2c9fa90,0x1c39cce,0x22eaae8,0x01f2bea },
      { 0x153b338,0x0534107,0x26c69b8,0x283be1f,0x3e0acc0,0x059cac3,
        0x13d1081,0x148bbee,0x3c1b9bd,0x002aac4 } },
    /* 147 */
    { { 0x2681297,0x3389e34,0x146addc,0x2c6d425,0x2cb350e,0x1986abc,
        0x0431737,0x04ba4b7,0x2028470,0x012e469 },
      { 0x2f8ddcf,0x3c4255c,0x1af4dcf,0x07a6a44,0x208ebf6,0x0dc90c3,
        0x34360ac,0x072ad23,0x0537232,0x01254d3 } },
    /* 148 */
    { { 0x07b7e9d,0x3df5c7c,0x116f83d,0x28c4f35,0x3a478ef,0x3011fb8,
        0x2f264b6,0x317b9e3,0x04fd65a,0x032bd1b },
      { 0x2aa8266,0x3431de4,0x04bba04,0x19a44da,0x0edf454,0x392c5ac,
        0x265168a,0x1dc3d5b,0x25704c6,0x00533a7 } },
    /* 149 */
    { { 0x25e8f91,0x1178fa5,0x2492994,0x2eb2c3c,0x0d3aca1,0x0322828,
        0x1cc70f9,0x269c74c,0x0a53e4c,0x006edc2 },
      { 0x18bdd7a,0x2a79a55,0x26b1d5c,0x0200628,0x0734a05,0x3273c7b,
        0x13aa714,0x0040ac2,0x2f2da30,0x03e7449 } },
    /* 150 */
    { { 0x3f9563e,0x2f29eab,0x14a0749,0x3fad264,0x1dd077a,0x3d7c59c,
        0x3a0311b,0x331a789,0x0b9729e,0x0201ebf },
      { 0x1b08b77,0x2a4cdf2,0x3e387f8,0x21510f1,0x286c3a7,0x1dbf62e,
        0x3afa594,0x3363217,0x0d16568,0x01d46b7 } },
    /* 151 */
    { { 0x0715c0d,0x28e2d04,0x17f78ae,0x1c63dda,0x1d113ea,0x0fefc1b,
        0x1eab149,0x1d0fd99,0x0682537,0x00a7b11 },
      { 0x10bebbc,0x11c672d,0x14223d9,0x2ff9141,0x1399ee5,0x34b7b6c,
        0x0d5b3a8,0x01df643,0x0e392a4,0x03fe4dc } },
    /* 152 */
    { { 0x2b75b65,0x0b5a6f1,0x11c559a,0x3549999,0x24188f8,0x37a75f4,
        0x29f33e3,0x34068a2,0x38ba2a9,0x025dd91 },
      { 0x29af2c7,0x0988b64,0x0923885,0x1b539a4,0x1334f5d,0x226947a,
        0x2cc7e5a,0x20beb39,0x13fac2f,0x01d298c } },
    /* 153 */
    { { 0x35f079c,0x137f76d,0x2fbbb2f,0x254638d,0x185b07c,0x1f34db7,
        0x2cfcf0e,0x218f46d,0x2150ff4,0x02add6f },
      { 0x33fc9b7,0x0d9f005,0x0fd081b,0x0834965,0x2b90a74,0x102448d,
        0x3dbf03c,0x167d857,0x02e0b44,0x013afab } },
    /* 154 */
    { { 0x09f2c53,0x317f9d7,0x1411eb6,0x0463aba,0x0d25220,0x256b176,
        0x087633f,0x2bff322,0x07b2c1b,0x037e662 },
      { 0x10aaecb,0x23bb4a1,0x2272bb7,0x06c075a,0x09d4918,0x0736f2b,
        0x0dd511b,0x101625e,0x0a7779f,0x009ec10 } },
    /* 155 */
    { { 0x33b2eb2,0x0176dfd,0x2118904,0x022386c,0x2e0df85,0x2588c9f,
        0x1b71525,0x28fd540,0x137e4cf,0x02ce4f7 },
      { 0x3d75165,0x0c39ecf,0x3554a12,0x30af34c,0x2d66344,0x3ded408,
        0x36f1be0,0x0d065b0,0x012d046,0x0025623 } },
    /* 156 */
    { { 0x2601c3b,0x1824fc0,0x335fe08,0x3e33d70,0x0fb0252,0x252bfca,
        0x1cf2808,0x1922e55,0x1a9db9f,0x020721e },
      { 0x2f56c51,0x39a1f31,0x218c040,0x1a4fc5d,0x3fed471,0x0164d4e,
        0x388a419,0x06f1113,0x0f55fc1,0x03e8352 } },
    /* 157 */
    { { 0x1608e4d,0x3872778,0x022cbc6,0x044d60a,0x3010dda,0x15fb0b5,
        0x37ddc11,0x19f5bda,0x156b6a3,0x023a838 },
      { 0x383b3b4,0x1380bc8,0x353ca35,0x250fc07,0x169966b,0x3780f29,
        0x36632b2,0x2d6b13f,0x124fa00,0x00fd6ae } },
    /* 158 */
    { { 0x1739efb,0x2ec3656,0x2c0d337,0x3d39faf,0x1c751b0,0x04699f4,
        0x252dd64,0x095b8b6,0x0872b74,0x022f1da },
      { 0x2d3d253,0x38edca0,0x379fa5b,0x287d635,0x3a9f679,0x059d9ee,
        0x0ac168e,0x3cd3e87,0x19060fc,0x02ce1bc } },
    /* 159 */
    { { 0x3edcfc2,0x0f04d4b,0x2f0d31f,0x1898be2,0x25396bf,0x15ca230,
        0x02b4eae,0x2713668,0x0f71b06,0x0132d18 },
      { 0x38095ea,0x1ed34d6,0x3603ae6,0x165bf01,0x192bbf8,0x1852859,
        0x075f66b,0x1488f85,0x10895ef,0x014b035 } },
    /* 160 */
    { { 0x1339848,0x3084385,0x0c8d231,0x3a1c1de,0x0e87a28,0x255b85c,
        0x1de6616,0x2702e74,0x1382bb0,0x012b0f2 },
      { 0x198987d,0x381545a,0x34d619b,0x312b827,0x18b2376,0x28fe4cf,
        0x20b7651,0x017d077,0x0c7e397,0x00e0365 } },
    /* 161 */
    { { 0x1542e75,0x0d56aa0,0x39b701a,0x287b806,0x396c724,0x0935c21,
        0x3a29776,0x0debdac,0x171de26,0x00b38f8 },
      { 0x1d5bc1a,0x3fad27d,0x22b5cfe,0x1f89ddf,0x0a65560,0x144dd5b,
        0x2aac2f9,0x139353f,0x0520b62,0x00b9b36 } },
    /* 162 */
    { { 0x031c31d,0x16552e3,0x1a0c368,0x0016fc8,0x168533d,0x171e7b2,
        0x17626e7,0x275502f,0x14742c6,0x03285dd },
      { 0x2d2dbb2,0x3b6bffd,0x1d18cc6,0x2f45d2a,0x0fd0d8c,0x2915e3a,
        0x1e8793a,0x0b39a1d,0x3139cab,0x02a5da9 } },
    /* 163 */
    { { 0x3fb353d,0x147c6e4,0x3a720a6,0x22d5ff3,0x1d75cab,0x06c54a0,
        0x08cfa73,0x12666aa,0x3170a1f,0x021c829 },
      { 0x13e1b90,0x3a34dda,0x1fc38c3,0x02c5bdb,0x2d345dc,0x14aa1d0,
        0x28d00ab,0x224f23a,0x329c769,0x025c67b } },
    /* 164 */
    { { 0x0e35909,0x3bb6356,0x0116820,0x370cf77,0x29366d8,0x3881409,
        0x3999d06,0x013075f,0x176e157,0x02941ca },
      { 0x0e70b2e,0x28dfab1,0x2a8a002,0x15da242,0x084dcf6,0x116ca97,
        0x31bf186,0x1dc9735,0x09df7b7,0x0264e27 } },
    /* 165 */
    { { 0x2da7a4b,0x3023c9e,0x1366238,0x00ff4e2,0x03abe9d,0x19bd44b,
        0x272e897,0x20b91ad,0x2aa202c,0x02a2201 },
      { 0x380184e,0x08112b4,0x0b85660,0x31049aa,0x3a8cb78,0x36113c5,
        0x1670c0a,0x373f9e7,0x3fb4738,0x00010ef } },
    /* 166 */
    { { 0x2d5192e,0x26d770d,0x32af8d5,0x34d1642,0x1acf885,0x05805e0,
        0x166d0a1,0x1219a0d,0x301ba6c,0x014bcfb },
      { 0x2dcb64d,0x19cca83,0x379f398,0x08e01a0,0x10a482c,0x0103cc2,
        0x0be5fa7,0x1f9d45b,0x1899ef2,0x00ca5af } },
    /* 167 */
    { { 0x14d81d7,0x2aea251,0x1b3c476,0x3bd47ae,0x29eade7,0x0715e61,
        0x1a21cd8,0x1c7a586,0x2bfaee5,0x00ee43f },
      { 0x096f7cb,0x0c08f95,0x1bc4939,0x361fed4,0x255be41,0x26fad73,
        0x31dd489,0x02c600f,0x29d9f81,0x01ba201 } },
    /* 168 */
    { { 0x03ea1db,0x1eac46d,0x1292ce3,0x2a54967,0x20a7ff1,0x3e13c61,
        0x1b02218,0x2b44e14,0x3eadefa,0x029c88a },
      { 0x30a9144,0x31e3b0a,0x19c5a2a,0x147cbe9,0x05a0240,0x051f38e,
        0x11eca56,0x31a4247,0x123bc2a,0x02fa535 } },
    /* 169 */
    { { 0x3226ce7,0x1251782,0x0b7072f,0x11e59fa,0x2b8afd7,0x169b18f,
        0x2a46f18,0x31d9bb7,0x2fe9be8,0x01de0b7 },
      { 0x1b38626,0x34aa90f,0x3ad1760,0x21ddbd9,0x3460ae7,0x1126736,
        0x1b86fc5,0x0b92cd0,0x167a289,0x000e0e1 } },
    /* 170 */
    { { 0x1ec1a0f,0x36bbf5e,0x1c972d8,0x3f73ace,0x13bbcd6,0x23d86a5,
        0x175ffc5,0x2d083d5,0x2c4adf7,0x036f661 },
      { 0x1f39eb7,0x2a20505,0x176c81a,0x3d6e636,0x16ee2fc,0x3cbdc5f,
        0x25475dc,0x2ef4151,0x3c46860,0x0238934 } },
    /* 171 */
    { { 0x2587390,0x3639526,0x0588749,0x13c32fb,0x212bb19,0x09660f1,
        0x207da4b,0x2bf211b,0x1c4407b,0x01506a6 },
      { 0x24c8842,0x105a498,0x05ffdb2,0x0ab61b0,0x26044c1,0x3dff3d8,
        0x1d14b44,0x0d74716,0x049f57d,0x030024b } },
    /* 172 */
    { { 0x32e61ef,0x31d70f7,0x35cad3c,0x320b86c,0x07e8841,0x027ca7d,
        0x2d30d19,0x2513718,0x2347286,0x01d7901 },
      { 0x3c237d0,0x107f16e,0x01c9e7d,0x3c3b13c,0x0c9537b,0x20af54d,
        0x051a162,0x2161a47,0x258c784,0x016df2d } },
    /* 173 */
    { { 0x228ead1,0x29c2122,0x07f6964,0x023f4ed,0x1802dc5,0x19f96ce,
        0x24bfd17,0x25e866b,0x2ba8df0,0x01eb84f },
      { 0x2dd384e,0x05bbe3a,0x3f06fd2,0x366dacb,0x30361a2,0x2f36d7c,
        0x0b98784,0x38ff481,0x074e2a8,0x01e1f60 } },
    /* 174 */
    { { 0x17fbb1c,0x0975add,0x1debc5e,0x2cb2880,0x3e47bdd,0x3488cff,
        0x15e9a36,0x2121129,0x0199ef2,0x017088a },
      { 0x0315250,0x352a162,0x17c1773,0x0ae09c2,0x321b21a,0x3bd74cf,
        0x3c4ea1d,0x3cac2ad,0x3abbaf0,0x039174d } },
    /* 175 */
    { { 0x0511c8a,0x3c78d0a,0x2cd3d2d,0x322f729,0x3ebb229,0x09f0e69,
        0x0a71a76,0x2e74d5e,0x12284df,0x03b5ef0 },
      { 0x3dea561,0x0a9b7e4,0x0ed1cf2,0x237523c,0x05443f1,0x2eb48fa,
        0x3861405,0x1b49f62,0x0c945ca,0x02ab25f } },
    /* 176 */
    { { 0x16bd00a,0x13a9d28,0x3cc1eb5,0x2b7d702,0x2d839e9,0x3e6ff01,
        0x2bb7f11,0x3713824,0x3b31163,0x00c63e5 },
      { 0x30d7138,0x0316fb0,0x0220ecc,0x08eaf0c,0x244e8df,0x0088d81,
        0x37972fb,0x3fd34ae,0x2a19a84,0x03e907e } },
    /* 177 */
    { { 0x2642269,0x0b65d29,0x03bd440,0x33a6ede,0x3c81814,0x2507982,
        0x0d38e47,0x3a788e6,0x32c1d26,0x00e2eda },
      { 0x2577f87,0x392895a,0x3e1cc64,0x14f7047,0x08b52d2,0x08a01ca,
        0x336abf6,0x00697fc,0x105ce76,0x0253742 } },
    /* 178 */
    { { 0x293f92a,0x33df737,0x3315156,0x32e26d7,0x0a01333,0x26579d4,
        0x004df9c,0x0aba409,0x067d25c,0x02481de },
      { 0x3f39d44,0x1c78042,0x13d7e24,0x0825aed,0x35f2c90,0x3270f63,
        0x04b7b35,0x3ad4531,0x28bd29b,0x0207a10 } },
    /* 179 */
    { { 0x077199f,0x270aeb1,0x0dd96dd,0x3b9ad7b,0x28cb8ee,0x3903f43,
        0x37db3fe,0x292c62b,0x362dbbf,0x006e52a },
      { 0x247f143,0x0362cf3,0x216344f,0x3f18fd1,0x351e623,0x31664e0,
        0x0f270fc,0x243bbc6,0x2280555,0x001a8e3 } },
    /* 180 */
    { { 0x3355b49,0x2c04e6c,0x399b2e5,0x182d3af,0x020e265,0x09a7cf7,
        0x0ffa6bd,0x353e302,0x02083d9,0x029ecdb },
      { 0x33e8830,0x0570e86,0x1c0b64d,0x386a27e,0x0d5fcea,0x0b45a4c,
        0x2ee4a2e,0x0a8833f,0x2b4a282,0x02f9531 } },
    /* 181 */
    { { 0x191167c,0x36cf7e3,0x225ed6c,0x1e79e99,0x0517c3f,0x11ab1fd,
        0x05648f3,0x08aedc4,0x1abeae0,0x02fcc29 },
      { 0x3828a68,0x1e16fa4,0x30368e7,0x0c9fcfb,0x25161c3,0x24851ac,
        0x1b5feb5,0x344eb84,0x0de2732,0x0347208 } },
    /* 182 */
    { { 0x038b363,0x384d1e4,0x2519043,0x151ac17,0x158c11f,0x009b2b4,
        0x257abe6,0x2368d3f,0x3ed68a1,0x02df45e },
      { 0x29c2559,0x2962478,0x3d8444c,0x1d96fff,0x04f7a03,0x1391a52,
        0x0de4af7,0x3319126,0x15e6412,0x00e65ff } },
    /* 183 */
    { { 0x3d61507,0x1d1a0a2,0x0d2af20,0x354d299,0x329e132,0x2a28578,
        0x2ddfb08,0x04fa3ff,0x1293c6c,0x003bae2 },
      { 0x3e259f8,0x1a68fa9,0x3e67e9b,0x39b44f9,0x1ce1db7,0x347e9a1,
        0x3318f6a,0x2dbbc9d,0x2f8c922,0x008a245 } },
    /* 184 */
    { { 0x212ab5b,0x2b896c2,0x0136959,0x07e55ef,0x0cc1117,0x05b8ac3,
        0x18429ed,0x025fa01,0x11d6e93,0x03b016b },
      { 0x03f3708,0x2e96fab,0x1d77157,0x0d4c2d6,0x131baf9,0x0608d39,
        0x3552371,0x06cdd1e,0x1567ff1,0x01f4c50 } },
    /* 185 */
    { { 0x2dfefab,0x270173d,0x37077bd,0x1a372cd,0x1be2f22,0x28e2ee5,
        0x3ead973,0x35e8f94,0x2fc9bc1,0x03a7399 },
      { 0x36a02a1,0x2855d9b,0x00ed75a,0x37d8398,0x138c087,0x233706e,
        0x147f346,0x01947e2,0x3017228,0x0365942 } },
    /* 186 */
    { { 0x2057e60,0x2d31296,0x25e4504,0x2fa37bc,0x1cbccc3,0x1f0732f,
        0x3532081,0x2de8a98,0x19a804e,0x005359a },
      { 0x31f411a,0x2a10576,0x369c2c8,0x02fe035,0x109fbaf,0x30bddeb,
        0x1eef901,0x1662ad3,0x0410d43,0x01bd31a } },
    /* 187 */
    { { 0x2c24a96,0x1b7d3a5,0x19a3872,0x217f2f6,0x2534dbc,0x2cab8c2,
        0x066ef28,0x26aecf1,0x0fd6118,0x01310d4 },
      { 0x055b8da,0x1fdc5be,0x38a1296,0x25118f0,0x341a423,0x2ba4cd0,
        0x3e1413e,0x062d70d,0x2425a31,0x029c9b4 } },
    /* 188 */
    { { 0x08c1086,0x1acfba5,0x22e1dae,0x0f72f4e,0x3f1de50,0x0f408bc,
        0x35ed3f0,0x3ce48fc,0x282cc6c,0x004d8e7 },
      { 0x1afaa86,0x24e3ef3,0x22589ac,0x3ec9952,0x1f45bc5,0x14144ca,
        0x23b26e4,0x0d68c65,0x1e1c1a3,0x032a4d9 } },
    /* 189 */
    { { 0x03b2d20,0x16b1d53,0x241b361,0x05e4138,0x1742a54,0x32741c7,
        0x0521c4c,0x1ca96c2,0x034970b,0x02738a7 },
      { 0x13e0ad6,0x207dcdb,0x034c8cc,0x27bcbe1,0x18060da,0x33a18b6,
        0x2d1d1a6,0x2be60d7,0x3d7ab42,0x012312a } },
    /* 190 */
    { { 0x0c7485a,0x06c3310,0x0dbfd22,0x2ef949d,0x0ead455,0x098f4ba,
        0x3c76989,0x0cf2d24,0x032f67b,0x01e005f },
      { 0x30cb5ee,0x0d5da64,0x0ed2b9d,0x2503102,0x1c0d14e,0x1cbc693,
        0x37bf552,0x07013e2,0x054de5c,0x014f341 } },
    /* 191 */
    { { 0x128ccac,0x1617e97,0x346ebcd,0x158016d,0x25f823e,0x34048ea,
        0x39f0a1c,0x3ea3df1,0x1c1d3d7,0x03ba919 },
      { 0x151803b,0x01967c1,0x2f70781,0x27df39a,0x06c0b59,0x24a239c,
        0x15a7702,0x2464d06,0x2a47ae6,0x006db90 } },
    /* 192 */
    { { 0x27d04c3,0x024df3d,0x38112e8,0x38a27ba,0x01e312b,0x0965358,
        0x35d8879,0x2f4f55a,0x214187f,0x0008936 },
      { 0x05fe36f,0x2ee18c3,0x1f5f87a,0x1813bd4,0x0580f3c,0x0ed0a7b,
        0x0fb1bfb,0x3fcce59,0x2f042bf,0x01820e3 } },
    /* 193 */
    { { 0x20bbe99,0x32cbc9f,0x39ee432,0x3cc12a8,0x37bda44,0x3ea4e40,
        0x097c7a9,0x0590d7d,0x2022d33,0x018dbac },
      { 0x3ae00aa,0x3439864,0x2d2ffcf,0x3f8c6b9,0x0875a00,0x3e4e407,
        0x3658a29,0x22eb3d0,0x2b63921,0x022113b } },
    /* 194 */
    { { 0x33bae58,0x05c749a,0x1f3e114,0x1c45f8e,0x27db3df,0x06a3ab6,
        0x37bc7f8,0x1e27b34,0x3dc51fb,0x009eea0 },
      { 0x3f54de5,0x3d0e7fe,0x1a71a7d,0x02ed7f8,0x0727703,0x2ca5e92,
        0x2e8e35d,0x292ad0b,0x13487f3,0x02b6d8b } },
    /* 195 */
    { { 0x175df2a,0x05a28a8,0x32e99b1,0x13d8630,0x2082aa0,0x11ac245,
        0x24f2e71,0x322cb27,0x17675e7,0x02e643f },
      { 0x1f37313,0x2765ad3,0x0789082,0x1e742d0,0x11c2055,0x2021dc4,
        0x09ae4a7,0x346359b,0x2f94d10,0x0205c1f } },
    /* 196 */
    { { 0x3d6ff96,0x1f2ac80,0x336097d,0x3f03610,0x35b851b,0x010b6d2,
        0x0823c4d,0x2a9709a,0x2ead5a8,0x00de4b6 },
      { 0x01afa0b,0x0621965,0x3671528,0x1050b60,0x3f3e9e7,0x2f93829,
        0x0825275,0x006e85f,0x35e94b0,0x016af58 } },
    /* 197 */
    { { 0x2c4927c,0x3ea1382,0x0f23727,0x0d69f23,0x3e38860,0x2b72837,
        0x3cd5ea4,0x2d84292,0x321846a,0x016656f },
      { 0x29dfa33,0x3e182e0,0x018be90,0x2ba563f,0x2caafe2,0x218c0d9,
        0x3baf447,0x1047a6c,0x0a2d483,0x01130cb } },
    /* 198 */
    { { 0x00ed80c,0x2a5fc79,0x0a82a74,0x2c4c74b,0x15f938c,0x30b5ab6,
        0x32124b7,0x295314f,0x2fb8082,0x007c858 },
      { 0x20b173e,0x19f315c,0x12f97e4,0x198217c,0x040e8a6,0x3275977,
        0x2bc20e4,0x01f2633,0x02bc3e9,0x023c750 } },
    /* 199 */
    { { 0x3c4058a,0x24be73e,0x16704f5,0x2d8a4bd,0x3b15e14,0x3076315,
        0x1cfe37b,0x36fe715,0x343926e,0x02c6603 },
      { 0x2c76b09,0x0cf824c,0x3f7898c,0x274cec1,0x11df527,0x18eed18,
        0x08ead48,0x23915bc,0x19b3744,0x00a0a2b } },
    /* 200 */
    { { 0x0cf4ac5,0x1c8b131,0x0afb696,0x0ff7799,0x2f5ac1a,0x022420c,
        0x11baa2e,0x2ce4015,0x1275a14,0x0125cfc },
      { 0x22eac5d,0x360cd4c,0x3568e59,0x3d42f66,0x35e07ee,0x09620e4,
        0x36720fa,0x22b1eac,0x2d0db16,0x01b6b23 } },
    /* 201 */
    { { 0x1a835ef,0x1516bbb,0x2d51f7b,0x3487443,0x14aa113,0x0dd06c2,
        0x1a65e01,0x379300d,0x35920b9,0x012c8fb },
      { 0x04c7341,0x2eda00f,0x3c37e82,0x1b4fd62,0x0d45770,0x1478fba,
        0x127863a,0x26939cd,0x134ddf4,0x01375c5 } },
    /* 202 */
    { { 0x1476cd9,0x1119ca5,0x325bbf9,0x0bf8c69,0x0648d07,0x312d9f8,
        0x01c8b8f,0x136ec51,0x0002f4a,0x03f4c5c },
      { 0x195d0e1,0x10ffd22,0x29aa1cb,0x3443bdc,0x276e695,0x05e6260,
        0x15f9764,0x3cd9783,0x18c9569,0x0053eb1 } },
    /* 203 */
    { { 0x312ae18,0x280197c,0x3fc9ad9,0x303f324,0x251958d,0x29f4a11,
        0x2142408,0x3694366,0x25136ab,0x03b5f1d },
      { 0x1d4abbc,0x1c3c689,0x13ea462,0x3cfc684,0x39b5dd8,0x2d4654b,
        0x09b0755,0x27d4f18,0x3f74d2e,0x03fbf2d } },
    /* 204 */
    { { 0x2119185,0x2525eae,0x1ba4bd0,0x0c2ab11,0x1d54e8c,0x294845e,
        0x2479dea,0x3602d24,0x17e87e0,0x0060069 },
      { 0x0afffb0,0x34fe37f,0x1240073,0x02eb895,0x06cf33c,0x2d7f7ef,
        0x1d763b5,0x04191e0,0x11e1ead,0x027e3f0 } },
    /* 205 */
    { { 0x269544c,0x0e85c57,0x3813158,0x19fc12d,0x20eaf85,0x1e2930c,
        0x22a8fd2,0x1a6a478,0x09d3d3a,0x02a74e0 },
      { 0x1a2da3b,0x30b0b16,0x0847936,0x3d86257,0x138ccbc,0x0f5421a,
        0x25244e6,0x23bdd79,0x1aee117,0x00c01ae } },
    /* 206 */
    { { 0x1eead28,0x07cac32,0x1fbc0bb,0x17627d3,0x17eef63,0x0b3a24e,
        0x0757fdb,0x3dd841d,0x3d745f8,0x002ae17 },
      { 0x25b4549,0x29f24cf,0x2f21ecd,0x1725e48,0x04be2bb,0x10ee010,
        0x1a1274b,0x10b0898,0x27511e9,0x02c48b5 } },
    /* 207 */
    { { 0x2a5ae7a,0x181ef99,0x0be33be,0x3e9dab7,0x101e703,0x3adb971,
        0x1043014,0x2ebb2be,0x1c1097d,0x027d667 },
      { 0x3f250ed,0x16dc603,0x20dc6d7,0x1d0d268,0x38eb915,0x02c89e8,
        0x1605a41,0x12de109,0x0e08a29,0x01f554a } },
    /* 208 */
    { { 0x0c26def,0x163d988,0x2d1ef0f,0x3a960ac,0x1025585,0x0738e20,
        0x27d79b0,0x05cc3ef,0x201303f,0x00a333a },
      { 0x1644ba5,0x2af345e,0x30b8d1d,0x3a01bff,0x31fc643,0x1acf85e,
        0x0a76fc6,0x04efe98,0x348a1d0,0x03062eb } },
    /* 209 */
    { { 0x1c4216d,0x18e3217,0x02ac34e,0x19c8185,0x200c010,0x17d4192,
        0x13a1719,0x165af51,0x09db7a9,0x0277be0 },
      { 0x3ab8d2c,0x2190b99,0x22b641e,0x0cd88de,0x3b42404,0x1310862,
        0x106a6d6,0x23395f5,0x0b06880,0x000d5fe } },
    /* 210 */
    { { 0x0d2cc88,0x36f9913,0x339d8e9,0x237c2e3,0x0cc61c2,0x34c2832,
        0x309874c,0x2621d28,0x2dd1b48,0x0392806 },
      { 0x17cd8f9,0x07bab3d,0x0c482ed,0x0faf565,0x31b767d,0x2f4bde1,
        0x295c717,0x330c29c,0x179ce10,0x0119b5f } },
    /* 211 */
    { { 0x1ada2c7,0x0c624a7,0x227d47d,0x30e3e6a,0x14fa0a6,0x0829678,
        0x24fd288,0x2b46a43,0x122451e,0x0319ca9 },
      { 0x186b655,0x01f3217,0x0af1306,0x0efe6b5,0x2f0235d,0x1c45ca9,
        0x2086805,0x1d44e66,0x0faf2a6,0x0178f59 } },
    /* 212 */
    { { 0x33b4416,0x10431e6,0x2d99aa6,0x217aac9,0x0cd8fcf,0x2d95a9d,
        0x3ff74ad,0x10bf17a,0x295eb8e,0x01b229e },
      { 0x02a63bd,0x182e9ec,0x004710c,0x00e2e3c,0x06b2f23,0x04b642c,
        0x2c37383,0x32a4631,0x022ad82,0x00d22b9 } },
    /* 213 */
    { { 0x0cda2fb,0x1d198d7,0x26d27f4,0x286381c,0x022acca,0x24ac7c8,
        0x2df7824,0x0b4ba16,0x1e0d9ef,0x03041d3 },
      { 0x29a65b3,0x0f3912b,0x151bfcf,0x2b0175c,0x0fd71e4,0x39aa5e2,
        0x311f50c,0x13ff351,0x3dbc9e5,0x03eeb7e } },
    /* 214 */
    { { 0x0a99363,0x0fc7348,0x2775171,0x23db3c8,0x2b91565,0x134d66c,
        0x0175cd2,0x1bf365a,0x2b48371,0x02dfe5d },
      { 0x16dbf74,0x2389357,0x2f36575,0x3f5c70e,0x38d23ba,0x090f7f8,
        0x3477600,0x3201523,0x32ecafc,0x03d3506 } },
    /* 215 */
    { { 0x1abd48d,0x073ca3f,0x38a451f,0x0d8cb01,0x1ce81be,0x05c51ba,
        0x0e29741,0x03c41ab,0x0eae016,0x0060209 },
      { 0x2e58358,0x1da62d9,0x2358038,0x14b39b2,0x1635687,0x39079b1,
        0x380e345,0x1b49608,0x23983cf,0x019f97d } },
    /* 216 */
    { { 0x34899ef,0x332e373,0x04c0f89,0x3c27aed,0x1949015,0x09663b2,
        0x2f9276b,0x07f1951,0x09a04c1,0x027fbde },
      { 0x3d2a071,0x19fb3d4,0x1b096d3,0x1fe9146,0x3b10e1a,0x0478bbb,
        0x2b3fb06,0x1388329,0x181a99c,0x02f2030 } },
    /* 217 */
    { { 0x1eb82e6,0x14dbe39,0x3920972,0x31fd5b2,0x21a484f,0x02d7697,
        0x0e21715,0x37c431e,0x2629f8c,0x01249c3 },
      { 0x26b50ad,0x26deefa,0x0ffc1a3,0x30688e2,0x39a0284,0x041c65e,
        0x03eb178,0x0bdfd50,0x2f96137,0x034bb94 } },
    /* 218 */
    { { 0x0e0362a,0x334a162,0x194dd37,0x29e3e97,0x2442fa8,0x10d2949,
        0x3836e5a,0x2dccebf,0x0bee5ab,0x037ed1e },
      { 0x33eede6,0x3c739d9,0x2f04a91,0x350ad6c,0x3a5390a,0x14c368b,
        0x26f7bf5,0x11ce979,0x0b408df,0x0366850 } },
    /* 219 */
    { { 0x28ea498,0x0886d5b,0x2e090e0,0x0a4d58f,0x2623478,0x0d74ab7,
        0x2b83913,0x12c6b81,0x18d623f,0x01d8301 },
      { 0x198aa79,0x26d6330,0x3a7f0b8,0x34bc1ea,0x2f74890,0x378955a,
        0x204110f,0x0102538,0x02d8f19,0x01c5066 } },
    /* 220 */
    { { 0x14b0f45,0x2838cd3,0x14e16f0,0x0e0e4aa,0x2d9280b,0x0f18757,
        0x3324c6b,0x1391ceb,0x1ce89d5,0x00ebe74 },
      { 0x0930371,0x3de6048,0x3097fd8,0x1308705,0x3eda266,0x3108c26,
        0x1545dcd,0x1f7583a,0x1c37395,0x02c7e05 } },
    /* 221 */
    { { 0x1fec44a,0x2a9e3a2,0x0caf84f,0x11cf2a9,0x0c8c2ae,0x06da989,
        0x1c807dc,0x3c149a4,0x1141543,0x02906bb },
      { 0x15ffe04,0x0d4e65f,0x2e20424,0x37d896d,0x18bacb2,0x1e05ddd,
        0x1660be8,0x183be17,0x1dd86fb,0x035ba70 } },
    /* 222 */
    { { 0x2853264,0x0ba5fb1,0x0a0b3aa,0x2df88c1,0x2771533,0x23aba6f,
        0x112bb7b,0x3e3086e,0x210ae9b,0x027271b },
      { 0x030b74c,0x0269678,0x1e90a23,0x135a98c,0x24ed749,0x126de7c,
        0x344b23a,0x186da27,0x19640fa,0x0159af5 } },
    /* 223 */
    { { 0x18061f3,0x3004630,0x3c70066,0x34df20f,0x1190b25,0x1c9cc91,
        0x1fc8e02,0x0d17bc1,0x390f525,0x033cb1c },
      { 0x0eb30cf,0x2f3ad04,0x303aa09,0x2e835dd,0x1cfd2eb,0x143fc95,
        0x02c43a1,0x025e7a1,0x3558aa2,0x000bd45 } },
    /* 224 */
    { { 0x1db7d07,0x3bde52b,0x1500396,0x1089115,0x20b4fc7,0x1e2a8f3,
        0x3f8eacc,0x365f7eb,0x1a5e8d4,0x0053a6b },
      { 0x37079e2,0x120284b,0x000edaa,0x33792c2,0x145baa3,0x20e055f,
        0x365e2d7,0x26ba005,0x3ab8e9d,0x0282b53 } },
    /* 225 */
    { { 0x2653618,0x2dd8852,0x2a5f0bf,0x0f0c7aa,0x2187281,0x1252757,
        0x13e7374,0x3b47855,0x0b86e56,0x02f354c },
      { 0x2e9c47b,0x2fa14cc,0x19ab169,0x3fad401,0x0dc2776,0x24afeed,
        0x3a97611,0x0d07736,0x3cf6979,0x02424a0 } },
    /* 226 */
    { { 0x2e81a13,0x000c91d,0x123967b,0x265885c,0x29bee1a,0x0cb8675,
        0x2d361bd,0x1526823,0x3c9ace1,0x00d7bad },
      { 0x24e5bdc,0x02b969f,0x2c6e128,0x34edb3b,0x12dcd2c,0x3899af0,
        0x24224c6,0x3a1914b,0x0f4448a,0x026a2cb } },
    /* 227 */
    { { 0x1d03b59,0x1c6fc82,0x32abf64,0x28ed96b,0x1c90e62,0x2f57bb2,
        0x3ff168e,0x04de7fd,0x0f4d449,0x01af6d8 },
      { 0x255bc30,0x2bfaf22,0x3fe0dad,0x0584025,0x1c79ead,0x3078ef7,
        0x2197414,0x022a50b,0x0fd94ba,0x0007b0f } },
    /* 228 */
    { { 0x09485c2,0x09dfaf7,0x10c7ba6,0x1e48bec,0x248cc9a,0x028a362,
        0x21d60f7,0x193d93d,0x1c04754,0x0346b2c },
      { 0x2f36612,0x240ac49,0x0d8bd26,0x13b8186,0x259c3a4,0x020d5fb,
        0x38a8133,0x09b0937,0x39d4056,0x01f7341 } },
    /* 229 */
    { { 0x05a4b48,0x1f534fc,0x07725ce,0x148dc8c,0x2adcd29,0x04aa456,
        0x0f79718,0x066e346,0x189377d,0x002fd4d },
      { 0x068ea73,0x336569b,0x184d35e,0x32a08e9,0x3c7f3bb,0x11ce9c8,
        0x3674c6f,0x21bf27e,0x0d9e166,0x034a2f9 } },
    /* 230 */
    { { 0x0fa8e4b,0x2e6418e,0x18fc5d2,0x1ba24ff,0x0559f18,0x0dbedbf,
        0x2de2aa4,0x22338e9,0x3aa510f,0x035d801 },
      { 0x23a4988,0x02aad94,0x02732d1,0x111d374,0x0b455cf,0x0d01c9e,
        0x067082a,0x2ec05fd,0x368b303,0x03cad4b } },
    /* 231 */
    { { 0x035b4ca,0x1fabea6,0x1cbc0d5,0x3f2ed9a,0x02d2232,0x1990c66,
        0x2eb680c,0x3b4ea3b,0x18ecc5a,0x03636fa },
      { 0x1a02709,0x26f8ff1,0x1fa8cba,0x397d6e8,0x230be68,0x043aa14,
        0x3d43cdf,0x25c17fa,0x3a3ee55,0x0380564 } },
    /* 232 */
    { { 0x275a0a6,0x16bd43a,0x0033d3e,0x2b15e16,0x2512226,0x005d901,
        0x26d50fd,0x3bc19bf,0x3b1aeb8,0x02bfb01 },
      { 0x0bb0a31,0x26559e0,0x1aae7fb,0x330dcc2,0x16f1af3,0x06afce2,
        0x13a15a0,0x2ff7645,0x3546e2d,0x029c6e4 } },
    /* 233 */
    { { 0x0f593d2,0x384b806,0x122bbf8,0x0a281e0,0x1d1a904,0x2e93cab,
        0x0505db0,0x08f6454,0x05c6285,0x014e880 },
      { 0x3f2b935,0x22d8e79,0x161a07c,0x16b060a,0x02bff97,0x146328b,
        0x3ceea77,0x238f61a,0x19b3d58,0x02fd1f4 } },
    /* 234 */
    { { 0x17665d5,0x259e9f7,0x0de5672,0x15cbcbd,0x34e3030,0x035240f,
        0x0005ae8,0x286d851,0x07f39c9,0x000070b },
      { 0x1efc6d6,0x2a0051a,0x2724143,0x2a9ef1e,0x0c810bd,0x1e05429,
        0x25670ba,0x2e66d7d,0x0e786ff,0x03f6b7e } },
    /* 235 */
    { { 0x3c00785,0x232e23f,0x2b67fd3,0x244ed23,0x077fa75,0x3cda3ef,
        0x14d055b,0x0f25011,0x24d5aa4,0x00ea0e3 },
      { 0x297bb9a,0x198ca4f,0x14d9561,0x18d1076,0x39eb933,0x2b6caa0,
        0x1591a60,0x0768d45,0x257873e,0x00f36e0 } },
    /* 236 */
    { { 0x1e77eab,0x0502a5f,0x0109137,0x0350592,0x3f7e1c5,0x3ac7437,
        0x2dcad2c,0x1fee9d8,0x089f1f5,0x0169833 },
      { 0x0d45673,0x0d8e090,0x065580b,0x065644f,0x11b82be,0x3592dd0,
        0x3284b8d,0x23f0015,0x16fdbfd,0x0248bfd } },
    /* 237 */
    { { 0x1a129a1,0x1977bb2,0x0e041b2,0x15f30a1,0x0a5b1ce,0x3afef8f,
        0x380c46c,0x3358810,0x27df6c5,0x01ca466 },
      { 0x3b90f9a,0x3d14ea3,0x031b298,0x02e2390,0x2d719c0,0x25bc615,
        0x2c0e777,0x0226b8c,0x3803624,0x0179e45 } },
    /* 238 */
    { { 0x363cdfb,0x1bb155f,0x24fd5c1,0x1c7c72b,0x28e6a35,0x18165f2,
        0x226bea5,0x0beaff3,0x371e24c,0x0138294 },
      { 0x1765357,0x29034e9,0x22b4276,0x11035ce,0x23c89af,0x074468c,
        0x3370ae4,0x013bae3,0x018d566,0x03d7fde } },
    /* 239 */
    { { 0x209df21,0x0f8ff86,0x0e47fbf,0x23b99ba,0x126d5d2,0x2722405,
        0x16bd0a2,0x1799082,0x0e9533f,0x039077c },
      { 0x3ba9e3f,0x3f6902c,0x1895305,0x3ac9813,0x3f2340c,0x3c0d9f1,
        0x26e1927,0x0557c21,0x16eac4f,0x023b75f } },
    /* 240 */
    { { 0x3fc8ff3,0x0770382,0x342fc9a,0x0afa4db,0x314efd8,0x328e07b,
        0x016f7cc,0x3ba599c,0x1caed8a,0x0050cb0 },
      { 0x0b23c26,0x2120a5c,0x3273ec6,0x1cc1cd6,0x2a64fe8,0x2bbc3d6,
        0x09f6e5e,0x34b1b8e,0x00b5ac8,0x032bbd2 } },
    /* 241 */
    { { 0x1315922,0x1725e1d,0x0ca5524,0x1c4c18f,0x3d82951,0x193bcb2,
        0x0e60d0b,0x388dbcf,0x37e8efa,0x0342e85 },
      { 0x1b3af60,0x26ba3ec,0x220e53a,0x394f4b6,0x01a796a,0x3e7bbca,
        0x163605d,0x2b85807,0x17c1c54,0x03cc725 } },
    /* 242 */
    { { 0x1cc4597,0x1635492,0x2028c0f,0x2c2eb82,0x2dc5015,0x0d2a052,
        0x05fc557,0x1f0ebbf,0x0cb96e1,0x0004d01 },
      { 0x1a824bf,0x3896172,0x2ed7b29,0x178007a,0x0d59318,0x07bda2b,
        0x2ee6826,0x0f9b235,0x04b9193,0x01bcddf } },
    /* 243 */
    { { 0x0333fd2,0x0eeb46a,0x15b89f9,0x00968aa,0x2a89302,0x2bdd6b3,
        0x1e5037e,0x2541884,0x24ed2d0,0x01b6e8f },
      { 0x04399cd,0x3be6334,0x3adea48,0x1bb9adc,0x31811c6,0x05fb2bc,
        0x360752c,0x3d29dcb,0x3423bec,0x03c4f3c } },
    /* 244 */
    { { 0x119e2eb,0x2e7b02a,0x0f68cee,0x257d8b0,0x183a9a1,0x2ae88a6,
        0x3a3bb67,0x2eb4f3e,0x1a9274b,0x0320fea },
      { 0x2fa1ce0,0x346c2d8,0x2fbf0d7,0x3d4d063,0x0e58b60,0x09c1bc1,
        0x28ef9e5,0x09a0efe,0x0f45d70,0x02d275c } },
    /* 245 */
    { { 0x2d5513b,0x31d443e,0x1e2d914,0x3b2c5d4,0x105f32e,0x27ee756,
        0x050418d,0x3c73db6,0x1bb0c30,0x01673eb },
      { 0x1cb7fd6,0x1eb08d5,0x26a3e16,0x2e20810,0x0249367,0x029e219,
        0x2ec58c9,0x12d9fab,0x362354a,0x016eafc } },
    /* 246 */
    { { 0x2424865,0x260747b,0x177f37c,0x1e3cb95,0x08b0028,0x2783016,
        0x2970f1b,0x323c1c0,0x2a79026,0x0186231 },
      { 0x0f244da,0x26866f4,0x087306f,0x173ec20,0x31ecced,0x3c84d8d,
        0x070f9b9,0x2e764d5,0x075df50,0x0264ff9 } },
    /* 247 */
    { { 0x32c3609,0x0c737e6,0x14ea68e,0x300b11b,0x184eb19,0x29dd440,
        0x09ec1a9,0x185adeb,0x0664c80,0x0207dd9 },
      { 0x1fbe978,0x30a969d,0x33561d7,0x34fc60e,0x36743fe,0x00774af,
        0x0d1f045,0x018360e,0x12a5fe9,0x01592a0 } },
    /* 248 */
    { { 0x2817d1d,0x2993d3e,0x2e0f7a5,0x112faa0,0x255f968,0x355fe6a,
        0x3f5a0fc,0x075b2d7,0x3cf00e5,0x0089afc },
      { 0x32833cf,0x06a7e4b,0x09a8d6d,0x1693d3e,0x320a0a3,0x3cfdfdd,
        0x136c498,0x1e0d845,0x347ff25,0x01a1de7 } },
    /* 249 */
    { { 0x3043d08,0x030705c,0x20fa79b,0x1d07f00,0x0a54467,0x29b49b4,
        0x367e289,0x0b82f4d,0x0d1eb09,0x025ef2c },
      { 0x32ed3c3,0x1baaa3c,0x3c482ab,0x146ca06,0x3c8a4f1,0x3e85e3c,
        0x1bf4f3b,0x1195534,0x3e80a78,0x02a1cbf } },
    /* 250 */
    { { 0x32b2086,0x2de4d68,0x3486b1a,0x03a0583,0x2e1eb71,0x2dab9af,
        0x10cd913,0x28daa6f,0x3fcb732,0x000a04a },
      { 0x3605318,0x3f5f2b3,0x2d1da63,0x143f7f5,0x1646e5d,0x040b586,
        0x1683982,0x25abe87,0x0c9fe53,0x001ce47 } },
    /* 251 */
    { { 0x380d02b,0x055fc22,0x3f7fc50,0x3458a1d,0x26b8333,0x23550ab,
        0x0a1af87,0x0a821eb,0x2dc7e6d,0x00d574a },
      { 0x07386e1,0x3ccd68a,0x3275b41,0x253e390,0x2fd272a,0x1e6627a,
        0x2ca2cde,0x0e9e4a1,0x1e37c2a,0x00f70ac } },
    /* 252 */
    { { 0x0581352,0x2748701,0x02bed68,0x094dd9e,0x30a00c8,0x3fb5c07,
        0x3bd5909,0x211ac80,0x1103ccd,0x0311e1a },
      { 0x0c768ed,0x29dc209,0x36575db,0x009a107,0x272feea,0x2b33383,
        0x313ed56,0x134c9cc,0x168d5bb,0x033310a } },
    /* 253 */
    { { 0x17620b9,0x143784f,0x256a94e,0x229664a,0x1d89a5c,0x1d521f2,
        0x0076406,0x1c73f70,0x342aa48,0x03851fa },
      { 0x0f3ae46,0x2ad3bab,0x0fbe274,0x3ed40d4,0x2fd4936,0x232103a,
        0x2afe474,0x25b8f7c,0x047080e,0x008e6b0 } },
    /* 254 */
    { { 0x3fee8d4,0x347cd4a,0x0fec481,0x33fe9ec,0x0ce80b5,0x33a6bcf,
        0x1c4c9e2,0x3967441,0x1a3f5f7,0x03157e8 },
      { 0x257c227,0x1bc53a0,0x200b318,0x0fcd0af,0x2c5b165,0x2a413ec,
        0x2fc998a,0x2da6426,0x19cd4f4,0x0025336 } },
    /* 255 */
    { { 0x303beba,0x2072135,0x32918a9,0x140cb3a,0x08631d1,0x0ef527b,
        0x05f2c9e,0x2b4ce91,0x0b642ab,0x02e428c },
      { 0x0a5abf9,0x15013ed,0x3603b46,0x30dd76d,0x3004750,0x28d7627,
        0x1a42ccc,0x093ddbe,0x39a1b79,0x00067e2 } },
};

/* Multiply the base point of P256 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * Stripe implementation.
 * Pre-generated: 2^0, 2^32, ...
 * Pre-generated: products of all combinations of above.
 * 8 doubles and adds (with qz=1)
 *
 * r     Resulting point.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_256_ecc_mulmod_base_10(sp_point_256* r, const sp_digit* k,
        int map, void* heap)
{
    return sp_256_ecc_mulmod_stripe_10(r, &p256_base, p256_table,
                                      k, map, heap);
}

#endif

/* Multiply the base point of P256 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * km    Scalar to multiply by.
 * r     Resulting point.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_mulmod_base_256(const mp_int* km, ecc_point* r, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_256 p;
    sp_digit kd[10];
#endif
    sp_point_256* point;
    sp_digit* k = NULL;
    int err = MP_OKAY;

    err = sp_256_point_new_10(heap, p, point);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * 10, heap, DYNAMIC_TYPE_ECC);
        if (k == NULL) {
            err = MEMORY_E;
        }
    }
#else
    k = kd;
#endif
    if (err == MP_OKAY) {
        sp_256_from_mp(k, 10, km);

            err = sp_256_ecc_mulmod_base_10(point, k, map, heap);
    }
    if (err == MP_OKAY) {
        err = sp_256_point_to_ecc_point_10(point, r);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_256_point_free_10(point, 0, heap);

    return err;
}

/* Multiply the base point of P256 by the scalar, add point a and return
 * the result. If map is true then convert result to affine coordinates.
 *
 * km      Scalar to multiply by.
 * am      Point to add to scalar mulitply result.
 * inMont  Point to add is in montogmery form.
 * r       Resulting point.
 * map     Indicates whether to convert result to affine.
 * heap    Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_mulmod_base_add_256(const mp_int* km, const ecc_point* am,
        int inMont, ecc_point* r, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_256 p;
    sp_point_256 a;
    sp_digit kd[10];
    sp_digit t[10 * 2 * 5];
#endif
    sp_point_256* point;
    sp_point_256* addP = NULL;
    sp_digit* tmp = NULL;
    sp_digit* k = NULL;
    int err = MP_OKAY;

    err = sp_256_point_new_10(heap, p, point);
    if (err == MP_OKAY) {
        err = sp_256_point_new_10(heap, a, addP);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * (10 + 10 * 2 * 5), heap, DYNAMIC_TYPE_ECC);
        if (k == NULL) {
            err = MEMORY_E;
        }
        else {
            tmp = k + 10;
        }
    }
#else
    k = kd;
    tmp = t;
#endif
    if (err == MP_OKAY) {
        sp_256_from_mp(k, 10, km);
        sp_256_point_from_ecc_point_10(addP, am);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_256_mod_mul_norm_10(addP->x, addP->x, p256_mod);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_256_mod_mul_norm_10(addP->y, addP->y, p256_mod);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_256_mod_mul_norm_10(addP->z, addP->z, p256_mod);
    }
    if (err == MP_OKAY) {
            err = sp_256_ecc_mulmod_base_10(point, k, 0, heap);
    }
    if (err == MP_OKAY) {
            sp_256_proj_point_add_10(point, point, addP, tmp);

        if (map) {
            sp_256_map_10(point, point, tmp);
        }

        err = sp_256_point_to_ecc_point_10(point, r);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_256_point_free_10(addP, 0, heap);
    sp_256_point_free_10(point, 0, heap);

    return err;
}

#if defined(WOLFSSL_VALIDATE_ECC_KEYGEN) || defined(HAVE_ECC_SIGN) || \
                                                        defined(HAVE_ECC_VERIFY)
/* Returns 1 if the number of zero.
 * Implementation is constant time.
 *
 * a  Number to check.
 * returns 1 if the number is zero and 0 otherwise.
 */
static int sp_256_iszero_10(const sp_digit* a)
{
    return (a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7] |
            a[8] | a[9]) == 0;
}

#endif /* WOLFSSL_VALIDATE_ECC_KEYGEN | HAVE_ECC_SIGN | HAVE_ECC_VERIFY */
/* Add 1 to a. (a = a + 1)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_256_add_one_10(sp_digit* a)
{
    a[0]++;
    sp_256_norm_10(a);
}

/* Read big endian unsigned byte array into r.
 *
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  Byte array.
 * n  Number of bytes in array to read.
 */
static void sp_256_from_bin(sp_digit* r, int size, const byte* a, int n)
{
    int i;
    int j = 0;
    word32 s = 0;

    r[0] = 0;
    for (i = n-1; i >= 0; i--) {
        r[j] |= (((sp_digit)a[i]) << s);
        if (s >= 18U) {
            r[j] &= 0x3ffffff;
            s = 26U - s;
            if (j + 1 >= size) {
                break;
            }
            r[++j] = (sp_digit)a[i] >> s;
            s = 8U - s;
        }
        else {
            s += 8U;
        }
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
}

/* Generates a scalar that is in the range 1..order-1.
 *
 * rng  Random number generator.
 * k    Scalar value.
 * returns RNG failures, MEMORY_E when memory allocation fails and
 * MP_OKAY on success.
 */
static int sp_256_ecc_gen_k_10(WC_RNG* rng, sp_digit* k)
{
    int err;
    byte buf[32];

    do {
        err = wc_RNG_GenerateBlock(rng, buf, sizeof(buf));
        if (err == 0) {
            sp_256_from_bin(k, 10, buf, (int)sizeof(buf));
            if (sp_256_cmp_10(k, p256_order2) < 0) {
                sp_256_add_one_10(k);
                break;
            }
        }
    }
    while (err == 0);

    return err;
}

/* Makes a random EC key pair.
 *
 * rng   Random number generator.
 * priv  Generated private value.
 * pub   Generated public point.
 * heap  Heap to use for allocation.
 * returns ECC_INF_E when the point does not have the correct order, RNG
 * failures, MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_make_key_256(WC_RNG* rng, mp_int* priv, ecc_point* pub, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_256 p;
    sp_digit kd[10];
#ifdef WOLFSSL_VALIDATE_ECC_KEYGEN
    sp_point_256 inf;
#endif
#endif
    sp_point_256* point;
    sp_digit* k = NULL;
#ifdef WOLFSSL_VALIDATE_ECC_KEYGEN
    sp_point_256* infinity;
#endif
    int err;

    (void)heap;

    err = sp_256_point_new_10(heap, p, point);
#ifdef WOLFSSL_VALIDATE_ECC_KEYGEN
    if (err == MP_OKAY) {
        err = sp_256_point_new_10(heap, inf, infinity);
    }
#endif
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * 10, heap,
                                                              DYNAMIC_TYPE_ECC);
        if (k == NULL) {
            err = MEMORY_E;
        }
    }
#else
    k = kd;
#endif

    if (err == MP_OKAY) {
        err = sp_256_ecc_gen_k_10(rng, k);
    }
    if (err == MP_OKAY) {
            err = sp_256_ecc_mulmod_base_10(point, k, 1, NULL);
    }

#ifdef WOLFSSL_VALIDATE_ECC_KEYGEN
    if (err == MP_OKAY) {
            err = sp_256_ecc_mulmod_10(infinity, point, p256_order, 1, NULL);
    }
    if (err == MP_OKAY) {
        if ((sp_256_iszero_10(point->x) == 0) || (sp_256_iszero_10(point->y) == 0)) {
            err = ECC_INF_E;
        }
    }
#endif

    if (err == MP_OKAY) {
        err = sp_256_to_mp(k, priv);
    }
    if (err == MP_OKAY) {
        err = sp_256_point_to_ecc_point_10(point, pub);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
#ifdef WOLFSSL_VALIDATE_ECC_KEYGEN
    sp_256_point_free_10(infinity, 1, heap);
#endif
    sp_256_point_free_10(point, 1, heap);

    return err;
}

#ifdef HAVE_ECC_DHE
/* Write r as big endian to byte array.
 * Fixed length number of bytes written: 32
 *
 * r  A single precision integer.
 * a  Byte array.
 */
static void sp_256_to_bin(sp_digit* r, byte* a)
{
    int i;
    int j;
    int s = 0;
    int b;

    for (i=0; i<9; i++) {
        r[i+1] += r[i] >> 26;
        r[i] &= 0x3ffffff;
    }
    j = 256 / 8 - 1;
    a[j] = 0;
    for (i=0; i<10 && j>=0; i++) {
        b = 0;
        /* lint allow cast of mismatch sp_digit and int */
        a[j--] |= (byte)(r[i] << s); /*lint !e9033*/
        b += 8 - s;
        if (j < 0) {
            break;
        }
        while (b < 26) {
            a[j--] = (byte)(r[i] >> b);
            b += 8;
            if (j < 0) {
                break;
            }
        }
        s = 8 - (b - 26);
        if (j >= 0) {
            a[j] = 0;
        }
        if (s != 0) {
            j++;
        }
    }
}

/* Multiply the point by the scalar and serialize the X ordinate.
 * The number is 0 padded to maximum size on output.
 *
 * priv    Scalar to multiply the point by.
 * pub     Point to multiply.
 * out     Buffer to hold X ordinate.
 * outLen  On entry, size of the buffer in bytes.
 *         On exit, length of data in buffer in bytes.
 * heap    Heap to use for allocation.
 * returns BUFFER_E if the buffer is to small for output size,
 * MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_secret_gen_256(const mp_int* priv, const ecc_point* pub, byte* out,
                          word32* outLen, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_256 p;
    sp_digit kd[10];
#endif
    sp_point_256* point = NULL;
    sp_digit* k = NULL;
    int err = MP_OKAY;

    if (*outLen < 32U) {
        err = BUFFER_E;
    }

    if (err == MP_OKAY) {
        err = sp_256_point_new_10(heap, p, point);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * 10, heap,
                                                              DYNAMIC_TYPE_ECC);
        if (k == NULL)
            err = MEMORY_E;
    }
#else
    k = kd;
#endif

    if (err == MP_OKAY) {
        sp_256_from_mp(k, 10, priv);
        sp_256_point_from_ecc_point_10(point, pub);
            err = sp_256_ecc_mulmod_10(point, point, k, 1, heap);
    }
    if (err == MP_OKAY) {
        sp_256_to_bin(point->x, out);
        *outLen = 32;
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_256_point_free_10(point, 0, heap);

    return err;
}
#endif /* HAVE_ECC_DHE */

#if defined(HAVE_ECC_SIGN) || defined(HAVE_ECC_VERIFY)
#endif
#if defined(HAVE_ECC_SIGN) || defined(HAVE_ECC_VERIFY)
/* Multiply a by scalar b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_256_mul_d_10(sp_digit* r, const sp_digit* a,
    sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 10; i++) {
        t += tb * a[i];
        r[i] = t & 0x3ffffff;
        t >>= 26;
    }
    r[10] = (sp_digit)t;
#else
    int64_t tb = b;
    int64_t t[10];

    t[ 0] = tb * a[ 0];
    t[ 1] = tb * a[ 1];
    t[ 2] = tb * a[ 2];
    t[ 3] = tb * a[ 3];
    t[ 4] = tb * a[ 4];
    t[ 5] = tb * a[ 5];
    t[ 6] = tb * a[ 6];
    t[ 7] = tb * a[ 7];
    t[ 8] = tb * a[ 8];
    t[ 9] = tb * a[ 9];
    r[ 0] =                           (t[ 0] & 0x3ffffff);
    r[ 1] = (sp_digit)(t[ 0] >> 26) + (t[ 1] & 0x3ffffff);
    r[ 2] = (sp_digit)(t[ 1] >> 26) + (t[ 2] & 0x3ffffff);
    r[ 3] = (sp_digit)(t[ 2] >> 26) + (t[ 3] & 0x3ffffff);
    r[ 4] = (sp_digit)(t[ 3] >> 26) + (t[ 4] & 0x3ffffff);
    r[ 5] = (sp_digit)(t[ 4] >> 26) + (t[ 5] & 0x3ffffff);
    r[ 6] = (sp_digit)(t[ 5] >> 26) + (t[ 6] & 0x3ffffff);
    r[ 7] = (sp_digit)(t[ 6] >> 26) + (t[ 7] & 0x3ffffff);
    r[ 8] = (sp_digit)(t[ 7] >> 26) + (t[ 8] & 0x3ffffff);
    r[ 9] = (sp_digit)(t[ 8] >> 26) + (t[ 9] & 0x3ffffff);
    r[10] = (sp_digit)(t[ 9] >> 26);
#endif /* WOLFSSL_SP_SMALL */
}

#ifdef WOLFSSL_SP_DIV_32
static WC_INLINE sp_digit sp_256_div_word_10(sp_digit d1, sp_digit d0,
    sp_digit dv)
{
    sp_digit d;
    sp_digit r;
    sp_digit t;

    /* All 26 bits from d1 and top 5 bits from d0. */
    d = (d1 << 5) | (d0 >> 21);
    r = d / dv;
    d -= r * dv;
    /* Up to 6 bits in r */
    /* Next 5 bits from d0. */
    r <<= 5;
    d <<= 5;
    d |= (d0 >> 16) & ((1 << 5) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 11 bits in r */
    /* Next 5 bits from d0. */
    r <<= 5;
    d <<= 5;
    d |= (d0 >> 11) & ((1 << 5) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 16 bits in r */
    /* Next 5 bits from d0. */
    r <<= 5;
    d <<= 5;
    d |= (d0 >> 6) & ((1 << 5) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 21 bits in r */
    /* Next 5 bits from d0. */
    r <<= 5;
    d <<= 5;
    d |= (d0 >> 1) & ((1 << 5) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 26 bits in r */
    /* Remaining 1 bits from d0. */
    r <<= 1;
    d <<= 1;
    d |= d0 & ((1 << 1) - 1);
    t = d / dv;
    r += t;

    return r;
}
#endif /* WOLFSSL_SP_DIV_32 */

/* Divide d in a and put remainder into r (m*d + r = a)
 * m is not calculated as it is not needed at this time.
 *
 * a  Number to be divided.
 * d  Number to divide with.
 * m  Multiplier result.
 * r  Remainder from the division.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_256_div_10(const sp_digit* a, const sp_digit* d,
        const sp_digit* m, sp_digit* r)
{
    int i;
#ifndef WOLFSSL_SP_DIV_32
    int64_t d1;
#endif
    sp_digit dv;
    sp_digit r1;
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit t1d[20];
    sp_digit t2d[10 + 1];
#endif
    sp_digit* t1;
    sp_digit* t2;
    int err = MP_OKAY;

    (void)m;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * (3 * 10 + 1), NULL,
                                                       DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t1 = td;
        t2 = td + 2 * 10;
#else
        t1 = t1d;
        t2 = t2d;
#endif

        dv = d[9];
        XMEMCPY(t1, a, sizeof(*t1) * 2U * 10U);
        for (i=9; i>=0; i--) {
            t1[10 + i] += t1[10 + i - 1] >> 26;
            t1[10 + i - 1] &= 0x3ffffff;
#ifndef WOLFSSL_SP_DIV_32
            d1 = t1[10 + i];
            d1 <<= 26;
            d1 += t1[10 + i - 1];
            r1 = (sp_digit)(d1 / dv);
#else
            r1 = sp_256_div_word_10(t1[10 + i], t1[10 + i - 1], dv);
#endif

            sp_256_mul_d_10(t2, d, r1);
            (void)sp_256_sub_10(&t1[i], &t1[i], t2);
            t1[10 + i] -= t2[10];
            t1[10 + i] += t1[10 + i - 1] >> 26;
            t1[10 + i - 1] &= 0x3ffffff;
            r1 = (((-t1[10 + i]) << 26) - t1[10 + i - 1]) / dv;
            r1++;
            sp_256_mul_d_10(t2, d, r1);
            (void)sp_256_add_10(&t1[i], &t1[i], t2);
            t1[10 + i] += t1[10 + i - 1] >> 26;
            t1[10 + i - 1] &= 0x3ffffff;
        }
        t1[10 - 1] += t1[10 - 2] >> 26;
        t1[10 - 2] &= 0x3ffffff;
        r1 = t1[10 - 1] / dv;

        sp_256_mul_d_10(t2, d, r1);
        (void)sp_256_sub_10(t1, t1, t2);
        XMEMCPY(r, t1, sizeof(*r) * 2U * 10U);
        for (i=0; i<9; i++) {
            r[i+1] += r[i] >> 26;
            r[i] &= 0x3ffffff;
        }
        sp_256_cond_add_10(r, r, d, 0 - ((r[9] < 0) ?
                    (sp_digit)1 : (sp_digit)0));
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
}

/* Reduce a modulo m into r. (r = a mod m)
 *
 * r  A single precision number that is the reduced result.
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_256_mod_10(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    return sp_256_div_10(a, m, NULL, r);
}

#endif
#if defined(HAVE_ECC_SIGN) || defined(HAVE_ECC_VERIFY)
#ifdef WOLFSSL_SP_SMALL
/* Order-2 for the P256 curve. */
static const uint32_t p256_order_minus_2[8] = {
    0xfc63254fU,0xf3b9cac2U,0xa7179e84U,0xbce6faadU,0xffffffffU,0xffffffffU,
    0x00000000U,0xffffffffU
};
#else
/* The low half of the order-2 of the P256 curve. */
static const sp_int_digit p256_order_low[4] = {
    0xfc63254fU,0xf3b9cac2U,0xa7179e84U,0xbce6faadU
};
#endif /* WOLFSSL_SP_SMALL */

/* Multiply two number mod the order of P256 curve. (r = a * b mod order)
 *
 * r  Result of the multiplication.
 * a  First operand of the multiplication.
 * b  Second operand of the multiplication.
 */
static void sp_256_mont_mul_order_10(sp_digit* r, const sp_digit* a, const sp_digit* b)
{
    sp_256_mul_10(r, a, b);
    sp_256_mont_reduce_order_10(r, p256_order, p256_mp_order);
}

/* Square number mod the order of P256 curve. (r = a * a mod order)
 *
 * r  Result of the squaring.
 * a  Number to square.
 */
static void sp_256_mont_sqr_order_10(sp_digit* r, const sp_digit* a)
{
    sp_256_sqr_10(r, a);
    sp_256_mont_reduce_order_10(r, p256_order, p256_mp_order);
}

#ifndef WOLFSSL_SP_SMALL
/* Square number mod the order of P256 curve a number of times.
 * (r = a ^ n mod order)
 *
 * r  Result of the squaring.
 * a  Number to square.
 */
static void sp_256_mont_sqr_n_order_10(sp_digit* r, const sp_digit* a, int n)
{
    int i;

    sp_256_mont_sqr_order_10(r, a);
    for (i=1; i<n; i++) {
        sp_256_mont_sqr_order_10(r, r);
    }
}
#endif /* !WOLFSSL_SP_SMALL */

/* Invert the number, in Montgomery form, modulo the order of the P256 curve.
 * (r = 1 / a mod order)
 *
 * r   Inverse result.
 * a   Number to invert.
 * td  Temporary data.
 */

#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_256_mont_inv_order_10_ctx {
    int state;
    int i;
} sp_256_mont_inv_order_10_ctx;
static int sp_256_mont_inv_order_10_nb(sp_ecc_ctx_t* sp_ctx, sp_digit* r, const sp_digit* a,
        sp_digit* t)
{
    int err = FP_WOULDBLOCK;
    sp_256_mont_inv_order_10_ctx* ctx = (sp_256_mont_inv_order_10_ctx*)sp_ctx;
    
    typedef char ctx_size_test[sizeof(sp_256_mont_inv_order_10_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    switch (ctx->state) {
    case 0:
        XMEMCPY(t, a, sizeof(sp_digit) * 10);
        ctx->i = 254;
        ctx->state = 1;
        break;
    case 1:
        sp_256_mont_sqr_order_10(t, t);
        if ((p256_order_minus_2[ctx->i / 32] & ((sp_int_digit)1 << (ctx->i % 32))) != 0) {
            sp_256_mont_mul_order_10(t, t, a);
        }
        ctx->i--;
        if (ctx->i == 0) {
            ctx->state = 2;
        }
        break;
    case 2:
        XMEMCPY(r, t, sizeof(sp_digit) * 10U);
        err = MP_OKAY;
        break;
    }
    return err;
}
#endif /* WOLFSSL_SP_NONBLOCK */

static void sp_256_mont_inv_order_10(sp_digit* r, const sp_digit* a,
        sp_digit* td)
{
#ifdef WOLFSSL_SP_SMALL
    sp_digit* t = td;
    int i;

    XMEMCPY(t, a, sizeof(sp_digit) * 10);
    for (i=254; i>=0; i--) {
        sp_256_mont_sqr_order_10(t, t);
        if ((p256_order_minus_2[i / 32] & ((sp_int_digit)1 << (i % 32))) != 0) {
            sp_256_mont_mul_order_10(t, t, a);
        }
    }
    XMEMCPY(r, t, sizeof(sp_digit) * 10U);
#else
    sp_digit* t = td;
    sp_digit* t2 = td + 2 * 10;
    sp_digit* t3 = td + 4 * 10;
    int i;

    /* t = a^2 */
    sp_256_mont_sqr_order_10(t, a);
    /* t = a^3 = t * a */
    sp_256_mont_mul_order_10(t, t, a);
    /* t2= a^c = t ^ 2 ^ 2 */
    sp_256_mont_sqr_n_order_10(t2, t, 2);
    /* t3= a^f = t2 * t */
    sp_256_mont_mul_order_10(t3, t2, t);
    /* t2= a^f0 = t3 ^ 2 ^ 4 */
    sp_256_mont_sqr_n_order_10(t2, t3, 4);
    /* t = a^ff = t2 * t3 */
    sp_256_mont_mul_order_10(t, t2, t3);
    /* t3= a^ff00 = t ^ 2 ^ 8 */
    sp_256_mont_sqr_n_order_10(t2, t, 8);
    /* t = a^ffff = t2 * t */
    sp_256_mont_mul_order_10(t, t2, t);
    /* t2= a^ffff0000 = t ^ 2 ^ 16 */
    sp_256_mont_sqr_n_order_10(t2, t, 16);
    /* t = a^ffffffff = t2 * t */
    sp_256_mont_mul_order_10(t, t2, t);
    /* t2= a^ffffffff0000000000000000 = t ^ 2 ^ 64  */
    sp_256_mont_sqr_n_order_10(t2, t, 64);
    /* t2= a^ffffffff00000000ffffffff = t2 * t */
    sp_256_mont_mul_order_10(t2, t2, t);
    /* t2= a^ffffffff00000000ffffffff00000000 = t2 ^ 2 ^ 32  */
    sp_256_mont_sqr_n_order_10(t2, t2, 32);
    /* t2= a^ffffffff00000000ffffffffffffffff = t2 * t */
    sp_256_mont_mul_order_10(t2, t2, t);
    /* t2= a^ffffffff00000000ffffffffffffffffbce6 */
    for (i=127; i>=112; i--) {
        sp_256_mont_sqr_order_10(t2, t2);
        if ((p256_order_low[i / 32] & ((sp_int_digit)1 << (i % 32))) != 0) {
            sp_256_mont_mul_order_10(t2, t2, a);
        }
    }
    /* t2= a^ffffffff00000000ffffffffffffffffbce6f */
    sp_256_mont_sqr_n_order_10(t2, t2, 4);
    sp_256_mont_mul_order_10(t2, t2, t3);
    /* t2= a^ffffffff00000000ffffffffffffffffbce6faada7179e84 */
    for (i=107; i>=64; i--) {
        sp_256_mont_sqr_order_10(t2, t2);
        if ((p256_order_low[i / 32] & ((sp_int_digit)1 << (i % 32))) != 0) {
            sp_256_mont_mul_order_10(t2, t2, a);
        }
    }
    /* t2= a^ffffffff00000000ffffffffffffffffbce6faada7179e84f */
    sp_256_mont_sqr_n_order_10(t2, t2, 4);
    sp_256_mont_mul_order_10(t2, t2, t3);
    /* t2= a^ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2 */
    for (i=59; i>=32; i--) {
        sp_256_mont_sqr_order_10(t2, t2);
        if ((p256_order_low[i / 32] & ((sp_int_digit)1 << (i % 32))) != 0) {
            sp_256_mont_mul_order_10(t2, t2, a);
        }
    }
    /* t2= a^ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2f */
    sp_256_mont_sqr_n_order_10(t2, t2, 4);
    sp_256_mont_mul_order_10(t2, t2, t3);
    /* t2= a^ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63254 */
    for (i=27; i>=0; i--) {
        sp_256_mont_sqr_order_10(t2, t2);
        if ((p256_order_low[i / 32] & ((sp_int_digit)1 << (i % 32))) != 0) {
            sp_256_mont_mul_order_10(t2, t2, a);
        }
    }
    /* t2= a^ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632540 */
    sp_256_mont_sqr_n_order_10(t2, t2, 4);
    /* r = a^ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63254f */
    sp_256_mont_mul_order_10(r, t2, t3);
#endif /* WOLFSSL_SP_SMALL */
}

#endif /* HAVE_ECC_SIGN | HAVE_ECC_VERIFY */
#ifdef HAVE_ECC_SIGN
#ifndef SP_ECC_MAX_SIG_GEN
#define SP_ECC_MAX_SIG_GEN  64
#endif

/* Calculate second signature value S from R, k and private value.
 *
 * s = (r * x + e) / k
 *
 * s    Signature value.
 * r    First signature value.
 * k    Ephemeral private key.
 * x    Private key as a number.
 * e    Hash of message as a number.
 * tmp  Temporary storage for intermediate numbers.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_256_calc_s_10(sp_digit* s, const sp_digit* r, sp_digit* k,
    sp_digit* x, const sp_digit* e, sp_digit* tmp)
{
    int err;
    sp_digit carry;
    int32_t c;
    sp_digit* kInv = k;

    /* Conv k to Montgomery form (mod order) */
        sp_256_mul_10(k, k, p256_norm_order);
    err = sp_256_mod_10(k, k, p256_order);
    if (err == MP_OKAY) {
        sp_256_norm_10(k);

        /* kInv = 1/k mod order */
            sp_256_mont_inv_order_10(kInv, k, tmp);
        sp_256_norm_10(kInv);

        /* s = r * x + e */
            sp_256_mul_10(x, x, r);
        err = sp_256_mod_10(x, x, p256_order);
    }
    if (err == MP_OKAY) {
        sp_256_norm_10(x);
        carry = sp_256_add_10(s, e, x);
        sp_256_cond_sub_10(s, s, p256_order, 0 - carry);
        sp_256_norm_10(s);
        c = sp_256_cmp_10(s, p256_order);
        sp_256_cond_sub_10(s, s, p256_order, 0L - (sp_digit)(c >= 0));
        sp_256_norm_10(s);

        /* s = s * k^-1 mod order */
            sp_256_mont_mul_order_10(s, s, kInv);
        sp_256_norm_10(s);
    }

    return err;
}

/* Sign the hash using the private key.
 *   e = [hash, 256 bits] from binary
 *   r = (k.G)->x mod order
 *   s = (r * x + e) / k mod order
 * The hash is truncated to the first 256 bits.
 *
 * hash     Hash to sign.
 * hashLen  Length of the hash data.
 * rng      Random number generator.
 * priv     Private part of key - scalar.
 * rm       First part of result as an mp_int.
 * sm       Sirst part of result as an mp_int.
 * heap     Heap to use for allocation.
 * returns RNG failures, MEMORY_E when memory allocation fails and
 * MP_OKAY on success.
 */
#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_ecc_sign_256_ctx {
    int state;
    union {
        sp_256_ecc_mulmod_10_ctx mulmod_ctx;
        sp_256_mont_inv_order_10_ctx mont_inv_order_ctx;
    };
    sp_digit e[2*10];
    sp_digit x[2*10];
    sp_digit k[2*10];
    sp_digit r[2*10];
    sp_digit tmp[3 * 2*10];
    sp_point_256 point;
    sp_digit* s;
    sp_digit* kInv;
    int i;
} sp_ecc_sign_256_ctx;

int sp_ecc_sign_256_nb(sp_ecc_ctx_t* sp_ctx, const byte* hash, word32 hashLen, WC_RNG* rng, mp_int* priv,
                    mp_int* rm, mp_int* sm, mp_int* km, void* heap)
{
    int err = FP_WOULDBLOCK;
    sp_ecc_sign_256_ctx* ctx = (sp_ecc_sign_256_ctx*)sp_ctx->data;

    typedef char ctx_size_test[sizeof(sp_ecc_sign_256_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    (void)heap;

    switch (ctx->state) {
    case 0: /* INIT */
        ctx->s = ctx->e;
        ctx->kInv = ctx->k;
        if (hashLen > 32U) {
            hashLen = 32U;
        }

        sp_256_from_bin(ctx->e, 10, hash, (int)hashLen);

        ctx->i = SP_ECC_MAX_SIG_GEN;
        ctx->state = 1;
        break;
    case 1: /* GEN */
        sp_256_from_mp(ctx->x, 10, priv);
        /* New random point. */
        if (km == NULL || mp_iszero(km)) {
            err = sp_256_ecc_gen_k_10(rng, ctx->k);
        }
        else {
            sp_256_from_mp(ctx->k, 10, km);
            mp_zero(km);
        }
        XMEMSET(&ctx->mulmod_ctx, 0, sizeof(ctx->mulmod_ctx));
        ctx->state = 2;
        break; 
    case 2: /* MULMOD */
        err = sp_256_ecc_mulmod_10_nb((sp_ecc_ctx_t*)&ctx->mulmod_ctx, 
            &ctx->point, &p256_base, ctx->k, 1, heap);
        if (err == MP_OKAY) {
            ctx->state = 3;
        }
        break;
    case 3: /* MODORDER */
    {
        int32_t c;
        /* r = point->x mod order */
        XMEMCPY(ctx->r, ctx->point.x, sizeof(sp_digit) * 10U);
        sp_256_norm_10(ctx->r);
        c = sp_256_cmp_10(ctx->r, p256_order);
        sp_256_cond_sub_10(ctx->r, ctx->r, p256_order, 0L - (sp_digit)(c >= 0));
        sp_256_norm_10(ctx->r);
        ctx->state = 4;
        break;
    }
    case 4: /* KMODORDER */
        /* Conv k to Montgomery form (mod order) */
        sp_256_mul_10(ctx->k, ctx->k, p256_norm_order);
        err = sp_256_mod_10(ctx->k, ctx->k, p256_order);
        if (err == MP_OKAY) {
            sp_256_norm_10(ctx->k);
            XMEMSET(&ctx->mont_inv_order_ctx, 0, sizeof(ctx->mont_inv_order_ctx));
            ctx->state = 5;
        }
        break;
    case 5: /* KINV */
        /* kInv = 1/k mod order */
        err = sp_256_mont_inv_order_10_nb((sp_ecc_ctx_t*)&ctx->mont_inv_order_ctx, ctx->kInv, ctx->k, ctx->tmp);
        if (err == MP_OKAY) {
            XMEMSET(&ctx->mont_inv_order_ctx, 0, sizeof(ctx->mont_inv_order_ctx));
            ctx->state = 6;
        }
        break;
    case 6: /* KINVNORM */
        sp_256_norm_10(ctx->kInv);
        ctx->state = 7;
        break;
    case 7: /* R */
        /* s = r * x + e */
        sp_256_mul_10(ctx->x, ctx->x, ctx->r);
        ctx->state = 8;
        break;
    case 8: /* S1 */
        err = sp_256_mod_10(ctx->x, ctx->x, p256_order);
        if (err == MP_OKAY)
            ctx->state = 9;
        break;
    case 9: /* S2 */
    {
        sp_digit carry;
        int32_t c;
        sp_256_norm_10(ctx->x);
        carry = sp_256_add_10(ctx->s, ctx->e, ctx->x);
        sp_256_cond_sub_10(ctx->s, ctx->s, p256_order, 0 - carry);
        sp_256_norm_10(ctx->s);
        c = sp_256_cmp_10(ctx->s, p256_order);
        sp_256_cond_sub_10(ctx->s, ctx->s, p256_order, 0L - (sp_digit)(c >= 0));
        sp_256_norm_10(ctx->s);

        /* s = s * k^-1 mod order */
        sp_256_mont_mul_order_10(ctx->s, ctx->s, ctx->kInv);
        sp_256_norm_10(ctx->s);

        /* Check that signature is usable. */
        if (sp_256_iszero_10(ctx->s) == 0) {
            ctx->state = 10;
            break;
        }

        /* not usable gen, try again */
        ctx->i--;
        if (ctx->i == 0) {
            err = RNG_FAILURE_E;
        }
        ctx->state = 1;
        break;
    }
    case 10: /* RES */
        err = sp_256_to_mp(ctx->r, rm);
        if (err == MP_OKAY) {
            err = sp_256_to_mp(ctx->s, sm);
        }
        break;
    }

    if (err == MP_OKAY && ctx->state != 10) {
        err = FP_WOULDBLOCK;
    }
    if (err != FP_WOULDBLOCK) {
        XMEMSET(ctx->e, 0, sizeof(sp_digit) * 2U * 10U);
        XMEMSET(ctx->x, 0, sizeof(sp_digit) * 2U * 10U);
        XMEMSET(ctx->k, 0, sizeof(sp_digit) * 2U * 10U);
        XMEMSET(ctx->r, 0, sizeof(sp_digit) * 2U * 10U);
        XMEMSET(ctx->tmp, 0, sizeof(sp_digit) * 3U * 2U * 10U);
    }

    return err;
}
#endif /* WOLFSSL_SP_NONBLOCK */

int sp_ecc_sign_256(const byte* hash, word32 hashLen, WC_RNG* rng,
    const mp_int* priv, mp_int* rm, mp_int* sm, mp_int* km, void* heap)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* d = NULL;
#else
    sp_digit ed[2*10];
    sp_digit xd[2*10];
    sp_digit kd[2*10];
    sp_digit rd[2*10];
    sp_digit td[3 * 2*10];
    sp_point_256 p;
#endif
    sp_digit* e = NULL;
    sp_digit* x = NULL;
    sp_digit* k = NULL;
    sp_digit* r = NULL;
    sp_digit* tmp = NULL;
    sp_point_256* point = NULL;
    sp_digit* s = NULL;
    int32_t c;
    int err = MP_OKAY;
    int i;

    (void)heap;

    err = sp_256_point_new_10(heap, p, point);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 7 * 2 * 10, heap,
                                                              DYNAMIC_TYPE_ECC);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        e = d + 0 * 10;
        x = d + 2 * 10;
        k = d + 4 * 10;
        r = d + 6 * 10;
        tmp = d + 8 * 10;
#else
        e = ed;
        x = xd;
        k = kd;
        r = rd;
        tmp = td;
#endif
        s = e;

        if (hashLen > 32U) {
            hashLen = 32U;
        }

        sp_256_from_bin(e, 10, hash, (int)hashLen);
    }

    for (i = SP_ECC_MAX_SIG_GEN; err == MP_OKAY && i > 0; i--) {
        /* New random point. */
        if (km == NULL || mp_iszero(km)) {
            err = sp_256_ecc_gen_k_10(rng, k);
        }
        else {
            sp_256_from_mp(k, 10, km);
            mp_zero(km);
        }
        if (err == MP_OKAY) {
                err = sp_256_ecc_mulmod_base_10(point, k, 1, heap);
        }
        if (err == MP_OKAY) {
            /* r = point->x mod order */
            XMEMCPY(r, point->x, sizeof(sp_digit) * 10U);
            sp_256_norm_10(r);
            c = sp_256_cmp_10(r, p256_order);
            sp_256_cond_sub_10(r, r, p256_order, 0L - (sp_digit)(c >= 0));
            sp_256_norm_10(r);

            sp_256_from_mp(x, 10, priv);

            err = sp_256_calc_s_10(s, r, k, x, e, tmp);
        }

        /* Check that signature is usable. */
        if ((err == MP_OKAY) && (sp_256_iszero_10(s) == 0)) {
            break;
        }
    }

    if (i == 0) {
        err = RNG_FAILURE_E;
    }

    if (err == MP_OKAY) {
        err = sp_256_to_mp(r, rm);
    }
    if (err == MP_OKAY) {
        err = sp_256_to_mp(s, sm);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL) {
        XMEMSET(d, 0, sizeof(sp_digit) * 8 * 10);
        XFREE(d, heap, DYNAMIC_TYPE_ECC);
    }
#else
    XMEMSET(e, 0, sizeof(sp_digit) * 2U * 10U);
    XMEMSET(x, 0, sizeof(sp_digit) * 2U * 10U);
    XMEMSET(k, 0, sizeof(sp_digit) * 2U * 10U);
    XMEMSET(r, 0, sizeof(sp_digit) * 2U * 10U);
    XMEMSET(r, 0, sizeof(sp_digit) * 2U * 10U);
    XMEMSET(tmp, 0, sizeof(sp_digit) * 3U * 2U * 10U);
#endif
    sp_256_point_free_10(point, 1, heap);

    return err;
}
#endif /* HAVE_ECC_SIGN */

#ifdef HAVE_ECC_VERIFY

/* Add point p1 into point p2. Handles p1 == p2 and result at infinity.
 *
 * p1   First point to add and holds result.
 * p2   Second point to add.
 * tmp  Temporary storage for intermediate numbers.
 */
static void sp_256_add_points_10(sp_point_256* p1, const sp_point_256* p2,
    sp_digit* tmp)
{

        sp_256_proj_point_add_10(p1, p1, p2, tmp);
    if (sp_256_iszero_10(p1->z)) {
        if (sp_256_iszero_10(p1->x) && sp_256_iszero_10(p1->y)) {
                sp_256_proj_point_dbl_10(p1, p2, tmp);
        }
        else {
            /* Y ordinate is not used from here - don't set. */
            p1->x[0] = 0;
            p1->x[1] = 0;
            p1->x[2] = 0;
            p1->x[3] = 0;
            p1->x[4] = 0;
            p1->x[5] = 0;
            p1->x[6] = 0;
            p1->x[7] = 0;
            p1->x[8] = 0;
            p1->x[9] = 0;
            XMEMCPY(p1->z, p256_norm_mod, sizeof(p256_norm_mod));
        }
    }
}

/* Calculate the verification point: [e/s]G + [r/s]Q
 *
 * p1    Calculated point.
 * p2    Public point and temporary.
 * s     Second part of signature as a number.
 * u1    Temporary number.
 * u2    Temproray number.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_256_calc_vfy_point_10(sp_point_256* p1, sp_point_256* p2,
    sp_digit* s, sp_digit* u1, sp_digit* u2, sp_digit* tmp, void* heap)
{
    int err;

    sp_256_norm_10(s);
        sp_256_mont_inv_order_10(s, s, tmp);
        sp_256_mont_mul_order_10(u1, u1, s);
        sp_256_mont_mul_order_10(u2, u2, s);
        err = sp_256_ecc_mulmod_base_10(p1, u1, 0, heap);
    if (err == MP_OKAY) {
            err = sp_256_ecc_mulmod_10(p2, p2, u2, 0, heap);
    }

    if (err == MP_OKAY) {
        sp_256_add_points_10(p1, p2, tmp);
    }

    return err;
}

/* Verify the signature values with the hash and public key.
 *   e = Truncate(hash, 256)
 *   u1 = e/s mod order
 *   u2 = r/s mod order
 *   r == (u1.G + u2.Q)->x mod order
 * Optimization: Leave point in projective form.
 *   (x, y, 1) == (x' / z'*z', y' / z'*z'*z', z' / z')
 *   (r + n*order).z'.z' mod prime == (u1.G + u2.Q)->x'
 * The hash is truncated to the first 256 bits.
 *
 * hash     Hash to sign.
 * hashLen  Length of the hash data.
 * rng      Random number generator.
 * priv     Private part of key - scalar.
 * rm       First part of result as an mp_int.
 * sm       Sirst part of result as an mp_int.
 * heap     Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_ecc_verify_256_ctx {
    int state;
    union {
        sp_256_ecc_mulmod_10_ctx mulmod_ctx;
        sp_256_mont_inv_order_10_ctx mont_inv_order_ctx;
        sp_256_proj_point_dbl_10_ctx dbl_ctx;
        sp_256_proj_point_add_10_ctx add_ctx;
    };
    sp_digit u1[2*10];
    sp_digit u2[2*10];
    sp_digit s[2*10];
    sp_digit tmp[2*10 * 5];
    sp_point_256 p1;
    sp_point_256 p2;
} sp_ecc_verify_256_ctx;

int sp_ecc_verify_256_nb(sp_ecc_ctx_t* sp_ctx, const byte* hash, word32 hashLen, mp_int* pX,
    mp_int* pY, mp_int* pZ, mp_int* r, mp_int* sm, int* res, void* heap)
{
    int err = FP_WOULDBLOCK;
    sp_ecc_verify_256_ctx* ctx = (sp_ecc_verify_256_ctx*)sp_ctx->data;

    typedef char ctx_size_test[sizeof(sp_ecc_verify_256_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    switch (ctx->state) {
    case 0: /* INIT */
        if (hashLen > 32U) {
            hashLen = 32U;
        }

        sp_256_from_bin(ctx->u1, 10, hash, (int)hashLen);
        sp_256_from_mp(ctx->u2, 10, r);
        sp_256_from_mp(ctx->s, 10, sm);
        sp_256_from_mp(ctx->p2.x, 10, pX);
        sp_256_from_mp(ctx->p2.y, 10, pY);
        sp_256_from_mp(ctx->p2.z, 10, pZ);
        sp_256_mul_10(ctx->s, ctx->s, p256_norm_order);
        err = sp_256_mod_10(ctx->s, ctx->s, p256_order);
        if (err == MP_OKAY)
            ctx->state = 1;
        break;
    case 1: /* NORMS1 */
        sp_256_norm_10(ctx->s);
        XMEMSET(&ctx->mont_inv_order_ctx, 0, sizeof(ctx->mont_inv_order_ctx));
        ctx->state = 2;
        break;
    case 2: /* NORMS2 */
        err = sp_256_mont_inv_order_10_nb((sp_ecc_ctx_t*)&ctx->mont_inv_order_ctx, ctx->s, ctx->s, ctx->tmp);
        if (err == MP_OKAY) {
            ctx->state = 3;
        }
        break;
    case 3: /* NORMS3 */
        sp_256_mont_mul_order_10(ctx->u1, ctx->u1, ctx->s);
        ctx->state = 4;
        break;
    case 4: /* NORMS4 */
        sp_256_mont_mul_order_10(ctx->u2, ctx->u2, ctx->s);
        XMEMSET(&ctx->mulmod_ctx, 0, sizeof(ctx->mulmod_ctx));
        ctx->state = 5;
        break;
    case 5: /* MULBASE */
        err = sp_256_ecc_mulmod_10_nb((sp_ecc_ctx_t*)&ctx->mulmod_ctx, &ctx->p1, &p256_base, ctx->u1, 0, heap);
        if (err == MP_OKAY) {
            XMEMSET(&ctx->mulmod_ctx, 0, sizeof(ctx->mulmod_ctx));
            ctx->state = 6;
        }
        break;
    case 6: /* MULMOD */
        err = sp_256_ecc_mulmod_10_nb((sp_ecc_ctx_t*)&ctx->mulmod_ctx, &ctx->p2, &ctx->p2, ctx->u2, 0, heap);
        if (err == MP_OKAY) {
            XMEMSET(&ctx->add_ctx, 0, sizeof(ctx->add_ctx));
            ctx->state = 7;
        }
        break;
    case 7: /* ADD */
        err = sp_256_proj_point_add_10_nb((sp_ecc_ctx_t*)&ctx->add_ctx, &ctx->p1, &ctx->p1, &ctx->p2, ctx->tmp);
        if (err == MP_OKAY)
            ctx->state = 8;
        break;
    case 8: /* DBLPREP */
        if (sp_256_iszero_10(ctx->p1.z)) {
            if (sp_256_iszero_10(ctx->p1.x) && sp_256_iszero_10(ctx->p1.y)) {
                XMEMSET(&ctx->dbl_ctx, 0, sizeof(ctx->dbl_ctx));
                ctx->state = 9;
                break;
            }
            else {
                /* Y ordinate is not used from here - don't set. */
                int i;
                for (i=0; i<10; i++) {
                    ctx->p1.x[i] = 0;
                }
                XMEMCPY(ctx->p1.z, p256_norm_mod, sizeof(p256_norm_mod));
            }
        }
        ctx->state = 10;
        break;
    case 9: /* DBL */
        err = sp_256_proj_point_dbl_10_nb((sp_ecc_ctx_t*)&ctx->dbl_ctx, &ctx->p1, 
            &ctx->p2, ctx->tmp);
        if (err == MP_OKAY) {
            ctx->state = 10;
        }
        break;
    case 10: /* MONT */
        /* (r + n*order).z'.z' mod prime == (u1.G + u2.Q)->x' */
        /* Reload r and convert to Montgomery form. */
        sp_256_from_mp(ctx->u2, 10, r);
        err = sp_256_mod_mul_norm_10(ctx->u2, ctx->u2, p256_mod);
        if (err == MP_OKAY)
            ctx->state = 11;
        break;
    case 11: /* SQR */
        /* u1 = r.z'.z' mod prime */
        sp_256_mont_sqr_10(ctx->p1.z, ctx->p1.z, p256_mod, p256_mp_mod);
        ctx->state = 12;
        break;
    case 12: /* MUL */
        sp_256_mont_mul_10(ctx->u1, ctx->u2, ctx->p1.z, p256_mod, p256_mp_mod);
        ctx->state = 13;
        break;
    case 13: /* RES */
        err = MP_OKAY; /* math okay, now check result */
        *res = (int)(sp_256_cmp_10(ctx->p1.x, ctx->u1) == 0);
        if (*res == 0) {
            sp_digit carry;
            int32_t c;

            /* Reload r and add order. */
            sp_256_from_mp(ctx->u2, 10, r);
            carry = sp_256_add_10(ctx->u2, ctx->u2, p256_order);
            /* Carry means result is greater than mod and is not valid. */
            if (carry == 0) {
                sp_256_norm_10(ctx->u2);

                /* Compare with mod and if greater or equal then not valid. */
                c = sp_256_cmp_10(ctx->u2, p256_mod);
                if (c < 0) {
                    /* Convert to Montogomery form */
                    err = sp_256_mod_mul_norm_10(ctx->u2, ctx->u2, p256_mod);
                    if (err == MP_OKAY) {
                        /* u1 = (r + 1*order).z'.z' mod prime */
                        sp_256_mont_mul_10(ctx->u1, ctx->u2, ctx->p1.z, p256_mod,
                                                                  p256_mp_mod);
                        *res = (int)(sp_256_cmp_10(ctx->p1.x, ctx->u1) == 0);
                    }
                }
            }
        }
        break;
    }

    if (err == MP_OKAY && ctx->state != 13) {
        err = FP_WOULDBLOCK;
    }

    return err;
}
#endif /* WOLFSSL_SP_NONBLOCK */

int sp_ecc_verify_256(const byte* hash, word32 hashLen, const mp_int* pX,
    const mp_int* pY, const mp_int* pZ, const mp_int* r, const mp_int* sm,
    int* res, void* heap)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* d = NULL;
#else
    sp_digit u1d[2*10];
    sp_digit u2d[2*10];
    sp_digit sd[2*10];
    sp_digit tmpd[2*10 * 5];
    sp_point_256 p1d;
    sp_point_256 p2d;
#endif
    sp_digit* u1 = NULL;
    sp_digit* u2 = NULL;
    sp_digit* s = NULL;
    sp_digit* tmp = NULL;
    sp_point_256* p1;
    sp_point_256* p2 = NULL;
    sp_digit carry;
    int32_t c = 0;
    int err;

    err = sp_256_point_new_10(heap, p1d, p1);
    if (err == MP_OKAY) {
        err = sp_256_point_new_10(heap, p2d, p2);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 16 * 10, heap,
                                                              DYNAMIC_TYPE_ECC);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        u1  = d + 0 * 10;
        u2  = d + 2 * 10;
        s   = d + 4 * 10;
        tmp = d + 6 * 10;
#else
        u1 = u1d;
        u2 = u2d;
        s  = sd;
        tmp = tmpd;
#endif

        if (hashLen > 32U) {
            hashLen = 32U;
        }

        sp_256_from_bin(u1, 10, hash, (int)hashLen);
        sp_256_from_mp(u2, 10, r);
        sp_256_from_mp(s, 10, sm);
        sp_256_from_mp(p2->x, 10, pX);
        sp_256_from_mp(p2->y, 10, pY);
        sp_256_from_mp(p2->z, 10, pZ);

            sp_256_mul_10(s, s, p256_norm_order);
        err = sp_256_mod_10(s, s, p256_order);
    }
    if (err == MP_OKAY) {
        err = sp_256_calc_vfy_point_10(p1, p2, s, u1, u2, tmp,
            heap);
    }
    if (err == MP_OKAY) {
        /* (r + n*order).z'.z' mod prime == (u1.G + u2.Q)->x' */
        /* Reload r and convert to Montgomery form. */
        sp_256_from_mp(u2, 10, r);
        err = sp_256_mod_mul_norm_10(u2, u2, p256_mod);
    }

    if (err == MP_OKAY) {
        /* u1 = r.z'.z' mod prime */
        sp_256_mont_sqr_10(p1->z, p1->z, p256_mod, p256_mp_mod);
        sp_256_mont_mul_10(u1, u2, p1->z, p256_mod, p256_mp_mod);
        *res = (sp_256_cmp_10(p1->x, u1) == 0);
        if (*res == 0) {
            /* Reload r and add order. */
            sp_256_from_mp(u2, 10, r);
            carry = sp_256_add_10(u2, u2, p256_order);
            /* Carry means result is greater than mod and is not valid. */
            if (carry == 0) {
                sp_256_norm_10(u2);

                /* Compare with mod and if greater or equal then not valid. */
                c = sp_256_cmp_10(u2, p256_mod);
            }
         }
         if ((*res == 0) && (c < 0)) {
            /* Convert to Montogomery form */
            err = sp_256_mod_mul_norm_10(u2, u2, p256_mod);
            if (err == MP_OKAY) {
                /* u1 = (r + 1*order).z'.z' mod prime */
                sp_256_mont_mul_10(u1, u2, p1->z, p256_mod,
                    p256_mp_mod);
                *res = (sp_256_cmp_10(p1->x, u1) == 0);
            }
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL)
        XFREE(d, heap, DYNAMIC_TYPE_ECC);
#endif
    sp_256_point_free_10(p1, 0, heap);
    sp_256_point_free_10(p2, 0, heap);

    return err;
}
#endif /* HAVE_ECC_VERIFY */

#ifdef HAVE_ECC_CHECK_KEY
/* Check that the x and y oridinates are a valid point on the curve.
 *
 * point  EC point.
 * heap   Heap to use if dynamically allocating.
 * returns MEMORY_E if dynamic memory allocation fails, MP_VAL if the point is
 * not on the curve and MP_OKAY otherwise.
 */
static int sp_256_ecc_is_point_10(const sp_point_256* point, void* heap)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* d = NULL;
#else
    sp_digit t1d[2*10];
    sp_digit t2d[2*10];
#endif
    sp_digit* t1;
    sp_digit* t2;
    int err = MP_OKAY;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 10 * 4, heap, DYNAMIC_TYPE_ECC);
    if (d == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t1 = d + 0 * 10;
        t2 = d + 2 * 10;
#else
        (void)heap;

        t1 = t1d;
        t2 = t2d;
#endif

        sp_256_sqr_10(t1, point->y);
        (void)sp_256_mod_10(t1, t1, p256_mod);
        sp_256_sqr_10(t2, point->x);
        (void)sp_256_mod_10(t2, t2, p256_mod);
        sp_256_mul_10(t2, t2, point->x);
        (void)sp_256_mod_10(t2, t2, p256_mod);
        (void)sp_256_sub_10(t2, p256_mod, t2);
        sp_256_mont_add_10(t1, t1, t2, p256_mod);

        sp_256_mont_add_10(t1, t1, point->x, p256_mod);
        sp_256_mont_add_10(t1, t1, point->x, p256_mod);
        sp_256_mont_add_10(t1, t1, point->x, p256_mod);

        if (sp_256_cmp_10(t1, p256_b) != 0) {
            err = MP_VAL;
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL) {
        XFREE(d, heap, DYNAMIC_TYPE_ECC);
    }
#endif

    return err;
}

/* Check that the x and y oridinates are a valid point on the curve.
 *
 * pX  X ordinate of EC point.
 * pY  Y ordinate of EC point.
 * returns MEMORY_E if dynamic memory allocation fails, MP_VAL if the point is
 * not on the curve and MP_OKAY otherwise.
 */
int sp_ecc_is_point_256(const mp_int* pX, const mp_int* pY)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_256 pubd;
#endif
    sp_point_256* pub;
    byte one[1] = { 1 };
    int err;

    err = sp_256_point_new_10(NULL, pubd, pub);
    if (err == MP_OKAY) {
        sp_256_from_mp(pub->x, 10, pX);
        sp_256_from_mp(pub->y, 10, pY);
        sp_256_from_bin(pub->z, 10, one, (int)sizeof(one));

        err = sp_256_ecc_is_point_10(pub, NULL);
    }

    sp_256_point_free_10(pub, 0, NULL);

    return err;
}

/* Check that the private scalar generates the EC point (px, py), the point is
 * on the curve and the point has the correct order.
 *
 * pX     X ordinate of EC point.
 * pY     Y ordinate of EC point.
 * privm  Private scalar that generates EC point.
 * returns MEMORY_E if dynamic memory allocation fails, MP_VAL if the point is
 * not on the curve, ECC_INF_E if the point does not have the correct order,
 * ECC_PRIV_KEY_E when the private scalar doesn't generate the EC point and
 * MP_OKAY otherwise.
 */
int sp_ecc_check_key_256(const mp_int* pX, const mp_int* pY,
    const mp_int* privm, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit privd[10];
    sp_point_256 pubd;
    sp_point_256 pd;
#endif
    sp_digit* priv = NULL;
    sp_point_256* pub;
    sp_point_256* p = NULL;
    byte one[1] = { 1 };
    int err;

    err = sp_256_point_new_10(heap, pubd, pub);
    if (err == MP_OKAY) {
        err = sp_256_point_new_10(heap, pd, p);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        priv = (sp_digit*)XMALLOC(sizeof(sp_digit) * 10, heap,
                                                              DYNAMIC_TYPE_ECC);
        if (priv == NULL) {
            err = MEMORY_E;
        }
    }
#endif

    if (err == MP_OKAY) {
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
        priv = privd;
#endif

        sp_256_from_mp(pub->x, 10, pX);
        sp_256_from_mp(pub->y, 10, pY);
        sp_256_from_bin(pub->z, 10, one, (int)sizeof(one));
        sp_256_from_mp(priv, 10, privm);

        /* Check point at infinitiy. */
        if ((sp_256_iszero_10(pub->x) != 0) &&
            (sp_256_iszero_10(pub->y) != 0)) {
            err = ECC_INF_E;
        }
    }

    /* Check range of X and Y */
    if ((err == MP_OKAY) &&
            ((sp_256_cmp_10(pub->x, p256_mod) >= 0) ||
             (sp_256_cmp_10(pub->y, p256_mod) >= 0))) {
        err = ECC_OUT_OF_RANGE_E;
    }

    if (err == MP_OKAY) {
        /* Check point is on curve */
        err = sp_256_ecc_is_point_10(pub, heap);
    }

    if (err == MP_OKAY) {
        /* Point * order = infinity */
            err = sp_256_ecc_mulmod_10(p, pub, p256_order, 1, heap);
    }
    /* Check result is infinity */
    if ((err == MP_OKAY) && ((sp_256_iszero_10(p->x) == 0) ||
                             (sp_256_iszero_10(p->y) == 0))) {
        err = ECC_INF_E;
    }

    if (err == MP_OKAY) {
        /* Base * private = point */
            err = sp_256_ecc_mulmod_base_10(p, priv, 1, heap);
    }
    /* Check result is public key */
    if ((err == MP_OKAY) && ((sp_256_cmp_10(p->x, pub->x) != 0) ||
                             (sp_256_cmp_10(p->y, pub->y) != 0))) {
        err = ECC_PRIV_KEY_E;
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (priv != NULL) {
        XFREE(priv, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_256_point_free_10(p, 0, heap);
    sp_256_point_free_10(pub, 0, heap);

    return err;
}
#endif
#ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
/* Add two projective EC points together.
 * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
 *
 * pX   First EC point's X ordinate.
 * pY   First EC point's Y ordinate.
 * pZ   First EC point's Z ordinate.
 * qX   Second EC point's X ordinate.
 * qY   Second EC point's Y ordinate.
 * qZ   Second EC point's Z ordinate.
 * rX   Resultant EC point's X ordinate.
 * rY   Resultant EC point's Y ordinate.
 * rZ   Resultant EC point's Z ordinate.
 * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
 */
int sp_ecc_proj_add_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                              mp_int* qX, mp_int* qY, mp_int* qZ,
                              mp_int* rX, mp_int* rY, mp_int* rZ)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit tmpd[2 * 10 * 5];
    sp_point_256 pd;
    sp_point_256 qd;
#endif
    sp_digit* tmp;
    sp_point_256* p;
    sp_point_256* q = NULL;
    int err;

    err = sp_256_point_new_10(NULL, pd, p);
    if (err == MP_OKAY) {
        err = sp_256_point_new_10(NULL, qd, q);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 10 * 5, NULL,
                                                              DYNAMIC_TYPE_ECC);
        if (tmp == NULL) {
            err = MEMORY_E;
        }
    }
#else
    tmp = tmpd;
#endif

    if (err == MP_OKAY) {
        sp_256_from_mp(p->x, 10, pX);
        sp_256_from_mp(p->y, 10, pY);
        sp_256_from_mp(p->z, 10, pZ);
        sp_256_from_mp(q->x, 10, qX);
        sp_256_from_mp(q->y, 10, qY);
        sp_256_from_mp(q->z, 10, qZ);

            sp_256_proj_point_add_10(p, p, q, tmp);
    }

    if (err == MP_OKAY) {
        err = sp_256_to_mp(p->x, rX);
    }
    if (err == MP_OKAY) {
        err = sp_256_to_mp(p->y, rY);
    }
    if (err == MP_OKAY) {
        err = sp_256_to_mp(p->z, rZ);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (tmp != NULL) {
        XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_256_point_free_10(q, 0, NULL);
    sp_256_point_free_10(p, 0, NULL);

    return err;
}

/* Double a projective EC point.
 * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
 *
 * pX   EC point's X ordinate.
 * pY   EC point's Y ordinate.
 * pZ   EC point's Z ordinate.
 * rX   Resultant EC point's X ordinate.
 * rY   Resultant EC point's Y ordinate.
 * rZ   Resultant EC point's Z ordinate.
 * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
 */
int sp_ecc_proj_dbl_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                              mp_int* rX, mp_int* rY, mp_int* rZ)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit tmpd[2 * 10 * 2];
    sp_point_256 pd;
#endif
    sp_digit* tmp;
    sp_point_256* p;
    int err;

    err = sp_256_point_new_10(NULL, pd, p);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 10 * 2, NULL,
                                                              DYNAMIC_TYPE_ECC);
        if (tmp == NULL) {
            err = MEMORY_E;
        }
    }
#else
    tmp = tmpd;
#endif

    if (err == MP_OKAY) {
        sp_256_from_mp(p->x, 10, pX);
        sp_256_from_mp(p->y, 10, pY);
        sp_256_from_mp(p->z, 10, pZ);

            sp_256_proj_point_dbl_10(p, p, tmp);
    }

    if (err == MP_OKAY) {
        err = sp_256_to_mp(p->x, rX);
    }
    if (err == MP_OKAY) {
        err = sp_256_to_mp(p->y, rY);
    }
    if (err == MP_OKAY) {
        err = sp_256_to_mp(p->z, rZ);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (tmp != NULL) {
        XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_256_point_free_10(p, 0, NULL);

    return err;
}

/* Map a projective EC point to affine in place.
 * pZ will be one.
 *
 * pX   EC point's X ordinate.
 * pY   EC point's Y ordinate.
 * pZ   EC point's Z ordinate.
 * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
 */
int sp_ecc_map_256(mp_int* pX, mp_int* pY, mp_int* pZ)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit tmpd[2 * 10 * 4];
    sp_point_256 pd;
#endif
    sp_digit* tmp;
    sp_point_256* p;
    int err;

    err = sp_256_point_new_10(NULL, pd, p);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 10 * 4, NULL,
                                                              DYNAMIC_TYPE_ECC);
        if (tmp == NULL) {
            err = MEMORY_E;
        }
    }
#else
    tmp = tmpd;
#endif
    if (err == MP_OKAY) {
        sp_256_from_mp(p->x, 10, pX);
        sp_256_from_mp(p->y, 10, pY);
        sp_256_from_mp(p->z, 10, pZ);

        sp_256_map_10(p, p, tmp);
    }

    if (err == MP_OKAY) {
        err = sp_256_to_mp(p->x, pX);
    }
    if (err == MP_OKAY) {
        err = sp_256_to_mp(p->y, pY);
    }
    if (err == MP_OKAY) {
        err = sp_256_to_mp(p->z, pZ);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (tmp != NULL) {
        XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_256_point_free_10(p, 0, NULL);

    return err;
}
#endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
#ifdef HAVE_COMP_KEY
/* Find the square root of a number mod the prime of the curve.
 *
 * y  The number to operate on and the result.
 * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
 */
static int sp_256_mont_sqrt_10(sp_digit* y)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* d;
#else
    sp_digit t1d[2 * 10];
    sp_digit t2d[2 * 10];
#endif
    sp_digit* t1;
    sp_digit* t2;
    int err = MP_OKAY;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 4 * 10, NULL, DYNAMIC_TYPE_ECC);
    if (d == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t1 = d + 0 * 10;
        t2 = d + 2 * 10;
#else
        t1 = t1d;
        t2 = t2d;
#endif

        {
            /* t2 = y ^ 0x2 */
            sp_256_mont_sqr_10(t2, y, p256_mod, p256_mp_mod);
            /* t1 = y ^ 0x3 */
            sp_256_mont_mul_10(t1, t2, y, p256_mod, p256_mp_mod);
            /* t2 = y ^ 0xc */
            sp_256_mont_sqr_n_10(t2, t1, 2, p256_mod, p256_mp_mod);
            /* t1 = y ^ 0xf */
            sp_256_mont_mul_10(t1, t1, t2, p256_mod, p256_mp_mod);
            /* t2 = y ^ 0xf0 */
            sp_256_mont_sqr_n_10(t2, t1, 4, p256_mod, p256_mp_mod);
            /* t1 = y ^ 0xff */
            sp_256_mont_mul_10(t1, t1, t2, p256_mod, p256_mp_mod);
            /* t2 = y ^ 0xff00 */
            sp_256_mont_sqr_n_10(t2, t1, 8, p256_mod, p256_mp_mod);
            /* t1 = y ^ 0xffff */
            sp_256_mont_mul_10(t1, t1, t2, p256_mod, p256_mp_mod);
            /* t2 = y ^ 0xffff0000 */
            sp_256_mont_sqr_n_10(t2, t1, 16, p256_mod, p256_mp_mod);
            /* t1 = y ^ 0xffffffff */
            sp_256_mont_mul_10(t1, t1, t2, p256_mod, p256_mp_mod);
            /* t1 = y ^ 0xffffffff00000000 */
            sp_256_mont_sqr_n_10(t1, t1, 32, p256_mod, p256_mp_mod);
            /* t1 = y ^ 0xffffffff00000001 */
            sp_256_mont_mul_10(t1, t1, y, p256_mod, p256_mp_mod);
            /* t1 = y ^ 0xffffffff00000001000000000000000000000000 */
            sp_256_mont_sqr_n_10(t1, t1, 96, p256_mod, p256_mp_mod);
            /* t1 = y ^ 0xffffffff00000001000000000000000000000001 */
            sp_256_mont_mul_10(t1, t1, y, p256_mod, p256_mp_mod);
            sp_256_mont_sqr_n_10(y, t1, 94, p256_mod, p256_mp_mod);
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL) {
        XFREE(d, NULL, DYNAMIC_TYPE_ECC);
    }
#endif

    return err;
}


/* Uncompress the point given the X ordinate.
 *
 * xm    X ordinate.
 * odd   Whether the Y ordinate is odd.
 * ym    Calculated Y ordinate.
 * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
 */
int sp_ecc_uncompress_256(mp_int* xm, int odd, mp_int* ym)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* d;
#else
    sp_digit xd[2 * 10];
    sp_digit yd[2 * 10];
#endif
    sp_digit* x = NULL;
    sp_digit* y = NULL;
    int err = MP_OKAY;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 4 * 10, NULL, DYNAMIC_TYPE_ECC);
    if (d == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        x = d + 0 * 10;
        y = d + 2 * 10;
#else
        x = xd;
        y = yd;
#endif

        sp_256_from_mp(x, 10, xm);
        err = sp_256_mod_mul_norm_10(x, x, p256_mod);
    }
    if (err == MP_OKAY) {
        /* y = x^3 */
        {
            sp_256_mont_sqr_10(y, x, p256_mod, p256_mp_mod);
            sp_256_mont_mul_10(y, y, x, p256_mod, p256_mp_mod);
        }
        /* y = x^3 - 3x */
        sp_256_mont_sub_10(y, y, x, p256_mod);
        sp_256_mont_sub_10(y, y, x, p256_mod);
        sp_256_mont_sub_10(y, y, x, p256_mod);
        /* y = x^3 - 3x + b */
        err = sp_256_mod_mul_norm_10(x, p256_b, p256_mod);
    }
    if (err == MP_OKAY) {
        sp_256_mont_add_10(y, y, x, p256_mod);
        /* y = sqrt(x^3 - 3x + b) */
        err = sp_256_mont_sqrt_10(y);
    }
    if (err == MP_OKAY) {
        XMEMSET(y + 10, 0, 10U * sizeof(sp_digit));
        sp_256_mont_reduce_10(y, p256_mod, p256_mp_mod);
        if ((((word32)y[0] ^ (word32)odd) & 1U) != 0U) {
            sp_256_mont_sub_10(y, p256_mod, y, p256_mod);
        }

        err = sp_256_to_mp(y, ym);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL) {
        XFREE(d, NULL, DYNAMIC_TYPE_ECC);
    }
#endif

    return err;
}
#endif
#endif /* !WOLFSSL_SP_NO_256 */
#ifdef WOLFSSL_SP_384

/* Point structure to use. */
typedef struct sp_point_384 {
    /* X ordinate of point. */
    sp_digit x[2 * 15];
    /* Y ordinate of point. */
    sp_digit y[2 * 15];
    /* Z ordinate of point. */
    sp_digit z[2 * 15];
    /* Indicates point is at infinity. */
    int infinity;
} sp_point_384;

#ifdef WOLFSSL_SP_SMALL
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_384_mul_15(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[14]) * b[14];
    r[29] = (sp_digit)(c >> 26);
    c = (c & 0x3ffffff) << 26;
    for (k = 27; k >= 0; k--) {
        for (i = 14; i >= 0; i--) {
            j = k - i;
            if (j >= 15) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * b[j];
        }
        r[k + 2] += c >> 52;
        r[k + 1] = (c >> 26) & 0x3ffffff;
        c = (c & 0x3ffffff) << 26;
    }
    r[0] = (sp_digit)(c >> 26);
}

#else
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_384_mul_15(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int64_t t0   = ((int64_t)a[ 0]) * b[ 0];
    int64_t t1   = ((int64_t)a[ 0]) * b[ 1]
                 + ((int64_t)a[ 1]) * b[ 0];
    int64_t t2   = ((int64_t)a[ 0]) * b[ 2]
                 + ((int64_t)a[ 1]) * b[ 1]
                 + ((int64_t)a[ 2]) * b[ 0];
    int64_t t3   = ((int64_t)a[ 0]) * b[ 3]
                 + ((int64_t)a[ 1]) * b[ 2]
                 + ((int64_t)a[ 2]) * b[ 1]
                 + ((int64_t)a[ 3]) * b[ 0];
    int64_t t4   = ((int64_t)a[ 0]) * b[ 4]
                 + ((int64_t)a[ 1]) * b[ 3]
                 + ((int64_t)a[ 2]) * b[ 2]
                 + ((int64_t)a[ 3]) * b[ 1]
                 + ((int64_t)a[ 4]) * b[ 0];
    int64_t t5   = ((int64_t)a[ 0]) * b[ 5]
                 + ((int64_t)a[ 1]) * b[ 4]
                 + ((int64_t)a[ 2]) * b[ 3]
                 + ((int64_t)a[ 3]) * b[ 2]
                 + ((int64_t)a[ 4]) * b[ 1]
                 + ((int64_t)a[ 5]) * b[ 0];
    int64_t t6   = ((int64_t)a[ 0]) * b[ 6]
                 + ((int64_t)a[ 1]) * b[ 5]
                 + ((int64_t)a[ 2]) * b[ 4]
                 + ((int64_t)a[ 3]) * b[ 3]
                 + ((int64_t)a[ 4]) * b[ 2]
                 + ((int64_t)a[ 5]) * b[ 1]
                 + ((int64_t)a[ 6]) * b[ 0];
    int64_t t7   = ((int64_t)a[ 0]) * b[ 7]
                 + ((int64_t)a[ 1]) * b[ 6]
                 + ((int64_t)a[ 2]) * b[ 5]
                 + ((int64_t)a[ 3]) * b[ 4]
                 + ((int64_t)a[ 4]) * b[ 3]
                 + ((int64_t)a[ 5]) * b[ 2]
                 + ((int64_t)a[ 6]) * b[ 1]
                 + ((int64_t)a[ 7]) * b[ 0];
    int64_t t8   = ((int64_t)a[ 0]) * b[ 8]
                 + ((int64_t)a[ 1]) * b[ 7]
                 + ((int64_t)a[ 2]) * b[ 6]
                 + ((int64_t)a[ 3]) * b[ 5]
                 + ((int64_t)a[ 4]) * b[ 4]
                 + ((int64_t)a[ 5]) * b[ 3]
                 + ((int64_t)a[ 6]) * b[ 2]
                 + ((int64_t)a[ 7]) * b[ 1]
                 + ((int64_t)a[ 8]) * b[ 0];
    int64_t t9   = ((int64_t)a[ 0]) * b[ 9]
                 + ((int64_t)a[ 1]) * b[ 8]
                 + ((int64_t)a[ 2]) * b[ 7]
                 + ((int64_t)a[ 3]) * b[ 6]
                 + ((int64_t)a[ 4]) * b[ 5]
                 + ((int64_t)a[ 5]) * b[ 4]
                 + ((int64_t)a[ 6]) * b[ 3]
                 + ((int64_t)a[ 7]) * b[ 2]
                 + ((int64_t)a[ 8]) * b[ 1]
                 + ((int64_t)a[ 9]) * b[ 0];
    int64_t t10  = ((int64_t)a[ 0]) * b[10]
                 + ((int64_t)a[ 1]) * b[ 9]
                 + ((int64_t)a[ 2]) * b[ 8]
                 + ((int64_t)a[ 3]) * b[ 7]
                 + ((int64_t)a[ 4]) * b[ 6]
                 + ((int64_t)a[ 5]) * b[ 5]
                 + ((int64_t)a[ 6]) * b[ 4]
                 + ((int64_t)a[ 7]) * b[ 3]
                 + ((int64_t)a[ 8]) * b[ 2]
                 + ((int64_t)a[ 9]) * b[ 1]
                 + ((int64_t)a[10]) * b[ 0];
    int64_t t11  = ((int64_t)a[ 0]) * b[11]
                 + ((int64_t)a[ 1]) * b[10]
                 + ((int64_t)a[ 2]) * b[ 9]
                 + ((int64_t)a[ 3]) * b[ 8]
                 + ((int64_t)a[ 4]) * b[ 7]
                 + ((int64_t)a[ 5]) * b[ 6]
                 + ((int64_t)a[ 6]) * b[ 5]
                 + ((int64_t)a[ 7]) * b[ 4]
                 + ((int64_t)a[ 8]) * b[ 3]
                 + ((int64_t)a[ 9]) * b[ 2]
                 + ((int64_t)a[10]) * b[ 1]
                 + ((int64_t)a[11]) * b[ 0];
    int64_t t12  = ((int64_t)a[ 0]) * b[12]
                 + ((int64_t)a[ 1]) * b[11]
                 + ((int64_t)a[ 2]) * b[10]
                 + ((int64_t)a[ 3]) * b[ 9]
                 + ((int64_t)a[ 4]) * b[ 8]
                 + ((int64_t)a[ 5]) * b[ 7]
                 + ((int64_t)a[ 6]) * b[ 6]
                 + ((int64_t)a[ 7]) * b[ 5]
                 + ((int64_t)a[ 8]) * b[ 4]
                 + ((int64_t)a[ 9]) * b[ 3]
                 + ((int64_t)a[10]) * b[ 2]
                 + ((int64_t)a[11]) * b[ 1]
                 + ((int64_t)a[12]) * b[ 0];
    int64_t t13  = ((int64_t)a[ 0]) * b[13]
                 + ((int64_t)a[ 1]) * b[12]
                 + ((int64_t)a[ 2]) * b[11]
                 + ((int64_t)a[ 3]) * b[10]
                 + ((int64_t)a[ 4]) * b[ 9]
                 + ((int64_t)a[ 5]) * b[ 8]
                 + ((int64_t)a[ 6]) * b[ 7]
                 + ((int64_t)a[ 7]) * b[ 6]
                 + ((int64_t)a[ 8]) * b[ 5]
                 + ((int64_t)a[ 9]) * b[ 4]
                 + ((int64_t)a[10]) * b[ 3]
                 + ((int64_t)a[11]) * b[ 2]
                 + ((int64_t)a[12]) * b[ 1]
                 + ((int64_t)a[13]) * b[ 0];
    int64_t t14  = ((int64_t)a[ 0]) * b[14]
                 + ((int64_t)a[ 1]) * b[13]
                 + ((int64_t)a[ 2]) * b[12]
                 + ((int64_t)a[ 3]) * b[11]
                 + ((int64_t)a[ 4]) * b[10]
                 + ((int64_t)a[ 5]) * b[ 9]
                 + ((int64_t)a[ 6]) * b[ 8]
                 + ((int64_t)a[ 7]) * b[ 7]
                 + ((int64_t)a[ 8]) * b[ 6]
                 + ((int64_t)a[ 9]) * b[ 5]
                 + ((int64_t)a[10]) * b[ 4]
                 + ((int64_t)a[11]) * b[ 3]
                 + ((int64_t)a[12]) * b[ 2]
                 + ((int64_t)a[13]) * b[ 1]
                 + ((int64_t)a[14]) * b[ 0];
    int64_t t15  = ((int64_t)a[ 1]) * b[14]
                 + ((int64_t)a[ 2]) * b[13]
                 + ((int64_t)a[ 3]) * b[12]
                 + ((int64_t)a[ 4]) * b[11]
                 + ((int64_t)a[ 5]) * b[10]
                 + ((int64_t)a[ 6]) * b[ 9]
                 + ((int64_t)a[ 7]) * b[ 8]
                 + ((int64_t)a[ 8]) * b[ 7]
                 + ((int64_t)a[ 9]) * b[ 6]
                 + ((int64_t)a[10]) * b[ 5]
                 + ((int64_t)a[11]) * b[ 4]
                 + ((int64_t)a[12]) * b[ 3]
                 + ((int64_t)a[13]) * b[ 2]
                 + ((int64_t)a[14]) * b[ 1];
    int64_t t16  = ((int64_t)a[ 2]) * b[14]
                 + ((int64_t)a[ 3]) * b[13]
                 + ((int64_t)a[ 4]) * b[12]
                 + ((int64_t)a[ 5]) * b[11]
                 + ((int64_t)a[ 6]) * b[10]
                 + ((int64_t)a[ 7]) * b[ 9]
                 + ((int64_t)a[ 8]) * b[ 8]
                 + ((int64_t)a[ 9]) * b[ 7]
                 + ((int64_t)a[10]) * b[ 6]
                 + ((int64_t)a[11]) * b[ 5]
                 + ((int64_t)a[12]) * b[ 4]
                 + ((int64_t)a[13]) * b[ 3]
                 + ((int64_t)a[14]) * b[ 2];
    int64_t t17  = ((int64_t)a[ 3]) * b[14]
                 + ((int64_t)a[ 4]) * b[13]
                 + ((int64_t)a[ 5]) * b[12]
                 + ((int64_t)a[ 6]) * b[11]
                 + ((int64_t)a[ 7]) * b[10]
                 + ((int64_t)a[ 8]) * b[ 9]
                 + ((int64_t)a[ 9]) * b[ 8]
                 + ((int64_t)a[10]) * b[ 7]
                 + ((int64_t)a[11]) * b[ 6]
                 + ((int64_t)a[12]) * b[ 5]
                 + ((int64_t)a[13]) * b[ 4]
                 + ((int64_t)a[14]) * b[ 3];
    int64_t t18  = ((int64_t)a[ 4]) * b[14]
                 + ((int64_t)a[ 5]) * b[13]
                 + ((int64_t)a[ 6]) * b[12]
                 + ((int64_t)a[ 7]) * b[11]
                 + ((int64_t)a[ 8]) * b[10]
                 + ((int64_t)a[ 9]) * b[ 9]
                 + ((int64_t)a[10]) * b[ 8]
                 + ((int64_t)a[11]) * b[ 7]
                 + ((int64_t)a[12]) * b[ 6]
                 + ((int64_t)a[13]) * b[ 5]
                 + ((int64_t)a[14]) * b[ 4];
    int64_t t19  = ((int64_t)a[ 5]) * b[14]
                 + ((int64_t)a[ 6]) * b[13]
                 + ((int64_t)a[ 7]) * b[12]
                 + ((int64_t)a[ 8]) * b[11]
                 + ((int64_t)a[ 9]) * b[10]
                 + ((int64_t)a[10]) * b[ 9]
                 + ((int64_t)a[11]) * b[ 8]
                 + ((int64_t)a[12]) * b[ 7]
                 + ((int64_t)a[13]) * b[ 6]
                 + ((int64_t)a[14]) * b[ 5];
    int64_t t20  = ((int64_t)a[ 6]) * b[14]
                 + ((int64_t)a[ 7]) * b[13]
                 + ((int64_t)a[ 8]) * b[12]
                 + ((int64_t)a[ 9]) * b[11]
                 + ((int64_t)a[10]) * b[10]
                 + ((int64_t)a[11]) * b[ 9]
                 + ((int64_t)a[12]) * b[ 8]
                 + ((int64_t)a[13]) * b[ 7]
                 + ((int64_t)a[14]) * b[ 6];
    int64_t t21  = ((int64_t)a[ 7]) * b[14]
                 + ((int64_t)a[ 8]) * b[13]
                 + ((int64_t)a[ 9]) * b[12]
                 + ((int64_t)a[10]) * b[11]
                 + ((int64_t)a[11]) * b[10]
                 + ((int64_t)a[12]) * b[ 9]
                 + ((int64_t)a[13]) * b[ 8]
                 + ((int64_t)a[14]) * b[ 7];
    int64_t t22  = ((int64_t)a[ 8]) * b[14]
                 + ((int64_t)a[ 9]) * b[13]
                 + ((int64_t)a[10]) * b[12]
                 + ((int64_t)a[11]) * b[11]
                 + ((int64_t)a[12]) * b[10]
                 + ((int64_t)a[13]) * b[ 9]
                 + ((int64_t)a[14]) * b[ 8];
    int64_t t23  = ((int64_t)a[ 9]) * b[14]
                 + ((int64_t)a[10]) * b[13]
                 + ((int64_t)a[11]) * b[12]
                 + ((int64_t)a[12]) * b[11]
                 + ((int64_t)a[13]) * b[10]
                 + ((int64_t)a[14]) * b[ 9];
    int64_t t24  = ((int64_t)a[10]) * b[14]
                 + ((int64_t)a[11]) * b[13]
                 + ((int64_t)a[12]) * b[12]
                 + ((int64_t)a[13]) * b[11]
                 + ((int64_t)a[14]) * b[10];
    int64_t t25  = ((int64_t)a[11]) * b[14]
                 + ((int64_t)a[12]) * b[13]
                 + ((int64_t)a[13]) * b[12]
                 + ((int64_t)a[14]) * b[11];
    int64_t t26  = ((int64_t)a[12]) * b[14]
                 + ((int64_t)a[13]) * b[13]
                 + ((int64_t)a[14]) * b[12];
    int64_t t27  = ((int64_t)a[13]) * b[14]
                 + ((int64_t)a[14]) * b[13];
    int64_t t28  = ((int64_t)a[14]) * b[14];

    t1   += t0  >> 26; r[ 0] = t0  & 0x3ffffff;
    t2   += t1  >> 26; r[ 1] = t1  & 0x3ffffff;
    t3   += t2  >> 26; r[ 2] = t2  & 0x3ffffff;
    t4   += t3  >> 26; r[ 3] = t3  & 0x3ffffff;
    t5   += t4  >> 26; r[ 4] = t4  & 0x3ffffff;
    t6   += t5  >> 26; r[ 5] = t5  & 0x3ffffff;
    t7   += t6  >> 26; r[ 6] = t6  & 0x3ffffff;
    t8   += t7  >> 26; r[ 7] = t7  & 0x3ffffff;
    t9   += t8  >> 26; r[ 8] = t8  & 0x3ffffff;
    t10  += t9  >> 26; r[ 9] = t9  & 0x3ffffff;
    t11  += t10 >> 26; r[10] = t10 & 0x3ffffff;
    t12  += t11 >> 26; r[11] = t11 & 0x3ffffff;
    t13  += t12 >> 26; r[12] = t12 & 0x3ffffff;
    t14  += t13 >> 26; r[13] = t13 & 0x3ffffff;
    t15  += t14 >> 26; r[14] = t14 & 0x3ffffff;
    t16  += t15 >> 26; r[15] = t15 & 0x3ffffff;
    t17  += t16 >> 26; r[16] = t16 & 0x3ffffff;
    t18  += t17 >> 26; r[17] = t17 & 0x3ffffff;
    t19  += t18 >> 26; r[18] = t18 & 0x3ffffff;
    t20  += t19 >> 26; r[19] = t19 & 0x3ffffff;
    t21  += t20 >> 26; r[20] = t20 & 0x3ffffff;
    t22  += t21 >> 26; r[21] = t21 & 0x3ffffff;
    t23  += t22 >> 26; r[22] = t22 & 0x3ffffff;
    t24  += t23 >> 26; r[23] = t23 & 0x3ffffff;
    t25  += t24 >> 26; r[24] = t24 & 0x3ffffff;
    t26  += t25 >> 26; r[25] = t25 & 0x3ffffff;
    t27  += t26 >> 26; r[26] = t26 & 0x3ffffff;
    t28  += t27 >> 26; r[27] = t27 & 0x3ffffff;
    r[29] = (sp_digit)(t28 >> 26);
                       r[28] = t28 & 0x3ffffff;
}

#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_384_sqr_15(sp_digit* r, const sp_digit* a)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[14]) * a[14];
    r[29] = (sp_digit)(c >> 26);
    c = (c & 0x3ffffff) << 26;
    for (k = 27; k >= 0; k--) {
        for (i = 14; i >= 0; i--) {
            j = k - i;
            if (j >= 15 || i <= j) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * a[j] * 2;
        }
        if (i == j) {
           c += ((int64_t)a[i]) * a[i];
        }

        r[k + 2] += c >> 52;
        r[k + 1] = (c >> 26) & 0x3ffffff;
        c = (c & 0x3ffffff) << 26;
    }
    r[0] = (sp_digit)(c >> 26);
}

#else
/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_384_sqr_15(sp_digit* r, const sp_digit* a)
{
    int64_t t0   =  ((int64_t)a[ 0]) * a[ 0];
    int64_t t1   = (((int64_t)a[ 0]) * a[ 1]) * 2;
    int64_t t2   = (((int64_t)a[ 0]) * a[ 2]) * 2
                 +  ((int64_t)a[ 1]) * a[ 1];
    int64_t t3   = (((int64_t)a[ 0]) * a[ 3]
                 +  ((int64_t)a[ 1]) * a[ 2]) * 2;
    int64_t t4   = (((int64_t)a[ 0]) * a[ 4]
                 +  ((int64_t)a[ 1]) * a[ 3]) * 2
                 +  ((int64_t)a[ 2]) * a[ 2];
    int64_t t5   = (((int64_t)a[ 0]) * a[ 5]
                 +  ((int64_t)a[ 1]) * a[ 4]
                 +  ((int64_t)a[ 2]) * a[ 3]) * 2;
    int64_t t6   = (((int64_t)a[ 0]) * a[ 6]
                 +  ((int64_t)a[ 1]) * a[ 5]
                 +  ((int64_t)a[ 2]) * a[ 4]) * 2
                 +  ((int64_t)a[ 3]) * a[ 3];
    int64_t t7   = (((int64_t)a[ 0]) * a[ 7]
                 +  ((int64_t)a[ 1]) * a[ 6]
                 +  ((int64_t)a[ 2]) * a[ 5]
                 +  ((int64_t)a[ 3]) * a[ 4]) * 2;
    int64_t t8   = (((int64_t)a[ 0]) * a[ 8]
                 +  ((int64_t)a[ 1]) * a[ 7]
                 +  ((int64_t)a[ 2]) * a[ 6]
                 +  ((int64_t)a[ 3]) * a[ 5]) * 2
                 +  ((int64_t)a[ 4]) * a[ 4];
    int64_t t9   = (((int64_t)a[ 0]) * a[ 9]
                 +  ((int64_t)a[ 1]) * a[ 8]
                 +  ((int64_t)a[ 2]) * a[ 7]
                 +  ((int64_t)a[ 3]) * a[ 6]
                 +  ((int64_t)a[ 4]) * a[ 5]) * 2;
    int64_t t10  = (((int64_t)a[ 0]) * a[10]
                 +  ((int64_t)a[ 1]) * a[ 9]
                 +  ((int64_t)a[ 2]) * a[ 8]
                 +  ((int64_t)a[ 3]) * a[ 7]
                 +  ((int64_t)a[ 4]) * a[ 6]) * 2
                 +  ((int64_t)a[ 5]) * a[ 5];
    int64_t t11  = (((int64_t)a[ 0]) * a[11]
                 +  ((int64_t)a[ 1]) * a[10]
                 +  ((int64_t)a[ 2]) * a[ 9]
                 +  ((int64_t)a[ 3]) * a[ 8]
                 +  ((int64_t)a[ 4]) * a[ 7]
                 +  ((int64_t)a[ 5]) * a[ 6]) * 2;
    int64_t t12  = (((int64_t)a[ 0]) * a[12]
                 +  ((int64_t)a[ 1]) * a[11]
                 +  ((int64_t)a[ 2]) * a[10]
                 +  ((int64_t)a[ 3]) * a[ 9]
                 +  ((int64_t)a[ 4]) * a[ 8]
                 +  ((int64_t)a[ 5]) * a[ 7]) * 2
                 +  ((int64_t)a[ 6]) * a[ 6];
    int64_t t13  = (((int64_t)a[ 0]) * a[13]
                 +  ((int64_t)a[ 1]) * a[12]
                 +  ((int64_t)a[ 2]) * a[11]
                 +  ((int64_t)a[ 3]) * a[10]
                 +  ((int64_t)a[ 4]) * a[ 9]
                 +  ((int64_t)a[ 5]) * a[ 8]
                 +  ((int64_t)a[ 6]) * a[ 7]) * 2;
    int64_t t14  = (((int64_t)a[ 0]) * a[14]
                 +  ((int64_t)a[ 1]) * a[13]
                 +  ((int64_t)a[ 2]) * a[12]
                 +  ((int64_t)a[ 3]) * a[11]
                 +  ((int64_t)a[ 4]) * a[10]
                 +  ((int64_t)a[ 5]) * a[ 9]
                 +  ((int64_t)a[ 6]) * a[ 8]) * 2
                 +  ((int64_t)a[ 7]) * a[ 7];
    int64_t t15  = (((int64_t)a[ 1]) * a[14]
                 +  ((int64_t)a[ 2]) * a[13]
                 +  ((int64_t)a[ 3]) * a[12]
                 +  ((int64_t)a[ 4]) * a[11]
                 +  ((int64_t)a[ 5]) * a[10]
                 +  ((int64_t)a[ 6]) * a[ 9]
                 +  ((int64_t)a[ 7]) * a[ 8]) * 2;
    int64_t t16  = (((int64_t)a[ 2]) * a[14]
                 +  ((int64_t)a[ 3]) * a[13]
                 +  ((int64_t)a[ 4]) * a[12]
                 +  ((int64_t)a[ 5]) * a[11]
                 +  ((int64_t)a[ 6]) * a[10]
                 +  ((int64_t)a[ 7]) * a[ 9]) * 2
                 +  ((int64_t)a[ 8]) * a[ 8];
    int64_t t17  = (((int64_t)a[ 3]) * a[14]
                 +  ((int64_t)a[ 4]) * a[13]
                 +  ((int64_t)a[ 5]) * a[12]
                 +  ((int64_t)a[ 6]) * a[11]
                 +  ((int64_t)a[ 7]) * a[10]
                 +  ((int64_t)a[ 8]) * a[ 9]) * 2;
    int64_t t18  = (((int64_t)a[ 4]) * a[14]
                 +  ((int64_t)a[ 5]) * a[13]
                 +  ((int64_t)a[ 6]) * a[12]
                 +  ((int64_t)a[ 7]) * a[11]
                 +  ((int64_t)a[ 8]) * a[10]) * 2
                 +  ((int64_t)a[ 9]) * a[ 9];
    int64_t t19  = (((int64_t)a[ 5]) * a[14]
                 +  ((int64_t)a[ 6]) * a[13]
                 +  ((int64_t)a[ 7]) * a[12]
                 +  ((int64_t)a[ 8]) * a[11]
                 +  ((int64_t)a[ 9]) * a[10]) * 2;
    int64_t t20  = (((int64_t)a[ 6]) * a[14]
                 +  ((int64_t)a[ 7]) * a[13]
                 +  ((int64_t)a[ 8]) * a[12]
                 +  ((int64_t)a[ 9]) * a[11]) * 2
                 +  ((int64_t)a[10]) * a[10];
    int64_t t21  = (((int64_t)a[ 7]) * a[14]
                 +  ((int64_t)a[ 8]) * a[13]
                 +  ((int64_t)a[ 9]) * a[12]
                 +  ((int64_t)a[10]) * a[11]) * 2;
    int64_t t22  = (((int64_t)a[ 8]) * a[14]
                 +  ((int64_t)a[ 9]) * a[13]
                 +  ((int64_t)a[10]) * a[12]) * 2
                 +  ((int64_t)a[11]) * a[11];
    int64_t t23  = (((int64_t)a[ 9]) * a[14]
                 +  ((int64_t)a[10]) * a[13]
                 +  ((int64_t)a[11]) * a[12]) * 2;
    int64_t t24  = (((int64_t)a[10]) * a[14]
                 +  ((int64_t)a[11]) * a[13]) * 2
                 +  ((int64_t)a[12]) * a[12];
    int64_t t25  = (((int64_t)a[11]) * a[14]
                 +  ((int64_t)a[12]) * a[13]) * 2;
    int64_t t26  = (((int64_t)a[12]) * a[14]) * 2
                 +  ((int64_t)a[13]) * a[13];
    int64_t t27  = (((int64_t)a[13]) * a[14]) * 2;
    int64_t t28  =  ((int64_t)a[14]) * a[14];

    t1   += t0  >> 26; r[ 0] = t0  & 0x3ffffff;
    t2   += t1  >> 26; r[ 1] = t1  & 0x3ffffff;
    t3   += t2  >> 26; r[ 2] = t2  & 0x3ffffff;
    t4   += t3  >> 26; r[ 3] = t3  & 0x3ffffff;
    t5   += t4  >> 26; r[ 4] = t4  & 0x3ffffff;
    t6   += t5  >> 26; r[ 5] = t5  & 0x3ffffff;
    t7   += t6  >> 26; r[ 6] = t6  & 0x3ffffff;
    t8   += t7  >> 26; r[ 7] = t7  & 0x3ffffff;
    t9   += t8  >> 26; r[ 8] = t8  & 0x3ffffff;
    t10  += t9  >> 26; r[ 9] = t9  & 0x3ffffff;
    t11  += t10 >> 26; r[10] = t10 & 0x3ffffff;
    t12  += t11 >> 26; r[11] = t11 & 0x3ffffff;
    t13  += t12 >> 26; r[12] = t12 & 0x3ffffff;
    t14  += t13 >> 26; r[13] = t13 & 0x3ffffff;
    t15  += t14 >> 26; r[14] = t14 & 0x3ffffff;
    t16  += t15 >> 26; r[15] = t15 & 0x3ffffff;
    t17  += t16 >> 26; r[16] = t16 & 0x3ffffff;
    t18  += t17 >> 26; r[17] = t17 & 0x3ffffff;
    t19  += t18 >> 26; r[18] = t18 & 0x3ffffff;
    t20  += t19 >> 26; r[19] = t19 & 0x3ffffff;
    t21  += t20 >> 26; r[20] = t20 & 0x3ffffff;
    t22  += t21 >> 26; r[21] = t21 & 0x3ffffff;
    t23  += t22 >> 26; r[22] = t22 & 0x3ffffff;
    t24  += t23 >> 26; r[23] = t23 & 0x3ffffff;
    t25  += t24 >> 26; r[24] = t24 & 0x3ffffff;
    t26  += t25 >> 26; r[25] = t25 & 0x3ffffff;
    t27  += t26 >> 26; r[26] = t26 & 0x3ffffff;
    t28  += t27 >> 26; r[27] = t27 & 0x3ffffff;
    r[29] = (sp_digit)(t28 >> 26);
                       r[28] = t28 & 0x3ffffff;
}

#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_384_add_15(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 15; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#else
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_384_add_15(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    r[ 0] = a[ 0] + b[ 0];
    r[ 1] = a[ 1] + b[ 1];
    r[ 2] = a[ 2] + b[ 2];
    r[ 3] = a[ 3] + b[ 3];
    r[ 4] = a[ 4] + b[ 4];
    r[ 5] = a[ 5] + b[ 5];
    r[ 6] = a[ 6] + b[ 6];
    r[ 7] = a[ 7] + b[ 7];
    r[ 8] = a[ 8] + b[ 8];
    r[ 9] = a[ 9] + b[ 9];
    r[10] = a[10] + b[10];
    r[11] = a[11] + b[11];
    r[12] = a[12] + b[12];
    r[13] = a[13] + b[13];
    r[14] = a[14] + b[14];

    return 0;
}

#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_384_sub_15(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 15; i++) {
        r[i] = a[i] - b[i];
    }

    return 0;
}

#else
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_384_sub_15(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    r[ 0] = a[ 0] - b[ 0];
    r[ 1] = a[ 1] - b[ 1];
    r[ 2] = a[ 2] - b[ 2];
    r[ 3] = a[ 3] - b[ 3];
    r[ 4] = a[ 4] - b[ 4];
    r[ 5] = a[ 5] - b[ 5];
    r[ 6] = a[ 6] - b[ 6];
    r[ 7] = a[ 7] - b[ 7];
    r[ 8] = a[ 8] - b[ 8];
    r[ 9] = a[ 9] - b[ 9];
    r[10] = a[10] - b[10];
    r[11] = a[11] - b[11];
    r[12] = a[12] - b[12];
    r[13] = a[13] - b[13];
    r[14] = a[14] - b[14];

    return 0;
}

#endif /* WOLFSSL_SP_SMALL */
/* The modulus (prime) of the curve P384. */
static const sp_digit p384_mod[15] = {
    0x3ffffff,0x000003f,0x0000000,0x3fc0000,0x2ffffff,0x3ffffff,0x3ffffff,
    0x3ffffff,0x3ffffff,0x3ffffff,0x3ffffff,0x3ffffff,0x3ffffff,0x3ffffff,
    0x00fffff
};
/* The Montogmery normalizer for modulus of the curve P384. */
static const sp_digit p384_norm_mod[15] = {
    0x0000001,0x3ffffc0,0x3ffffff,0x003ffff,0x1000000,0x0000000,0x0000000,
    0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
    0x0000000
};
/* The Montogmery multiplier for modulus of the curve P384. */
static sp_digit p384_mp_mod = 0x000001;
#if defined(WOLFSSL_VALIDATE_ECC_KEYGEN) || defined(HAVE_ECC_SIGN) || \
                                            defined(HAVE_ECC_VERIFY)
/* The order of the curve P384. */
static const sp_digit p384_order[15] = {
    0x0c52973,0x3065ab3,0x277aece,0x2c922c2,0x3581a0d,0x10dcb77,0x234d81f,
    0x3ffff1d,0x3ffffff,0x3ffffff,0x3ffffff,0x3ffffff,0x3ffffff,0x3ffffff,
    0x00fffff
};
#endif
/* The order of the curve P384 minus 2. */
static const sp_digit p384_order2[15] = {
    0x0c52971,0x3065ab3,0x277aece,0x2c922c2,0x3581a0d,0x10dcb77,0x234d81f,
    0x3ffff1d,0x3ffffff,0x3ffffff,0x3ffffff,0x3ffffff,0x3ffffff,0x3ffffff,
    0x00fffff
};
#if defined(HAVE_ECC_SIGN) || defined(HAVE_ECC_VERIFY)
/* The Montogmery normalizer for order of the curve P384. */
static const sp_digit p384_norm_order[15] = {
    0x33ad68d,0x0f9a54c,0x1885131,0x136dd3d,0x0a7e5f2,0x2f23488,0x1cb27e0,
    0x00000e2,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
    0x0000000
};
#endif
#if defined(HAVE_ECC_SIGN) || defined(HAVE_ECC_VERIFY)
/* The Montogmery multiplier for order of the curve P384. */
static sp_digit p384_mp_order = 0x8fdc45;
#endif
/* The base point of curve P384. */
static const sp_point_384 p384_base = {
    /* X ordinate */
    {
        0x2760ab7,0x1178e1c,0x296c3a5,0x176fd54,0x05502f2,0x0950a8e,0x3741e08,
        0x26e6167,0x3628ba7,0x11b874e,0x3320ad7,0x2c71c7b,0x305378e,0x288afa2,
        0x00aa87c,
        0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L
    },
    /* Y ordinate */
    {
        0x0ea0e5f,0x0c75f24,0x019d7a4,0x33875fa,0x00a60b1,0x17c2e30,0x1a3113b,
        0x051f3a7,0x1bd289a,0x27e3d07,0x1292dc2,0x27a62fe,0x22c6f5d,0x392a589,
        0x003617d,
        0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L
    },
    /* Z ordinate */
    {
        0x0000001,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
        0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
        0x0000000,
        0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L
    },
    /* infinity */
    0
};
#if defined(HAVE_ECC_CHECK_KEY) || defined(HAVE_COMP_KEY)
static const sp_digit p384_b[15] = {
    0x3ec2aef,0x1723b74,0x119d2a8,0x23628bb,0x2c65639,0x004e1d6,0x14088f5,
    0x104480c,0x06efe81,0x2460767,0x23f82d1,0x23815af,0x2e7e498,0x3e9f88f,
    0x00b3312
};
#endif

/* Create a new point.
 *
 * heap  [in]   Buffer to allocate dynamic memory from.
 * sp    [in]   Data for point - only if not allocating.
 * p     [out]  New point.
 * returns MEMORY_E when dynamic memory allocation fails and 0 otherwise. 
 */
static int sp_384_point_new_ex_15(void* heap, sp_point_384* sp,
        sp_point_384** p)
{
    int ret = MP_OKAY;
    (void)heap;
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    (void)sp;
    *p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), heap, DYNAMIC_TYPE_ECC);
#else
    *p = sp;
#endif
    if (*p == NULL) {
        ret = MEMORY_E;
    }
    return ret;
}

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
/* Allocate memory for point and return error. */
#define sp_384_point_new_15(heap, sp, p) sp_384_point_new_ex_15((heap), NULL, &(p))
#else
/* Set pointer to data and return no error. */
#define sp_384_point_new_15(heap, sp, p) sp_384_point_new_ex_15((heap), &(sp), &(p))
#endif


/* Free the point.
 *
 * p      [in,out]  Point to free.
 * clear  [in]      Indicates whether to zeroize point.
 * heap   [in]      Buffer from which dynamic memory was allocate from.
 */
static void sp_384_point_free_15(sp_point_384* p, int clear, void* heap)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
/* If valid pointer then clear point data if requested and free data. */
    if (p != NULL) {
        if (clear != 0) {
            XMEMSET(p, 0, sizeof(*p));
        }
        XFREE(p, heap, DYNAMIC_TYPE_ECC);
    }
#else
/* Clear point data if requested. */
    if (clear != 0) {
        XMEMSET(p, 0, sizeof(*p));
    }
#endif
    (void)heap;
}

/* Convert an mp_int to an array of sp_digit.
 *
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  A multi-precision integer.
 */
static void sp_384_from_mp(sp_digit* r, int size, const mp_int* a)
{
#if DIGIT_BIT == 26
    int j;

    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);

    for (j = a->used; j < size; j++) {
        r[j] = 0;
    }
#elif DIGIT_BIT > 26
    int i;
    int j = 0;
    word32 s = 0;

    r[0] = 0;
    for (i = 0; i < a->used && j < size; i++) {
        r[j] |= ((sp_digit)a->dp[i] << s);
        r[j] &= 0x3ffffff;
        s = 26U - s;
        if (j + 1 >= size) {
            break;
        }
        /* lint allow cast of mismatch word32 and mp_digit */
        r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
        while ((s + 26U) <= (word32)DIGIT_BIT) {
            s += 26U;
            r[j] &= 0x3ffffff;
            if (j + 1 >= size) {
                break;
            }
            if (s < (word32)DIGIT_BIT) {
                /* lint allow cast of mismatch word32 and mp_digit */
                r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
            }
            else {
                r[++j] = 0L;
            }
        }
        s = (word32)DIGIT_BIT - s;
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#else
    int i;
    int j = 0;
    int s = 0;

    r[0] = 0;
    for (i = 0; i < a->used && j < size; i++) {
        r[j] |= ((sp_digit)a->dp[i]) << s;
        if (s + DIGIT_BIT >= 26) {
            r[j] &= 0x3ffffff;
            if (j + 1 >= size) {
                break;
            }
            s = 26 - s;
            if (s == DIGIT_BIT) {
                r[++j] = 0;
                s = 0;
            }
            else {
                r[++j] = a->dp[i] >> s;
                s = DIGIT_BIT - s;
            }
        }
        else {
            s += DIGIT_BIT;
        }
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#endif
}

/* Convert a point of type ecc_point to type sp_point_384.
 *
 * p   Point of type sp_point_384 (result).
 * pm  Point of type ecc_point.
 */
static void sp_384_point_from_ecc_point_15(sp_point_384* p,
        const ecc_point* pm)
{
    XMEMSET(p->x, 0, sizeof(p->x));
    XMEMSET(p->y, 0, sizeof(p->y));
    XMEMSET(p->z, 0, sizeof(p->z));
    sp_384_from_mp(p->x, 15, pm->x);
    sp_384_from_mp(p->y, 15, pm->y);
    sp_384_from_mp(p->z, 15, pm->z);
    p->infinity = 0;
}

/* Convert an array of sp_digit to an mp_int.
 *
 * a  A single precision integer.
 * r  A multi-precision integer.
 */
static int sp_384_to_mp(const sp_digit* a, mp_int* r)
{
    int err;

    err = mp_grow(r, (384 + DIGIT_BIT - 1) / DIGIT_BIT);
    if (err == MP_OKAY) { /*lint !e774 case where err is always MP_OKAY*/
#if DIGIT_BIT == 26
        XMEMCPY(r->dp, a, sizeof(sp_digit) * 15);
        r->used = 15;
        mp_clamp(r);
#elif DIGIT_BIT < 26
        int i;
        int j = 0;
        int s = 0;

        r->dp[0] = 0;
        for (i = 0; i < 15; i++) {
            r->dp[j] |= (mp_digit)(a[i] << s);
            r->dp[j] &= ((sp_digit)1 << DIGIT_BIT) - 1;
            s = DIGIT_BIT - s;
            r->dp[++j] = (mp_digit)(a[i] >> s);
            while (s + DIGIT_BIT <= 26) {
                s += DIGIT_BIT;
                r->dp[j++] &= ((sp_digit)1 << DIGIT_BIT) - 1;
                if (s == SP_WORD_SIZE) {
                    r->dp[j] = 0;
                }
                else {
                    r->dp[j] = (mp_digit)(a[i] >> s);
                }
            }
            s = 26 - s;
        }
        r->used = (384 + DIGIT_BIT - 1) / DIGIT_BIT;
        mp_clamp(r);
#else
        int i;
        int j = 0;
        int s = 0;

        r->dp[0] = 0;
        for (i = 0; i < 15; i++) {
            r->dp[j] |= ((mp_digit)a[i]) << s;
            if (s + 26 >= DIGIT_BIT) {
    #if DIGIT_BIT != 32 && DIGIT_BIT != 64
                r->dp[j] &= ((sp_digit)1 << DIGIT_BIT) - 1;
    #endif
                s = DIGIT_BIT - s;
                r->dp[++j] = a[i] >> s;
                s = 26 - s;
            }
            else {
                s += 26;
            }
        }
        r->used = (384 + DIGIT_BIT - 1) / DIGIT_BIT;
        mp_clamp(r);
#endif
    }

    return err;
}

/* Convert a point of type sp_point_384 to type ecc_point.
 *
 * p   Point of type sp_point_384.
 * pm  Point of type ecc_point (result).
 * returns MEMORY_E when allocation of memory in ecc_point fails otherwise
 * MP_OKAY.
 */
static int sp_384_point_to_ecc_point_15(const sp_point_384* p, ecc_point* pm)
{
    int err;

    err = sp_384_to_mp(p->x, pm->x);
    if (err == MP_OKAY) {
        err = sp_384_to_mp(p->y, pm->y);
    }
    if (err == MP_OKAY) {
        err = sp_384_to_mp(p->z, pm->z);
    }

    return err;
}

#define sp_384_mont_reduce_order_15         sp_384_mont_reduce_15

/* Compare a with b in constant time.
 *
 * a  A single precision integer.
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
static sp_digit sp_384_cmp_15(const sp_digit* a, const sp_digit* b)
{
    sp_digit r = 0;
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=14; i>=0; i--) {
        r |= (a[i] - b[i]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#else
    r |= (a[14] - b[14]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[13] - b[13]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[12] - b[12]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[11] - b[11]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[10] - b[10]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 9] - b[ 9]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 8] - b[ 8]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 7] - b[ 7]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 6] - b[ 6]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 5] - b[ 5]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 4] - b[ 4]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 3] - b[ 3]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 2] - b[ 2]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 1] - b[ 1]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[ 0] - b[ 0]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
#endif /* WOLFSSL_SP_SMALL */

    return r;
}

/* Conditionally subtract b from a using the mask m.
 * m is -1 to subtract and 0 when not.
 *
 * r  A single precision number representing condition subtract result.
 * a  A single precision number to subtract from.
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
static void sp_384_cond_sub_15(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 15; i++) {
        r[i] = a[i] - (b[i] & m);
    }
#else
    r[ 0] = a[ 0] - (b[ 0] & m);
    r[ 1] = a[ 1] - (b[ 1] & m);
    r[ 2] = a[ 2] - (b[ 2] & m);
    r[ 3] = a[ 3] - (b[ 3] & m);
    r[ 4] = a[ 4] - (b[ 4] & m);
    r[ 5] = a[ 5] - (b[ 5] & m);
    r[ 6] = a[ 6] - (b[ 6] & m);
    r[ 7] = a[ 7] - (b[ 7] & m);
    r[ 8] = a[ 8] - (b[ 8] & m);
    r[ 9] = a[ 9] - (b[ 9] & m);
    r[10] = a[10] - (b[10] & m);
    r[11] = a[11] - (b[11] & m);
    r[12] = a[12] - (b[12] & m);
    r[13] = a[13] - (b[13] & m);
    r[14] = a[14] - (b[14] & m);
#endif /* WOLFSSL_SP_SMALL */
}

/* Mul a by scalar b and add into r. (r += a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_384_mul_add_15(sp_digit* r, const sp_digit* a,
        const sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 15; i++) {
        t += (tb * a[i]) + r[i];
        r[i] = t & 0x3ffffff;
        t >>= 26;
    }
    r[15] += t;
#else
    int64_t tb = b;
    int64_t t[15];

    t[ 0] = tb * a[ 0];
    t[ 1] = tb * a[ 1];
    t[ 2] = tb * a[ 2];
    t[ 3] = tb * a[ 3];
    t[ 4] = tb * a[ 4];
    t[ 5] = tb * a[ 5];
    t[ 6] = tb * a[ 6];
    t[ 7] = tb * a[ 7];
    t[ 8] = tb * a[ 8];
    t[ 9] = tb * a[ 9];
    t[10] = tb * a[10];
    t[11] = tb * a[11];
    t[12] = tb * a[12];
    t[13] = tb * a[13];
    t[14] = tb * a[14];
    r[ 0] += (sp_digit)                 (t[ 0] & 0x3ffffff);
    r[ 1] += (sp_digit)((t[ 0] >> 26) + (t[ 1] & 0x3ffffff));
    r[ 2] += (sp_digit)((t[ 1] >> 26) + (t[ 2] & 0x3ffffff));
    r[ 3] += (sp_digit)((t[ 2] >> 26) + (t[ 3] & 0x3ffffff));
    r[ 4] += (sp_digit)((t[ 3] >> 26) + (t[ 4] & 0x3ffffff));
    r[ 5] += (sp_digit)((t[ 4] >> 26) + (t[ 5] & 0x3ffffff));
    r[ 6] += (sp_digit)((t[ 5] >> 26) + (t[ 6] & 0x3ffffff));
    r[ 7] += (sp_digit)((t[ 6] >> 26) + (t[ 7] & 0x3ffffff));
    r[ 8] += (sp_digit)((t[ 7] >> 26) + (t[ 8] & 0x3ffffff));
    r[ 9] += (sp_digit)((t[ 8] >> 26) + (t[ 9] & 0x3ffffff));
    r[10] += (sp_digit)((t[ 9] >> 26) + (t[10] & 0x3ffffff));
    r[11] += (sp_digit)((t[10] >> 26) + (t[11] & 0x3ffffff));
    r[12] += (sp_digit)((t[11] >> 26) + (t[12] & 0x3ffffff));
    r[13] += (sp_digit)((t[12] >> 26) + (t[13] & 0x3ffffff));
    r[14] += (sp_digit)((t[13] >> 26) + (t[14] & 0x3ffffff));
    r[15] += (sp_digit) (t[14] >> 26);
#endif /* WOLFSSL_SP_SMALL */
}

/* Normalize the values in each word to 26.
 *
 * a  Array of sp_digit to normalize.
 */
static void sp_384_norm_15(sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    for (i = 0; i < 14; i++) {
        a[i+1] += a[i] >> 26;
        a[i] &= 0x3ffffff;
    }
#else
    a[1] += a[0] >> 26; a[0] &= 0x3ffffff;
    a[2] += a[1] >> 26; a[1] &= 0x3ffffff;
    a[3] += a[2] >> 26; a[2] &= 0x3ffffff;
    a[4] += a[3] >> 26; a[3] &= 0x3ffffff;
    a[5] += a[4] >> 26; a[4] &= 0x3ffffff;
    a[6] += a[5] >> 26; a[5] &= 0x3ffffff;
    a[7] += a[6] >> 26; a[6] &= 0x3ffffff;
    a[8] += a[7] >> 26; a[7] &= 0x3ffffff;
    a[9] += a[8] >> 26; a[8] &= 0x3ffffff;
    a[10] += a[9] >> 26; a[9] &= 0x3ffffff;
    a[11] += a[10] >> 26; a[10] &= 0x3ffffff;
    a[12] += a[11] >> 26; a[11] &= 0x3ffffff;
    a[13] += a[12] >> 26; a[12] &= 0x3ffffff;
    a[14] += a[13] >> 26; a[13] &= 0x3ffffff;
#endif
}

/* Shift the result in the high 384 bits down to the bottom.
 *
 * r  A single precision number.
 * a  A single precision number.
 */
static void sp_384_mont_shift_15(sp_digit* r, const sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    int64_t n = a[14] >> 20;
    n += ((int64_t)a[15]) << 6;

    for (i = 0; i < 14; i++) {
        r[i] = n & 0x3ffffff;
        n >>= 26;
        n += ((int64_t)a[16 + i]) << 6;
    }
    r[14] = (sp_digit)n;
#else
    int64_t n = a[14] >> 20;
    n += ((int64_t)a[15]) << 6;
    r[ 0] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[16]) << 6;
    r[ 1] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[17]) << 6;
    r[ 2] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[18]) << 6;
    r[ 3] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[19]) << 6;
    r[ 4] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[20]) << 6;
    r[ 5] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[21]) << 6;
    r[ 6] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[22]) << 6;
    r[ 7] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[23]) << 6;
    r[ 8] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[24]) << 6;
    r[ 9] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[25]) << 6;
    r[10] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[26]) << 6;
    r[11] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[27]) << 6;
    r[12] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[28]) << 6;
    r[13] = n & 0x3ffffff; n >>= 26; n += ((int64_t)a[29]) << 6;
    r[14] = (sp_digit)n;
#endif /* WOLFSSL_SP_SMALL */
    XMEMSET(&r[15], 0, sizeof(*r) * 15U);
}

/* Reduce the number back to 384 bits using Montgomery reduction.
 *
 * a   A single precision number to reduce in place.
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
static void sp_384_mont_reduce_15(sp_digit* a, const sp_digit* m, sp_digit mp)
{
    int i;
    sp_digit mu;

    sp_384_norm_15(a + 15);

    for (i=0; i<14; i++) {
        mu = (a[i] * mp) & 0x3ffffff;
        sp_384_mul_add_15(a+i, m, mu);
        a[i+1] += a[i] >> 26;
    }
    mu = (a[i] * mp) & 0xfffffL;
    sp_384_mul_add_15(a+i, m, mu);
    a[i+1] += a[i] >> 26;
    a[i] &= 0x3ffffff;

    sp_384_mont_shift_15(a, a);
    sp_384_cond_sub_15(a, a, m, 0 - (((a[14] >> 20) > 0) ?
            (sp_digit)1 : (sp_digit)0));
    sp_384_norm_15(a);
}

/* Multiply two Montogmery form numbers mod the modulus (prime).
 * (r = a * b mod m)
 *
 * r   Result of multiplication.
 * a   First number to multiply in Montogmery form.
 * b   Second number to multiply in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_384_mont_mul_15(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit* m, sp_digit mp)
{
    sp_384_mul_15(r, a, b);
    sp_384_mont_reduce_15(r, m, mp);
}

/* Square the Montgomery form number. (r = a * a mod m)
 *
 * r   Result of squaring.
 * a   Number to square in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_384_mont_sqr_15(sp_digit* r, const sp_digit* a,
        const sp_digit* m, sp_digit mp)
{
    sp_384_sqr_15(r, a);
    sp_384_mont_reduce_15(r, m, mp);
}

#if !defined(WOLFSSL_SP_SMALL) || defined(HAVE_COMP_KEY)
/* Square the Montgomery form number a number of times. (r = a ^ n mod m)
 *
 * r   Result of squaring.
 * a   Number to square in Montogmery form.
 * n   Number of times to square.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_384_mont_sqr_n_15(sp_digit* r, const sp_digit* a, int n,
        const sp_digit* m, sp_digit mp)
{
    sp_384_mont_sqr_15(r, a, m, mp);
    for (; n > 1; n--) {
        sp_384_mont_sqr_15(r, r, m, mp);
    }
}

#endif /* !WOLFSSL_SP_SMALL | HAVE_COMP_KEY */
#ifdef WOLFSSL_SP_SMALL
/* Mod-2 for the P384 curve. */
static const uint32_t p384_mod_minus_2[12] = {
    0xfffffffdU,0x00000000U,0x00000000U,0xffffffffU,0xfffffffeU,0xffffffffU,
    0xffffffffU,0xffffffffU,0xffffffffU,0xffffffffU,0xffffffffU,0xffffffffU
};
#endif /* !WOLFSSL_SP_SMALL */

/* Invert the number, in Montgomery form, modulo the modulus (prime) of the
 * P384 curve. (r = 1 / a mod m)
 *
 * r   Inverse result.
 * a   Number to invert.
 * td  Temporary data.
 */
static void sp_384_mont_inv_15(sp_digit* r, const sp_digit* a, sp_digit* td)
{
#ifdef WOLFSSL_SP_SMALL
    sp_digit* t = td;
    int i;

    XMEMCPY(t, a, sizeof(sp_digit) * 15);
    for (i=382; i>=0; i--) {
        sp_384_mont_sqr_15(t, t, p384_mod, p384_mp_mod);
        if (p384_mod_minus_2[i / 32] & ((sp_digit)1 << (i % 32)))
            sp_384_mont_mul_15(t, t, a, p384_mod, p384_mp_mod);
    }
    XMEMCPY(r, t, sizeof(sp_digit) * 15);
#else
    sp_digit* t1 = td;
    sp_digit* t2 = td + 2 * 15;
    sp_digit* t3 = td + 4 * 15;
    sp_digit* t4 = td + 6 * 15;
    sp_digit* t5 = td + 8 * 15;

    /* 0x2 */
    sp_384_mont_sqr_15(t1, a, p384_mod, p384_mp_mod);
    /* 0x3 */
    sp_384_mont_mul_15(t5, t1, a, p384_mod, p384_mp_mod);
    /* 0xc */
    sp_384_mont_sqr_n_15(t1, t5, 2, p384_mod, p384_mp_mod);
    /* 0xf */
    sp_384_mont_mul_15(t2, t5, t1, p384_mod, p384_mp_mod);
    /* 0x1e */
    sp_384_mont_sqr_15(t1, t2, p384_mod, p384_mp_mod);
    /* 0x1f */
    sp_384_mont_mul_15(t4, t1, a, p384_mod, p384_mp_mod);
    /* 0x3e0 */
    sp_384_mont_sqr_n_15(t1, t4, 5, p384_mod, p384_mp_mod);
    /* 0x3ff */
    sp_384_mont_mul_15(t2, t4, t1, p384_mod, p384_mp_mod);
    /* 0x7fe0 */
    sp_384_mont_sqr_n_15(t1, t2, 5, p384_mod, p384_mp_mod);
    /* 0x7fff */
    sp_384_mont_mul_15(t4, t4, t1, p384_mod, p384_mp_mod);
    /* 0x3fff8000 */
    sp_384_mont_sqr_n_15(t1, t4, 15, p384_mod, p384_mp_mod);
    /* 0x3fffffff */
    sp_384_mont_mul_15(t2, t4, t1, p384_mod, p384_mp_mod);
    /* 0xfffffffc */
    sp_384_mont_sqr_n_15(t3, t2, 2, p384_mod, p384_mp_mod);
    /* 0xfffffffd */
    sp_384_mont_mul_15(r, t3, a, p384_mod, p384_mp_mod);
    /* 0xffffffff */
    sp_384_mont_mul_15(t3, t5, t3, p384_mod, p384_mp_mod);
    /* 0xfffffffc0000000 */
    sp_384_mont_sqr_n_15(t1, t2, 30, p384_mod, p384_mp_mod);
    /* 0xfffffffffffffff */
    sp_384_mont_mul_15(t2, t2, t1, p384_mod, p384_mp_mod);
    /* 0xfffffffffffffff000000000000000 */
    sp_384_mont_sqr_n_15(t1, t2, 60, p384_mod, p384_mp_mod);
    /* 0xffffffffffffffffffffffffffffff */
    sp_384_mont_mul_15(t2, t2, t1, p384_mod, p384_mp_mod);
    /* 0xffffffffffffffffffffffffffffff000000000000000000000000000000 */
    sp_384_mont_sqr_n_15(t1, t2, 120, p384_mod, p384_mp_mod);
    /* 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff */
    sp_384_mont_mul_15(t2, t2, t1, p384_mod, p384_mp_mod);
    /* 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8000 */
    sp_384_mont_sqr_n_15(t1, t2, 15, p384_mod, p384_mp_mod);
    /* 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff */
    sp_384_mont_mul_15(t2, t4, t1, p384_mod, p384_mp_mod);
    /* 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00000000 */
    sp_384_mont_sqr_n_15(t1, t2, 33, p384_mod, p384_mp_mod);
    /* 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff */
    sp_384_mont_mul_15(t2, t3, t1, p384_mod, p384_mp_mod);
    /* 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff000000000000000000000000 */
    sp_384_mont_sqr_n_15(t1, t2, 96, p384_mod, p384_mp_mod);
    /* 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffd */
    sp_384_mont_mul_15(r, r, t1, p384_mod, p384_mp_mod);

#endif /* WOLFSSL_SP_SMALL */
}

/* Map the Montgomery form projective coordinate point to an affine point.
 *
 * r  Resulting affine coordinate point.
 * p  Montgomery form projective coordinate point.
 * t  Temporary ordinate data.
 */
static void sp_384_map_15(sp_point_384* r, const sp_point_384* p,
        sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*15;
    int32_t n;

    sp_384_mont_inv_15(t1, p->z, t + 2*15);

    sp_384_mont_sqr_15(t2, t1, p384_mod, p384_mp_mod);
    sp_384_mont_mul_15(t1, t2, t1, p384_mod, p384_mp_mod);

    /* x /= z^2 */
    sp_384_mont_mul_15(r->x, p->x, t2, p384_mod, p384_mp_mod);
    XMEMSET(r->x + 15, 0, sizeof(r->x) / 2U);
    sp_384_mont_reduce_15(r->x, p384_mod, p384_mp_mod);
    /* Reduce x to less than modulus */
    n = sp_384_cmp_15(r->x, p384_mod);
    sp_384_cond_sub_15(r->x, r->x, p384_mod, 0 - ((n >= 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_384_norm_15(r->x);

    /* y /= z^3 */
    sp_384_mont_mul_15(r->y, p->y, t1, p384_mod, p384_mp_mod);
    XMEMSET(r->y + 15, 0, sizeof(r->y) / 2U);
    sp_384_mont_reduce_15(r->y, p384_mod, p384_mp_mod);
    /* Reduce y to less than modulus */
    n = sp_384_cmp_15(r->y, p384_mod);
    sp_384_cond_sub_15(r->y, r->y, p384_mod, 0 - ((n >= 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_384_norm_15(r->y);

    XMEMSET(r->z, 0, sizeof(r->z));
    r->z[0] = 1;

}

/* Add two Montgomery form numbers (r = a + b % m).
 *
 * r   Result of addition.
 * a   First number to add in Montogmery form.
 * b   Second number to add in Montogmery form.
 * m   Modulus (prime).
 */
static void sp_384_mont_add_15(sp_digit* r, const sp_digit* a, const sp_digit* b,
        const sp_digit* m)
{
    (void)sp_384_add_15(r, a, b);
    sp_384_norm_15(r);
    sp_384_cond_sub_15(r, r, m, 0 - (((r[14] >> 20) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_384_norm_15(r);
}

/* Double a Montgomery form number (r = a + a % m).
 *
 * r   Result of doubling.
 * a   Number to double in Montogmery form.
 * m   Modulus (prime).
 */
static void sp_384_mont_dbl_15(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    (void)sp_384_add_15(r, a, a);
    sp_384_norm_15(r);
    sp_384_cond_sub_15(r, r, m, 0 - (((r[14] >> 20) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_384_norm_15(r);
}

/* Triple a Montgomery form number (r = a + a + a % m).
 *
 * r   Result of Tripling.
 * a   Number to triple in Montogmery form.
 * m   Modulus (prime).
 */
static void sp_384_mont_tpl_15(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    (void)sp_384_add_15(r, a, a);
    sp_384_norm_15(r);
    sp_384_cond_sub_15(r, r, m, 0 - (((r[14] >> 20) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_384_norm_15(r);
    (void)sp_384_add_15(r, r, a);
    sp_384_norm_15(r);
    sp_384_cond_sub_15(r, r, m, 0 - (((r[14] >> 20) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_384_norm_15(r);
}

/* Conditionally add a and b using the mask m.
 * m is -1 to add and 0 when not.
 *
 * r  A single precision number representing conditional add result.
 * a  A single precision number to add with.
 * b  A single precision number to add.
 * m  Mask value to apply.
 */
static void sp_384_cond_add_15(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 15; i++) {
        r[i] = a[i] + (b[i] & m);
    }
#else
    r[ 0] = a[ 0] + (b[ 0] & m);
    r[ 1] = a[ 1] + (b[ 1] & m);
    r[ 2] = a[ 2] + (b[ 2] & m);
    r[ 3] = a[ 3] + (b[ 3] & m);
    r[ 4] = a[ 4] + (b[ 4] & m);
    r[ 5] = a[ 5] + (b[ 5] & m);
    r[ 6] = a[ 6] + (b[ 6] & m);
    r[ 7] = a[ 7] + (b[ 7] & m);
    r[ 8] = a[ 8] + (b[ 8] & m);
    r[ 9] = a[ 9] + (b[ 9] & m);
    r[10] = a[10] + (b[10] & m);
    r[11] = a[11] + (b[11] & m);
    r[12] = a[12] + (b[12] & m);
    r[13] = a[13] + (b[13] & m);
    r[14] = a[14] + (b[14] & m);
#endif /* WOLFSSL_SP_SMALL */
}

/* Subtract two Montgomery form numbers (r = a - b % m).
 *
 * r   Result of subtration.
 * a   Number to subtract from in Montogmery form.
 * b   Number to subtract with in Montogmery form.
 * m   Modulus (prime).
 */
static void sp_384_mont_sub_15(sp_digit* r, const sp_digit* a, const sp_digit* b,
        const sp_digit* m)
{
    (void)sp_384_sub_15(r, a, b);
    sp_384_cond_add_15(r, r, m, r[14] >> 20);
    sp_384_norm_15(r);
}

/* Shift number left one bit.
 * Bottom bit is lost.
 *
 * r  Result of shift.
 * a  Number to shift.
 */
SP_NOINLINE static void sp_384_rshift1_15(sp_digit* r, const sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=0; i<14; i++) {
        r[i] = (a[i] >> 1) + ((a[i + 1] << 25) & 0x3ffffff);
    }
#else
    r[0] = (a[0] >> 1) + ((a[1] << 25) & 0x3ffffff);
    r[1] = (a[1] >> 1) + ((a[2] << 25) & 0x3ffffff);
    r[2] = (a[2] >> 1) + ((a[3] << 25) & 0x3ffffff);
    r[3] = (a[3] >> 1) + ((a[4] << 25) & 0x3ffffff);
    r[4] = (a[4] >> 1) + ((a[5] << 25) & 0x3ffffff);
    r[5] = (a[5] >> 1) + ((a[6] << 25) & 0x3ffffff);
    r[6] = (a[6] >> 1) + ((a[7] << 25) & 0x3ffffff);
    r[7] = (a[7] >> 1) + ((a[8] << 25) & 0x3ffffff);
    r[8] = (a[8] >> 1) + ((a[9] << 25) & 0x3ffffff);
    r[9] = (a[9] >> 1) + ((a[10] << 25) & 0x3ffffff);
    r[10] = (a[10] >> 1) + ((a[11] << 25) & 0x3ffffff);
    r[11] = (a[11] >> 1) + ((a[12] << 25) & 0x3ffffff);
    r[12] = (a[12] >> 1) + ((a[13] << 25) & 0x3ffffff);
    r[13] = (a[13] >> 1) + ((a[14] << 25) & 0x3ffffff);
#endif
    r[14] = a[14] >> 1;
}

/* Divide the number by 2 mod the modulus (prime). (r = a / 2 % m)
 *
 * r  Result of division by 2.
 * a  Number to divide.
 * m  Modulus (prime).
 */
static void sp_384_div2_15(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    sp_384_cond_add_15(r, a, m, 0 - (a[0] & 1));
    sp_384_norm_15(r);
    sp_384_rshift1_15(r, r);
}

/* Double the Montgomery form projective point p.
 *
 * r  Result of doubling point.
 * p  Point to double.
 * t  Temporary ordinate data.
 */
#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_384_proj_point_dbl_15_ctx {
    int state;
    sp_digit* t1;
    sp_digit* t2;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;
} sp_384_proj_point_dbl_15_ctx;

static int sp_384_proj_point_dbl_15_nb(sp_ecc_ctx_t* sp_ctx, sp_point_384* r, const sp_point_384* p, sp_digit* t)
{
    int err = FP_WOULDBLOCK;
    sp_384_proj_point_dbl_15_ctx* ctx = (sp_384_proj_point_dbl_15_ctx*)sp_ctx->data;

    typedef char ctx_size_test[sizeof(sp_384_proj_point_dbl_15_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    switch (ctx->state) {
    case 0:
        ctx->t1 = t;
        ctx->t2 = t + 2*15;
        ctx->x = r->x;
        ctx->y = r->y;
        ctx->z = r->z;

        /* Put infinity into result. */
        if (r != p) {
            r->infinity = p->infinity;
        }
        ctx->state = 1;
        break;
    case 1:
        /* T1 = Z * Z */
        sp_384_mont_sqr_15(ctx->t1, p->z, p384_mod, p384_mp_mod);
        ctx->state = 2;
        break;
    case 2:
        /* Z = Y * Z */
        sp_384_mont_mul_15(ctx->z, p->y, p->z, p384_mod, p384_mp_mod);
        ctx->state = 3;
        break;
    case 3:
        /* Z = 2Z */
        sp_384_mont_dbl_15(ctx->z, ctx->z, p384_mod);
        ctx->state = 4;
        break;
    case 4:
        /* T2 = X - T1 */
        sp_384_mont_sub_15(ctx->t2, p->x, ctx->t1, p384_mod);
        ctx->state = 5;
        break;
    case 5:
        /* T1 = X + T1 */
        sp_384_mont_add_15(ctx->t1, p->x, ctx->t1, p384_mod);
        ctx->state = 6;
        break;
    case 6:
        /* T2 = T1 * T2 */
        sp_384_mont_mul_15(ctx->t2, ctx->t1, ctx->t2, p384_mod, p384_mp_mod);
        ctx->state = 7;
        break;
    case 7:
        /* T1 = 3T2 */
        sp_384_mont_tpl_15(ctx->t1, ctx->t2, p384_mod);
        ctx->state = 8;
        break;
    case 8:
        /* Y = 2Y */
        sp_384_mont_dbl_15(ctx->y, p->y, p384_mod);
        ctx->state = 9;
        break;
    case 9:
        /* Y = Y * Y */
        sp_384_mont_sqr_15(ctx->y, ctx->y, p384_mod, p384_mp_mod);
        ctx->state = 10;
        break;
    case 10:
        /* T2 = Y * Y */
        sp_384_mont_sqr_15(ctx->t2, ctx->y, p384_mod, p384_mp_mod);
        ctx->state = 11;
        break;
    case 11:
        /* T2 = T2/2 */
        sp_384_div2_15(ctx->t2, ctx->t2, p384_mod);
        ctx->state = 12;
        break;
    case 12:
        /* Y = Y * X */
        sp_384_mont_mul_15(ctx->y, ctx->y, p->x, p384_mod, p384_mp_mod);
        ctx->state = 13;
        break;
    case 13:
        /* X = T1 * T1 */
        sp_384_mont_sqr_15(ctx->x, ctx->t1, p384_mod, p384_mp_mod);
        ctx->state = 14;
        break;
    case 14:
        /* X = X - Y */
        sp_384_mont_sub_15(ctx->x, ctx->x, ctx->y, p384_mod);
        ctx->state = 15;
        break;
    case 15:
        /* X = X - Y */
        sp_384_mont_sub_15(ctx->x, ctx->x, ctx->y, p384_mod);
        ctx->state = 16;
        break;
    case 16:
        /* Y = Y - X */
        sp_384_mont_sub_15(ctx->y, ctx->y, ctx->x, p384_mod);
        ctx->state = 17;
        break;
    case 17:
        /* Y = Y * T1 */
        sp_384_mont_mul_15(ctx->y, ctx->y, ctx->t1, p384_mod, p384_mp_mod);
        ctx->state = 18;
        break;
    case 18:
        /* Y = Y - T2 */
        sp_384_mont_sub_15(ctx->y, ctx->y, ctx->t2, p384_mod);
        ctx->state = 19;
        /* fall-through */
    case 19:
        err = MP_OKAY;
        break;
    }

    if (err == MP_OKAY && ctx->state != 19) {
        err = FP_WOULDBLOCK;
    }

    return err;
}
#endif /* WOLFSSL_SP_NONBLOCK */

static void sp_384_proj_point_dbl_15(sp_point_384* r,
        const sp_point_384* p, sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*15;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;

    x = r->x;
    y = r->y;
    z = r->z;
    /* Put infinity into result. */
    if (r != p) {
        r->infinity = p->infinity;
    }

    /* T1 = Z * Z */
    sp_384_mont_sqr_15(t1, p->z, p384_mod, p384_mp_mod);
    /* Z = Y * Z */
    sp_384_mont_mul_15(z, p->y, p->z, p384_mod, p384_mp_mod);
    /* Z = 2Z */
    sp_384_mont_dbl_15(z, z, p384_mod);
    /* T2 = X - T1 */
    sp_384_mont_sub_15(t2, p->x, t1, p384_mod);
    /* T1 = X + T1 */
    sp_384_mont_add_15(t1, p->x, t1, p384_mod);
    /* T2 = T1 * T2 */
    sp_384_mont_mul_15(t2, t1, t2, p384_mod, p384_mp_mod);
    /* T1 = 3T2 */
    sp_384_mont_tpl_15(t1, t2, p384_mod);
    /* Y = 2Y */
    sp_384_mont_dbl_15(y, p->y, p384_mod);
    /* Y = Y * Y */
    sp_384_mont_sqr_15(y, y, p384_mod, p384_mp_mod);
    /* T2 = Y * Y */
    sp_384_mont_sqr_15(t2, y, p384_mod, p384_mp_mod);
    /* T2 = T2/2 */
    sp_384_div2_15(t2, t2, p384_mod);
    /* Y = Y * X */
    sp_384_mont_mul_15(y, y, p->x, p384_mod, p384_mp_mod);
    /* X = T1 * T1 */
    sp_384_mont_sqr_15(x, t1, p384_mod, p384_mp_mod);
    /* X = X - Y */
    sp_384_mont_sub_15(x, x, y, p384_mod);
    /* X = X - Y */
    sp_384_mont_sub_15(x, x, y, p384_mod);
    /* Y = Y - X */
    sp_384_mont_sub_15(y, y, x, p384_mod);
    /* Y = Y * T1 */
    sp_384_mont_mul_15(y, y, t1, p384_mod, p384_mp_mod);
    /* Y = Y - T2 */
    sp_384_mont_sub_15(y, y, t2, p384_mod);
}

/* Compare two numbers to determine if they are equal.
 * Constant time implementation.
 *
 * a  First number to compare.
 * b  Second number to compare.
 * returns 1 when equal and 0 otherwise.
 */
static int sp_384_cmp_equal_15(const sp_digit* a, const sp_digit* b)
{
    return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2]) | (a[3] ^ b[3]) |
            (a[4] ^ b[4]) | (a[5] ^ b[5]) | (a[6] ^ b[6]) | (a[7] ^ b[7]) |
            (a[8] ^ b[8]) | (a[9] ^ b[9]) | (a[10] ^ b[10]) | (a[11] ^ b[11]) |
            (a[12] ^ b[12]) | (a[13] ^ b[13]) | (a[14] ^ b[14])) == 0;
}

/* Add two Montgomery form projective points.
 *
 * r  Result of addition.
 * p  First point to add.
 * q  Second point to add.
 * t  Temporary ordinate data.
 */

#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_384_proj_point_add_15_ctx {
    int state;
    sp_384_proj_point_dbl_15_ctx dbl_ctx;
    const sp_point_384* ap[2];
    sp_point_384* rp[2];
    sp_digit* t1;
    sp_digit* t2;
    sp_digit* t3;
    sp_digit* t4;
    sp_digit* t5;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;
} sp_384_proj_point_add_15_ctx;

static int sp_384_proj_point_add_15_nb(sp_ecc_ctx_t* sp_ctx, sp_point_384* r, 
    const sp_point_384* p, const sp_point_384* q, sp_digit* t)
{
    int err = FP_WOULDBLOCK;
    sp_384_proj_point_add_15_ctx* ctx = (sp_384_proj_point_add_15_ctx*)sp_ctx->data;

    /* Ensure only the first point is the same as the result. */
    if (q == r) {
        const sp_point_384* a = p;
        p = q;
        q = a;
    }

    typedef char ctx_size_test[sizeof(sp_384_proj_point_add_15_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    switch (ctx->state) {
    case 0: /* INIT */
        ctx->t1 = t;
        ctx->t2 = t + 2*15;
        ctx->t3 = t + 4*15;
        ctx->t4 = t + 6*15;
        ctx->t5 = t + 8*15;

        ctx->state = 1;
        break;
    case 1:
        /* Check double */
        (void)sp_384_sub_15(ctx->t1, p384_mod, q->y);
        sp_384_norm_15(ctx->t1);
        if ((sp_384_cmp_equal_15(p->x, q->x) & sp_384_cmp_equal_15(p->z, q->z) &
            (sp_384_cmp_equal_15(p->y, q->y) | sp_384_cmp_equal_15(p->y, ctx->t1))) != 0)
        {
            XMEMSET(&ctx->dbl_ctx, 0, sizeof(ctx->dbl_ctx));
            ctx->state = 2;
        }
        else {
            ctx->state = 3;
        }
        break;
    case 2:
        err = sp_384_proj_point_dbl_15_nb((sp_ecc_ctx_t*)&ctx->dbl_ctx, r, p, t);
        if (err == MP_OKAY)
            ctx->state = 27; /* done */
        break;
    case 3:
    {
        int i;
        ctx->rp[0] = r;

        /*lint allow cast to different type of pointer*/
        ctx->rp[1] = (sp_point_384*)t; /*lint !e9087 !e740*/
        XMEMSET(ctx->rp[1], 0, sizeof(sp_point_384));
        ctx->x = ctx->rp[p->infinity | q->infinity]->x;
        ctx->y = ctx->rp[p->infinity | q->infinity]->y;
        ctx->z = ctx->rp[p->infinity | q->infinity]->z;

        ctx->ap[0] = p;
        ctx->ap[1] = q;
        for (i=0; i<15; i++) {
            r->x[i] = ctx->ap[p->infinity]->x[i];
        }
        for (i=0; i<15; i++) {
            r->y[i] = ctx->ap[p->infinity]->y[i];
        }
        for (i=0; i<15; i++) {
            r->z[i] = ctx->ap[p->infinity]->z[i];
        }
        r->infinity = ctx->ap[p->infinity]->infinity;

        ctx->state = 4;
        break;
    }
    case 4:
        /* U1 = X1*Z2^2 */
        sp_384_mont_sqr_15(ctx->t1, q->z, p384_mod, p384_mp_mod);
        ctx->state = 5;
        break;
    case 5:
        sp_384_mont_mul_15(ctx->t3, ctx->t1, q->z, p384_mod, p384_mp_mod);
        ctx->state = 6;
        break;
    case 6:
        sp_384_mont_mul_15(ctx->t1, ctx->t1, ctx->x, p384_mod, p384_mp_mod);
        ctx->state = 7;
        break;
    case 7:
        /* U2 = X2*Z1^2 */
        sp_384_mont_sqr_15(ctx->t2, ctx->z, p384_mod, p384_mp_mod);
        ctx->state = 8;
        break;
    case 8:
        sp_384_mont_mul_15(ctx->t4, ctx->t2, ctx->z, p384_mod, p384_mp_mod);
        ctx->state = 9;
        break;
    case 9:
        sp_384_mont_mul_15(ctx->t2, ctx->t2, q->x, p384_mod, p384_mp_mod);
        ctx->state = 10;
        break;
    case 10:
        /* S1 = Y1*Z2^3 */
        sp_384_mont_mul_15(ctx->t3, ctx->t3, ctx->y, p384_mod, p384_mp_mod);
        ctx->state = 11;
        break;
    case 11:
        /* S2 = Y2*Z1^3 */
        sp_384_mont_mul_15(ctx->t4, ctx->t4, q->y, p384_mod, p384_mp_mod);
        ctx->state = 12;
        break;
    case 12:
        /* H = U2 - U1 */
        sp_384_mont_sub_15(ctx->t2, ctx->t2, ctx->t1, p384_mod);
        ctx->state = 13;
        break;
    case 13:
        /* R = S2 - S1 */
        sp_384_mont_sub_15(ctx->t4, ctx->t4, ctx->t3, p384_mod);
        ctx->state = 14;
        break;
    case 14:
        /* Z3 = H*Z1*Z2 */
        sp_384_mont_mul_15(ctx->z, ctx->z, q->z, p384_mod, p384_mp_mod);
        ctx->state = 15;
        break;
    case 15:
        sp_384_mont_mul_15(ctx->z, ctx->z, ctx->t2, p384_mod, p384_mp_mod);
        ctx->state = 16;
        break;
    case 16:
        /* X3 = R^2 - H^3 - 2*U1*H^2 */
        sp_384_mont_sqr_15(ctx->x, ctx->t4, p384_mod, p384_mp_mod);
        ctx->state = 17;
        break;
    case 17:
        sp_384_mont_sqr_15(ctx->t5, ctx->t2, p384_mod, p384_mp_mod);
        ctx->state = 18;
        break;
    case 18:
        sp_384_mont_mul_15(ctx->y, ctx->t1, ctx->t5, p384_mod, p384_mp_mod);
        ctx->state = 19;
        break;
    case 19:
        sp_384_mont_mul_15(ctx->t5, ctx->t5, ctx->t2, p384_mod, p384_mp_mod);
        ctx->state = 20;
        break;
    case 20:
        sp_384_mont_sub_15(ctx->x, ctx->x, ctx->t5, p384_mod);
        ctx->state = 21;
        break;
    case 21:
        sp_384_mont_dbl_15(ctx->t1, ctx->y, p384_mod);
        ctx->state = 22;
        break;
    case 22:
        sp_384_mont_sub_15(ctx->x, ctx->x, ctx->t1, p384_mod);
        ctx->state = 23;
        break;
    case 23:
        /* Y3 = R*(U1*H^2 - X3) - S1*H^3 */
        sp_384_mont_sub_15(ctx->y, ctx->y, ctx->x, p384_mod);
        ctx->state = 24;
        break;
    case 24:
        sp_384_mont_mul_15(ctx->y, ctx->y, ctx->t4, p384_mod, p384_mp_mod);
        ctx->state = 25;
        break;
    case 25:
        sp_384_mont_mul_15(ctx->t5, ctx->t5, ctx->t3, p384_mod, p384_mp_mod);
        ctx->state = 26;
        break;
    case 26:
        sp_384_mont_sub_15(ctx->y, ctx->y, ctx->t5, p384_mod);
        ctx->state = 27;
        /* fall-through */
    case 27:
        err = MP_OKAY;
        break;
    }

    if (err == MP_OKAY && ctx->state != 27) {
        err = FP_WOULDBLOCK;
    }
    return err;
}
#endif /* WOLFSSL_SP_NONBLOCK */

static void sp_384_proj_point_add_15(sp_point_384* r,
        const sp_point_384* p, const sp_point_384* q, sp_digit* t)
{
    const sp_point_384* ap[2];
    sp_point_384* rp[2];
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*15;
    sp_digit* t3 = t + 4*15;
    sp_digit* t4 = t + 6*15;
    sp_digit* t5 = t + 8*15;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;
    int i;

    /* Ensure only the first point is the same as the result. */
    if (q == r) {
        const sp_point_384* a = p;
        p = q;
        q = a;
    }

    /* Check double */
    (void)sp_384_sub_15(t1, p384_mod, q->y);
    sp_384_norm_15(t1);
    if ((sp_384_cmp_equal_15(p->x, q->x) & sp_384_cmp_equal_15(p->z, q->z) &
        (sp_384_cmp_equal_15(p->y, q->y) | sp_384_cmp_equal_15(p->y, t1))) != 0) {
        sp_384_proj_point_dbl_15(r, p, t);
    }
    else {
        rp[0] = r;

        /*lint allow cast to different type of pointer*/
        rp[1] = (sp_point_384*)t; /*lint !e9087 !e740*/
        XMEMSET(rp[1], 0, sizeof(sp_point_384));
        x = rp[p->infinity | q->infinity]->x;
        y = rp[p->infinity | q->infinity]->y;
        z = rp[p->infinity | q->infinity]->z;

        ap[0] = p;
        ap[1] = q;
        for (i=0; i<15; i++) {
            r->x[i] = ap[p->infinity]->x[i];
        }
        for (i=0; i<15; i++) {
            r->y[i] = ap[p->infinity]->y[i];
        }
        for (i=0; i<15; i++) {
            r->z[i] = ap[p->infinity]->z[i];
        }
        r->infinity = ap[p->infinity]->infinity;

        /* U1 = X1*Z2^2 */
        sp_384_mont_sqr_15(t1, q->z, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(t3, t1, q->z, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(t1, t1, x, p384_mod, p384_mp_mod);
        /* U2 = X2*Z1^2 */
        sp_384_mont_sqr_15(t2, z, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(t4, t2, z, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(t2, t2, q->x, p384_mod, p384_mp_mod);
        /* S1 = Y1*Z2^3 */
        sp_384_mont_mul_15(t3, t3, y, p384_mod, p384_mp_mod);
        /* S2 = Y2*Z1^3 */
        sp_384_mont_mul_15(t4, t4, q->y, p384_mod, p384_mp_mod);
        /* H = U2 - U1 */
        sp_384_mont_sub_15(t2, t2, t1, p384_mod);
        /* R = S2 - S1 */
        sp_384_mont_sub_15(t4, t4, t3, p384_mod);
        /* Z3 = H*Z1*Z2 */
        sp_384_mont_mul_15(z, z, q->z, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(z, z, t2, p384_mod, p384_mp_mod);
        /* X3 = R^2 - H^3 - 2*U1*H^2 */
        sp_384_mont_sqr_15(x, t4, p384_mod, p384_mp_mod);
        sp_384_mont_sqr_15(t5, t2, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(y, t1, t5, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(t5, t5, t2, p384_mod, p384_mp_mod);
        sp_384_mont_sub_15(x, x, t5, p384_mod);
        sp_384_mont_dbl_15(t1, y, p384_mod);
        sp_384_mont_sub_15(x, x, t1, p384_mod);
        /* Y3 = R*(U1*H^2 - X3) - S1*H^3 */
        sp_384_mont_sub_15(y, y, x, p384_mod);
        sp_384_mont_mul_15(y, y, t4, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(t5, t5, t3, p384_mod, p384_mp_mod);
        sp_384_mont_sub_15(y, y, t5, p384_mod);
    }
}

/* Multiply a number by Montogmery normalizer mod modulus (prime).
 *
 * r  The resulting Montgomery form number.
 * a  The number to convert.
 * m  The modulus (prime).
 * returns MEMORY_E when memory allocation fails and MP_OKAY otherwise.
 */
static int sp_384_mod_mul_norm_15(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    int64_t* td;
#else
    int64_t td[12];
    int64_t a32d[12];
#endif
    int64_t* t;
    int64_t* a32;
    int64_t o;
    int err = MP_OKAY;

    (void)m;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (int64_t*)XMALLOC(sizeof(int64_t) * 2 * 12, NULL, DYNAMIC_TYPE_ECC);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t = td;
        a32 = td + 12;
#else
        t = td;
        a32 = a32d;
#endif

        a32[0] = a[0];
        a32[0] |= a[1] << 26U;
        a32[0] &= 0xffffffffL;
        a32[1] = (a[1] >> 6);
        a32[1] |= a[2] << 20U;
        a32[1] &= 0xffffffffL;
        a32[2] = (a[2] >> 12);
        a32[2] |= a[3] << 14U;
        a32[2] &= 0xffffffffL;
        a32[3] = (a[3] >> 18);
        a32[3] |= a[4] << 8U;
        a32[3] &= 0xffffffffL;
        a32[4] = (a[4] >> 24);
        a32[4] |= a[5] << 2U;
        a32[4] |= a[6] << 28U;
        a32[4] &= 0xffffffffL;
        a32[5] = (a[6] >> 4);
        a32[5] |= a[7] << 22U;
        a32[5] &= 0xffffffffL;
        a32[6] = (a[7] >> 10);
        a32[6] |= a[8] << 16U;
        a32[6] &= 0xffffffffL;
        a32[7] = (a[8] >> 16);
        a32[7] |= a[9] << 10U;
        a32[7] &= 0xffffffffL;
        a32[8] = (a[9] >> 22);
        a32[8] |= a[10] << 4U;
        a32[8] |= a[11] << 30U;
        a32[8] &= 0xffffffffL;
        a32[9] = (a[11] >> 2);
        a32[9] |= a[12] << 24U;
        a32[9] &= 0xffffffffL;
        a32[10] = (a[12] >> 8);
        a32[10] |= a[13] << 18U;
        a32[10] &= 0xffffffffL;
        a32[11] = (a[13] >> 14);
        a32[11] |= a[14] << 12U;
        a32[11] &= 0xffffffffL;

        /*  1  0  0  0  0  0  0  0  1  1  0 -1 */
        t[0] = 0 + a32[0] + a32[8] + a32[9] - a32[11];
        /* -1  1  0  0  0  0  0  0 -1  0  1  1 */
        t[1] = 0 - a32[0] + a32[1] - a32[8] + a32[10] + a32[11];
        /*  0 -1  1  0  0  0  0  0  0 -1  0  1 */
        t[2] = 0 - a32[1] + a32[2] - a32[9] + a32[11];
        /*  1  0 -1  1  0  0  0  0  1  1 -1 -1 */
        t[3] = 0 + a32[0] - a32[2] + a32[3] + a32[8] + a32[9] - a32[10] - a32[11];
        /*  1  1  0 -1  1  0  0  0  1  2  1 -2 */
        t[4] = 0 + a32[0] + a32[1] - a32[3] + a32[4] + a32[8] + 2 * a32[9] + a32[10] -  2 * a32[11];
        /*  0  1  1  0 -1  1  0  0  0  1  2  1 */
        t[5] = 0 + a32[1] + a32[2] - a32[4] + a32[5] + a32[9] + 2 * a32[10] + a32[11];
        /*  0  0  1  1  0 -1  1  0  0  0  1  2 */
        t[6] = 0 + a32[2] + a32[3] - a32[5] + a32[6] + a32[10] + 2 * a32[11];
        /*  0  0  0  1  1  0 -1  1  0  0  0  1 */
        t[7] = 0 + a32[3] + a32[4] - a32[6] + a32[7] + a32[11];
        /*  0  0  0  0  1  1  0 -1  1  0  0  0 */
        t[8] = 0 + a32[4] + a32[5] - a32[7] + a32[8];
        /*  0  0  0  0  0  1  1  0 -1  1  0  0 */
        t[9] = 0 + a32[5] + a32[6] - a32[8] + a32[9];
        /*  0  0  0  0  0  0  1  1  0 -1  1  0 */
        t[10] = 0 + a32[6] + a32[7] - a32[9] + a32[10];
        /*  0  0  0  0  0  0  0  1  1  0 -1  1 */
        t[11] = 0 + a32[7] + a32[8] - a32[10] + a32[11];

        t[1] += t[0] >> 32; t[0] &= 0xffffffff;
        t[2] += t[1] >> 32; t[1] &= 0xffffffff;
        t[3] += t[2] >> 32; t[2] &= 0xffffffff;
        t[4] += t[3] >> 32; t[3] &= 0xffffffff;
        t[5] += t[4] >> 32; t[4] &= 0xffffffff;
        t[6] += t[5] >> 32; t[5] &= 0xffffffff;
        t[7] += t[6] >> 32; t[6] &= 0xffffffff;
        t[8] += t[7] >> 32; t[7] &= 0xffffffff;
        t[9] += t[8] >> 32; t[8] &= 0xffffffff;
        t[10] += t[9] >> 32; t[9] &= 0xffffffff;
        t[11] += t[10] >> 32; t[10] &= 0xffffffff;
        o     = t[11] >> 32; t[11] &= 0xffffffff;
        t[0] += o;
        t[1] -= o;
        t[3] += o;
        t[4] += o;
        t[1] += t[0] >> 32; t[0] &= 0xffffffff;
        t[2] += t[1] >> 32; t[1] &= 0xffffffff;
        t[3] += t[2] >> 32; t[2] &= 0xffffffff;
        t[4] += t[3] >> 32; t[3] &= 0xffffffff;
        t[5] += t[4] >> 32; t[4] &= 0xffffffff;
        t[6] += t[5] >> 32; t[5] &= 0xffffffff;
        t[7] += t[6] >> 32; t[6] &= 0xffffffff;
        t[8] += t[7] >> 32; t[7] &= 0xffffffff;
        t[9] += t[8] >> 32; t[8] &= 0xffffffff;
        t[10] += t[9] >> 32; t[9] &= 0xffffffff;
        t[11] += t[10] >> 32; t[10] &= 0xffffffff;

        r[0] = (sp_digit)(t[0]) & 0x3ffffffL;
        r[1] = (sp_digit)(t[0] >> 26U);
        r[1] |= t[1] << 6U;
        r[1] &= 0x3ffffffL;
        r[2] = (sp_digit)(t[1] >> 20U);
        r[2] |= t[2] << 12U;
        r[2] &= 0x3ffffffL;
        r[3] = (sp_digit)(t[2] >> 14U);
        r[3] |= t[3] << 18U;
        r[3] &= 0x3ffffffL;
        r[4] = (sp_digit)(t[3] >> 8U);
        r[4] |= t[4] << 24U;
        r[4] &= 0x3ffffffL;
        r[5] = (sp_digit)(t[4] >> 2U) & 0x3ffffffL;
        r[6] = (sp_digit)(t[4] >> 28U);
        r[6] |= t[5] << 4U;
        r[6] &= 0x3ffffffL;
        r[7] = (sp_digit)(t[5] >> 22U);
        r[7] |= t[6] << 10U;
        r[7] &= 0x3ffffffL;
        r[8] = (sp_digit)(t[6] >> 16U);
        r[8] |= t[7] << 16U;
        r[8] &= 0x3ffffffL;
        r[9] = (sp_digit)(t[7] >> 10U);
        r[9] |= t[8] << 22U;
        r[9] &= 0x3ffffffL;
        r[10] = (sp_digit)(t[8] >> 4U) & 0x3ffffffL;
        r[11] = (sp_digit)(t[8] >> 30U);
        r[11] |= t[9] << 2U;
        r[11] &= 0x3ffffffL;
        r[12] = (sp_digit)(t[9] >> 24U);
        r[12] |= t[10] << 8U;
        r[12] &= 0x3ffffffL;
        r[13] = (sp_digit)(t[10] >> 18U);
        r[13] |= t[11] << 14U;
        r[13] &= 0x3ffffffL;
        r[14] = (sp_digit)(t[11] >> 12U);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL)
        XFREE(td, NULL, DYNAMIC_TYPE_ECC);
#endif

    return err;
}

#ifdef WOLFSSL_SP_SMALL
/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * Small implementation using add and double that is cache attack resistant but
 * allocates memory rather than use large stacks.
 * 384 adds and doubles.
 *
 * r     Resulting point.
 * g     Point to multiply.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */

#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_384_ecc_mulmod_15_ctx {
    int state;
    union {
        sp_384_proj_point_dbl_15_ctx dbl_ctx;
        sp_384_proj_point_add_15_ctx add_ctx;
    };
    sp_point_384 t[3];
    sp_digit tmp[2 * 15 * 6];
    sp_digit n;
    int i;
    int c;
    int y;
} sp_384_ecc_mulmod_15_ctx;

static int sp_384_ecc_mulmod_15_nb(sp_ecc_ctx_t* sp_ctx, sp_point_384* r, 
    const sp_point_384* g, const sp_digit* k, int map, void* heap)
{
    int err = FP_WOULDBLOCK;
    sp_384_ecc_mulmod_15_ctx* ctx = (sp_384_ecc_mulmod_15_ctx*)sp_ctx->data;

    typedef char ctx_size_test[sizeof(sp_384_ecc_mulmod_15_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    switch (ctx->state) {
    case 0: /* INIT */
        XMEMSET(ctx->t, 0, sizeof(sp_point_384) * 3);
        ctx->i = 14;
        ctx->c = 20;
        ctx->n = k[ctx->i--] << (26 - ctx->c);

        /* t[0] = {0, 0, 1} * norm */
        ctx->t[0].infinity = 1;
        ctx->state = 1;
        break;
    case 1: /* T1X */
        /* t[1] = {g->x, g->y, g->z} * norm */
        err = sp_384_mod_mul_norm_15(ctx->t[1].x, g->x, p384_mod);
        ctx->state = 2;
        break;
    case 2: /* T1Y */
        err = sp_384_mod_mul_norm_15(ctx->t[1].y, g->y, p384_mod);
        ctx->state = 3;
        break;
    case 3: /* T1Z */
        err = sp_384_mod_mul_norm_15(ctx->t[1].z, g->z, p384_mod);
        ctx->state = 4;
        break;
    case 4: /* ADDPREP */
        if (ctx->c == 0) {
            if (ctx->i == -1) {
                ctx->state = 7;
                break;
            }

            ctx->n = k[ctx->i--];
            ctx->c = 26;
        }
        ctx->y = (ctx->n >> 25) & 1;
        ctx->n <<= 1;
        XMEMSET(&ctx->add_ctx, 0, sizeof(ctx->add_ctx));
        ctx->state = 5;
        break;
    case 5: /* ADD */
        err = sp_384_proj_point_add_15_nb((sp_ecc_ctx_t*)&ctx->add_ctx, 
            &ctx->t[ctx->y^1], &ctx->t[0], &ctx->t[1], ctx->tmp);
        if (err == MP_OKAY) {
            XMEMCPY(&ctx->t[2], (void*)(((size_t)&ctx->t[0] & addr_mask[ctx->y^1]) +
                                        ((size_t)&ctx->t[1] & addr_mask[ctx->y])),
                    sizeof(sp_point_384));
            XMEMSET(&ctx->dbl_ctx, 0, sizeof(ctx->dbl_ctx));
            ctx->state = 6;
        }
        break;
    case 6: /* DBL */
        err = sp_384_proj_point_dbl_15_nb((sp_ecc_ctx_t*)&ctx->dbl_ctx, &ctx->t[2], 
            &ctx->t[2], ctx->tmp);
        if (err == MP_OKAY) {
            XMEMCPY((void*)(((size_t)&ctx->t[0] & addr_mask[ctx->y^1]) +
                            ((size_t)&ctx->t[1] & addr_mask[ctx->y])), &ctx->t[2],
                    sizeof(sp_point_384));
            ctx->state = 4;
            ctx->c--;
        }
        break;
    case 7: /* MAP */
        if (map != 0) {
            sp_384_map_15(r, &ctx->t[0], ctx->tmp);
        }
        else {
            XMEMCPY(r, &ctx->t[0], sizeof(sp_point_384));
        }
        err = MP_OKAY;
        break;
    }

    if (err == MP_OKAY && ctx->state != 7) {
        err = FP_WOULDBLOCK;
    }
    if (err != FP_WOULDBLOCK) {
        ForceZero(ctx->tmp, sizeof(ctx->tmp));
        ForceZero(ctx->t, sizeof(ctx->t));
    }

    (void)heap;

    return err;
}

#endif /* WOLFSSL_SP_NONBLOCK */

static int sp_384_ecc_mulmod_15(sp_point_384* r, const sp_point_384* g,
        const sp_digit* k, int map, void* heap)
{
#ifdef WOLFSSL_SP_NO_MALLOC
    sp_point_384 t[3];
    sp_digit tmp[2 * 15 * 6];
#else
    sp_point_384* t;
    sp_digit* tmp;
#endif
    sp_digit n;
    int i;
    int c;
    int y;
    int err = MP_OKAY;

    (void)heap;

#ifndef WOLFSSL_SP_NO_MALLOC
    t = (sp_point_384*)XMALLOC(sizeof(sp_point_384) * 3, heap, DYNAMIC_TYPE_ECC);
    if (t == NULL)
        err = MEMORY_E;
    tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 15 * 6, heap,
                                                              DYNAMIC_TYPE_ECC);
    if (tmp == NULL)
        err = MEMORY_E;
#endif

    if (err == MP_OKAY) {
        XMEMSET(t, 0, sizeof(sp_point_384) * 3);

        /* t[0] = {0, 0, 1} * norm */
        t[0].infinity = 1;
        /* t[1] = {g->x, g->y, g->z} * norm */
        err = sp_384_mod_mul_norm_15(t[1].x, g->x, p384_mod);
    }
    if (err == MP_OKAY)
        err = sp_384_mod_mul_norm_15(t[1].y, g->y, p384_mod);
    if (err == MP_OKAY)
        err = sp_384_mod_mul_norm_15(t[1].z, g->z, p384_mod);

    if (err == MP_OKAY) {
        i = 14;
        c = 20;
        n = k[i--] << (26 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1)
                    break;

                n = k[i--];
                c = 26;
            }

            y = (n >> 25) & 1;
            n <<= 1;

            sp_384_proj_point_add_15(&t[y^1], &t[0], &t[1], tmp);

            XMEMCPY(&t[2], (void*)(((size_t)&t[0] & addr_mask[y^1]) +
                                   ((size_t)&t[1] & addr_mask[y])),
                    sizeof(sp_point_384));
            sp_384_proj_point_dbl_15(&t[2], &t[2], tmp);
            XMEMCPY((void*)(((size_t)&t[0] & addr_mask[y^1]) +
                            ((size_t)&t[1] & addr_mask[y])), &t[2],
                    sizeof(sp_point_384));
        }

        if (map != 0) {
            sp_384_map_15(r, &t[0], tmp);
        }
        else {
            XMEMCPY(r, &t[0], sizeof(sp_point_384));
        }
    }

#ifndef WOLFSSL_SP_NO_MALLOC
    if (tmp != NULL) {
        XMEMSET(tmp, 0, sizeof(sp_digit) * 2 * 15 * 6);
        XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
    }
    if (t != NULL) {
        XMEMSET(t, 0, sizeof(sp_point_384) * 3);
        XFREE(t, NULL, DYNAMIC_TYPE_ECC);
    }
#else
    ForceZero(tmp, sizeof(tmp));
    ForceZero(t, sizeof(t));
#endif

    return err;
}

#elif defined(WOLFSSL_SP_CACHE_RESISTANT)
/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * Small implementation using add and double that is cache attack resistant
 * that uses large stack.
 * 384 adds and doubles.
 *
 * r     Resulting point.
 * g     Point to multiply.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_384_ecc_mulmod_15(sp_point_384* r, const sp_point_384* g,
        const sp_digit* k, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_384 t[3];
    sp_digit tmp[2 * 15 * 6];
#else
    sp_point_384* t;
    sp_digit* tmp;
#endif
    sp_digit n;
    int i;
    int c;
    int y;
    int err = MP_OKAY;

    (void)heap;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    t = (sp_point_384*)XMALLOC(sizeof(*t) * 3, heap, DYNAMIC_TYPE_ECC);
    if (t == NULL)
        err = MEMORY_E;
    tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 15 * 6, heap,
                             DYNAMIC_TYPE_ECC);
    if (tmp == NULL)
        err = MEMORY_E;
#endif

    if (err == MP_OKAY) {
        /* t[0] = {0, 0, 1} * norm */
        XMEMSET(&t[0], 0, sizeof(t[0]));
        t[0].infinity = 1;
        /* t[1] = {g->x, g->y, g->z} * norm */
        t[1].infinity = 0;
        err = sp_384_mod_mul_norm_15(t[1].x, g->x, p384_mod);
    }
    if (err == MP_OKAY)
        err = sp_384_mod_mul_norm_15(t[1].y, g->y, p384_mod);
    if (err == MP_OKAY)
        err = sp_384_mod_mul_norm_15(t[1].z, g->z, p384_mod);

    if (err == MP_OKAY) {
        i = 14;
        c = 20;
        n = k[i--] << (26 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1)
                    break;

                n = k[i--];
                c = 26;
            }

            y = (n >> 25) & 1;
            n <<= 1;

            sp_384_proj_point_add_15(&t[y^1], &t[0], &t[1], tmp);

            XMEMCPY(&t[2], (void*)(((size_t)&t[0] & addr_mask[y^1]) +
                                 ((size_t)&t[1] & addr_mask[y])), sizeof(t[2]));
            sp_384_proj_point_dbl_15(&t[2], &t[2], tmp);
            XMEMCPY((void*)(((size_t)&t[0] & addr_mask[y^1]) +
                          ((size_t)&t[1] & addr_mask[y])), &t[2], sizeof(t[2]));
        }

        if (map != 0) {
            sp_384_map_15(r, &t[0], tmp);
        }
        else {
            XMEMCPY(r, &t[0], sizeof(sp_point_384));
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (tmp != NULL) {
        XMEMSET(tmp, 0, sizeof(sp_digit) * 2 * 15 * 6);
        XFREE(tmp, heap, DYNAMIC_TYPE_ECC);
    }
    if (t != NULL) {
        XMEMSET(t, 0, sizeof(sp_point_384) * 3);
        XFREE(t, heap, DYNAMIC_TYPE_ECC);
    }
#else
    ForceZero(tmp, sizeof(tmp));
    ForceZero(t, sizeof(t));
#endif

    return err;
}

#else
/* A table entry for pre-computed points. */
typedef struct sp_table_entry_384 {
    sp_digit x[15];
    sp_digit y[15];
} sp_table_entry_384;

/* Conditionally copy a into r using the mask m.
 * m is -1 to copy and 0 when not.
 *
 * r  A single precision number to copy over.
 * a  A single precision number to copy.
 * m  Mask value to apply.
 */
static void sp_384_cond_copy_15(sp_digit* r, const sp_digit* a, const sp_digit m)
{
    sp_digit t[15];
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 15; i++) {
        t[i] = r[i] ^ a[i];
    }
    for (i = 0; i < 15; i++) {
        r[i] ^= t[i] & m;
    }
#else
    t[ 0] = r[ 0] ^ a[ 0];
    t[ 1] = r[ 1] ^ a[ 1];
    t[ 2] = r[ 2] ^ a[ 2];
    t[ 3] = r[ 3] ^ a[ 3];
    t[ 4] = r[ 4] ^ a[ 4];
    t[ 5] = r[ 5] ^ a[ 5];
    t[ 6] = r[ 6] ^ a[ 6];
    t[ 7] = r[ 7] ^ a[ 7];
    t[ 8] = r[ 8] ^ a[ 8];
    t[ 9] = r[ 9] ^ a[ 9];
    t[10] = r[10] ^ a[10];
    t[11] = r[11] ^ a[11];
    t[12] = r[12] ^ a[12];
    t[13] = r[13] ^ a[13];
    t[14] = r[14] ^ a[14];
    r[ 0] ^= t[ 0] & m;
    r[ 1] ^= t[ 1] & m;
    r[ 2] ^= t[ 2] & m;
    r[ 3] ^= t[ 3] & m;
    r[ 4] ^= t[ 4] & m;
    r[ 5] ^= t[ 5] & m;
    r[ 6] ^= t[ 6] & m;
    r[ 7] ^= t[ 7] & m;
    r[ 8] ^= t[ 8] & m;
    r[ 9] ^= t[ 9] & m;
    r[10] ^= t[10] & m;
    r[11] ^= t[11] & m;
    r[12] ^= t[12] & m;
    r[13] ^= t[13] & m;
    r[14] ^= t[14] & m;
#endif /* WOLFSSL_SP_SMALL */
}

/* Double the Montgomery form projective point p a number of times.
 *
 * r  Result of repeated doubling of point.
 * p  Point to double.
 * n  Number of times to double
 * t  Temporary ordinate data.
 */
static void sp_384_proj_point_dbl_n_15(sp_point_384* p, int n,
        sp_digit* t)
{
    sp_digit* w = t;
    sp_digit* a = t + 2*15;
    sp_digit* b = t + 4*15;
    sp_digit* t1 = t + 6*15;
    sp_digit* t2 = t + 8*15;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;

    x = p->x;
    y = p->y;
    z = p->z;

    /* Y = 2*Y */
    sp_384_mont_dbl_15(y, y, p384_mod);
    /* W = Z^4 */
    sp_384_mont_sqr_15(w, z, p384_mod, p384_mp_mod);
    sp_384_mont_sqr_15(w, w, p384_mod, p384_mp_mod);

#ifndef WOLFSSL_SP_SMALL
    while (--n > 0)
#else
    while (--n >= 0)
#endif
    {
        /* A = 3*(X^2 - W) */
        sp_384_mont_sqr_15(t1, x, p384_mod, p384_mp_mod);
        sp_384_mont_sub_15(t1, t1, w, p384_mod);
        sp_384_mont_tpl_15(a, t1, p384_mod);
        /* B = X*Y^2 */
        sp_384_mont_sqr_15(t1, y, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(b, t1, x, p384_mod, p384_mp_mod);
        /* X = A^2 - 2B */
        sp_384_mont_sqr_15(x, a, p384_mod, p384_mp_mod);
        sp_384_mont_dbl_15(t2, b, p384_mod);
        sp_384_mont_sub_15(x, x, t2, p384_mod);
        /* Z = Z*Y */
        sp_384_mont_mul_15(z, z, y, p384_mod, p384_mp_mod);
        /* t2 = Y^4 */
        sp_384_mont_sqr_15(t1, t1, p384_mod, p384_mp_mod);
#ifdef WOLFSSL_SP_SMALL
        if (n != 0)
        {
#endif
            /* W = W*Y^4 */
            sp_384_mont_mul_15(w, w, t1, p384_mod, p384_mp_mod);
#ifdef WOLFSSL_SP_SMALL
        }
#endif
        /* y = 2*A*(B - X) - Y^4 */
        sp_384_mont_sub_15(y, b, x, p384_mod);
        sp_384_mont_mul_15(y, y, a, p384_mod, p384_mp_mod);
        sp_384_mont_dbl_15(y, y, p384_mod);
        sp_384_mont_sub_15(y, y, t1, p384_mod);
    }
#ifndef WOLFSSL_SP_SMALL
    /* A = 3*(X^2 - W) */
    sp_384_mont_sqr_15(t1, x, p384_mod, p384_mp_mod);
    sp_384_mont_sub_15(t1, t1, w, p384_mod);
    sp_384_mont_tpl_15(a, t1, p384_mod);
    /* B = X*Y^2 */
    sp_384_mont_sqr_15(t1, y, p384_mod, p384_mp_mod);
    sp_384_mont_mul_15(b, t1, x, p384_mod, p384_mp_mod);
    /* X = A^2 - 2B */
    sp_384_mont_sqr_15(x, a, p384_mod, p384_mp_mod);
    sp_384_mont_dbl_15(t2, b, p384_mod);
    sp_384_mont_sub_15(x, x, t2, p384_mod);
    /* Z = Z*Y */
    sp_384_mont_mul_15(z, z, y, p384_mod, p384_mp_mod);
    /* t2 = Y^4 */
    sp_384_mont_sqr_15(t1, t1, p384_mod, p384_mp_mod);
    /* y = 2*A*(B - X) - Y^4 */
    sp_384_mont_sub_15(y, b, x, p384_mod);
    sp_384_mont_mul_15(y, y, a, p384_mod, p384_mp_mod);
    sp_384_mont_dbl_15(y, y, p384_mod);
    sp_384_mont_sub_15(y, y, t1, p384_mod);
#endif
    /* Y = Y/2 */
    sp_384_div2_15(y, y, p384_mod);
}

/* Double the Montgomery form projective point p a number of times.
 *
 * r  Result of repeated doubling of point.
 * p  Point to double.
 * n  Number of times to double
 * t  Temporary ordinate data.
 */
static void sp_384_proj_point_dbl_n_store_15(sp_point_384* r,
        const sp_point_384* p, int n, int m, sp_digit* t)
{
    sp_digit* w = t;
    sp_digit* a = t + 2*15;
    sp_digit* b = t + 4*15;
    sp_digit* t1 = t + 6*15;
    sp_digit* t2 = t + 8*15;
    sp_digit* x = r[2*m].x;
    sp_digit* y = r[(1<<n)*m].y;
    sp_digit* z = r[2*m].z;
    int i;

    for (i=0; i<15; i++) {
        x[i] = p->x[i];
    }
    for (i=0; i<15; i++) {
        y[i] = p->y[i];
    }
    for (i=0; i<15; i++) {
        z[i] = p->z[i];
    }

    /* Y = 2*Y */
    sp_384_mont_dbl_15(y, y, p384_mod);
    /* W = Z^4 */
    sp_384_mont_sqr_15(w, z, p384_mod, p384_mp_mod);
    sp_384_mont_sqr_15(w, w, p384_mod, p384_mp_mod);
    for (i=1; i<=n; i++) {
        /* A = 3*(X^2 - W) */
        sp_384_mont_sqr_15(t1, x, p384_mod, p384_mp_mod);
        sp_384_mont_sub_15(t1, t1, w, p384_mod);
        sp_384_mont_tpl_15(a, t1, p384_mod);
        /* B = X*Y^2 */
        sp_384_mont_sqr_15(t2, y, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(b, t2, x, p384_mod, p384_mp_mod);
        x = r[(1<<i)*m].x;
        /* X = A^2 - 2B */
        sp_384_mont_sqr_15(x, a, p384_mod, p384_mp_mod);
        sp_384_mont_dbl_15(t1, b, p384_mod);
        sp_384_mont_sub_15(x, x, t1, p384_mod);
        /* Z = Z*Y */
        sp_384_mont_mul_15(r[(1<<i)*m].z, z, y, p384_mod, p384_mp_mod);
        z = r[(1<<i)*m].z;
        /* t2 = Y^4 */
        sp_384_mont_sqr_15(t2, t2, p384_mod, p384_mp_mod);
        if (i != n) {
            /* W = W*Y^4 */
            sp_384_mont_mul_15(w, w, t2, p384_mod, p384_mp_mod);
        }
        /* y = 2*A*(B - X) - Y^4 */
        sp_384_mont_sub_15(y, b, x, p384_mod);
        sp_384_mont_mul_15(y, y, a, p384_mod, p384_mp_mod);
        sp_384_mont_dbl_15(y, y, p384_mod);
        sp_384_mont_sub_15(y, y, t2, p384_mod);

        /* Y = Y/2 */
        sp_384_div2_15(r[(1<<i)*m].y, y, p384_mod);
        r[(1<<i)*m].infinity = 0;
    }
}

/* Add two Montgomery form projective points.
 *
 * ra  Result of addition.
 * rs  Result of subtraction.
 * p   First point to add.
 * q   Second point to add.
 * t   Temporary ordinate data.
 */
static void sp_384_proj_point_add_sub_15(sp_point_384* ra,
        sp_point_384* rs, const sp_point_384* p, const sp_point_384* q,
        sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*15;
    sp_digit* t3 = t + 4*15;
    sp_digit* t4 = t + 6*15;
    sp_digit* t5 = t + 8*15;
    sp_digit* t6 = t + 10*15;
    sp_digit* x = ra->x;
    sp_digit* y = ra->y;
    sp_digit* z = ra->z;
    sp_digit* xs = rs->x;
    sp_digit* ys = rs->y;
    sp_digit* zs = rs->z;


    XMEMCPY(x, p->x, sizeof(p->x) / 2);
    XMEMCPY(y, p->y, sizeof(p->y) / 2);
    XMEMCPY(z, p->z, sizeof(p->z) / 2);
    ra->infinity = 0;
    rs->infinity = 0;

    /* U1 = X1*Z2^2 */
    sp_384_mont_sqr_15(t1, q->z, p384_mod, p384_mp_mod);
    sp_384_mont_mul_15(t3, t1, q->z, p384_mod, p384_mp_mod);
    sp_384_mont_mul_15(t1, t1, x, p384_mod, p384_mp_mod);
    /* U2 = X2*Z1^2 */
    sp_384_mont_sqr_15(t2, z, p384_mod, p384_mp_mod);
    sp_384_mont_mul_15(t4, t2, z, p384_mod, p384_mp_mod);
    sp_384_mont_mul_15(t2, t2, q->x, p384_mod, p384_mp_mod);
    /* S1 = Y1*Z2^3 */
    sp_384_mont_mul_15(t3, t3, y, p384_mod, p384_mp_mod);
    /* S2 = Y2*Z1^3 */
    sp_384_mont_mul_15(t4, t4, q->y, p384_mod, p384_mp_mod);
    /* H = U2 - U1 */
    sp_384_mont_sub_15(t2, t2, t1, p384_mod);
    /* RS = S2 + S1 */
    sp_384_mont_add_15(t6, t4, t3, p384_mod);
    /* R = S2 - S1 */
    sp_384_mont_sub_15(t4, t4, t3, p384_mod);
    /* Z3 = H*Z1*Z2 */
    /* ZS = H*Z1*Z2 */
    sp_384_mont_mul_15(z, z, q->z, p384_mod, p384_mp_mod);
    sp_384_mont_mul_15(z, z, t2, p384_mod, p384_mp_mod);
    XMEMCPY(zs, z, sizeof(p->z)/2);
    /* X3 = R^2 - H^3 - 2*U1*H^2 */
    /* XS = RS^2 - H^3 - 2*U1*H^2 */
    sp_384_mont_sqr_15(x, t4, p384_mod, p384_mp_mod);
    sp_384_mont_sqr_15(xs, t6, p384_mod, p384_mp_mod);
    sp_384_mont_sqr_15(t5, t2, p384_mod, p384_mp_mod);
    sp_384_mont_mul_15(y, t1, t5, p384_mod, p384_mp_mod);
    sp_384_mont_mul_15(t5, t5, t2, p384_mod, p384_mp_mod);
    sp_384_mont_sub_15(x, x, t5, p384_mod);
    sp_384_mont_sub_15(xs, xs, t5, p384_mod);
    sp_384_mont_dbl_15(t1, y, p384_mod);
    sp_384_mont_sub_15(x, x, t1, p384_mod);
    sp_384_mont_sub_15(xs, xs, t1, p384_mod);
    /* Y3 = R*(U1*H^2 - X3) - S1*H^3 */
    /* YS = -RS*(U1*H^2 - XS) - S1*H^3 */
    sp_384_mont_sub_15(ys, y, xs, p384_mod);
    sp_384_mont_sub_15(y, y, x, p384_mod);
    sp_384_mont_mul_15(y, y, t4, p384_mod, p384_mp_mod);
    sp_384_sub_15(t6, p384_mod, t6);
    sp_384_mont_mul_15(ys, ys, t6, p384_mod, p384_mp_mod);
    sp_384_mont_mul_15(t5, t5, t3, p384_mod, p384_mp_mod);
    sp_384_mont_sub_15(y, y, t5, p384_mod);
    sp_384_mont_sub_15(ys, ys, t5, p384_mod);
}

/* Structure used to describe recoding of scalar multiplication. */
typedef struct ecc_recode_384 {
    /* Index into pre-computation table. */
    uint8_t i;
    /* Use the negative of the point. */
    uint8_t neg;
} ecc_recode_384;

/* The index into pre-computation table to use. */
static const uint8_t recode_index_15_6[66] = {
     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
    32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17,
    16, 15, 14, 13, 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,
     0,  1,
};

/* Whether to negate y-ordinate. */
static const uint8_t recode_neg_15_6[66] = {
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
     0,  0,
};

/* Recode the scalar for multiplication using pre-computed values and
 * subtraction.
 *
 * k  Scalar to multiply by.
 * v  Vector of operations to perform.
 */
static void sp_384_ecc_recode_6_15(const sp_digit* k, ecc_recode_384* v)
{
    int i;
    int j;
    uint8_t y;
    int carry = 0;
    int o;
    sp_digit n;

    j = 0;
    n = k[j];
    o = 0;
    for (i=0; i<65; i++) {
        y = (uint8_t)n;
        if (o + 6 < 26) {
            y &= 0x3f;
            n >>= 6;
            o += 6;
        }
        else if (o + 6 == 26) {
            n >>= 6;
            if (++j < 15)
                n = k[j];
            o = 0;
        }
        else if (++j < 15) {
            n = k[j];
            y |= (n << (26 - o)) & 0x3f;
            o -= 20;
            n >>= o;
        }

        y += (uint8_t)carry;
        v[i].i = recode_index_15_6[y];
        v[i].neg = recode_neg_15_6[y];
        carry = (y >> 6) + v[i].neg;
    }
}

/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * r     Resulting point.
 * g     Point to multiply.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_384_ecc_mulmod_win_add_sub_15(sp_point_384* r,
        const sp_point_384* g, const sp_digit* k, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_384 td[33];
    sp_point_384 rtd;
    sp_point_384 pd;
    sp_digit tmpd[2 * 15 * 6];
#endif
    sp_point_384* t;
    sp_point_384* rt;
    sp_point_384* p = NULL;
    sp_digit* tmp;
    sp_digit* negy;
    int i;
    ecc_recode_384 v[65];
    int err;

    (void)heap;

    err = sp_384_point_new_15(heap, rtd, rt);
    if (err == MP_OKAY)
        err = sp_384_point_new_15(heap, pd, p);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    t = (sp_point_384*)XMALLOC(sizeof(sp_point_384) * 33, heap, DYNAMIC_TYPE_ECC);
    if (t == NULL)
        err = MEMORY_E;
    tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 15 * 6, heap,
                             DYNAMIC_TYPE_ECC);
    if (tmp == NULL)
        err = MEMORY_E;
#else
    t = td;
    tmp = tmpd;
#endif


    if (err == MP_OKAY) {
        /* t[0] = {0, 0, 1} * norm */
        XMEMSET(&t[0], 0, sizeof(t[0]));
        t[0].infinity = 1;
        /* t[1] = {g->x, g->y, g->z} * norm */
        err = sp_384_mod_mul_norm_15(t[1].x, g->x, p384_mod);
    }
    if (err == MP_OKAY) {
        err = sp_384_mod_mul_norm_15(t[1].y, g->y, p384_mod);
    }
    if (err == MP_OKAY) {
        err = sp_384_mod_mul_norm_15(t[1].z, g->z, p384_mod);
    }

    if (err == MP_OKAY) {
        t[1].infinity = 0;
        /* t[2] ... t[32]  */
        sp_384_proj_point_dbl_n_store_15(t, &t[ 1], 5, 1, tmp);
        sp_384_proj_point_add_15(&t[ 3], &t[ 2], &t[ 1], tmp);
        sp_384_proj_point_dbl_15(&t[ 6], &t[ 3], tmp);
        sp_384_proj_point_add_sub_15(&t[ 7], &t[ 5], &t[ 6], &t[ 1], tmp);
        sp_384_proj_point_dbl_15(&t[10], &t[ 5], tmp);
        sp_384_proj_point_add_sub_15(&t[11], &t[ 9], &t[10], &t[ 1], tmp);
        sp_384_proj_point_dbl_15(&t[12], &t[ 6], tmp);
        sp_384_proj_point_dbl_15(&t[14], &t[ 7], tmp);
        sp_384_proj_point_add_sub_15(&t[15], &t[13], &t[14], &t[ 1], tmp);
        sp_384_proj_point_dbl_15(&t[18], &t[ 9], tmp);
        sp_384_proj_point_add_sub_15(&t[19], &t[17], &t[18], &t[ 1], tmp);
        sp_384_proj_point_dbl_15(&t[20], &t[10], tmp);
        sp_384_proj_point_dbl_15(&t[22], &t[11], tmp);
        sp_384_proj_point_add_sub_15(&t[23], &t[21], &t[22], &t[ 1], tmp);
        sp_384_proj_point_dbl_15(&t[24], &t[12], tmp);
        sp_384_proj_point_dbl_15(&t[26], &t[13], tmp);
        sp_384_proj_point_add_sub_15(&t[27], &t[25], &t[26], &t[ 1], tmp);
        sp_384_proj_point_dbl_15(&t[28], &t[14], tmp);
        sp_384_proj_point_dbl_15(&t[30], &t[15], tmp);
        sp_384_proj_point_add_sub_15(&t[31], &t[29], &t[30], &t[ 1], tmp);

        negy = t[0].y;

        sp_384_ecc_recode_6_15(k, v);

        i = 64;
        XMEMCPY(rt, &t[v[i].i], sizeof(sp_point_384));
        for (--i; i>=0; i--) {
            sp_384_proj_point_dbl_n_15(rt, 6, tmp);

            XMEMCPY(p, &t[v[i].i], sizeof(sp_point_384));
            sp_384_sub_15(negy, p384_mod, p->y);
            sp_384_norm_15(negy);
            sp_384_cond_copy_15(p->y, negy, (sp_digit)0 - v[i].neg);
            sp_384_proj_point_add_15(rt, rt, p, tmp);
        }

        if (map != 0) {
            sp_384_map_15(r, rt, tmp);
        }
        else {
            XMEMCPY(r, rt, sizeof(sp_point_384));
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (t != NULL)
        XFREE(t, heap, DYNAMIC_TYPE_ECC);
    if (tmp != NULL)
        XFREE(tmp, heap, DYNAMIC_TYPE_ECC);
#endif
    sp_384_point_free_15(p, 0, heap);
    sp_384_point_free_15(rt, 0, heap);

    return err;
}

#ifdef FP_ECC
#endif /* FP_ECC */
/* Add two Montgomery form projective points. The second point has a q value of
 * one.
 * Only the first point can be the same pointer as the result point.
 *
 * r  Result of addition.
 * p  First point to add.
 * q  Second point to add.
 * t  Temporary ordinate data.
 */
static void sp_384_proj_point_add_qz1_15(sp_point_384* r, const sp_point_384* p,
        const sp_point_384* q, sp_digit* t)
{
    const sp_point_384* ap[2];
    sp_point_384* rp[2];
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*15;
    sp_digit* t3 = t + 4*15;
    sp_digit* t4 = t + 6*15;
    sp_digit* t5 = t + 8*15;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;
    int i;

    /* Check double */
    (void)sp_384_sub_15(t1, p384_mod, q->y);
    sp_384_norm_15(t1);
    if ((sp_384_cmp_equal_15(p->x, q->x) & sp_384_cmp_equal_15(p->z, q->z) &
        (sp_384_cmp_equal_15(p->y, q->y) | sp_384_cmp_equal_15(p->y, t1))) != 0) {
        sp_384_proj_point_dbl_15(r, p, t);
    }
    else {
        rp[0] = r;

        /*lint allow cast to different type of pointer*/
        rp[1] = (sp_point_384*)t; /*lint !e9087 !e740*/
        XMEMSET(rp[1], 0, sizeof(sp_point_384));
        x = rp[p->infinity | q->infinity]->x;
        y = rp[p->infinity | q->infinity]->y;
        z = rp[p->infinity | q->infinity]->z;

        ap[0] = p;
        ap[1] = q;
        for (i=0; i<15; i++) {
            r->x[i] = ap[p->infinity]->x[i];
        }
        for (i=0; i<15; i++) {
            r->y[i] = ap[p->infinity]->y[i];
        }
        for (i=0; i<15; i++) {
            r->z[i] = ap[p->infinity]->z[i];
        }
        r->infinity = ap[p->infinity]->infinity;

        /* U2 = X2*Z1^2 */
        sp_384_mont_sqr_15(t2, z, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(t4, t2, z, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(t2, t2, q->x, p384_mod, p384_mp_mod);
        /* S2 = Y2*Z1^3 */
        sp_384_mont_mul_15(t4, t4, q->y, p384_mod, p384_mp_mod);
        /* H = U2 - X1 */
        sp_384_mont_sub_15(t2, t2, x, p384_mod);
        /* R = S2 - Y1 */
        sp_384_mont_sub_15(t4, t4, y, p384_mod);
        /* Z3 = H*Z1 */
        sp_384_mont_mul_15(z, z, t2, p384_mod, p384_mp_mod);
        /* X3 = R^2 - H^3 - 2*X1*H^2 */
        sp_384_mont_sqr_15(t1, t4, p384_mod, p384_mp_mod);
        sp_384_mont_sqr_15(t5, t2, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(t3, x, t5, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(t5, t5, t2, p384_mod, p384_mp_mod);
        sp_384_mont_sub_15(x, t1, t5, p384_mod);
        sp_384_mont_dbl_15(t1, t3, p384_mod);
        sp_384_mont_sub_15(x, x, t1, p384_mod);
        /* Y3 = R*(X1*H^2 - X3) - Y1*H^3 */
        sp_384_mont_sub_15(t3, t3, x, p384_mod);
        sp_384_mont_mul_15(t3, t3, t4, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(t5, t5, y, p384_mod, p384_mp_mod);
        sp_384_mont_sub_15(y, t3, t5, p384_mod);
    }
}

#ifdef FP_ECC
/* Convert the projective point to affine.
 * Ordinates are in Montgomery form.
 *
 * a  Point to convert.
 * t  Temporary data.
 */
static void sp_384_proj_to_affine_15(sp_point_384* a, sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2 * 15;
    sp_digit* tmp = t + 4 * 15;

    sp_384_mont_inv_15(t1, a->z, tmp);

    sp_384_mont_sqr_15(t2, t1, p384_mod, p384_mp_mod);
    sp_384_mont_mul_15(t1, t2, t1, p384_mod, p384_mp_mod);

    sp_384_mont_mul_15(a->x, a->x, t2, p384_mod, p384_mp_mod);
    sp_384_mont_mul_15(a->y, a->y, t1, p384_mod, p384_mp_mod);
    XMEMCPY(a->z, p384_norm_mod, sizeof(p384_norm_mod));
}

/* Generate the pre-computed table of points for the base point.
 *
 * width = 8
 * 256 entries
 * 48 bits between
 *
 * a      The base point.
 * table  Place to store generated point data.
 * tmp    Temporary data.
 * heap  Heap to use for allocation.
 */
static int sp_384_gen_stripe_table_15(const sp_point_384* a,
        sp_table_entry_384* table, sp_digit* tmp, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_384 td;
    sp_point_384 s1d;
    sp_point_384 s2d;
#endif
    sp_point_384* t;
    sp_point_384* s1 = NULL;
    sp_point_384* s2 = NULL;
    int i;
    int j;
    int err;

    (void)heap;

    err = sp_384_point_new_15(heap, td, t);
    if (err == MP_OKAY) {
        err = sp_384_point_new_15(heap, s1d, s1);
    }
    if (err == MP_OKAY) {
        err = sp_384_point_new_15(heap, s2d, s2);
    }

    if (err == MP_OKAY) {
        err = sp_384_mod_mul_norm_15(t->x, a->x, p384_mod);
    }
    if (err == MP_OKAY) {
        err = sp_384_mod_mul_norm_15(t->y, a->y, p384_mod);
    }
    if (err == MP_OKAY) {
        err = sp_384_mod_mul_norm_15(t->z, a->z, p384_mod);
    }
    if (err == MP_OKAY) {
        t->infinity = 0;
        sp_384_proj_to_affine_15(t, tmp);

        XMEMCPY(s1->z, p384_norm_mod, sizeof(p384_norm_mod));
        s1->infinity = 0;
        XMEMCPY(s2->z, p384_norm_mod, sizeof(p384_norm_mod));
        s2->infinity = 0;

        /* table[0] = {0, 0, infinity} */
        XMEMSET(&table[0], 0, sizeof(sp_table_entry_384));
        /* table[1] = Affine version of 'a' in Montgomery form */
        XMEMCPY(table[1].x, t->x, sizeof(table->x));
        XMEMCPY(table[1].y, t->y, sizeof(table->y));

        for (i=1; i<8; i++) {
            sp_384_proj_point_dbl_n_15(t, 48, tmp);
            sp_384_proj_to_affine_15(t, tmp);
            XMEMCPY(table[1<<i].x, t->x, sizeof(table->x));
            XMEMCPY(table[1<<i].y, t->y, sizeof(table->y));
        }

        for (i=1; i<8; i++) {
            XMEMCPY(s1->x, table[1<<i].x, sizeof(table->x));
            XMEMCPY(s1->y, table[1<<i].y, sizeof(table->y));
            for (j=(1<<i)+1; j<(1<<(i+1)); j++) {
                XMEMCPY(s2->x, table[j-(1<<i)].x, sizeof(table->x));
                XMEMCPY(s2->y, table[j-(1<<i)].y, sizeof(table->y));
                sp_384_proj_point_add_qz1_15(t, s1, s2, tmp);
                sp_384_proj_to_affine_15(t, tmp);
                XMEMCPY(table[j].x, t->x, sizeof(table->x));
                XMEMCPY(table[j].y, t->y, sizeof(table->y));
            }
        }
    }

    sp_384_point_free_15(s2, 0, heap);
    sp_384_point_free_15(s1, 0, heap);
    sp_384_point_free_15( t, 0, heap);

    return err;
}

#endif /* FP_ECC */
/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * Stripe implementation.
 * Pre-generated: 2^0, 2^48, ...
 * Pre-generated: products of all combinations of above.
 * 8 doubles and adds (with qz=1)
 *
 * r     Resulting point.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_384_ecc_mulmod_stripe_15(sp_point_384* r,
        const sp_point_384* g, const sp_table_entry_384* table,
        const sp_digit* k, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_384 rtd;
    sp_point_384 pd;
    sp_digit td[2 * 15 * 6];
#endif
    sp_point_384* rt;
    sp_point_384* p = NULL;
    sp_digit* t;
    int i;
    int j;
    int y;
    int x;
    int err;

    (void)g;
    (void)heap;


    err = sp_384_point_new_15(heap, rtd, rt);
    if (err == MP_OKAY) {
        err = sp_384_point_new_15(heap, pd, p);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    t = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 15 * 6, heap,
                           DYNAMIC_TYPE_ECC);
    if (t == NULL) {
        err = MEMORY_E;
    }
#else
    t = td;
#endif

    if (err == MP_OKAY) {
        XMEMCPY(p->z, p384_norm_mod, sizeof(p384_norm_mod));
        XMEMCPY(rt->z, p384_norm_mod, sizeof(p384_norm_mod));

        y = 0;
        x = 47;
        for (j = 0; j < 8; j++) {
            y |= ((k[x / 26] >> (x % 26)) & 1) << j;
            x += 48;
        }
        XMEMCPY(rt->x, table[y].x, sizeof(table[y].x));
        XMEMCPY(rt->y, table[y].y, sizeof(table[y].y));
        rt->infinity = !y;
        for (i = 46; i >= 0; i--) {
            y = 0;
            x = i;
            for (j=0; j<8; j++) {
                y |= ((k[x / 26] >> (x % 26)) & 1) << j;
                x += 48;
            }

            sp_384_proj_point_dbl_15(rt, rt, t);
            XMEMCPY(p->x, table[y].x, sizeof(table[y].x));
            XMEMCPY(p->y, table[y].y, sizeof(table[y].y));
            p->infinity = !y;
            sp_384_proj_point_add_qz1_15(rt, rt, p, t);
        }

        if (map != 0) {
            sp_384_map_15(r, rt, t);
        }
        else {
            XMEMCPY(r, rt, sizeof(sp_point_384));
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (t != NULL) {
        XFREE(t, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_384_point_free_15(p, 0, heap);
    sp_384_point_free_15(rt, 0, heap);

    return err;
}

#ifdef FP_ECC
#ifndef FP_ENTRIES
    #define FP_ENTRIES 16
#endif

/* Cache entry - holds precomputation tables for a point. */
typedef struct sp_cache_384_t {
    /* X ordinate of point that table was generated from. */
    sp_digit x[15];
    /* Y ordinate of point that table was generated from. */
    sp_digit y[15];
    /* Precomputation table for point. */
    sp_table_entry_384 table[256];
    /* Count of entries in table. */
    uint32_t cnt;
    /* Point and table set in entry. */
    int set;
} sp_cache_384_t;

/* Cache of tables. */
static THREAD_LS_T sp_cache_384_t sp_cache_384[FP_ENTRIES];
/* Index of last entry in cache. */
static THREAD_LS_T int sp_cache_384_last = -1;
/* Cache has been initialized. */
static THREAD_LS_T int sp_cache_384_inited = 0;

#ifndef HAVE_THREAD_LS
    static volatile int initCacheMutex_384 = 0;
    static wolfSSL_Mutex sp_cache_384_lock;
#endif

/* Get the cache entry for the point.
 *
 * g      [in]   Point scalar multipling.
 * cache  [out]  Cache table to use.
 */
static void sp_ecc_get_cache_384(const sp_point_384* g,
        sp_cache_384_t** cache)
{
    int i;
    int j;
    uint32_t least;

    if (sp_cache_384_inited == 0) {
        for (i=0; i<FP_ENTRIES; i++) {
            sp_cache_384[i].set = 0;
        }
        sp_cache_384_inited = 1;
    }

    /* Compare point with those in cache. */
    for (i=0; i<FP_ENTRIES; i++) {
        if (!sp_cache_384[i].set)
            continue;

        if (sp_384_cmp_equal_15(g->x, sp_cache_384[i].x) &
                           sp_384_cmp_equal_15(g->y, sp_cache_384[i].y)) {
            sp_cache_384[i].cnt++;
            break;
        }
    }

    /* No match. */
    if (i == FP_ENTRIES) {
        /* Find empty entry. */
        i = (sp_cache_384_last + 1) % FP_ENTRIES;
        for (; i != sp_cache_384_last; i=(i+1)%FP_ENTRIES) {
            if (!sp_cache_384[i].set) {
                break;
            }
        }

        /* Evict least used. */
        if (i == sp_cache_384_last) {
            least = sp_cache_384[0].cnt;
            for (j=1; j<FP_ENTRIES; j++) {
                if (sp_cache_384[j].cnt < least) {
                    i = j;
                    least = sp_cache_384[i].cnt;
                }
            }
        }

        XMEMCPY(sp_cache_384[i].x, g->x, sizeof(sp_cache_384[i].x));
        XMEMCPY(sp_cache_384[i].y, g->y, sizeof(sp_cache_384[i].y));
        sp_cache_384[i].set = 1;
        sp_cache_384[i].cnt = 1;
    }

    *cache = &sp_cache_384[i];
    sp_cache_384_last = i;
}
#endif /* FP_ECC */

/* Multiply the base point of P384 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * r     Resulting point.
 * g     Point to multiply.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_384_ecc_mulmod_15(sp_point_384* r, const sp_point_384* g,
        const sp_digit* k, int map, void* heap)
{
#ifndef FP_ECC
    return sp_384_ecc_mulmod_win_add_sub_15(r, g, k, map, heap);
#else
    sp_digit tmp[2 * 15 * 7];
    sp_cache_384_t* cache;
    int err = MP_OKAY;

#ifndef HAVE_THREAD_LS
    if (initCacheMutex_384 == 0) {
         wc_InitMutex(&sp_cache_384_lock);
         initCacheMutex_384 = 1;
    }
    if (wc_LockMutex(&sp_cache_384_lock) != 0)
       err = BAD_MUTEX_E;
#endif /* HAVE_THREAD_LS */

    if (err == MP_OKAY) {
        sp_ecc_get_cache_384(g, &cache);
        if (cache->cnt == 2)
            sp_384_gen_stripe_table_15(g, cache->table, tmp, heap);

#ifndef HAVE_THREAD_LS
        wc_UnLockMutex(&sp_cache_384_lock);
#endif /* HAVE_THREAD_LS */

        if (cache->cnt < 2) {
            err = sp_384_ecc_mulmod_win_add_sub_15(r, g, k, map, heap);
        }
        else {
            err = sp_384_ecc_mulmod_stripe_15(r, g, cache->table, k,
                    map, heap);
        }
    }

    return err;
#endif
}

#endif
/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * km    Scalar to multiply by.
 * p     Point to multiply.
 * r     Resulting point.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_mulmod_384(const mp_int* km, const ecc_point* gm, ecc_point* r,
    int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_384 p;
    sp_digit kd[15];
#endif
    sp_point_384* point;
    sp_digit* k = NULL;
    int err = MP_OKAY;

    err = sp_384_point_new_15(heap, p, point);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * 15, heap,
                                                              DYNAMIC_TYPE_ECC);
        if (k == NULL)
            err = MEMORY_E;
    }
#else
    k = kd;
#endif
    if (err == MP_OKAY) {
        sp_384_from_mp(k, 15, km);
        sp_384_point_from_ecc_point_15(point, gm);

            err = sp_384_ecc_mulmod_15(point, point, k, map, heap);
    }
    if (err == MP_OKAY) {
        err = sp_384_point_to_ecc_point_15(point, r);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_384_point_free_15(point, 0, heap);

    return err;
}

/* Multiply the point by the scalar, add point a and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * km      Scalar to multiply by.
 * p       Point to multiply.
 * am      Point to add to scalar mulitply result.
 * inMont  Point to add is in montogmery form.
 * r       Resulting point.
 * map     Indicates whether to convert result to affine.
 * heap    Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_mulmod_add_384(const mp_int* km, const ecc_point* gm,
    const ecc_point* am, int inMont, ecc_point* r, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_384 p;
    sp_point_384 a;
    sp_digit kd[15];
    sp_digit t[15 * 2 * 6];
#endif
    sp_point_384* point;
    sp_point_384* addP = NULL;
    sp_digit* k = NULL;
    sp_digit* tmp = NULL;
    int err = MP_OKAY;

    err = sp_384_point_new_15(heap, p, point);
    if (err == MP_OKAY) {
        err = sp_384_point_new_15(heap, a, addP);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * (15 + 15 * 2 * 6), heap, DYNAMIC_TYPE_ECC);
        if (k == NULL) {
            err = MEMORY_E;
        }
        else {
            tmp = k + 15;
        }
    }
#else
    k = kd;
    tmp = t;
#endif
    if (err == MP_OKAY) {
        sp_384_from_mp(k, 15, km);
        sp_384_point_from_ecc_point_15(point, gm);
        sp_384_point_from_ecc_point_15(addP, am);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_384_mod_mul_norm_15(addP->x, addP->x, p384_mod);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_384_mod_mul_norm_15(addP->y, addP->y, p384_mod);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_384_mod_mul_norm_15(addP->z, addP->z, p384_mod);
    }
    if (err == MP_OKAY) {
            err = sp_384_ecc_mulmod_15(point, point, k, 0, heap);
    }
    if (err == MP_OKAY) {
            sp_384_proj_point_add_15(point, point, addP, tmp);

        if (map) {
            sp_384_map_15(point, point, tmp);
        }

        err = sp_384_point_to_ecc_point_15(point, r);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_384_point_free_15(addP, 0, heap);
    sp_384_point_free_15(point, 0, heap);

    return err;
}

#ifdef WOLFSSL_SP_SMALL
/* Multiply the base point of P384 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * r     Resulting point.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_384_ecc_mulmod_base_15(sp_point_384* r, const sp_digit* k,
        int map, void* heap)
{
    /* No pre-computed values. */
    return sp_384_ecc_mulmod_15(r, &p384_base, k, map, heap);
}

#elif defined(WOLFSSL_SP_CACHE_RESISTANT)
/* Multiply the base point of P384 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * r     Resulting point.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_384_ecc_mulmod_base_15(sp_point_384* r, const sp_digit* k,
        int map, void* heap)
{
    /* No pre-computed values. */
    return sp_384_ecc_mulmod_15(r, &p384_base, k, map, heap);
}

#else
/* Striping precomputation table.
 * 8 points combined into a table of 256 points.
 * Distance of 48 between points.
 */
static const sp_table_entry_384 p384_table[256] = {
    /* 0 */
    { { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    /* 1 */
    { { 0x1c0b528,0x01d5992,0x0e383dd,0x38a835b,0x220e378,0x106d35b,
        0x1c3afc5,0x03bfe1e,0x28459a3,0x2d91521,0x214ede2,0x0bfdc8d,
        0x2151381,0x3708a67,0x004d3aa },
      { 0x303a4fe,0x10f6b52,0x29ac230,0x2fdeed2,0x0a1bfa8,0x3a0ec14,
        0x2de7562,0x3ff662e,0x21968f4,0x031b0d4,0x3969a84,0x2000898,
        0x1c5e9dd,0x2f09685,0x002b78a } },
    /* 2 */
    { { 0x30c535b,0x191d4ca,0x2296298,0x14dc141,0x090dd69,0x05aae6b,
        0x0cd6b42,0x35da80e,0x3b7be12,0x2cf7e6d,0x1f347bd,0x3d365e1,
        0x1448913,0x32704fa,0x00222c5 },
      { 0x280dc64,0x39e5bc9,0x24175f8,0x2dd60d4,0x0120e7c,0x041d02e,
        0x0b5d8ad,0x37b9895,0x2fb5337,0x1f0e2e3,0x14f0224,0x2230b86,
        0x1bc4cf6,0x17cdb09,0x007b5c7 } },
    /* 3 */
    { { 0x2dffea5,0x28f30e7,0x29fce26,0x070df5f,0x235bbfd,0x2f78fbd,
        0x27700d9,0x23d6bc3,0x3471a53,0x0c0e03a,0x05bf9eb,0x276a2ec,
        0x20c3e2e,0x31cc691,0x00dbb93 },
      { 0x126b605,0x2e8983d,0x153737d,0x23bf5e1,0x295d497,0x35ca812,
        0x2d793ae,0x16c6893,0x3777600,0x089a520,0x1e681f8,0x3d55ee6,
        0x154ef99,0x155f592,0x00ae5f9 } },
    /* 4 */
    { { 0x26feef9,0x20315fc,0x1240244,0x250e838,0x3c31a26,0x1cf8af1,
        0x1002c32,0x3b531cd,0x1c53ef1,0x22310ba,0x3f4948e,0x22eafd9,
        0x3863202,0x3d0e2a5,0x006a502 },
      { 0x34536fe,0x04e91ad,0x30ebf5f,0x2af62a7,0x01d218b,0x1c8c9da,
        0x336bcc3,0x23060c3,0x331576e,0x1b14c5e,0x1bbcb76,0x0755e9a,
        0x3d4dcef,0x24c2cf8,0x00917c4 } },
    /* 5 */
    { { 0x349ddd0,0x09b8bb8,0x0250114,0x3e66cbf,0x29f117e,0x3005d29,
        0x36b480e,0x2119bfc,0x2761845,0x253d2f7,0x0580604,0x0bb6db4,
        0x3ca922f,0x1744677,0x008adc7 },
      { 0x3d5a7ce,0x27425ed,0x11e9a61,0x3968d10,0x3874275,0x3692d3b,
        0x03e0470,0x0763d50,0x3d97790,0x3cbaeab,0x2747170,0x18faf3a,
        0x180365e,0x2511fe7,0x0012a36 } },
    /* 6 */
    { { 0x3c52870,0x2701e93,0x296128f,0x120694e,0x1ce0b37,0x3860a36,
        0x10fa180,0x0896b55,0x2f76adb,0x22892ae,0x2e58a34,0x07b4295,
        0x2cb62d1,0x079a522,0x00f3d81 },
      { 0x061ed22,0x2375dd3,0x3c9d861,0x3e602d1,0x10bb747,0x39ae156,
        0x3f796fd,0x087a48a,0x06d680a,0x37f7f47,0x2af2c9d,0x36c55dc,
        0x10f3dc0,0x279b07a,0x00a0937 } },
    /* 7 */
    { { 0x085c629,0x319bbf8,0x089a386,0x184256f,0x15fc2a4,0x00fd2d0,
        0x13d6312,0x363d44d,0x32b7e4b,0x25f2865,0x27df8ce,0x1dce02a,
        0x24ea3b0,0x0e27b9f,0x00d8a90 },
      { 0x3b14461,0x1d371f9,0x0f781bc,0x0503271,0x0dc2cb0,0x13bc284,
        0x34b3a68,0x1ff894a,0x25d2032,0x16f79ba,0x260f961,0x07b10d5,
        0x18173b7,0x2812e2b,0x00eede5 } },
    /* 8 */
    { { 0x13b9a2d,0x132ece2,0x0c5d558,0x02c0214,0x1820c66,0x37cb50f,
        0x26d8267,0x3a00504,0x3f00109,0x33756ee,0x38172f1,0x2e4bb8c,
        0x030d985,0x3e4fcc5,0x00609d4 },
      { 0x2daf9d6,0x16681fa,0x1fb01e0,0x1b03c49,0x370e653,0x183c839,
        0x2207515,0x0ea6b58,0x1ae7aaf,0x3a96522,0x24bae14,0x1c38bd9,
        0x082497b,0x1c05db4,0x000dd03 } },
    /* 9 */
    { { 0x110521f,0x04efa21,0x0c174cc,0x2a7dc93,0x387315b,0x14f7098,
        0x1d83bb3,0x2495ed2,0x2fe0c27,0x1e2d9df,0x093c953,0x0287073,
        0x02c9951,0x336291c,0x0033e30 },
      { 0x208353f,0x3f22748,0x2b2bf0f,0x2373b50,0x10170fa,0x1b8a97d,
        0x0851ed2,0x0b25824,0x055ecb5,0x12049d9,0x3fe1adf,0x11b1385,
        0x28eab06,0x11fac21,0x00513f0 } },
    /* 10 */
    { { 0x35bdf53,0x1847d37,0x1a6dc07,0x29d62c4,0x045d331,0x313b8e5,
        0x165daf1,0x1e34562,0x3e75a58,0x16ea2fa,0x02dd302,0x3302862,
        0x3eb8bae,0x2266a48,0x00cf2a3 },
      { 0x24fd048,0x324a074,0x025df98,0x1662eec,0x3841bfb,0x26ae754,
        0x1df8cec,0x0113ae3,0x0b67fef,0x094e293,0x2323666,0x0ab087c,
        0x2f06509,0x0e142d9,0x00a919d } },
    /* 11 */
    { { 0x1d480d8,0x00ed021,0x3a7d3db,0x1e46ca1,0x28cd9f4,0x2a3ceeb,
        0x24dc754,0x0624a3c,0x0003db4,0x1520bae,0x1c56e0f,0x2fe7ace,
        0x1dc6f38,0x0c826a4,0x008b977 },
      { 0x209cfc2,0x2c16c9c,0x1b70a31,0x21416cb,0x34c49bf,0x186549e,
        0x062498d,0x146e959,0x0391fac,0x08ff944,0x2b4b834,0x013d57a,
        0x2eabffb,0x0370131,0x00c07c1 } },
    /* 12 */
    { { 0x332f048,0x0bf9336,0x16dfad2,0x2451d7b,0x35f23bf,0x299adb2,
        0x0ce0c0a,0x0170294,0x289f034,0x2b7d89e,0x395e2d6,0x1d20df7,
        0x2e64e36,0x16dae90,0x00081c9 },
      { 0x31d6ceb,0x0f80db9,0x0271eba,0x33db1ac,0x1b45bcc,0x1a11c07,
        0x347e630,0x148fd9e,0x142e712,0x3183e3e,0x1cd47ad,0x108d1c9,
        0x09cbb82,0x35e61d9,0x0083027 } },
    /* 13 */
    { { 0x215b0b8,0x0a7a98d,0x2c41b39,0x3f69536,0x0b41441,0x16da8da,
        0x15d556b,0x3c17a26,0x129167e,0x3ea0351,0x2d25a27,0x2f2d285,
        0x15b68f6,0x2931ef5,0x00210d6 },
      { 0x1351130,0x012aec9,0x37ebf38,0x26640f8,0x01d2df6,0x2130972,
        0x201efc0,0x23a457c,0x087a1c6,0x14c68a3,0x163f62a,0x36b494d,
        0x015d481,0x39c35b1,0x005dd6d } },
    /* 14 */
    { { 0x06612ce,0x11c3f61,0x199729f,0x3b36863,0x2986f3e,0x3cd2be1,
        0x04c1612,0x2be2dae,0x00846dd,0x3d7bc29,0x249e795,0x1016803,
        0x37a3714,0x2c5aa8b,0x005f491 },
      { 0x341b38d,0x01eb936,0x3caac7f,0x27863ef,0x1ef7d11,0x1110ec6,
        0x18e0761,0x26498e8,0x01a79a1,0x390d5a1,0x22226fb,0x3d2a473,
        0x0872191,0x1230f32,0x00dc772 } },
    /* 15 */
    { { 0x0b1ec9d,0x03fc6b9,0x3706d57,0x03b9fbb,0x221d23e,0x2867821,
        0x1e40f4c,0x2c9c0f3,0x3c4cd4b,0x31f5948,0x3f13aa6,0x307c1b2,
        0x04b6016,0x116b453,0x005aa72 },
      { 0x0b74de8,0x20519d1,0x134e37f,0x05d882a,0x1839e7a,0x3a2c6a8,
        0x0d14e8d,0x1d78bdd,0x251f30d,0x3a1e27e,0x081c261,0x2c9014b,
        0x165ee09,0x19e0cf1,0x00654e2 } },
    /* 16 */
    { { 0x39fbe67,0x081778b,0x0e44378,0x20dfdca,0x1c4afcb,0x20b803c,
        0x0ec06c6,0x1508f6f,0x1c3114d,0x3bca851,0x3a52463,0x07661d1,
        0x17b0aa0,0x16c5f5c,0x00fc093 },
      { 0x0d01f95,0x0ef13f5,0x2d34965,0x2a25582,0x39aa83e,0x3e38fcf,
        0x3943dca,0x385bbdd,0x210e86f,0x3dc1dd2,0x3f9ffdc,0x18b9bc6,
        0x345c96b,0x0e79621,0x008a72f } },
    /* 17 */
    { { 0x341c342,0x3793688,0x042273a,0x153a9c1,0x3dd326e,0x1d073bc,
        0x2c7d983,0x05524cd,0x00d59e6,0x347abe8,0x3d9a3ef,0x0fb624a,
        0x2c7e4cd,0x09b3171,0x0003faf },
      { 0x045f8ac,0x38bf3cc,0x1e73087,0x0c85d3c,0x314a655,0x382be69,
        0x384f28f,0x24d6cb3,0x2842cdc,0x1777f5e,0x2929c89,0x03c45ed,
        0x3cfcc4c,0x0b59322,0x0035657 } },
    /* 18 */
    { { 0x18c1bba,0x2eb005f,0x33d57ec,0x30e42c3,0x36058f9,0x1865f43,
        0x2116e3f,0x2c4a2bb,0x0684033,0x0f1375c,0x0209b98,0x2136e9b,
        0x1bc4af0,0x0b3e0c7,0x0097c7c },
      { 0x16010e8,0x398777e,0x2a172f4,0x0814a7e,0x0d97e4e,0x274dfc8,
        0x2666606,0x1b5c93b,0x1ed3d36,0x3f3304e,0x13488e0,0x02dbb88,
        0x2d53369,0x3717ce9,0x007cad1 } },
    /* 19 */
    { { 0x257a41f,0x2a6a076,0x39b6660,0x04bb000,0x1e74a04,0x3876b45,
        0x343c6b5,0x0753108,0x3f54668,0x24a13cf,0x23749e8,0x0421fc5,
        0x32f13b5,0x0f31be7,0x00070f2 },
      { 0x1186e14,0x0847697,0x0dff542,0x0dff76c,0x084748f,0x2c7d060,
        0x23aab4d,0x0b43906,0x27ba640,0x1497b59,0x02f5835,0x0a492a4,
        0x0a6892f,0x39f3e91,0x005844e } },
    /* 20 */
    { { 0x33b236f,0x02181cf,0x21dafab,0x0760788,0x019e9d4,0x249ed0a,
        0x36571e3,0x3c7dbcf,0x1337550,0x010d22a,0x285e62f,0x19ee65a,
        0x052bf71,0x1d65fd5,0x0062d43 },
      { 0x2955926,0x3fae7bc,0x0353d85,0x07db7de,0x1440a56,0x328dad6,
        0x1668ec9,0x28058e2,0x1a1a22d,0x1014afc,0x3609325,0x3effdcb,
        0x209f3bd,0x3ca3888,0x0094e50 } },
    /* 21 */
    { { 0x062e8af,0x0b96ccc,0x136990b,0x1d7a28f,0x1a85723,0x0076dec,
        0x21b00b2,0x06a88ff,0x2f0ee65,0x1fa49b7,0x39b10ad,0x10b26fa,
        0x0be7465,0x026e8bf,0x00098e3 },
      { 0x3f1d63f,0x37bacff,0x1374779,0x02882ff,0x323d0e8,0x1da3de5,
        0x12bb3b8,0x0a15a11,0x34d1f95,0x2b3dd6e,0x29ea3fa,0x39ad000,
        0x33a538f,0x390204d,0x0012bd3 } },
    /* 22 */
    { { 0x04cbba5,0x0de0344,0x1d4cc02,0x11fe8d7,0x36207e7,0x32a6da8,
        0x0239281,0x1ec40d7,0x3e89798,0x213fc66,0x0022eee,0x11daefe,
        0x3e74db8,0x28534ee,0x00aa0a4 },
      { 0x07d4543,0x250cc46,0x206620f,0x1c1e7db,0x1321538,0x31fa0b8,
        0x30f74ea,0x01aae0e,0x3a2828f,0x3e9dd22,0x026ef35,0x3c0a62b,
        0x27dbdc5,0x01c23a6,0x000f0c5 } },
    /* 23 */
    { { 0x2f029dd,0x3091337,0x21b80c5,0x21e1419,0x13dabc6,0x3847660,
        0x12b865f,0x36eb666,0x38f6274,0x0ba6006,0x098da24,0x1398c64,
        0x13d08e5,0x246a469,0x009929a },
      { 0x1285887,0x3ff5c8d,0x010237b,0x097c506,0x0bc7594,0x34b9b88,
        0x00cc35f,0x0bb964a,0x00cfbc4,0x29cd718,0x0837619,0x2b4a192,
        0x0c57bb7,0x08c69de,0x00a3627 } },
    /* 24 */
    { { 0x1361ed8,0x266d724,0x366cae7,0x1d5b18c,0x247d71b,0x2c9969a,
        0x0dd5211,0x1edd153,0x25998d7,0x0380856,0x3ab29db,0x09366de,
        0x1e53644,0x2b31ff6,0x008b0ff },
      { 0x3b5d9ef,0x217448d,0x174746d,0x18afea4,0x15b106d,0x3e66e8b,
        0x0479f85,0x13793b4,0x1231d10,0x3c39bce,0x25e8983,0x2a13210,
        0x05a7083,0x382be04,0x00a9507 } },
    /* 25 */
    { { 0x0cf381c,0x1a29b85,0x31ccf6c,0x2f708b8,0x3af9d27,0x2a29732,
        0x168d4da,0x393488d,0x2c0e338,0x3f90c7b,0x0f52ad1,0x2a0a3fa,
        0x2cd80f1,0x15e7a1a,0x00db6a0 },
      { 0x107832a,0x159cb91,0x1289288,0x17e21f9,0x073fc27,0x1584342,
        0x3802780,0x3d6c197,0x154075f,0x16366d1,0x09f712b,0x23a3ec4,
        0x29cf23a,0x3218baf,0x0039f0a } },
    /* 26 */
    { { 0x052edf5,0x2afde13,0x2e53d8f,0x3969626,0x3dcd737,0x1e46ac5,
        0x118bf0d,0x01b2652,0x156bcff,0x16d7ef6,0x1ca46d4,0x34c0cbb,
        0x3e486f6,0x1f85068,0x002cdff },
      { 0x1f47ec8,0x12cee98,0x0608667,0x18fbbe1,0x08a8821,0x31a1fe4,
        0x17c7054,0x3c89e89,0x2edf6cd,0x1b8c32c,0x3f6ea84,0x1319329,
        0x3cd3c2c,0x05f331a,0x00186fa } },
    /* 27 */
    { { 0x1fcb91e,0x0fd4d87,0x358a48a,0x04d91b4,0x083595e,0x044a1e6,
        0x15827b9,0x1d5eaf4,0x2b82187,0x08f3984,0x21bd737,0x0c54285,
        0x2f56887,0x14c2d98,0x00f4684 },
      { 0x01896f6,0x0e542d0,0x2090883,0x269dfcf,0x1e11cb8,0x239fd29,
        0x312cac4,0x19dfacb,0x369f606,0x0cc4f75,0x16579f9,0x33c22cc,
        0x0f22bfd,0x3b251ae,0x006429c } },
    /* 28 */
    { { 0x375f9a4,0x137552e,0x3570498,0x2e4a74e,0x24aef06,0x35b9307,
        0x384ca23,0x3bcd6d7,0x011b083,0x3c93187,0x392ca9f,0x129ce48,
        0x0a800ce,0x145d9cc,0x00865d6 },
      { 0x22b4a2b,0x37f9d9c,0x3e0eca3,0x3e5ec20,0x112c04b,0x2e1ae29,
        0x3ce5b51,0x0f83200,0x32d6a7e,0x10ff1d8,0x081adbe,0x265c30b,
        0x216b1c8,0x0eb4483,0x003cbcd } },
    /* 29 */
    { { 0x030ce93,0x2d331fb,0x20a2fbf,0x1f6dc9c,0x010ed6c,0x1ed5540,
        0x275bf74,0x3df0fb1,0x103333f,0x0241c96,0x1075bfc,0x30e5cf9,
        0x0f31bc7,0x32c01eb,0x00b049e },
      { 0x358839c,0x1dbabd3,0x1e4fb40,0x36a8ac1,0x2101896,0x2d0319b,
        0x2033b0a,0x192e8fd,0x2ebc8d8,0x2867ba7,0x07bf6d2,0x1b3c555,
        0x2477deb,0x198fe09,0x008e5a9 } },
    /* 30 */
    { { 0x3fbd5e1,0x18bf77d,0x2b1d69e,0x151da44,0x338ecfe,0x0768efe,
        0x1a3d56d,0x3c35211,0x10e1c86,0x2012525,0x3bc36ce,0x32b6fe4,
        0x0c8d183,0x15c93f3,0x0041fce },
      { 0x332c144,0x24e70a0,0x246e05f,0x22c21c7,0x2b17f24,0x1ba2bfd,
        0x0534e26,0x318a4f6,0x1dc3b85,0x0c741bc,0x23131b7,0x01a8cba,
        0x364e5db,0x21362cf,0x00f2951 } },
    /* 31 */
    { { 0x2ddc103,0x14ffdcd,0x206fd96,0x0de57bd,0x025f43e,0x381b73a,
        0x2301fcf,0x3bafc27,0x34130b6,0x0216bc8,0x0ff56b2,0x2c4ad4c,
        0x23c6b79,0x1267fa6,0x009b4fb },
      { 0x1d27ac2,0x13e2494,0x1389015,0x38d5b29,0x2d33167,0x3f01969,
        0x28ec1fa,0x1b26de0,0x2587f74,0x1c25668,0x0c44f83,0x23c6f8c,
        0x32fdbb1,0x045f104,0x00a7946 } },
    /* 32 */
    { { 0x23c647b,0x09addd7,0x1348c04,0x0e633c1,0x1bfcbd9,0x1cb034f,
        0x1312e31,0x11cdcc7,0x1e6ee75,0x057d27f,0x2da7ee6,0x154c3c1,
        0x3a5fb89,0x2c2ba2c,0x00cf281 },
      { 0x1b8a543,0x125cd50,0x1d30fd1,0x29cc203,0x341a625,0x14e4233,
        0x3aae076,0x289e38a,0x036ba02,0x230f405,0x3b21b8f,0x34088b9,
        0x01297a0,0x03a75fb,0x00fdc27 } },
    /* 33 */
    { { 0x07f41d6,0x1cf032f,0x1641008,0x0f86deb,0x3d97611,0x0e110fe,
        0x136ff42,0x0b914a9,0x0e241e6,0x180c340,0x1f545fc,0x0ba619d,
        0x1208c53,0x04223a4,0x00cd033 },
      { 0x397612c,0x0132665,0x34e2d1a,0x00bba99,0x1d4393e,0x065d0a8,
        0x2fa69ee,0x1643b55,0x08085f0,0x3774aad,0x08a2243,0x33bf149,
        0x03f41a5,0x1ed950e,0x0048cc6 } },
    /* 34 */
    { { 0x014ab48,0x010c3bf,0x2a744e5,0x13c99c1,0x2195b7f,0x32207fd,
        0x28a228c,0x004f4bf,0x0e2d945,0x2ec6e5a,0x0b92162,0x1aa95e5,
        0x2754a93,0x1adcd93,0x004fb76 },
      { 0x1e1ff7f,0x24ef28c,0x269113f,0x32b393c,0x2696eb5,0x0ac2780,
        0x354bf8a,0x0ffe3fd,0x09ce58e,0x0163c4f,0x1678c0b,0x15cd1bc,
        0x292b3b7,0x036ea19,0x00d5420 } },
    /* 35 */
    { { 0x1da1265,0x0c2ef5b,0x18dd9a0,0x3f3a25c,0x0f7b4f3,0x0d8196e,
        0x24931f9,0x090729a,0x1875f72,0x1ef39cb,0x2577585,0x2ed472d,
        0x136756c,0x20553a6,0x00c7161 },
      { 0x2e32189,0x283de4b,0x00b2e81,0x0989df7,0x3ef2fab,0x1c7d1a7,
        0x24f6feb,0x3e16679,0x233dfda,0x06d1233,0x3e6b5df,0x1707132,
        0x05f7b3f,0x2c00779,0x00fb8df } },
    /* 36 */
    { { 0x15bb921,0x117e9d3,0x267ec73,0x2f934ad,0x25c7e04,0x20b5e8f,
        0x2d3a802,0x2ca911f,0x3f87e47,0x39709dd,0x08488e2,0x2cec400,
        0x35b4589,0x1f0acba,0x009aad7 },
      { 0x2ac34ae,0x06f29f6,0x3326d68,0x3949abe,0x02452e4,0x0687b85,
        0x0879244,0x1eb7832,0x0d4c240,0x31d0ec1,0x3c17a2a,0x17a666f,
        0x01a06cb,0x3e0929c,0x004dca2 } },
    /* 37 */
    { { 0x127bc1a,0x0c72984,0x13be68e,0x26c5fab,0x1a3edd5,0x097d685,
        0x36b645e,0x385799e,0x394a420,0x39d8885,0x0b1e872,0x13f60ed,
        0x2ce1b79,0x3c0ecb7,0x007cab3 },
      { 0x29b3586,0x26fc572,0x0bd7711,0x0913494,0x0a55459,0x31af3c9,
        0x3633eac,0x3e2105c,0x0c2b1b6,0x0e6f4c2,0x047d38c,0x2b81bd5,
        0x1fe1c3b,0x04d7cd0,0x0054dcc } },
    /* 38 */
    { { 0x03caf0d,0x0d66365,0x313356d,0x2a4897f,0x2ce044e,0x18feb7a,
        0x1f6a7c5,0x3709e7b,0x14473e8,0x2d8cbae,0x3190dca,0x12d19f8,
        0x31e3181,0x3cc5b6e,0x002d4f4 },
      { 0x143b7ca,0x2604728,0x39508d6,0x0cb79f3,0x24ec1ac,0x1ed7fa0,
        0x3ab5fd3,0x3c76488,0x2e49390,0x03a0985,0x3580461,0x3fd2c81,
        0x308f0ab,0x38561d6,0x0011b9b } },
    /* 39 */
    { { 0x3be682c,0x0c68f4e,0x32dd4ae,0x099d3bb,0x0bc7c5d,0x311f750,
        0x2fd10a3,0x2e7864a,0x23bc14a,0x13b1f82,0x32e495e,0x1b0f746,
        0x3cd856a,0x17a4c26,0x00085ee },
      { 0x02e67fd,0x06a4223,0x2af2f38,0x2038987,0x132083a,0x1b7bb85,
        0x0d6a499,0x131e43f,0x3035e52,0x278ee3e,0x1d5b08b,0x30d8364,
        0x2719f8d,0x0b21fc9,0x003a06e } },
    /* 40 */
    { { 0x237cac0,0x27d6a1c,0x27945cd,0x2750d61,0x293f0b5,0x253db13,
        0x04a764e,0x20b4d0e,0x12bb627,0x160c13b,0x0de0601,0x236e2cf,
        0x2190f0b,0x354d76f,0x004336d },
      { 0x2ab473a,0x10d54e4,0x1046574,0x1d6f97b,0x0031c72,0x06426a9,
        0x38678c2,0x0b76cf9,0x04f9920,0x152adf8,0x2977e63,0x1234819,
        0x198be26,0x061024c,0x00d427d } },
    /* 41 */
    { { 0x39b5a31,0x2123d43,0x362a822,0x1a2eab6,0x0bb0034,0x0d5d567,
        0x3a04723,0x3a10c8c,0x08079ae,0x0d27bda,0x2eb9e1e,0x2619e82,
        0x39a55a8,0x0c6c7db,0x00c1519 },
      { 0x174251e,0x13ac2eb,0x295ed26,0x18d2afc,0x037b9b2,0x1258344,
        0x00921b0,0x1f702d8,0x1bc4da7,0x1c3794f,0x12b1869,0x366eacf,
        0x16ddf01,0x31ebdc5,0x00ad54e } },
    /* 42 */
    { { 0x1efdc58,0x1370d5e,0x0ddb8e7,0x1a53fda,0x1456bd3,0x0c825a9,
        0x0e74ccd,0x20f41c9,0x3423867,0x139073f,0x3c70d8a,0x131fc85,
        0x219a2a0,0x34bf986,0x0041199 },
      { 0x1c05dd2,0x268f80a,0x3da9d38,0x1af9f8f,0x0535f2a,0x30ad37e,
        0x2cf72d7,0x14a509b,0x1f4fe74,0x259e09d,0x1d23f51,0x0672732,
        0x08fc463,0x00b6201,0x001e05a } },
    /* 43 */
    { { 0x0d5ffe8,0x3238bb5,0x17f275c,0x25b6fa8,0x2f8bb48,0x3b8f2d2,
        0x059790c,0x18594d4,0x285a47c,0x3d301bb,0x12935d2,0x23ffc96,
        0x3d7c7f9,0x15c8cbf,0x0034c4a },
      { 0x20376a2,0x05201ba,0x1e02c4b,0x1413c45,0x02ea5e7,0x39575f0,
        0x2d76e21,0x113694c,0x011f310,0x0da3725,0x31b7799,0x1cb9195,
        0x0cfd592,0x22ee4ea,0x00adaa3 } },
    /* 44 */
    { { 0x14ed72a,0x031c49f,0x39a34bf,0x192e87d,0x0da0e92,0x130e7a9,
        0x00258bf,0x144e123,0x2d82a71,0x0294e53,0x3f06c66,0x3d4473a,
        0x037cd4a,0x3bbfb17,0x00fcebc },
      { 0x39ae8c1,0x2dd6a9d,0x206ef23,0x332b479,0x2deff59,0x09d5720,
        0x3526fd2,0x33bf7cf,0x344bb32,0x359316a,0x115bdef,0x1b8468a,
        0x3813ea9,0x11a8450,0x00ab197 } },
    /* 45 */
    { { 0x0837d7d,0x1e1617b,0x0ba443c,0x2f2e3b8,0x2ca5b6f,0x176ed7b,
        0x2924d9d,0x07294d3,0x104bb4f,0x1cfd3e8,0x398640f,0x1162dc8,
        0x007ea15,0x2aa75fd,0x004231f },
      { 0x16e6896,0x01987be,0x0f9d53e,0x1a740ec,0x1554e4c,0x31e1634,
        0x3cb07b9,0x013eb53,0x39352cb,0x1dfa549,0x0974e7f,0x17c55d2,
        0x157c85f,0x1561adb,0x002e3fa } },
    /* 46 */
    { { 0x29951a8,0x35200da,0x2ad042c,0x22109e4,0x3a8b15b,0x2eca69c,
        0x28bcf9a,0x0cfa063,0x0924099,0x12ff668,0x2fb88dc,0x028d653,
        0x2445876,0x218d01c,0x0014418 },
      { 0x1caedc7,0x295bba6,0x01c9162,0x3364744,0x28fb12e,0x24c80b6,
        0x2719673,0x35e5ba9,0x04aa4cc,0x206ab23,0x1cf185a,0x2c140d8,
        0x1095a7d,0x1b3633f,0x000c9f8 } },
    /* 47 */
    { { 0x0b2a556,0x0a051c4,0x30b29a7,0x190c9ed,0x3767ca9,0x38de66d,
        0x2d9e125,0x3aca813,0x2dc22a3,0x319e074,0x0d9450a,0x3445bac,
        0x3e08a5b,0x07f29fa,0x00eccac },
      { 0x02d6e94,0x21113f7,0x321bde6,0x0a4d7b3,0x03621f4,0x2780e8b,
        0x22d5432,0x1fc2853,0x0d57d3e,0x254f90b,0x33ed00b,0x289b025,
        0x12272bb,0x30e715f,0x0000297 } },
    /* 48 */
    { { 0x0243a7d,0x2aac42e,0x0c5b3aa,0x0fa3e96,0x06eeef9,0x2b9fdd9,
        0x26fca39,0x0134fe1,0x22661ab,0x1990416,0x03945d6,0x15e3628,
        0x3848ca3,0x0f91e46,0x00b08cd },
      { 0x16d2411,0x3717e1d,0x128c45e,0x3669d54,0x0d4a790,0x2797da8,
        0x0f09634,0x2faab0b,0x27df649,0x3b19b49,0x0467039,0x39b65a2,
        0x3816f3c,0x31ad0bd,0x0050046 } },
    /* 49 */
    { { 0x2425043,0x3858099,0x389092a,0x3f7c236,0x11ff66a,0x3c58b39,
        0x2f5a7f8,0x1663ce1,0x2a0fcf5,0x38634b7,0x1a8ca18,0x0dcace8,
        0x0e6f778,0x03ae334,0x00df0d2 },
      { 0x1bb4045,0x357875d,0x14b77ed,0x33ae5b6,0x2252a47,0x31899dd,
        0x3293582,0x040c6f6,0x14340dd,0x3614f0e,0x3d5f47f,0x326fb3d,
        0x0044a9d,0x00beeb9,0x0027c23 } },
    /* 50 */
    { { 0x32d49ce,0x34822a3,0x30a22d1,0x00858b7,0x10d91aa,0x2681fd9,
        0x1cce870,0x2404a71,0x38b8433,0x377c1c8,0x019442c,0x0a38b21,
        0x22aba50,0x0d61c81,0x002dcbd },
      { 0x0680967,0x2f0f2f9,0x172cb5f,0x1167e4b,0x12a7bc6,0x05b0da7,
        0x2c76e11,0x3a36201,0x37a3177,0x1d71419,0x0569df5,0x0dce7ad,
        0x3f40b75,0x3bd8db0,0x002d481 } },
    /* 51 */
    { { 0x2a1103e,0x34e7f7f,0x1b171a2,0x24a57e0,0x2eaae55,0x166c992,
        0x10aa18f,0x0bb836f,0x01acb59,0x0e430e7,0x1750cca,0x18be036,
        0x3cc6cdf,0x0a0f7e5,0x00da4d8 },
      { 0x2201067,0x374d187,0x1f6b0a6,0x165a7ec,0x31531f8,0x3580487,
        0x15e5521,0x0724522,0x2b04c04,0x202c86a,0x3cc1ccf,0x225b11a,
        0x1bde79d,0x0eccc50,0x00d24da } },
    /* 52 */
    { { 0x3b0a354,0x2814dd4,0x1cd8575,0x3d031b7,0x0392ff2,0x1855ee5,
        0x0e8cff5,0x203442e,0x3bd3b1b,0x141cf95,0x3fedee1,0x1d783c0,
        0x26f192a,0x0392aa3,0x0075238 },
      { 0x158ffe9,0x3889f19,0x14151f4,0x06067b1,0x13a3486,0x1e65c21,
        0x382d5ef,0x1ab0aac,0x2ffddc4,0x3179b7a,0x3c8d094,0x05101e3,
        0x237c6e5,0x3947d83,0x00f674f } },
    /* 53 */
    { { 0x363408f,0x21eb96b,0x27376fb,0x2a735d6,0x1a39c36,0x3d31863,
        0x33313fc,0x32235e0,0x082f034,0x23ef351,0x39b3528,0x1a69d84,
        0x1d9c944,0x07159ad,0x0077a71 },
      { 0x04f8d65,0x25771e5,0x2ba84a6,0x194586a,0x1e6da5f,0x118059a,
        0x14e9c32,0x1d24619,0x3f528ae,0x22f22e4,0x0f5580d,0x0747a0e,
        0x32cc85f,0x286b3a8,0x008ccf9 } },
    /* 54 */
    { { 0x196fee2,0x2c4431c,0x094528a,0x18e1d32,0x175799d,0x26bb6b7,
        0x2293482,0x23fd289,0x07b2be8,0x1a5c533,0x158d60d,0x04a4f3f,
        0x164e9f7,0x32ccca9,0x00da6b6 },
      { 0x1d821c2,0x3f76c4f,0x323df43,0x17e4374,0x0f2f278,0x121227e,
        0x2464190,0x19d2644,0x326d24c,0x3185983,0x0803c15,0x0767a33,
        0x1c4c996,0x0563eab,0x00631c6 } },
    /* 55 */
    { { 0x1752366,0x0baf83f,0x288bacf,0x0384e6f,0x2b93c34,0x3c805e7,
        0x3664850,0x29e1663,0x254ff1d,0x3852080,0x0f85c16,0x1e389d9,
        0x3191352,0x3915eaa,0x00a246e },
      { 0x3763b33,0x187ad14,0x3c0d438,0x3f11702,0x1c49f03,0x35ac7a8,
        0x3f16bca,0x27266bf,0x08b6fd4,0x0f38ce4,0x37fde8c,0x147a6ff,
        0x02c5e5c,0x28e7fc5,0x00076a7 } },
    /* 56 */
    { { 0x2338d10,0x0e77fa7,0x011b046,0x1bfd0ad,0x28ee699,0x21d73bc,
        0x0461d1a,0x342ea58,0x2d695b4,0x30415ed,0x2906e0b,0x18e494a,
        0x20f8a27,0x026b870,0x002c19f },
      { 0x2f4c43d,0x3f0fc3b,0x0aa95b8,0x2a01ea1,0x3e2e1b1,0x0d74af6,
        0x0555288,0x0cb757d,0x24d2071,0x143d2bb,0x3907f67,0x3e0ce30,
        0x131f0e9,0x3724381,0x007a874 } },
    /* 57 */
    { { 0x3c27050,0x08b5165,0x0bf884b,0x3dd679c,0x3bd0b8d,0x25ce2e6,
        0x1674057,0x1f13ed3,0x1f5cd91,0x0d1fd35,0x13ce6e3,0x2671338,
        0x10f8b90,0x34e5487,0x00942bf },
      { 0x03b566d,0x23c3da9,0x37de502,0x1a486ff,0x1af6e86,0x1108cb3,
        0x36f856c,0x01a6a0f,0x179f915,0x1595a01,0x2cfecb8,0x082568b,
        0x1ba16d1,0x1abb6c0,0x00cf7f0 } },
    /* 58 */
    { { 0x2f96c80,0x1b8f123,0x209c0f5,0x2ccf76d,0x1d521f2,0x3705143,
        0x2941027,0x07f88af,0x07102a9,0x38b4868,0x1efa37d,0x1bdd3e8,
        0x028a12e,0x02e055b,0x009a9a9 },
      { 0x1c7dfcb,0x3aa7aa7,0x1d62c54,0x3f0b0b0,0x3c74e66,0x274f819,
        0x23f9674,0x0e2b67c,0x24654dd,0x0c71f0e,0x1946cee,0x0016211,
        0x0045dc7,0x0da1173,0x0089856 } },
    /* 59 */
    { { 0x0e73946,0x29f353f,0x056329d,0x2d48c5a,0x28f697d,0x2ea4bb1,
        0x235e9cc,0x34faa38,0x15f9f91,0x3557519,0x2a50a6c,0x1a27c8e,
        0x2a1a0f3,0x3098879,0x00dcf21 },
      { 0x1b818bf,0x2f20b98,0x2243cff,0x25b691e,0x3c74a2f,0x2f06833,
        0x0e980a8,0x32db48d,0x2b57929,0x33cd7f5,0x2fe17d6,0x11a384b,
        0x2dafb81,0x2b9562c,0x00ddea6 } },
    /* 60 */
    { { 0x2787b2e,0x37a21df,0x310d294,0x07ce6a4,0x1258acc,0x3050997,
        0x19714aa,0x122824b,0x11c708b,0x0462d56,0x21abbf7,0x331aec3,
        0x307b927,0x3e8d5a0,0x00c0581 },
      { 0x24d4d58,0x3d628fc,0x23279e0,0x2e38338,0x2febe9b,0x346f9c0,
        0x3d6a419,0x3264e47,0x245faca,0x3669f62,0x1e50d66,0x3028232,
        0x18201ab,0x0bdc192,0x0002c34 } },
    /* 61 */
    { { 0x17bdbc2,0x1c501c5,0x1605ccd,0x31ab438,0x372fa89,0x24a8057,
        0x13da2bb,0x3f95ac7,0x3cda0a3,0x1e2b679,0x24f0673,0x03b72f4,
        0x35be616,0x2ccd849,0x0079d4d },
      { 0x33497c4,0x0c7f657,0x2fb0d3d,0x3b81064,0x38cafea,0x0e942bc,
        0x3ca7451,0x2ab9784,0x1678c85,0x3c62098,0x1eb556f,0x01b3aa2,
        0x149f3ce,0x2656f6d,0x002eef1 } },
    /* 62 */
    { { 0x0596edc,0x1f4fad4,0x03a28ed,0x18a4149,0x3aa3593,0x12db40a,
        0x12c2c2a,0x3b1a288,0x327c4fb,0x35847f5,0x384f733,0x02e3fde,
        0x1af0e8a,0x2e417c3,0x00d85a6 },
      { 0x0091cf7,0x2267d75,0x276860e,0x19cbbfc,0x04fef2b,0x030ce59,
        0x3195cb1,0x1aa3f07,0x3699362,0x2a09d74,0x0d6c840,0x1e413d0,
        0x28acdc7,0x1ff5ea1,0x0088d8b } },
    /* 63 */
    { { 0x3d98425,0x08dc8de,0x154e85f,0x24b1c2c,0x2d44639,0x19a1e8b,
        0x300ee29,0x053f72e,0x3f7c832,0x12417f6,0x1359368,0x0674a4c,
        0x1218e20,0x0e4fbd4,0x000428c },
      { 0x01e909a,0x1d88fe6,0x12da40c,0x215ef86,0x2925133,0x004241f,
        0x3e480f4,0x2d16523,0x07c3120,0x3375e86,0x21fd8f3,0x35dc0b6,
        0x0efc5c9,0x14ef8d6,0x0066e47 } },
    /* 64 */
    { { 0x2973cf4,0x34d3845,0x34f7070,0x22df93c,0x120aee0,0x3ae2b4a,
        0x1af9b95,0x177689a,0x036a6a4,0x0377828,0x23df41e,0x22d4a39,
        0x0df2aa1,0x06ca898,0x0003cc7 },
      { 0x06b1dd7,0x19dc2a8,0x35d324a,0x0467499,0x25bfa9c,0x1a1110c,
        0x01e2a19,0x1b3c1cf,0x18d131a,0x10d9815,0x2ee7945,0x0a2720c,
        0x0ddcdb0,0x2c071b6,0x00a6aef } },
    /* 65 */
    { { 0x1ab5245,0x1192d00,0x13ffba1,0x1b71236,0x09b8d0b,0x0eb49cb,
        0x1867dc9,0x371de4e,0x05eae9f,0x36faf82,0x094ea8b,0x2b9440e,
        0x022e173,0x2268e6b,0x00740fc },
      { 0x0e23b23,0x22c28ca,0x04d05e2,0x0bb84c4,0x1235272,0x0289903,
        0x267a18b,0x0df0fd1,0x32e49bb,0x2ab1d29,0x281e183,0x3dcd3c3,
        0x1c0eb79,0x2db0ff6,0x00bffe5 } },
    /* 66 */
    { { 0x2a2123f,0x0d63d71,0x1f6db1a,0x257f8a3,0x1927b2d,0x06674be,
        0x302753f,0x20b7225,0x14c1a3f,0x0429cdd,0x377affe,0x0f40a75,
        0x2d34d06,0x05fb6b9,0x0054398 },
      { 0x38b83c4,0x1e7bbda,0x1682f79,0x0527651,0x2615cb2,0x1795fab,
        0x0e4facc,0x11f763c,0x1b81130,0x2010ae2,0x13f3650,0x20d5b72,
        0x1f32f88,0x34617f4,0x00bf008 } },
    /* 67 */
    { { 0x28068db,0x0aa8913,0x1a47801,0x10695ca,0x1c72cc6,0x0fc1a47,
        0x33df2c4,0x0517cf0,0x3471d92,0x1be815c,0x397f794,0x3f03cbe,
        0x121bfae,0x172cbe0,0x00813d7 },
      { 0x383bba6,0x04f1c90,0x0b3f056,0x1c29089,0x2a924ce,0x3c85e69,
        0x1cecbe5,0x0ad8796,0x0aa79f6,0x25e38ba,0x13ad807,0x30b30ed,
        0x0fa963a,0x35c763d,0x0055518 } },
    /* 68 */
    { { 0x0623f3b,0x3ca4880,0x2bff03c,0x0457ca7,0x3095c71,0x02a9a08,
        0x1722478,0x302c10b,0x3a17458,0x001131e,0x0959ec2,0x18bdfbc,
        0x2929fca,0x2adfe32,0x0040ae2 },
      { 0x127b102,0x14ddeaa,0x1771b8c,0x283700c,0x2398a86,0x085a901,
        0x108f9dc,0x0cc0012,0x33a918d,0x26d08e9,0x20b9473,0x12c3fc7,
        0x1f69763,0x1c94b5a,0x00e29de } },
    /* 69 */
    { { 0x035af04,0x3450021,0x12da744,0x077fb06,0x25f255b,0x0db7150,
        0x17dc123,0x1a2a07c,0x2a7636a,0x3972430,0x3704ca1,0x0327add,
        0x3d65a96,0x3c79bec,0x009de8c },
      { 0x11d3d06,0x3fb8354,0x12c7c60,0x04fe7ad,0x0466e23,0x01ac245,
        0x3c0f5f2,0x2a935d0,0x3ac2191,0x090bd56,0x3febdbc,0x3f1f23f,
        0x0ed1cce,0x02079ba,0x00d4fa6 } },
    /* 70 */
    { { 0x0ab9645,0x10174ec,0x3711b5e,0x26357c7,0x2aeec7f,0x2170a9b,
        0x1423115,0x1a5122b,0x39e512c,0x18116b2,0x290db1c,0x041b13a,
        0x26563ae,0x0f56263,0x00b89f3 },
      { 0x3ed2ce4,0x01f365f,0x1b2043b,0x05f7605,0x1f9934e,0x2a068d2,
        0x38d4d50,0x201859d,0x2de5291,0x0a7985a,0x17e6711,0x01b6c1b,
        0x08091fa,0x33c6212,0x001da23 } },
    /* 71 */
    { { 0x2f2c4b5,0x311acd0,0x1e47821,0x3bd9816,0x1931513,0x1bd4334,
        0x30ae436,0x2c49dc0,0x2c943e7,0x010ed4d,0x1fca536,0x189633d,
        0x17abf00,0x39e5ad5,0x00e4e3e },
      { 0x0c8b22f,0x2ce4009,0x1054bb6,0x307f2fc,0x32eb5e2,0x19d24ab,
        0x3b18c95,0x0e55e4d,0x2e4acf5,0x1bc250c,0x1dbf3a5,0x17d6a74,
        0x087cf58,0x07f6f82,0x00f8675 } },
    /* 72 */
    { { 0x110e0b2,0x0e672e7,0x11b7157,0x1598371,0x01c0d59,0x3d60c24,
        0x096b8a1,0x0121075,0x0268859,0x219962f,0x03213f2,0x3022adc,
        0x18de488,0x3dcdeb9,0x008d2e0 },
      { 0x06cfee6,0x26f2552,0x3c579b7,0x31fa796,0x2036a26,0x362ba5e,
        0x103601c,0x012506b,0x387ff3a,0x101a41f,0x2c7eb58,0x23d2efc,
        0x10a5a07,0x2fd5fa3,0x00e3731 } },
    /* 73 */
    { { 0x1cd0abe,0x08a0af8,0x2fa272f,0x17a1fbf,0x1d4f901,0x30e0d2f,
        0x1898066,0x273b674,0x0c1b8a2,0x3272337,0x3ee82eb,0x006e7d3,
        0x2a75606,0x0af1c81,0x0037105 },
      { 0x2f32562,0x2842491,0x1bb476f,0x1305cd4,0x1daad53,0x0d8daed,
        0x164c37b,0x138030f,0x05145d5,0x300e2a3,0x32c09e7,0x0798600,
        0x3515130,0x2b9e55c,0x009764e } },
    /* 74 */
    { { 0x3d5256a,0x06c67f2,0x3a3b879,0x3c9b284,0x04007e0,0x33c1a41,
        0x3794604,0x1d6240e,0x022b6c1,0x22c62a7,0x01d4590,0x32df5f6,
        0x368f1a1,0x2a7486e,0x006e13f },
      { 0x31e6e16,0x20f18a9,0x09ed471,0x23b861d,0x15cf0ef,0x397b502,
        0x1c7f9b2,0x05f84b2,0x2cce6e1,0x3c10bba,0x13fb5a7,0x1b52058,
        0x1feb1b8,0x03b7279,0x00ea1cf } },
    /* 75 */
    { { 0x2a4cc9b,0x15cf273,0x08f36e6,0x076bf3b,0x2541796,0x10e2dbd,
        0x0bf02aa,0x3aa2201,0x03cdcd4,0x3ee252c,0x3799571,0x3e01fa4,
        0x156e8d0,0x1fd6188,0x003466a },
      { 0x2515664,0x166b355,0x2b0b51e,0x0f28f17,0x355b0f9,0x2909e76,
        0x206b026,0x3823a12,0x179c5fa,0x0972141,0x2663a1a,0x01ee36e,
        0x3fc8dcf,0x2ef3d1b,0x0049a36 } },
    /* 76 */
    { { 0x2d93106,0x3d6b311,0x3c9ce47,0x382aa25,0x265b7ad,0x0b5f92f,
        0x0f4c941,0x32aa4df,0x380d4b2,0x0e8aba6,0x260357a,0x1f38273,
        0x0d5f95e,0x199f23b,0x0029f77 },
      { 0x0a0b1c5,0x21a3d6a,0x0ad8df6,0x33d8a5e,0x1240858,0x30000a8,
        0x3ac101d,0x2a8143d,0x1d7ffe9,0x1c74a2a,0x1b962c9,0x1261359,
        0x0c8b274,0x002cf4a,0x00a8a7c } },
    /* 77 */
    { { 0x211a338,0x22a14ab,0x16e77c5,0x3c746be,0x3a78613,0x0d5731c,
        0x1767d25,0x0b799fa,0x009792a,0x09ae8dc,0x124386b,0x183d860,
        0x176747d,0x14c4445,0x00ab09b },
      { 0x0eb9dd0,0x0121066,0x032895a,0x330541c,0x1e6c17a,0x2271b92,
        0x06da454,0x054c2bf,0x20abb21,0x0ead169,0x3d7ea93,0x2359649,
        0x242c6c5,0x3194255,0x00a3ef3 } },
    /* 78 */
    { { 0x3010879,0x1083a77,0x217989d,0x174e55d,0x29d2525,0x0e544ed,
        0x1efd50e,0x30c4e73,0x05bd5d1,0x0793bf9,0x3f7af77,0x052779c,
        0x2b06bc0,0x13d0d02,0x0055a6b },
      { 0x3eaf771,0x094947a,0x0288f13,0x0a21e35,0x22ab441,0x23816bf,
        0x15832e1,0x2d8aff3,0x348cc1f,0x2bbd4a8,0x01c4792,0x34209d3,
        0x06dc72b,0x211a1df,0x00345c5 } },
    /* 79 */
    { { 0x2a65e90,0x173ac2f,0x199cde1,0x0ac905b,0x00987f7,0x3618f7b,
        0x1b578df,0x0d5e113,0x34bac6a,0x27d85ed,0x1b48e99,0x18af5eb,
        0x1a1be9e,0x3987aac,0x00877ca },
      { 0x2358610,0x3776a8e,0x2b0723a,0x344c978,0x22fc4d6,0x1615d53,
        0x3198f51,0x2d61225,0x12cb392,0x07dd061,0x355f7de,0x09e0132,
        0x0efae99,0x13b46aa,0x00e9e6c } },
    /* 80 */
    { { 0x0683186,0x36d8e66,0x0ea9867,0x0937731,0x1fb5cf4,0x13c39ef,
        0x1a7ffed,0x27dfb32,0x31c7a77,0x09f15fd,0x16b25ef,0x1dd01e7,
        0x0168090,0x240ed02,0x0090eae },
      { 0x2e1fceb,0x2ab9783,0x1a1fdf2,0x093a1b0,0x33ff1da,0x2864fb7,
        0x3587d6c,0x275aa03,0x123dc9b,0x0e95a55,0x0592030,0x2102402,
        0x1bdef7b,0x37f2e9b,0x001efa4 } },
    /* 81 */
    { { 0x0540015,0x20e3e78,0x37dcfbd,0x11b0e41,0x02c3239,0x3586449,
        0x1fb9e6a,0x0baa22c,0x00c0ca6,0x3e58491,0x2dbe00f,0x366d4b0,
        0x176439a,0x2a86b86,0x00f52ab },
      { 0x0ac32ad,0x226250b,0x0f91d0e,0x1098aa6,0x3dfb79e,0x1dbd572,
        0x052ecf2,0x0f84995,0x0d27ad2,0x036c6b0,0x1e4986f,0x2317dab,
        0x2327df6,0x0dee0b3,0x00389ac } },
    /* 82 */
    { { 0x0e60f5b,0x0622d3e,0x2ada511,0x05522a8,0x27fe670,0x206af28,
        0x333cb83,0x3f25f6c,0x19ddaf3,0x0ec579b,0x36aabc0,0x093dbac,
        0x348b44b,0x277dca9,0x00c5978 },
      { 0x1cf5279,0x32e294a,0x1a6c26f,0x3f006b6,0x37a3c6b,0x2e2eb26,
        0x2cf88d4,0x3410619,0x1899c80,0x23d3226,0x30add14,0x2810905,
        0x01a41f0,0x11e5176,0x005a02f } },
    /* 83 */
    { { 0x1c90202,0x321df30,0x3570fa5,0x103e2b1,0x3d099d4,0x05e207d,
        0x0a5b1bd,0x0075d0a,0x3db5b25,0x2d87899,0x32e4465,0x226fc13,
        0x24cb8f8,0x3821daa,0x004da3a },
      { 0x3e66861,0x03f89b8,0x386d3ef,0x14ccc62,0x35e7729,0x11ce5b7,
        0x035fbc7,0x3f4df0f,0x29c439f,0x1144568,0x32d7037,0x312f65e,
        0x06b9dbf,0x03a9589,0x0008863 } },
    /* 84 */
    { { 0x0a9e8c9,0x1a19b6e,0x091ecd9,0x2e16ee0,0x2a11963,0x116cf34,
        0x390d530,0x194131f,0x2b580f3,0x31d569c,0x21d3751,0x3e2ce64,
        0x193de46,0x32454f0,0x004bffd },
      { 0x09554e7,0x170126e,0x2be6cd1,0x153de89,0x0353c67,0x350765c,
        0x202370b,0x1db01e5,0x30b12b1,0x3778591,0x00c8809,0x2e845d5,
        0x1fb1e56,0x170f90d,0x00e2db3 } },
    /* 85 */
    { { 0x328e33f,0x392aad8,0x36d1d71,0x0aebe04,0x1548678,0x1b55c8c,
        0x24995f8,0x2a5a01e,0x1bd1651,0x37c7c29,0x36803b6,0x3716c91,
        0x1a935a5,0x32f10b7,0x005c587 },
      { 0x2e8b4c0,0x336ccae,0x11382b6,0x22ec4cc,0x066d159,0x35fa585,
        0x23b2d25,0x3017528,0x2a674a8,0x3a4f900,0x1a7ce82,0x2b2539b,
        0x3d46545,0x0a07918,0x00eb9f8 } },
    /* 86 */
    { { 0x2cf5b9b,0x03e747f,0x166a34e,0x0afc81a,0x0a115b1,0x3aa814d,
        0x11cf3b1,0x163e556,0x3cbfb15,0x157c0a4,0x1bc703a,0x2141e90,
        0x01f811c,0x207218b,0x0092e6b },
      { 0x1af24e3,0x3af19b3,0x3c70cc9,0x335cbf3,0x068917e,0x055ee92,
        0x09a9308,0x2cac9b7,0x008b06a,0x1175097,0x36e929c,0x0be339c,
        0x0932436,0x15f18ba,0x0009f6f } },
    /* 87 */
    { { 0x29375fb,0x35ade34,0x11571c7,0x07b8d74,0x3fabd85,0x090fa91,
        0x362dcd4,0x02c3fdb,0x0608fe3,0x2477649,0x3fc6e70,0x059b7eb,
        0x1e6a708,0x1a4c220,0x00c6c4c },
      { 0x2a53fb0,0x1a3e1f5,0x11f9203,0x27e7ad3,0x038718e,0x3f5f9e4,
        0x308acda,0x0a8700f,0x34472fe,0x3420d7a,0x08076e5,0x014240e,
        0x0e7317e,0x197a98e,0x00538f7 } },
    /* 88 */
    { { 0x2663b4b,0x0927670,0x38dd0e0,0x16d1f34,0x3e700ab,0x3119567,
        0x12559d2,0x399b6c6,0x0a84bcd,0x163e7dd,0x3e2aced,0x058548c,
        0x03a5bad,0x011cf74,0x00c155c },
      { 0x3e454eb,0x2a1e64e,0x1ccd346,0x36e0edf,0x266ee94,0x2e74aaf,
        0x2d8378a,0x3cd547d,0x1d27733,0x0928e5b,0x353553c,0x26f502b,
        0x1d94341,0x2635cc7,0x00d0ead } },
    /* 89 */
    { { 0x0142408,0x382c3bb,0x3310908,0x2e50452,0x398943c,0x1d0ac75,
        0x1bf7d81,0x04bd00f,0x36b6934,0x3349c37,0x0f69e20,0x0195252,
        0x243a1c5,0x030da5f,0x00a76a9 },
      { 0x224825a,0x28ce111,0x34c2e0f,0x02e2b30,0x382e48c,0x26853ca,
        0x24bd14e,0x0200dec,0x1e24db3,0x0d3d775,0x132da0a,0x1dea79e,
        0x253dc0c,0x03c9d31,0x0020db9 } },
    /* 90 */
    { { 0x26c5fd9,0x05e6dc3,0x2eea261,0x08db260,0x2f8bec1,0x1255edf,
        0x283338d,0x3d9a91d,0x2640a72,0x03311f9,0x1bad935,0x152fda8,
        0x0e95abd,0x31abd15,0x00dfbf4 },
      { 0x107f4fa,0x29ebe9a,0x27353f7,0x3821972,0x27311fa,0x2925ab6,
        0x337ab82,0x2de6c91,0x1f115fe,0x044f909,0x21b93c2,0x3a5f142,
        0x13eb5e9,0x3ab1377,0x00b26b6 } },
    /* 91 */
    { { 0x22e5f2b,0x2ae7d4a,0x1ac481c,0x0a6fce1,0x2f93caf,0x242658e,
        0x3f35c3c,0x050f3d2,0x30074c9,0x142079c,0x0281b4c,0x295fea3,
        0x007413e,0x01726cd,0x00e4979 },
      { 0x1ab3cfb,0x1b76295,0x36adf55,0x1ad4636,0x1d444b9,0x3bd2e55,
        0x35425a5,0x1aa8cd3,0x3acecd2,0x1f769e8,0x1a655e9,0x1f6846f,
        0x24c70b5,0x3bff080,0x0002da3 } },
    /* 92 */
    { { 0x081d0d9,0x2c00d99,0x1fe2e24,0x396063f,0x03740db,0x243f680,
        0x3c1f451,0x1ff7b07,0x2803cf2,0x38ca724,0x2934f43,0x0d72d4d,
        0x0e8fe74,0x2975e21,0x002b505 },
      { 0x11adcc9,0x331a99c,0x21e16cf,0x1714c78,0x1f03432,0x2caa2a6,
        0x34a9679,0x2f7fe8b,0x0423c21,0x1a757ce,0x31b57d6,0x171e044,
        0x093b9b2,0x13602e0,0x00db534 } },
    /* 93 */
    { { 0x250a2f5,0x0b999eb,0x21d10d7,0x22b92a1,0x39b7f8d,0x0c37c72,
        0x29f70f3,0x3bf0e84,0x1d7e04f,0x07a42a9,0x272c3ae,0x1587b2f,
        0x155faff,0x10a336e,0x000d8fb },
      { 0x3663784,0x0d7dcf5,0x056ad22,0x319f8b1,0x0c05bae,0x2b6ff33,
        0x0292e42,0x0435797,0x188efb1,0x0d3f45e,0x119d49f,0x395dcd3,
        0x279fe27,0x133a13d,0x00188ac } },
    /* 94 */
    { { 0x396c53e,0x0d133e9,0x009b7ee,0x13421a0,0x1bbf607,0x1d284a5,
        0x1594f74,0x18cb47c,0x2dcac11,0x2999ddb,0x04e2fa5,0x1889e2c,
        0x0a89a18,0x33cb215,0x0052665 },
      { 0x104ab58,0x1d91920,0x3d6d7e3,0x04dc813,0x1167759,0x13a8466,
        0x0a06a54,0x103761b,0x25b1c92,0x26a8fdd,0x2474614,0x21406a4,
        0x251d75f,0x38c3734,0x007b982 } },
    /* 95 */
    { { 0x15f3060,0x3a7bf30,0x3be6e44,0x0baa1fa,0x05ad62f,0x1e54035,
        0x099d41c,0x2a744d9,0x1c0336f,0x3e99b5b,0x1afd3b1,0x2bf1255,
        0x1822bf8,0x2c93972,0x001d8cc },
      { 0x1d7584b,0x0508ade,0x20dd403,0x203a8fc,0x1c54a05,0x1611a31,
        0x037c8f9,0x1dcd4fe,0x110fbea,0x30f60bc,0x3dffe2f,0x26a1de1,
        0x0480367,0x18ec81c,0x0048eba } },
    /* 96 */
    { { 0x346e2f6,0x0435077,0x036789b,0x3e06545,0x313ab57,0x351a721,
        0x3372b91,0x15e6019,0x2fa4f6c,0x3c30656,0x272c9ac,0x10e84a8,
        0x2bdacea,0x232d9e2,0x009dadd },
      { 0x182579a,0x15b1af8,0x02d8cce,0x36cb49b,0x086feba,0x2911d17,
        0x268ee12,0x011e871,0x18698dc,0x35602b3,0x11b9ec2,0x0ade731,
        0x0f6a05a,0x1821015,0x00007da } },
    /* 97 */
    { { 0x3b00dd0,0x328d485,0x27a69e3,0x32c3a06,0x1046779,0x120b61c,
        0x19fef3d,0x0fef2e6,0x134d923,0x039bce0,0x348cd0e,0x0b0c007,
        0x066ae11,0x15d8f1b,0x00934e7 },
      { 0x33234dc,0x353f0f5,0x2fc1b44,0x18a193a,0x2fcae20,0x1afbc86,
        0x3afe252,0x17f7e10,0x107f3b7,0x2d84d54,0x394c2e6,0x19e96a9,
        0x0a37283,0x26c6152,0x003d262 } },
    /* 98 */
    { { 0x37cfaf8,0x01863d0,0x0299623,0x32c80cb,0x25b8742,0x0a4d90e,
        0x1f72472,0x13de652,0x31a0946,0x0ee0103,0x0f25414,0x2518b49,
        0x07e7604,0x1488d9b,0x00abd6b },
      { 0x1338f55,0x2ce4af5,0x1a0c119,0x3380525,0x21a80a9,0x235d4df,
        0x118ca7f,0x2dd8bcc,0x1c26bf4,0x32dc56b,0x28482b6,0x1418596,
        0x3c84d24,0x1f1a5a9,0x00d958d } },
    /* 99 */
    { { 0x1c21f31,0x22aa1ef,0x258c9ad,0x2d2018f,0x0adb3ca,0x01f75ee,
        0x186283b,0x31ad3bf,0x3621be7,0x3b1ee6d,0x015582d,0x3d61d04,
        0x2ddf32e,0x14b8a66,0x00c970c },
      { 0x2f24d66,0x00b8a88,0x100a78f,0x041d330,0x2efec1d,0x24c5b86,
        0x2a6a390,0x37526bc,0x2055849,0x3339f08,0x16bffc4,0x07f9d72,
        0x06ec09c,0x3f49ee8,0x00cad98 } },
    /* 100 */
    { { 0x248b73e,0x1b8b42d,0x285eed7,0x39473f4,0x1a9f92c,0x3b44f78,
        0x086c062,0x06a4ea3,0x34ea519,0x3c74e95,0x1ad1b8b,0x1737e2c,
        0x2cfe338,0x0a291f4,0x00bbecc },
      { 0x1cec548,0x0c9b01a,0x20b298d,0x377c902,0x24f5bc1,0x2415c8d,
        0x1a70622,0x2529090,0x1c5c682,0x283f1ba,0x2319f17,0x0120e2e,
        0x01c6f4d,0x33c67ff,0x008b612 } },
    /* 101 */
    { { 0x03830eb,0x02d4053,0x10c59bb,0x0f23b83,0x13d08f8,0x26ea4e2,
        0x2626427,0x0a45292,0x0449cbc,0x0175750,0x074c46f,0x27ae0f8,
        0x2d7d6ae,0x163dd3a,0x0063bb7 },
      { 0x2bb29e0,0x034bab1,0x341e1c4,0x21d2c0b,0x295aa2d,0x0f2c666,
        0x1891755,0x13db64a,0x2fe5158,0x337646e,0x31a1aae,0x057bee4,
        0x00f9e37,0x396d19e,0x00c1b6a } },
    /* 102 */
    { { 0x2772f41,0x34f92d0,0x39d1cde,0x174ef2d,0x03a700d,0x03fbb98,
        0x30d50e8,0x352ed10,0x1fcf5e5,0x3d113bc,0x26e358f,0x180653f,
        0x1b43cc6,0x3cc9aa4,0x00e68a2 },
      { 0x37fe4d2,0x09dd725,0x01eb584,0x171f8a9,0x278fdef,0x3e37c03,
        0x3bec02f,0x149757c,0x0cd5852,0x37d2e10,0x0e6988b,0x1c120e9,
        0x0b83708,0x38e7319,0x0039499 } },
    /* 103 */
    { { 0x08df5fe,0x177a02c,0x0362fc0,0x1f18ee8,0x00c1295,0x173c50a,
        0x379414d,0x1885ba8,0x32a54ef,0x2315644,0x39e65cf,0x357c4be,
        0x1d66333,0x09e05a5,0x0009c60 },
      { 0x1f7a2fb,0x073b518,0x2eb83ac,0x11353d7,0x1dd8384,0x0c63f2b,
        0x238c6c8,0x2a1920a,0x2e5e9f1,0x1cc56f8,0x042daf4,0x1ed5dc5,
        0x25f9e31,0x012a56a,0x0081b59 } },
    /* 104 */
    { { 0x321d232,0x2c71422,0x3a756b6,0x30230b2,0x387f3db,0x3a7c3eb,
        0x274b46a,0x201e69f,0x185bb7b,0x140da82,0x0d974a2,0x0616e42,
        0x35ec94f,0x3bc366b,0x005aa7c },
      { 0x3dcfffc,0x19a9c15,0x3225e05,0x36ae114,0x16ea311,0x0cda2aa,
        0x2a1a8d2,0x154b5cb,0x08348cd,0x17b66c8,0x080ea43,0x21e59f3,
        0x04173b9,0x31d5b04,0x00ad735 } },
    /* 105 */
    { { 0x2e76ef4,0x216acf3,0x2b93aea,0x112bc74,0x3449974,0x2b2e48f,
        0x11929be,0x2f03021,0x19051e3,0x0ac202d,0x19be68a,0x3b87619,
        0x26cdac4,0x086592c,0x00f00de },
      { 0x2e90d4d,0x3ed703c,0x2c648d7,0x29ddf67,0x000e219,0x3471247,
        0x26febd5,0x1161713,0x3541a8f,0x302038d,0x08d2af9,0x26e1b21,
        0x398514a,0x36dad99,0x002ed70 } },
    /* 106 */
    { { 0x06f25cb,0x1104596,0x370faee,0x07e83f3,0x0f7b686,0x228d43a,
        0x12cd201,0x0a1bd57,0x3e592dc,0x1e186fc,0x2226aba,0x2c63fe9,
        0x17b039a,0x1efaa61,0x00d1582 },
      { 0x2e6acef,0x07d51e4,0x3ac326c,0x322b07e,0x1422c63,0x32ff5c7,
        0x18760df,0x048928b,0x139b251,0x04d7da9,0x048d1a2,0x2a23e84,
        0x199dbba,0x2fa7afe,0x0049f1a } },
    /* 107 */
    { { 0x3492b73,0x27d3d3d,0x2b1a16f,0x07b2ce4,0x0cf28ec,0x2729bff,
        0x3130d46,0x3e96116,0x140b72e,0x14a2ea3,0x1ca066f,0x3a61f1d,
        0x022ebac,0x09192b4,0x003e399 },
      { 0x12555bb,0x0b6139d,0x239463a,0x12a70ab,0x2aaa93b,0x2254e72,
        0x00424ec,0x26a6736,0x26daa11,0x25b5ad6,0x379f262,0x140cd30,
        0x0c7d3bd,0x097bbcf,0x00899e9 } },
    /* 108 */
    { { 0x3825dc4,0x3cd946f,0x0462b7f,0x31102e7,0x30f741c,0x3313ed6,
        0x1ff5a95,0x15bf9dc,0x09b47fd,0x0f2e7a7,0x1626c0d,0x3c14f6d,
        0x14098bd,0x19d7df8,0x00a97ce },
      { 0x0934f5e,0x3f968db,0x046f68a,0x12333bf,0x26cd5e1,0x1ea2161,
        0x358570d,0x235031d,0x35edd55,0x05265e3,0x24ae00c,0x3542229,
        0x25bb2a1,0x1c83c75,0x0058f2a } },
    /* 109 */
    { { 0x24daedb,0x376928f,0x305266f,0x0499746,0x038318c,0x312efd7,
        0x1910a24,0x33450a3,0x1c478a9,0x39d8bf9,0x12cc0ae,0x397aeab,
        0x0654c08,0x095f283,0x00d2cdf },
      { 0x0b717d2,0x1f162c2,0x107a48f,0x128e1b3,0x2380718,0x39f4044,
        0x00f626a,0x05ec0c9,0x21bc439,0x200fa4d,0x20aea01,0x186a1d8,
        0x26372f2,0x1a91f87,0x0053f55 } },
    /* 110 */
    { { 0x3512a90,0x33b958b,0x29f1c84,0x0106c3a,0x224b3c0,0x09b307a,
        0x215d2de,0x3bdf43b,0x22cf0c9,0x176121d,0x1534143,0x09ba717,
        0x16b3110,0x0f73f6c,0x008f5b7 },
      { 0x2c75d95,0x26fbcb4,0x0dda1f6,0x206f819,0x28d33d5,0x1fb4d79,
        0x024c125,0x30a0630,0x1f9c309,0x0fe350d,0x1696019,0x0a54187,
        0x09541fd,0x35e3a79,0x0066618 } },
    /* 111 */
    { { 0x0e382de,0x33f5163,0x0dde571,0x3bb7a40,0x1175806,0x12ae8ed,
        0x0499653,0x3b25586,0x38ade7a,0x3fa265d,0x3f4aa97,0x3c03dbb,
        0x30c6de8,0x32d4042,0x00ae971 },
      { 0x2f788f1,0x1fbaf0e,0x3e2d182,0x3ff904f,0x0d46229,0x1d0726d,
        0x15455b4,0x093ae28,0x290f8e4,0x097c0b9,0x1ae8771,0x28480bb,
        0x04f6d40,0x3689925,0x0049b3b } },
    /* 112 */
    { { 0x35b2d69,0x31819c0,0x11b0d63,0x035afb6,0x2b50715,0x2bece6c,
        0x35f82f7,0x0ad987c,0x0011601,0x02e6f67,0x2d0a5f5,0x365e583,
        0x2f7c900,0x11449c5,0x00ed705 },
      { 0x27abdb4,0x1bbfd04,0x301c157,0x263c079,0x36850d6,0x3f21f8b,
        0x27d7493,0x0f9227e,0x06fb0ce,0x002daf3,0x37d8c1c,0x3ef87d7,
        0x19cc6f4,0x0c3809c,0x00cf752 } },
    /* 113 */
    { { 0x22d94ed,0x075b09c,0x020e676,0x084dc62,0x2d1ec3f,0x17439f1,
        0x240b702,0x33cc596,0x30ebaf3,0x0359fe0,0x393ea43,0x0ece01e,
        0x16c6963,0x03a82f2,0x0017faa },
      { 0x3866b98,0x3cd20b7,0x12d4e6b,0x3a6a76d,0x1205c1e,0x3e6ae1a,
        0x2f9bbdf,0x2e61547,0x2d175ee,0x28e18f6,0x13cf442,0x085b0ef,
        0x0e321ef,0x238fe72,0x003fb22 } },
    /* 114 */
    { { 0x360ac07,0x26dc301,0x3f4d94f,0x2ba75e6,0x1f3c9cc,0x17ff20f,
        0x0ea084c,0x30e39cf,0x143dc49,0x03bd43e,0x3c9e733,0x19e8aba,
        0x27fbaf4,0x12d913a,0x005ee53 },
      { 0x3609e7f,0x2d89c80,0x09f020c,0x1558bf7,0x3098443,0x3c515fd,
        0x1c8e580,0x16506bd,0x26cb4b2,0x1747d42,0x2ec8239,0x32c91f0,
        0x1ca3377,0x079768f,0x00a5f3e } },
    /* 115 */
    { { 0x185fa94,0x122759f,0x0e47023,0x0dcb6e7,0x10ba405,0x3b5eab4,
        0x1f7a1fa,0x32d003f,0x1739a4c,0x3295ec3,0x1b18967,0x3f3b265,
        0x34d2448,0x2dbadc9,0x00f30b5 },
      { 0x01c5338,0x2d1dcf2,0x2bd07cc,0x39a8fb5,0x2b85639,0x355bab6,
        0x1df95f1,0x01eb5f6,0x17f0a16,0x1b895b5,0x157574d,0x29fff72,
        0x3a8c46d,0x0118071,0x0065f84 } },
    /* 116 */
    { { 0x3a1e7f1,0x17432f2,0x1f648d4,0x3000ad5,0x2ef0a08,0x1f86624,
        0x1ca31b1,0x241f9dc,0x2cb4885,0x2b8610f,0x364ce16,0x1e5faf0,
        0x0b33867,0x2cb637d,0x00816d2 },
      { 0x1aa8671,0x02c394e,0x35f5e87,0x393040a,0x39f0db3,0x1c831a5,
        0x2966591,0x034a8d0,0x09e613c,0x042b532,0x018ddd6,0x3e402c9,
        0x2e20e1a,0x29cb4cd,0x00e087c } },
    /* 117 */
    { { 0x3a10079,0x20c7fea,0x3ff2222,0x1edb593,0x00dc5f8,0x3a32ccc,
        0x1479073,0x0cfed11,0x2a2702a,0x17a056a,0x1fba321,0x235acb9,
        0x149c833,0x172de7d,0x000f753 },
      { 0x2e95923,0x3b365cb,0x009f471,0x0df1b47,0x21e868b,0x199bbd3,
        0x07b8ecc,0x12ff0af,0x189808a,0x3bd5059,0x3fbc4d2,0x0fa7b88,
        0x1125bf2,0x0db0b5d,0x0043572 } },
    /* 118 */
    { { 0x29cdb1b,0x1db656e,0x391efe1,0x004be09,0x245a1ca,0x3793328,
        0x254af24,0x2f2e65d,0x10e5cc4,0x2af6fe7,0x2d97ac0,0x29f7d42,
        0x19fd6f6,0x0ac184d,0x00c5211 },
      { 0x305eae3,0x36738d3,0x2c2b696,0x00ba50e,0x3903adc,0x2122f85,
        0x0753470,0x1cf96a4,0x1702a39,0x247883c,0x2feb67e,0x2ab3071,
        0x3c6b9e1,0x30cb85a,0x002ca0a } },
    /* 119 */
    { { 0x3871eb5,0x284b93b,0x0a7affe,0x176a2fc,0x294c2f2,0x204d3aa,
        0x1e4c2a7,0x3ec4134,0x2fb0360,0x3847b45,0x05fc11b,0x0a6db6e,
        0x390fa40,0x2adfd34,0x005e9f7 },
      { 0x0646612,0x1b5cbcc,0x10d8507,0x0777687,0x3a0afed,0x1687440,
        0x0222578,0x1af34a4,0x2174e27,0x372d267,0x11246c3,0x34769c5,
        0x2044316,0x1b4d626,0x00c72d5 } },
    /* 120 */
    { { 0x2e5bb45,0x3ff1d36,0x16dcdf5,0x128986f,0x399068c,0x2a63b1e,
        0x0afa7aa,0x3a5b770,0x200f121,0x33b74bb,0x1414045,0x0f31ef8,
        0x2f50e16,0x2f38cd6,0x00b0b1b },
      { 0x1a06293,0x035e140,0x2644d44,0x1f1954b,0x2cdebab,0x31d5f91,
        0x0b8dbc8,0x38f2d23,0x3783cab,0x2a07e73,0x3123f59,0x3409846,
        0x3784ddd,0x223bbac,0x003dc7b } },
    /* 121 */
    { { 0x0741456,0x234e631,0x2121e1b,0x00980ca,0x3a9dfa9,0x098c916,
        0x3fc86d1,0x1c63072,0x3625244,0x13d0471,0x05b0fc5,0x1487550,
        0x2498596,0x11bb6ea,0x001afab },
      { 0x274b4ad,0x240aea1,0x3d12a75,0x2b56b61,0x1486b43,0x1b83426,
        0x31c7363,0x35b59ca,0x207bb6c,0x38e6243,0x19bace4,0x0a26671,
        0x35e3381,0x0c2ded4,0x00d8da4 } },
    /* 122 */
    { { 0x2b75791,0x19590b1,0x2bfb39f,0x2988601,0x0050947,0x0d8bbe1,
        0x23e3701,0x08e4432,0x2ed8c3d,0x326f182,0x332e1dd,0x12219c5,
        0x2e0779b,0x367aa63,0x0012d10 },
      { 0x251b7dc,0x0a08b4d,0x1138b6f,0x2ea02af,0x06345a5,0x1cb4f21,
        0x0332624,0x1d49d88,0x140acc5,0x2f55287,0x024447c,0x291ace9,
        0x1a4966e,0x015cbec,0x005bc41 } },
    /* 123 */
    { { 0x351cd0e,0x315e8e9,0x07d6e70,0x067ae8f,0x2190d84,0x351f556,
        0x03bee79,0x31b62c7,0x266f912,0x1b6a504,0x007a6ad,0x3a6ab31,
        0x3891112,0x3c45ba0,0x00d6ce5 },
      { 0x0e1f2ce,0x32a5edc,0x1434063,0x1ca084f,0x2a3e47c,0x137e042,
        0x16e2418,0x2069280,0x3b0dfd8,0x35a22b5,0x289bf0a,0x1f667f2,
        0x02d23a3,0x0ce688f,0x00d8e3f } },
    /* 124 */
    { { 0x10bed6f,0x14c58dd,0x0b0abdf,0x0ca0f9a,0x3808abc,0x2ec228c,
        0x2366275,0x12afa16,0x20f6b0e,0x37dca8e,0x3af0c6a,0x1c5b467,
        0x1b25ff7,0x00814de,0x0022dcc },
      { 0x1a56e11,0x02fe37e,0x3f21740,0x35d5a91,0x06cb8ba,0x29bad91,
        0x17176f7,0x2d919f2,0x0f7d1f5,0x13a3f61,0x04ddb05,0x0c82a51,
        0x286f598,0x2e8c777,0x0007071 } },
    /* 125 */
    { { 0x0f8fcb9,0x3e83966,0x170c6fd,0x3825343,0x089cec8,0x01b482a,
        0x0993971,0x3327282,0x39aba8a,0x32456fe,0x1507e01,0x1c3252d,
        0x21ffb13,0x29822a0,0x0083246 },
      { 0x23c378f,0x1cea7ef,0x1be9a82,0x224d689,0x37e5447,0x3764a75,
        0x3a49724,0x361e1b3,0x19d365b,0x3a61ffb,0x1c29a7a,0x20ab251,
        0x17ec549,0x175d777,0x004589a } },
    /* 126 */
    { { 0x15540a9,0x2ec5d2a,0x05b09fa,0x1bc058b,0x07cfb88,0x28f7b86,
        0x3e766be,0x189305e,0x01fe88e,0x23fdf69,0x0b919c3,0x02dc7ae,
        0x3f9a9ad,0x0b83cc7,0x0086a52 },
      { 0x28bc259,0x39bdca1,0x39e4bc8,0x0e0f33b,0x16130c6,0x2919955,
        0x31f4549,0x2fed027,0x30919b2,0x0a39b03,0x0ca7bb2,0x1711b24,
        0x3b67b94,0x05a136b,0x00acd87 } },
    /* 127 */
    { { 0x0c53841,0x31cb284,0x3ced090,0x06d5693,0x1c20ae0,0x0408d2b,
        0x37ebd5e,0x081900f,0x26a8589,0x0acfd0a,0x34a1472,0x2f0c302,
        0x124ccbd,0x10de328,0x00971bc },
      { 0x17ff2ff,0x27d1b54,0x147b6f7,0x38bb2ea,0x26a9c96,0x0a49448,
        0x39f2f46,0x247c579,0x3b16a4e,0x28c2a5a,0x2d4c72d,0x11f248c,
        0x1e4df11,0x047d604,0x0065bc3 } },
    /* 128 */
    { { 0x39b3239,0x1f75f44,0x3bae87c,0x139360c,0x18b5782,0x3ffc005,
        0x3c48789,0x2bc6af2,0x38b909e,0x223ff3b,0x31443a7,0x017d3bb,
        0x0bfed99,0x128b857,0x00020dd },
      { 0x306d695,0x25a7b28,0x2f60ca2,0x2b6e4f2,0x1df940c,0x1fa9b8e,
        0x37fab78,0x13f959f,0x10ff98c,0x38343b8,0x019cb91,0x11a1e6b,
        0x17ab4c6,0x1431f47,0x004b4ea } },
    /* 129 */
    { { 0x20db57e,0x102515e,0x170219e,0x2b66a32,0x1e6017c,0x2f973fe,
        0x3739e51,0x0e28b6f,0x3cda7a9,0x30d91ac,0x28350df,0x1444215,
        0x098b504,0x1bcd5b8,0x00ad3bd },
      { 0x22e3e3e,0x3aeaffb,0x26cb935,0x0091ce4,0x2fbd017,0x3a7ed6a,
        0x335b029,0x3bfc1f1,0x3852e3f,0x2b14a86,0x046b405,0x266af4c,
        0x3997191,0x33b0e40,0x00e306f } },
    /* 130 */
    { { 0x3e4712c,0x26bb208,0x18eed6d,0x1b30f06,0x27ca837,0x06faf62,
        0x1831873,0x3fbcf9b,0x3f3d88b,0x1fb55eb,0x0f44edc,0x29917bb,
        0x3151772,0x342d72e,0x00d4e63 },
      { 0x2ee0ecf,0x39e8733,0x2e8e98c,0x0cd4e0f,0x08f0126,0x1ad157a,
        0x079078a,0x23018ee,0x196c765,0x2b2f34f,0x0783336,0x075bf9c,
        0x3713672,0x098d699,0x00f21a7 } },
    /* 131 */
    { { 0x186ba11,0x22cf365,0x048019d,0x2ca2970,0x0d9e0ae,0x08c3bd7,
        0x261dbf2,0x2fc2790,0x1ee02e6,0x10256a7,0x00dc778,0x18dc8f2,
        0x157b189,0x2ebc514,0x005c97d },
      { 0x3c4503e,0x1d10d12,0x337097e,0x0c6169a,0x30fb1cb,0x3481752,
        0x0df2bec,0x19768fa,0x1bcf8f7,0x2925f74,0x2c988a1,0x3be571d,
        0x04cfa92,0x2ea9937,0x003f924 } },
    /* 132 */
    { { 0x268b448,0x06e375c,0x1b946bf,0x287bf5e,0x3d4c28b,0x138d547,
        0x21f8c8e,0x21ea4be,0x2d45c91,0x35da78e,0x00326c0,0x210ed35,
        0x1d66928,0x0251435,0x00fefc8 },
      { 0x0339366,0x216ff64,0x2c3a30c,0x3c5733d,0x04eeb56,0x2333477,
        0x32b1492,0x25e3839,0x1b5f2ce,0x0dcfba1,0x3165bb2,0x3acafcc,
        0x10abfcd,0x248d390,0x008106c } },
    /* 133 */
    { { 0x102f4ee,0x3c0585f,0x1225c8d,0x11c6388,0x08a7815,0x2b3e790,
        0x2895eb6,0x18cf53a,0x0b56e5a,0x2e2c003,0x3e981ff,0x0761b55,
        0x1bc32f3,0x0a7111d,0x00f5c80 },
      { 0x3568973,0x1587386,0x16ec764,0x20698a6,0x02f809b,0x2821502,
        0x113d64d,0x38c2679,0x15de61c,0x0309f60,0x272999e,0x29bfe64,
        0x173f70d,0x1de7fab,0x00bd284 } },
    /* 134 */
    { { 0x31cdf2b,0x0f0be66,0x2151603,0x01af17e,0x32a99cf,0x085dece,
        0x27d2591,0x1520df4,0x273c448,0x1ec7c54,0x102e229,0x355f604,
        0x2acb75f,0x005f1fd,0x003d43e },
      { 0x270eb28,0x22ec2ce,0x306b41a,0x238fa02,0x167de2d,0x030a379,
        0x245a417,0x1808c24,0x0b1a7b2,0x3ab5f6f,0x2cbc6c1,0x2c228d4,
        0x3041f70,0x2d9a6cc,0x00b504f } },
    /* 135 */
    { { 0x17a27c2,0x216ad7e,0x011ba8e,0x22f0428,0x16ac5ec,0x3ef3c58,
        0x345533f,0x0298155,0x2856579,0x0005e03,0x19ee75b,0x146fe16,
        0x29881e4,0x18ece70,0x008907a },
      { 0x20189ed,0x119ce09,0x35cb76d,0x0d91ef4,0x2284a44,0x032ad87,
        0x0e8c402,0x3c82b5d,0x38c416c,0x398992f,0x1fd820c,0x169b255,
        0x3b5fcfa,0x1343c92,0x00fa715 } },
    /* 136 */
    { { 0x33f5034,0x20b3b26,0x28fd184,0x16b3679,0x3962d44,0x15d1bc8,
        0x2fb1d69,0x1292c99,0x25a58c9,0x1b19ab7,0x2d68a5b,0x2f6a09b,
        0x0d6aedb,0x2935eac,0x0005664 },
      { 0x25e32fc,0x13f9440,0x3252bcd,0x2fea5b7,0x161a5ae,0x0564a8c,
        0x0a07e23,0x1545f62,0x0de9890,0x1d76765,0x1fd440e,0x2ed0041,
        0x3db4c96,0x1e8ba01,0x001b0c4 } },
    /* 137 */
    { { 0x0223878,0x29ab202,0x15585c2,0x1a79969,0x1ba08c2,0x2ef09ff,
        0x2b1b9b9,0x181f748,0x1bf72b9,0x224645c,0x2588dc5,0x2d157e7,
        0x22d939a,0x05b88d9,0x006d549 },
      { 0x31de0c1,0x23a4e0e,0x278f8da,0x1aa013c,0x1a84d18,0x0d185a5,
        0x0988ccd,0x2c32efd,0x3bee10e,0x37d7ab8,0x3f2a66e,0x3e2da3e,
        0x1b5701f,0x3d9f0c1,0x00a68da } },
    /* 138 */
    { { 0x0b2e045,0x0133fd1,0x05d4c10,0x0d92c70,0x391b5e1,0x2292281,
        0x2e40908,0x2ec694e,0x195ea11,0x29cfeca,0x3d93a4e,0x01215c0,
        0x08a5f32,0x37a0eff,0x00cce45 },
      { 0x2b3106e,0x12a5fb0,0x0b4faff,0x0c2da12,0x09069c6,0x35d8907,
        0x2837a6e,0x3db3fb6,0x3136cc3,0x222836b,0x3da018a,0x2741274,
        0x13ba319,0x1ac7642,0x00f867c } },
    /* 139 */
    { { 0x2527296,0x10a9595,0x178de4d,0x0f739c4,0x0ae26c7,0x3094599,
        0x20adac6,0x2b875c2,0x3ae5dc0,0x3e04d20,0x1aab2da,0x1d3ab37,
        0x15f4f75,0x0b730b5,0x00c56b5 },
      { 0x1f32923,0x2f059e5,0x2a89872,0x2056f74,0x04be175,0x1da67c0,
        0x17f1e7a,0x3780a6d,0x0723ac2,0x257f367,0x1237773,0x2bcee86,
        0x0b97f83,0x38aff14,0x00a64d4 } },
    /* 140 */
    { { 0x2552b40,0x0b6b883,0x12e8217,0x0974d35,0x062f497,0x1e563e6,
        0x30ee400,0x375d1e4,0x290751f,0x0d5b68a,0x353e48c,0x064a0d3,
        0x3c343f1,0x309a394,0x0034d2a },
      { 0x3111286,0x0f08604,0x1827107,0x0536a76,0x0201dac,0x3a574de,
        0x2c29dbe,0x382c7b0,0x1191f3e,0x324c5bc,0x144ce71,0x24327c1,
        0x1212778,0x22bc9d8,0x00d7713 } },
    /* 141 */
    { { 0x34ad1cd,0x1179b4e,0x1bc1780,0x1392a92,0x2cd86b9,0x359de85,
        0x251f1df,0x0da5d5f,0x135fa61,0x0f64a42,0x34f4d89,0x0fe564c,
        0x3cf9b7a,0x122d757,0x008c9c2 },
      { 0x370d4e9,0x0e9209b,0x0ae99f2,0x1518c64,0x0172734,0x2c20692,
        0x1d7c135,0x149c52f,0x38928d6,0x3c78b78,0x25841d1,0x2eaa897,
        0x372e50b,0x29e5d19,0x00c4c18 } },
    /* 142 */
    { { 0x13375ac,0x389a056,0x211310e,0x2f9f757,0x04f3288,0x103cd4e,
        0x17b2fb2,0x2c78a6a,0x09f1de6,0x23e8442,0x1351bc5,0x1b69588,
        0x285b551,0x0464b7e,0x00573b6 },
      { 0x0ba7df5,0x259a0db,0x2b4089e,0x05630a2,0x3f299be,0x350ff2f,
        0x1c9348a,0x3becfa4,0x3cc9a1c,0x17a6ef1,0x338b277,0x2b761d9,
        0x2aa01c8,0x3cb9dd7,0x006e3b1 } },
    /* 143 */
    { { 0x277788b,0x16a222d,0x173c036,0x310ff58,0x2634ae8,0x392636f,
        0x0987619,0x1e6acc1,0x26dc8f7,0x242310f,0x0c09aca,0x22b8e11,
        0x0d17006,0x1c2c806,0x002380c },
      { 0x297c5ec,0x1fef0e8,0x3948cf7,0x14f2915,0x2dacbc8,0x0dafb1f,
        0x10de043,0x31184da,0x06414ee,0x3c9aeeb,0x1f713ab,0x308f1f8,
        0x1569ed1,0x3f379bf,0x00f08bb } },
    /* 144 */
    { { 0x0770ee3,0x058fd21,0x17065f8,0x251d128,0x10e0c7f,0x06cb51b,
        0x0f05f7e,0x3666a72,0x3e7d01f,0x2d05fab,0x11440e5,0x28577d4,
        0x2fbcf2b,0x14aa469,0x00dc5c5 },
      { 0x270f721,0x1c75d28,0x085b862,0x1d68011,0x132c0a0,0x37be81d,
        0x1a87e38,0x083fa74,0x3acbf0d,0x16d6429,0x0feda1f,0x031070a,
        0x2ec2443,0x21e563d,0x00454d2 } },
    /* 145 */
    { { 0x0525435,0x1e98d5f,0x3dbc52b,0x1fcdf12,0x13d9ef5,0x3ff311d,
        0x393e9ed,0x3cef8ae,0x2987710,0x3bdee2e,0x21b727d,0x3ba1b68,
        0x10d0142,0x3c64b92,0x0055ac3 },
      { 0x0c1c390,0x38e9bb0,0x1e7b487,0x11511b3,0x1036fb3,0x25aba54,
        0x1eb2764,0x048d022,0x0d971ed,0x1bb7fb5,0x100f0b4,0x06c3756,
        0x2f0d366,0x3c6e160,0x0011bd6 } },
    /* 146 */
    { { 0x36bc9d1,0x24d43c1,0x12c35cf,0x2fb3cf3,0x015d903,0x16bc0c7,
        0x0fc8c22,0x3195c87,0x2488b1c,0x1f82b4c,0x30014e8,0x27ee58d,
        0x31658dd,0x1684a5f,0x00f0f3a },
      { 0x1f703aa,0x023eebc,0x20babb9,0x080bd9d,0x12f9cc4,0x1a8e2d4,
        0x0eec666,0x1176803,0x33005d6,0x1137b68,0x37de339,0x33d71cb,
        0x0c906b9,0x14086b5,0x00aeef6 } },
    /* 147 */
    { { 0x219045d,0x0f22c5e,0x024c058,0x00b414a,0x0ae7c31,0x3db3e96,
        0x234979f,0x0cf00a8,0x3c962c7,0x27fa77f,0x1c0c4b0,0x1fe8942,
        0x218053a,0x1eed3f8,0x0051643 },
      { 0x2a23ddb,0x138f570,0x104e945,0x21ca270,0x30726d8,0x3f45490,
        0x37d9184,0x242ea25,0x33f6d77,0x3f15679,0x065af85,0x34fa1f5,
        0x2e46b8f,0x31d17fb,0x00a2615 } },
    /* 148 */
    { { 0x335167d,0x181ea10,0x0887c8d,0x01383d7,0x18b42d8,0x263447e,
        0x1f13df3,0x0319d7e,0x0872074,0x2d6aa94,0x23d9234,0x36a69aa,
        0x0bad183,0x3138a95,0x00bd3a5 },
      { 0x1b0f658,0x0e4530b,0x373add1,0x1b968fc,0x329dcb6,0x09169ca,
        0x162df55,0x0211eff,0x02391e4,0x3867460,0x3136b1a,0x37dd36e,
        0x3bc5bd9,0x2dacfe4,0x0072a06 } },
    /* 149 */
    { { 0x119d96f,0x067b0eb,0x00996da,0x293eca9,0x2b342da,0x1889c7a,
        0x21633a6,0x0152c39,0x281ce8c,0x18ef3b3,0x0bd62dc,0x3238186,
        0x38d8b7c,0x3867b95,0x00ae189 },
      { 0x0ed1eed,0x1e89777,0x13ab73e,0x029e1d7,0x2c1257f,0x33fbc09,
        0x32d5a21,0x3d870b2,0x39bb1fd,0x33663bc,0x24e83e6,0x239bda4,
        0x3088bcd,0x01db1ed,0x00d71e7 } },
    /* 150 */
    { { 0x14245bf,0x0da0c27,0x153b339,0x05cab0a,0x122d962,0x1b0f0f3,
        0x3f5a825,0x267a2ce,0x2910d06,0x254326f,0x0f36645,0x025118e,
        0x37c35ec,0x36e944e,0x006c056 },
      { 0x05ab0e3,0x29aa0c1,0x1295687,0x1fd1172,0x08d40b5,0x05bd655,
        0x345048a,0x02a1c3c,0x2393d8f,0x0992d71,0x1f71c5e,0x18d4e8a,
        0x30dd410,0x11d61d3,0x00dd58b } },
    /* 151 */
    { { 0x2230c72,0x30213d8,0x05e367e,0x329204e,0x0f14f6c,0x3369ddd,
        0x0bb4074,0x2edafd6,0x1b1aa2d,0x0785404,0x0c035ab,0x220da74,
        0x1f2fdd4,0x092a091,0x00ef83c },
      { 0x3dc2538,0x1cca3e7,0x246afb5,0x24c647f,0x0798082,0x0bb7952,
        0x0f5c443,0x008b38a,0x299ea1a,0x3c6cf36,0x3df2ec7,0x398e6dc,
        0x29a1839,0x1cadd83,0x0077b62 } },
    /* 152 */
    { { 0x25d56d5,0x3546f69,0x16e02b1,0x3e5fa9a,0x03a9b71,0x2413d31,
        0x250ecc9,0x1d2de54,0x2ebe757,0x2a2f135,0x2aeeb9a,0x0d0fe2b,
        0x204cb0e,0x07464c3,0x00c473c },
      { 0x24cd8ae,0x0c86c41,0x221c282,0x0795588,0x1f4b437,0x06fc488,
        0x0c81ecd,0x020bf07,0x3a9e2c8,0x2294a81,0x3a64a95,0x0363966,
        0x32c9a35,0x0f79bec,0x0029e4f } },
    /* 153 */
    { { 0x289aaa5,0x2755b2e,0x059e0aa,0x3031318,0x0f0208a,0x35b7729,
        0x00d9c6b,0x3dd29d0,0x075f2c2,0x0ece139,0x31562dd,0x04187f2,
        0x13b8d4c,0x0920b85,0x003924e },
      { 0x09808ab,0x2e36621,0x2a36f38,0x1829246,0x229bf32,0x20883b7,
        0x159ada8,0x3108a14,0x15bbe5b,0x1e2d1e4,0x1730096,0x0d35cbb,
        0x15d0da9,0x0e60b94,0x00c4f30 } },
    /* 154 */
    { { 0x31de38b,0x27b9086,0x2760e3e,0x169098d,0x2a124e2,0x00596c6,
        0x3f73c09,0x0d31642,0x2341464,0x248600a,0x2e1fa10,0x2aa0fc8,
        0x051e954,0x00f3b67,0x001d4bd },
      { 0x18751e6,0x25a8e1e,0x07f5c2d,0x17e30d4,0x0ed2723,0x23093e2,
        0x3b80e2c,0x13de2d7,0x2fad37f,0x1be1cfb,0x3224ba9,0x0a7f5d3,
        0x1714972,0x06667b7,0x009dcd9 } },
    /* 155 */
    { { 0x294f22a,0x3e06993,0x0341ee9,0x24bdc7b,0x2e56098,0x2660a13,
        0x018ddda,0x2c261b2,0x2953b54,0x267f51c,0x0e8a7cc,0x29ab00c,
        0x3a38247,0x397ac81,0x00de684 },
      { 0x36b956b,0x347b34a,0x35834bd,0x053c06c,0x0090844,0x148cec5,
        0x380b325,0x2f17b8b,0x054ef5e,0x09683fb,0x3f8b29a,0x33c979a,
        0x1e01474,0x3e81fca,0x001c757 } },
    /* 156 */
    { { 0x30fdfe4,0x2d712ba,0x13671bc,0x2cfc226,0x3d7c649,0x16f020e,
        0x368e3f0,0x2981ebb,0x246a78a,0x115e81b,0x21223a4,0x04dbb30,
        0x1a50ba2,0x12114bd,0x0089bd6 },
      { 0x055f15a,0x1046e51,0x00fd724,0x1c022a7,0x323dfa9,0x36d8efb,
        0x0da4d16,0x0910dec,0x2c1fb16,0x2dbe29f,0x298284f,0x2b273bb,
        0x26022c1,0x20accd5,0x00085a5 } },
    /* 157 */
    { { 0x01f138a,0x2d87e7b,0x0c2815c,0x0c19a3c,0x311c9a2,0x3e4fce3,
        0x029729d,0x21236b2,0x2984048,0x3f3bc95,0x2bba8fb,0x1a1b680,
        0x0619a3f,0x29e0447,0x00ed5fe },
      { 0x2d1c833,0x3dcef35,0x3f809b4,0x01a1b9e,0x1509516,0x10ac754,
        0x2735080,0x27b0a8a,0x2495fb8,0x0a7bdba,0x1ef8b89,0x00233a5,
        0x0568bf1,0x1a126ba,0x0078a7e } },
    /* 158 */
    { { 0x0470cd8,0x20e9f04,0x30003fe,0x20be1b7,0x1927346,0x2a5026d,
        0x1ac06bd,0x2717ed7,0x2609493,0x3079ea5,0x1cc116d,0x31b0541,
        0x2c8ccde,0x10219ae,0x001a52b },
      { 0x2864045,0x0e8d95b,0x2fc1530,0x0aa44e7,0x345eae7,0x3cc7553,
        0x3ec6466,0x229b60e,0x06f6e95,0x00bed2a,0x0ff4403,0x181c639,
        0x2e0df67,0x1f8fa46,0x0000811 } },
    /* 159 */
    { { 0x04310a2,0x20cee8e,0x09fc5d5,0x3707f5b,0x0bdfb4e,0x12713ee,
        0x24f1028,0x0787ee6,0x39a581c,0x3797ec8,0x10a9746,0x112cb9f,
        0x142b9ba,0x1da0ef6,0x0078f7b },
      { 0x07607ae,0x3232872,0x2a7e076,0x0bb572a,0x182b23c,0x1d8f918,
        0x181f392,0x37c45a9,0x24a3886,0x0b2a297,0x264e7f2,0x1fa433c,
        0x0fcfcc8,0x21c0857,0x0004f74 } },
    /* 160 */
    { { 0x01d161c,0x1744585,0x2d17528,0x03a4f13,0x267cd2e,0x30d861f,
        0x062a647,0x213284b,0x139ed25,0x27d4ca5,0x02fbbd6,0x31ddf11,
        0x3c50ac4,0x1dd86f7,0x00107de },
      { 0x16beebd,0x1b7317a,0x2151997,0x256a196,0x3be2aff,0x3621cab,
        0x0a9da19,0x05f3038,0x23da63c,0x3178d5e,0x215cc67,0x07f7f63,
        0x0c6d8d3,0x3bf5e5c,0x00c44bb } },
    /* 161 */
    { { 0x00c62f1,0x3e0f893,0x1572703,0x3b93865,0x19b1e28,0x389b33b,
        0x02858bf,0x0e3e9aa,0x04bc436,0x234e072,0x25ba43d,0x3dca19e,
        0x0274394,0x20f442e,0x003b4a7 },
      { 0x176451e,0x2b5ed5d,0x35c8ee1,0x25c52da,0x0c3d0b5,0x32b306e,
        0x030954f,0x275ecf7,0x10e472c,0x21577c4,0x02f8a32,0x321bb5c,
        0x0098f97,0x104e237,0x00d0433 } },
    /* 162 */
    { { 0x0a8f2fe,0x034548b,0x141f1a6,0x121246f,0x1616409,0x237f80d,
        0x2e29a55,0x1218db6,0x3ea278e,0x1669856,0x1ad7c8e,0x36d11de,
        0x2c2fcbb,0x18c0b3a,0x001c706 },
      { 0x1699b4b,0x2d531a6,0x17e85e2,0x1b48e78,0x2b509ca,0x2818ea0,
        0x0165fee,0x0b809ca,0x09db6a2,0x3dad798,0x326ee1d,0x204e416,
        0x091fa12,0x1c890e5,0x0007b9f } },
    /* 163 */
    { { 0x0ff4e49,0x0bb0512,0x0129159,0x05db591,0x03e4e9f,0x055ab30,
        0x0f82881,0x0ac2deb,0x3a8bb09,0x356a8d2,0x3d38393,0x03e4089,
        0x38187cd,0x1377a93,0x0041672 },
      { 0x0139e73,0x3990730,0x187d3c4,0x33e4793,0x2e0fe46,0x2ad87e2,
        0x33c792c,0x21d4fb6,0x1e4d386,0x2932d1b,0x20f1098,0x1270874,
        0x0ea6ee4,0x0167d6e,0x005e5fd } },
    /* 164 */
    { { 0x1856031,0x2b7519d,0x3bd07fc,0x337abcb,0x089c7a4,0x2a1f120,
        0x3523ce7,0x2ba406b,0x09561d9,0x1797f04,0x3cdb95f,0x2d6193e,
        0x32c7d3f,0x223aed6,0x00beb51 },
      { 0x2e65825,0x158f0ce,0x16413d1,0x310395f,0x3116854,0x250baf4,
        0x373d341,0x156cc47,0x104c069,0x0893716,0x195a0a6,0x035320e,
        0x37b7d8a,0x21b5755,0x00fb26b } },
    /* 165 */
    { { 0x286ae17,0x04239f1,0x1a56c53,0x0e74707,0x29090d7,0x2bb142b,
        0x03b0139,0x1aac916,0x08ba49a,0x0376682,0x3382f85,0x064bbab,
        0x2910e28,0x1d5bd7f,0x00cc8df },
      { 0x0ab7630,0x208e8e7,0x3fc1877,0x26bee39,0x264984a,0x192ff05,
        0x08ef9c3,0x0aa6951,0x071c44e,0x26eed3e,0x035c95e,0x06906ad,
        0x10a0690,0x397eaa9,0x00c6c23 } },
    /* 166 */
    { { 0x034d8dd,0x005b064,0x279bb78,0x12c2c4f,0x1856bb4,0x0c90681,
        0x06409ab,0x3b48617,0x19a2d78,0x0a34bf8,0x326eddf,0x31f09b5,
        0x04f04dc,0x3d7c944,0x003ccaf },
      { 0x321f843,0x35fb71a,0x1e4c397,0x377a5d7,0x2da88e4,0x3d6ada7,
        0x33d3964,0x1b30149,0x0e39aae,0x054dda0,0x3e6f946,0x1273394,
        0x3ffd3f7,0x2f6655e,0x00021dd } },
    /* 167 */
    { { 0x37233cf,0x11617dd,0x26f07b6,0x3d8250a,0x0fe6771,0x3f9bbbc,
        0x2aba7ad,0x200a58d,0x3568603,0x198eefa,0x1e8fcf3,0x3b9610b,
        0x20524ac,0x2a67528,0x0048d9a },
      { 0x1a5e57a,0x1e9d303,0x16c9cff,0x0f39527,0x3c23259,0x03c8a1e,
        0x104bccf,0x182d5a1,0x18dbc83,0x05b5f42,0x1b402f4,0x317c525,
        0x11bf1ea,0x3c46e1f,0x0061936 } },
    /* 168 */
    { { 0x0153a9d,0x36859ee,0x2cf0aa9,0x2b27a0f,0x0a49fe3,0x2d984e1,
        0x018f8e1,0x1378453,0x1ab3843,0x1987093,0x283dae9,0x25cf0e8,
        0x14fc93d,0x280609d,0x00c99ba },
      { 0x026b1e3,0x34663d3,0x2202477,0x21a9d45,0x212e8e1,0x18ab77e,
        0x2e52f63,0x0a14ce1,0x295c396,0x00c7a3d,0x2aaedb6,0x30abc4d,
        0x374acde,0x1318a73,0x00fcfdb } },
    /* 169 */
    { { 0x0a40298,0x3ba5633,0x11956b3,0x14fcbd7,0x3c38781,0x34bab96,
        0x165630e,0x1f3c831,0x37e3a69,0x2b4226c,0x2d5029e,0x3b4ab1e,
        0x1da6ac2,0x3eb43c3,0x007e5cd },
      { 0x1b86202,0x109b7f6,0x2054f98,0x2c50cd7,0x2ed1960,0x3c518e7,
        0x1b02463,0x319c07f,0x1c30db6,0x045fdc2,0x373421e,0x31a1eb9,
        0x1a8acbf,0x31289b0,0x0013fef } },
    /* 170 */
    { { 0x3fa0a5f,0x068661f,0x2109e36,0x00b18ff,0x1f4b261,0x31d3844,
        0x0acbc56,0x3aebc99,0x1fa77ab,0x152bd11,0x24cddb7,0x2313f74,
        0x06eea44,0x15f5114,0x000b131 },
      { 0x2e9993d,0x1ac565c,0x2cbe22a,0x3921797,0x12c3c57,0x360f868,
        0x33560bf,0x320ee99,0x382c3b8,0x39af88f,0x00bbe38,0x2c4ea59,
        0x3399b40,0x00ceb45,0x0066eea } },
    /* 171 */
    { { 0x0c6c693,0x31ba56d,0x3d3849f,0x378dabd,0x0efc735,0x17f90bf,
        0x13343d3,0x2df0f81,0x27c6a9a,0x13c2a90,0x0a0fcb2,0x27c10d9,
        0x3bc50c7,0x090e4fa,0x0016287 },
      { 0x2927e1e,0x35af405,0x184c5c3,0x3499cee,0x240158e,0x33522e6,
        0x386fc84,0x0a0b69f,0x1a660ea,0x34590fb,0x22a1bee,0x2ce4fab,
        0x31a9445,0x0e78655,0x00664c8 } },
    /* 172 */
    { { 0x3eeaf94,0x115d409,0x21e7577,0x097aa67,0x22875c9,0x021ab7a,
        0x27e7ba5,0x1093f04,0x2a086fe,0x05d9494,0x2b6c028,0x10f31b0,
        0x1312d11,0x262759c,0x00c9bb2 },
      { 0x1acb0a5,0x30cdf14,0x0f78880,0x0574f18,0x1a37109,0x098adbb,
        0x2113c09,0x2060925,0x1f89ce4,0x1974976,0x3381358,0x2dab5ca,
        0x2159c53,0x3af1303,0x000ea3b } },
    /* 173 */
    { { 0x1e49bea,0x29142b1,0x1a59cab,0x055f017,0x0684e54,0x39eb0db,
        0x29cab9d,0x255ee8b,0x35f2e6f,0x05329e6,0x09b817b,0x1ec091c,
        0x1df0fef,0x2641f62,0x00eb304 },
      { 0x2fe5096,0x3dcc1d1,0x2aaf508,0x3a0b813,0x0695810,0x144bddb,
        0x2f1bd93,0x281ae23,0x3513ebc,0x1ddd984,0x0cf158b,0x35218eb,
        0x257daf7,0x391253b,0x00b2a81 } },
    /* 174 */
    { { 0x153e6ba,0x22396db,0x0ea2ff2,0x2a45121,0x0a90de1,0x34cf23b,
        0x2db60ce,0x1a900be,0x2f328b6,0x355e75b,0x2c24372,0x0b75b77,
        0x2ec7d4f,0x3f24759,0x00e9e33 },
      { 0x39eab6e,0x2267480,0x3b5e110,0x1e8fa5e,0x2a31a66,0x3f739a3,
        0x00166dc,0x3552d88,0x3ae5137,0x3efa0fa,0x0800acd,0x17df61d,
        0x38c8608,0x04cc31b,0x00cf4ab } },
    /* 175 */
    { { 0x31e08fb,0x1961164,0x22c003f,0x078541b,0x3643855,0x30da587,
        0x11f0dc9,0x324595e,0x329e3dc,0x29a041e,0x3495d2c,0x0908dd3,
        0x1895b83,0x198dbb9,0x00d8cfb },
      { 0x0349b1b,0x383c5a8,0x2b86525,0x1b1283e,0x133cd2c,0x2be376a,
        0x012ee82,0x1eb4d1b,0x0ba71e9,0x01f3109,0x37621eb,0x1d9b77c,
        0x0d39069,0x3d5a97c,0x0095565 } },
    /* 176 */
    { { 0x20f5e94,0x1eefc86,0x1327e0e,0x054760b,0x2f771e1,0x3ac447e,
        0x033e3dc,0x198e040,0x04dd342,0x1b49a5d,0x00d01ef,0x3cb6768,
        0x1ceafbd,0x31c6812,0x001cb80 },
      { 0x221c677,0x060ca27,0x398b17f,0x0146723,0x36452af,0x02d9e65,
        0x39c5f78,0x3cf50d6,0x0be40f8,0x2970b87,0x26d667c,0x3e45959,
        0x16e7943,0x01673e7,0x009faaa } },
    /* 177 */
    { { 0x2078fe6,0x0918602,0x11dd8ad,0x399193f,0x0f6cc73,0x0f8dd12,
        0x2ce34dc,0x06d7d34,0x0c5e327,0x0989254,0x2fc5af7,0x2443d7b,
        0x32bc662,0x2fe2a84,0x008b585 },
      { 0x039327f,0x08e616a,0x252f117,0x1f52ab0,0x234e2d2,0x0a5b313,
        0x2f59ef6,0x0f7a500,0x15c4705,0x2c02b81,0x28b4f09,0x08aa5c8,
        0x0180efc,0x0993e83,0x00a9e86 } },
    /* 178 */
    { { 0x0310ecc,0x2d8892f,0x14ed0b7,0x3c59fe8,0x08a1a74,0x0850e57,
        0x1d09607,0x044a21f,0x109f5c9,0x237c6cf,0x06b264a,0x3fc8f1a,
        0x0d4c539,0x2740f96,0x00dc2d4 },
      { 0x1d6f501,0x0adf4ea,0x14f7215,0x0930102,0x3f4c32e,0x24e2643,
        0x366596d,0x081ff18,0x38f94fb,0x2c21341,0x328594c,0x267c75c,
        0x196b3fd,0x29932cb,0x0036def } },
    /* 179 */
    { { 0x3ed7cbe,0x26de044,0x3d0e461,0x0565e12,0x295e500,0x31dc17f,
        0x32251c2,0x3420ca8,0x3995f0d,0x2e8ddab,0x0361a45,0x10971b0,
        0x11e7b55,0x33bc7ca,0x00812d2 },
      { 0x3d94972,0x1606817,0x0383ccf,0x0e795b7,0x026e20e,0x0f6fefc,
        0x13685d6,0x315d402,0x0cc36b8,0x1c7f059,0x390ef5e,0x316ae04,
        0x08c66b9,0x2fac9a4,0x0040086 } },
    /* 180 */
    { { 0x3e3c115,0x153de4d,0x1a8ae5e,0x2330511,0x169b8ee,0x1d965c2,
        0x2edff2b,0x3ef99e6,0x1631b46,0x1f8a238,0x118d7bb,0x12113c3,
        0x26424db,0x0f4122a,0x00e0ea2 },
      { 0x3d80a73,0x30393bc,0x0f98714,0x278ef59,0x087a0aa,0x3b18c20,
        0x04b8a82,0x2068e21,0x030255d,0x3382b27,0x055397f,0x05448dd,
        0x2015586,0x1190be0,0x000b979 } },
    /* 181 */
    { { 0x2e03080,0x2895692,0x09fb127,0x2d1602a,0x1232306,0x105bd4e,
        0x28cd6a6,0x0a83813,0x1ee13b0,0x2abadc3,0x0c09684,0x00e33e1,
        0x033eea3,0x30f0a39,0x00a710e },
      { 0x01b1f7d,0x1c959da,0x017077a,0x254bf0a,0x086fbce,0x15cd6b2,
        0x008683f,0x23a4f4d,0x22a6bd6,0x14e8c93,0x0027d15,0x31d0d4f,
        0x271777e,0x1533510,0x00ab603 } },
    /* 182 */
    { { 0x34c209d,0x14d0abb,0x270432a,0x1d02358,0x22ba752,0x209757f,
        0x34af6fc,0x1ffc52e,0x1ced28e,0x1870e46,0x1e0340f,0x3f0bf73,
        0x33ba91d,0x2ebca7c,0x00c6580 },
      { 0x1d442cb,0x0879d50,0x24e4ae1,0x3f4e91c,0x04c7727,0x093cd1d,
        0x16d6a45,0x10a8b95,0x0c77856,0x361f84f,0x217845f,0x0bbeec6,
        0x0485718,0x33c5385,0x00dcec0 } },
    /* 183 */
    { { 0x1539819,0x225507a,0x1bf11cb,0x13e7653,0x0c8cb3b,0x05f695e,
        0x353f634,0x2827874,0x3fb8053,0x22de9a5,0x035d8b7,0x2105cc7,
        0x2a7a98d,0x35bed95,0x0085748 },
      { 0x1859c5d,0x00e51f0,0x22a21fd,0x3054d74,0x06ce965,0x328eab7,
        0x26a13e0,0x13bfc65,0x01d4fb1,0x36600b9,0x36dd3fc,0x01232ed,
        0x15bbaa9,0x0ad7a51,0x0089b18 } },
    /* 184 */
    { { 0x3360710,0x1eb5a90,0x136bd77,0x3bd57a6,0x0841287,0x12886c9,
        0x35c6700,0x21bc6eb,0x25f35ad,0x3bcb01c,0x0707e72,0x23e9943,
        0x03e5233,0x34bb622,0x002bf8e },
      { 0x16e0d6a,0x04b3d2d,0x290cb02,0x049a10c,0x350537e,0x22cf71b,
        0x3184a19,0x2dc8b62,0x2350210,0x3b4afa6,0x159781e,0x1d01b6d,
        0x1853440,0x16442f0,0x005a78d } },
    /* 185 */
    { { 0x348b02c,0x1ea8ab5,0x3b954d5,0x14684ac,0x0be5b34,0x11c4496,
        0x0a7a456,0x14f6eb7,0x11a3221,0x2d65f82,0x32eb1ea,0x09c4018,
        0x3f301f3,0x32e8a1c,0x00bd9ad },
      { 0x0543f7f,0x31e744e,0x1fefd1d,0x24a486c,0x1000220,0x3977e3b,
        0x1b3ef51,0x2512a1b,0x2049e6b,0x122232b,0x391a32b,0x2f4a7b1,
        0x1c13e71,0x081a9b4,0x00d3516 } },
    /* 186 */
    { { 0x1924f43,0x1ae5495,0x28d52ef,0x2b93e77,0x2d2f401,0x371a010,
        0x33e8d7a,0x06ed3f1,0x30c0d9d,0x2589fa9,0x3bf3567,0x2ecf8fa,
        0x2dee4c3,0x152b620,0x007e8a2 },
      { 0x1924407,0x01bd42d,0x044a089,0x18686b5,0x2f14a0e,0x17cdce3,
        0x0efa216,0x3c586a8,0x1d6ae71,0x375831f,0x3175894,0x20e43eb,
        0x34c009e,0x3480527,0x00d115c } },
    /* 187 */
    { { 0x12abf77,0x38b0769,0x25682f2,0x295508c,0x0c2a0dc,0x1259b73,
        0x023ea25,0x340e7b5,0x3c7cd0d,0x1f92324,0x176405c,0x1528894,
        0x18f2e1e,0x2c59c35,0x001efb5 },
      { 0x0fb1471,0x07e7665,0x141da75,0x07d9f4a,0x0fdb31e,0x0dccda6,
        0x074eb25,0x3d92a9b,0x11189a0,0x1b4c557,0x24b8d2b,0x0533f92,
        0x0e9e344,0x2fa3dea,0x008d5a4 } },
    /* 188 */
    { { 0x2669e98,0x1ad3514,0x2a035c9,0x08a3f50,0x24547f9,0x0a145d3,
        0x1c1319d,0x3fe833d,0x1ae064b,0x1e01734,0x246d27e,0x3a2f13c,
        0x01e1150,0x263f55e,0x00f89ef },
      { 0x2e0b63f,0x3e57db7,0x23a4b4f,0x11c8899,0x0ad8500,0x348f3a7,
        0x2918604,0x27d6409,0x1ce5001,0x38f94c2,0x29a508a,0x39bdc89,
        0x3a52c27,0x194899e,0x00e9376 } },
    /* 189 */
    { { 0x0368708,0x34a2730,0x2e1da04,0x0bd78c1,0x2c45887,0x0c44bfa,
        0x3a23de3,0x390b9db,0x1746efd,0x05c638e,0x1d20609,0x3263370,
        0x31987f0,0x2988529,0x005fa3c },
      { 0x0aa9f2a,0x20622f7,0x060deee,0x0c9626a,0x3312cc7,0x18ebac7,
        0x008dd6c,0x0ad4fe6,0x3db4ea6,0x1dc3f50,0x090b6e9,0x0aff8d2,
        0x26aa62c,0x18f3e90,0x00105f8 } },
    /* 190 */
    { { 0x38059ad,0x25e576c,0x3ea00b2,0x1fa4191,0x25686b7,0x2d1ce8f,
        0x30470ed,0x3478bbf,0x340f9b6,0x1c9e348,0x3d594ec,0x2ffe56e,
        0x3f23deb,0x0cd34e9,0x00f4b72 },
      { 0x1a83f0b,0x2166029,0x28b32a2,0x06a5c5a,0x20786c4,0x0944604,
        0x0901bd2,0x379b84e,0x221e2fe,0x0346d54,0x1f4eb59,0x01b8993,
        0x2462e08,0x25f9d8b,0x006c4c8 } },
    /* 191 */
    { { 0x0b41d9d,0x2e417ed,0x265bd10,0x199148e,0x3826ca4,0x1a67e8d,
        0x1bbd13b,0x23e414d,0x3d773bc,0x356e64c,0x0d2118a,0x0cb587f,
        0x25fd093,0x24fb529,0x00158c6 },
      { 0x2806e63,0x3ecaa39,0x251b4dd,0x3b2d779,0x2e31ed3,0x066f1a6,
        0x060e518,0x2c7e3e5,0x0d62c76,0x0d88a70,0x101970a,0x1e3c8c6,
        0x272b8bb,0x083e73b,0x0031f38 } },
    /* 192 */
    { { 0x09e1c72,0x072bcb0,0x0cf4e93,0x2604a64,0x00715f2,0x10c98b6,
        0x2ad81d9,0x234fcce,0x37a7304,0x1974a4a,0x1c7415f,0x14aaa93,
        0x19587b1,0x3f643f4,0x00c3d10 },
      { 0x1ddadd0,0x2cd715d,0x294cf76,0x14479ed,0x19f5f4a,0x0198c09,
        0x1ab7ebc,0x182c0bc,0x0879202,0x1807273,0x05d39da,0x2c7d868,
        0x29c4ec4,0x1b13ad2,0x006dcd7 } },
    /* 193 */
    { { 0x1c83f01,0x0245bff,0x24f90ba,0x112554f,0x2354c8b,0x3f17988,
        0x0c511af,0x39e1e9b,0x26ae95b,0x0ae551c,0x35b41a6,0x0120455,
        0x1e989cb,0x1b37aff,0x00fa2ae },
      { 0x324659a,0x1aef1c3,0x1c43637,0x3f530a2,0x313a999,0x326af62,
        0x134184e,0x2ac131c,0x3f6a789,0x30a300a,0x13e526e,0x2107af3,
        0x093a8ff,0x2479902,0x00442b1 } },
    /* 194 */
    { { 0x22b6e20,0x31b18be,0x18614ca,0x26fdb5a,0x197f29e,0x325b44b,
        0x0ab1dbb,0x042348a,0x3275e8e,0x15bae44,0x0077124,0x2cf5345,
        0x2803ad4,0x188f2a2,0x0061b20 },
      { 0x2a560b1,0x3ced069,0x3cf42c2,0x100e167,0x3879e1d,0x0936ff0,
        0x1b51450,0x14c55f3,0x3153bfa,0x2957423,0x2a93823,0x15f5dce,
        0x2c9a22f,0x16731a8,0x00a97f2 } },
    /* 195 */
    { { 0x18edbbb,0x18c5ef9,0x1f13c30,0x071e77f,0x225ade5,0x1b60f75,
        0x1beaf11,0x3e495ad,0x2441dd8,0x2fa00e2,0x32a87b6,0x00050f2,
        0x038de7f,0x0037d6d,0x00a885d },
      { 0x39e48bd,0x1d9e433,0x2768e9f,0x3c29458,0x3f0bdf9,0x35ed5f2,
        0x36709fa,0x176dc10,0x012f7c1,0x2df8547,0x1d90ee3,0x053c089,
        0x21a8d35,0x200cb0d,0x002e84e } },
    /* 196 */
    { { 0x23ec8d8,0x1d81f55,0x0cb7227,0x07f8e4d,0x2a66181,0x163f577,
        0x272e7af,0x131a8f2,0x2046229,0x25e6276,0x36bbefe,0x2cdc22f,
        0x17c8288,0x33dd4fb,0x000d524 },
      { 0x330c073,0x1a6728b,0x1cf369f,0x12e7707,0x2f0fa26,0x17c2abd,
        0x0a45680,0x26ebd13,0x3c7d19b,0x1c3d6c8,0x2abd110,0x064fd07,
        0x09b8339,0x02b4a9f,0x009e3e1 } },
    /* 197 */
    { { 0x0ae972f,0x2093c35,0x06e7a90,0x0af1ba1,0x243eef0,0x2748582,
        0x0606122,0x13a45f9,0x0acfe60,0x08a685e,0x0eb184b,0x015bc11,
        0x0cdf423,0x157fad5,0x004fcad },
      { 0x2728d15,0x3e5bceb,0x0331a0f,0x31b1a80,0x28a2680,0x3b94955,
        0x04cae07,0x176b57e,0x03ac5a6,0x3d7918b,0x22d23f4,0x0ae077f,
        0x1eb075d,0x006f16c,0x006e473 } },
    /* 198 */
    { { 0x38219b9,0x0475a2b,0x107a774,0x39946c6,0x1cb883c,0x004e0ed,
        0x087e571,0x25c3497,0x059982f,0x0a71f66,0x118305d,0x1aaf294,
        0x3a5dbaa,0x34be404,0x00725fe },
      { 0x3abd109,0x336ebea,0x2528487,0x15a1d61,0x0c0f8cf,0x2b56095,
        0x2591e68,0x3549a80,0x1d1debb,0x0701c6c,0x161e7e3,0x1f7fa2e,
        0x3dfe192,0x17e6498,0x0055f89 } },
    /* 199 */
    { { 0x175645b,0x26c036c,0x0b92f89,0x09ed96d,0x351f3a6,0x19ce67b,
        0x33ac8db,0x2f0828b,0x27fe400,0x0b9c5e1,0x1967b95,0x3324080,
        0x11de142,0x1d44fb3,0x003d596 },
      { 0x3979775,0x3af37b6,0x3e88d41,0x2f1a8b9,0x299ba61,0x085413c,
        0x1149a53,0x0beb40e,0x31427ba,0x239f708,0x357d836,0x1558c22,
        0x280a79f,0x1b255f6,0x002b6d1 } },
    /* 200 */
    { { 0x39ad982,0x3d79d89,0x01a684a,0x0b6722e,0x39bb4c9,0x39a6399,
        0x1ad44e0,0x3059f5e,0x048265f,0x33a2fa4,0x0c3a4cc,0x0d7df98,
        0x23a33f1,0x34e2e21,0x00a0a10 },
      { 0x386efd9,0x1c91f34,0x06c2e19,0x3e6d48d,0x00eefd3,0x2181ef2,
        0x2415f97,0x1d33b08,0x0625086,0x1e8aa3e,0x08c9d60,0x0ab427b,
        0x2764fa7,0x3b7943e,0x00cd9f0 } },
    /* 201 */
    { { 0x1a46d4d,0x0e471f4,0x1693063,0x0467ac0,0x22df51c,0x127a0f7,
        0x0498008,0x20e0b16,0x1aa8ad0,0x1923f42,0x2a74273,0x01761ce,
        0x1600ca4,0x187b87e,0x00ee49e },
      { 0x0c76f73,0x19daf92,0x0b2ad76,0x3d8049d,0x1d9c100,0x0fe1c63,
        0x0bb67c8,0x035cc44,0x02002fc,0x37b2169,0x344656a,0x1127879,
        0x1939bc0,0x0dd8df6,0x0028ce7 } },
    /* 202 */
    { { 0x0544ac7,0x26bdc91,0x042697e,0x356e804,0x1f2c658,0x2ceb7ef,
        0x2dec39f,0x02c1dcc,0x391a2df,0x2344beb,0x2171e20,0x3099c94,
        0x0fa548a,0x37216c9,0x00f820c },
      { 0x0f4cf77,0x29bbaa5,0x33c6307,0x34a5128,0x118c783,0x2dd06b1,
        0x139d4c0,0x2db912e,0x1153ffb,0x1075eb3,0x3a255e4,0x2892161,
        0x36d5006,0x125338c,0x0014fbc } },
    /* 203 */
    { { 0x1584e3c,0x0830314,0x00279b9,0x167df95,0x2c7733c,0x2108aef,
        0x0ce1398,0x35aaf89,0x012523b,0x3c46b6a,0x388e6de,0x01a2002,
        0x0582dde,0x19c7fa3,0x007b872 },
      { 0x1e53510,0x11bca1f,0x19684e7,0x267de5c,0x2492f8b,0x364a2b0,
        0x080bc77,0x2c6d47b,0x248432e,0x3ace44f,0x32028f6,0x0212198,
        0x2f38bad,0x20d63f0,0x00122bb } },
    /* 204 */
    { { 0x30b29c3,0x3cec78e,0x01510a9,0x0c93e91,0x3837b64,0x1eca3a9,
        0x105c921,0x05d42e6,0x1379845,0x07ce6f2,0x0e8b6da,0x0e0f093,
        0x220b2cd,0x1f6c041,0x00299f5 },
      { 0x0afdce3,0x2b0e596,0x2f477b6,0x2ccf417,0x3a15206,0x26ec0bf,
        0x2e37e2b,0x2593282,0x0ab9db3,0x2841dd8,0x27954be,0x277a681,
        0x03f82e2,0x2b610c7,0x00446a1 } },
    /* 205 */
    { { 0x06b8195,0x3b3a817,0x31b9c6f,0x317d279,0x3d744a7,0x1de9eb9,
        0x296acc1,0x1ce9ea3,0x06c3587,0x246815d,0x3756736,0x0588518,
        0x1c971a4,0x1fde1f4,0x00aa021 },
      { 0x3fd3226,0x274561d,0x00be61e,0x01393d8,0x30f6f23,0x29b7fc1,
        0x04cebc7,0x0a892a7,0x20109f1,0x27456be,0x0c863ee,0x2eb6c8a,
        0x38c782b,0x039397a,0x00a2829 } },
    /* 206 */
    { { 0x29de330,0x21fe80f,0x145b55b,0x1986570,0x012b260,0x2482fbc,
        0x0536e0a,0x16b7382,0x32c4d19,0x1deffdb,0x145f418,0x0c67a76,
        0x2ce477f,0x218fe24,0x00f9848 },
      { 0x3e37657,0x3f074d3,0x245ad0e,0x20973c3,0x23c58de,0x2c332ef,
        0x2ad21a8,0x0bf1589,0x208af95,0x1f4a8c4,0x2b43735,0x1e46657,
        0x15d4f81,0x0c3e63a,0x005f19d } },
    /* 207 */
    { { 0x26865bb,0x20f6683,0x16a672e,0x0efd8d1,0x222f5af,0x18f2367,
        0x1e9c734,0x25c3902,0x178dfe6,0x2903a79,0x311b91c,0x1adbbe9,
        0x225a387,0x0b3e509,0x0089551 },
      { 0x34e462b,0x23b6a32,0x27c884c,0x129104b,0x384c015,0x3adedc7,
        0x325db1c,0x021dc10,0x1e366f7,0x3054df7,0x1992b9a,0x2824e64,
        0x0ae77f3,0x181b526,0x00a7316 } },
    /* 208 */
    { { 0x2d260f5,0x2434bf2,0x28c0139,0x0a7bb03,0x176c3be,0x3def5f5,
        0x05bee00,0x3692df7,0x3d2efeb,0x3a6f859,0x1122b87,0x38f779a,
        0x1415ccc,0x2c260ad,0x0075a28 },
      { 0x04607a6,0x042f37a,0x3f0df68,0x0a1bd36,0x3c6d581,0x2d36bfa,
        0x2d577d1,0x0a3affa,0x0b2066b,0x2e6f110,0x0b17e84,0x3c76a5e,
        0x1a57553,0x012f36a,0x0004595 } },
    /* 209 */
    { { 0x29e5836,0x0e6808c,0x269d13e,0x147dc5c,0x32c9e7d,0x09b258e,
        0x2c58d6f,0x1efd716,0x0437996,0x34ec31b,0x15908d9,0x2efa8fd,
        0x09ad160,0x079fc1f,0x00d8481 },
      { 0x3d20e4a,0x18269d6,0x3aa8fe7,0x34829c2,0x2e4325d,0x0d800e1,
        0x11f370b,0x10c08dc,0x22fd092,0x1a5fe55,0x0acc443,0x037030d,
        0x1cdd404,0x097379e,0x00fd6d7 } },
    /* 210 */
    { { 0x313eafb,0x3f438f3,0x2e5fb3e,0x2ed6a82,0x121009c,0x240889e,
        0x00c5537,0x269b792,0x334b2fc,0x1dd573c,0x07096ae,0x19296fc,
        0x3813985,0x2742f48,0x00ddd64 },
      { 0x2045041,0x3842c62,0x1572d0d,0x04f255f,0x06e05b4,0x383ec97,
        0x1ff8064,0x18bed71,0x39b6411,0x2764cc5,0x257439f,0x3521217,
        0x172aa42,0x342a2a3,0x0070c5b } },
    /* 211 */
    { { 0x3bdf646,0x1c5ce25,0x1f7ca76,0x2d2acca,0x3aa1485,0x23c97f7,
        0x3e11d6f,0x0609338,0x07ec622,0x01da8ff,0x3392474,0x17ca07f,
        0x13a9a04,0x353a5b4,0x0024557 },
      { 0x14c27cd,0x32012f7,0x3fea875,0x3d03d71,0x211c5f0,0x3157fdf,
        0x0c880bd,0x3c406b2,0x2c51103,0x24ab377,0x399faa8,0x0d06887,
        0x16b5738,0x28b33a7,0x00c7b67 } },
    /* 212 */
    { { 0x2357586,0x35c93e3,0x0da09a0,0x3d77d92,0x11d7f4f,0x37b98a9,
        0x3e6c9bf,0x2cdca70,0x2f00389,0x2412673,0x18eab87,0x0101436,
        0x11617e9,0x06d9b01,0x00e8eef },
      { 0x37e3ca9,0x16ffaf0,0x391debf,0x1b69382,0x07c5e94,0x312fa8a,
        0x0973142,0x2cadde4,0x109ee67,0x3a07db0,0x1afc5ed,0x08df66f,
        0x304c7af,0x0804aae,0x00d2e60 } },
    /* 213 */
    { { 0x24f57bf,0x1818322,0x182a615,0x25bfc44,0x0f97586,0x0a5bbc0,
        0x36773c6,0x1a2660c,0x3ceff66,0x3270152,0x319cd11,0x2845845,
        0x1acfad6,0x19076f8,0x009824a },
      { 0x289fd01,0x2de97ee,0x39d80b7,0x026227d,0x0f8d3b8,0x15e0a17,
        0x21ea08f,0x20a2317,0x136ae6d,0x3deb1d1,0x3521ef5,0x0de8801,
        0x0a25d5d,0x0612c98,0x005ecc4 } },
    /* 214 */
    { { 0x308c8d3,0x3aec669,0x01ecddc,0x13f18fe,0x1e63ed0,0x061cfe5,
        0x05f5a01,0x1db5741,0x14479f2,0x0ced6b5,0x025ae5b,0x09ca8f5,
        0x2160581,0x1404433,0x008bfeb },
      { 0x08228bf,0x0e02722,0x37df423,0x33ecabf,0x34bd82a,0x32f529f,
        0x28f1800,0x0c8f671,0x1246b44,0x1ff35dc,0x091db95,0x303f3da,
        0x28f7f60,0x3624136,0x00cfbb4 } },
    /* 215 */
    { { 0x326139a,0x2977e4e,0x3eb89a6,0x20ecb31,0x13e076a,0x2a592f3,
        0x28e82d5,0x235ad1e,0x239b927,0x262938a,0x2444354,0x141b263,
        0x0d56693,0x2a3fc78,0x0006497 },
      { 0x31efa05,0x3a3664a,0x3e333de,0x2a114e4,0x12da63c,0x3c15e6b,
        0x2f7277c,0x363aa92,0x2393236,0x16bd2d1,0x32b617f,0x32b656c,
        0x3b1246c,0x22e2e22,0x00ce76d } },
    /* 216 */
    { { 0x03843dc,0x094de82,0x13b463d,0x0507905,0x089eb35,0x2a6bf25,
        0x35ebc4e,0x2bb5d45,0x1808ed1,0x1de9949,0x185e829,0x0a55847,
        0x0b73d67,0x1a2ed61,0x008dd2d },
      { 0x133c3a4,0x04e7980,0x38ea237,0x2ad2f49,0x19de838,0x018bf36,
        0x29b072c,0x21c1ba0,0x14f63ba,0x31c1cc3,0x13cd05e,0x20120ff,
        0x1f84d60,0x16e0321,0x00872ab } },
    /* 217 */
    { { 0x19d4d49,0x1ddb4e6,0x05e7fc0,0x37bb0fd,0x1a3eb59,0x36b87f0,
        0x190e440,0x1c7fef2,0x31ea153,0x14cd65a,0x1bc7ab2,0x11f72ca,
        0x39582d4,0x0fa4d65,0x00cd5b6 },
      { 0x3d1ff11,0x0d9be9d,0x2903ae3,0x017b7b9,0x259f28f,0x110cefc,
        0x03fed1a,0x38039bd,0x09bdf9c,0x3055027,0x2ca9c5d,0x2d737b6,
        0x3bdb421,0x16560b5,0x00f9f33 } },
    /* 218 */
    { { 0x022c792,0x110de25,0x38bf959,0x08f2562,0x1239ea9,0x3c1d950,
        0x21a247d,0x315112d,0x285bb9f,0x2534a73,0x0b42455,0x1a4a99c,
        0x069009a,0x1680392,0x006e0ca },
      { 0x1b3bece,0x269e0a1,0x18926b7,0x0e7187e,0x241f35e,0x39d1fe0,
        0x02099aa,0x1675bfe,0x23fd0ca,0x3d6322b,0x19406b5,0x324c38a,
        0x242434a,0x3ae677c,0x002ce04 } },
    /* 219 */
    { { 0x2c37b82,0x1ae6506,0x0d83436,0x23496c1,0x0ff0c72,0x2711edf,
        0x1513611,0x04f9c7d,0x1edbeff,0x376fcb5,0x212a683,0x23bf547,
        0x0f9c4f7,0x16e6627,0x0082cd8 },
      { 0x0cb5d37,0x31b6db8,0x1a15e23,0x2f5cbb8,0x0818aee,0x21dc6c5,
        0x12aafd2,0x205f608,0x1d91def,0x3def088,0x1445c51,0x3100e8a,
        0x3746bda,0x145c4b0,0x00711b0 } },
    /* 220 */
    { { 0x2a99ecc,0x27b5217,0x35e10ed,0x036e32a,0x0f79950,0x15c32f7,
        0x2c87dcb,0x3ebb2a3,0x2c2d35d,0x114b3ec,0x2e4d80a,0x0c7eb89,
        0x2abe58d,0x3727737,0x00e6a37 },
      { 0x1eca452,0x1968d07,0x344e5d3,0x29435a2,0x109a5f8,0x181d12c,
        0x238ea5a,0x127a564,0x00dbb42,0x0fcbfb7,0x2909b2e,0x2571d3a,
        0x08250e3,0x0694e4e,0x00e156d } },
    /* 221 */
    { { 0x3181ae9,0x1acf411,0x3808d79,0x2a11065,0x0baf44b,0x133cfeb,
        0x1330943,0x1711b9a,0x2dec3bd,0x1906a9a,0x2ed947c,0x369d763,
        0x1a5254f,0x104a7a9,0x00acd9d },
      { 0x030301b,0x31568f5,0x2a4965c,0x33ded4b,0x03c9a5b,0x16541fc,
        0x1319cf1,0x2a3748b,0x1b5de74,0x18bb82e,0x077ac2b,0x309a87a,
        0x3c31420,0x0f6a4b9,0x00387d7 } },
    /* 222 */
    { { 0x0d3fdac,0x120cfa3,0x1b8e13c,0x1ccccb9,0x376fcd4,0x0bf87f4,
        0x271b4be,0x363b3fd,0x28b5d98,0x0535cd3,0x114bbc1,0x3ab4f19,
        0x10494b1,0x2161ece,0x00d14ca },
      { 0x12d37e9,0x110ebd7,0x062295a,0x1cc0119,0x073c6ea,0x15d5411,
        0x0aeb4b1,0x23fba91,0x175fab5,0x3ee8fe1,0x1c680a6,0x1e76f27,
        0x3ddfc97,0x3d69ecd,0x00e1ee5 } },
    /* 223 */
    { { 0x2d29f46,0x2d19204,0x3137cd0,0x02c3b54,0x193295b,0x02fbdb2,
        0x2260948,0x22c02ff,0x3885424,0x1299595,0x00e7f9c,0x310ff2a,
        0x01ea169,0x0deef85,0x0021908 },
      { 0x1b26cfb,0x38566a8,0x2852875,0x21debff,0x290ca9f,0x0b29663,
        0x26550d9,0x2b44457,0x05d1938,0x1f8f825,0x366ef93,0x1d8daec,
        0x069e5ef,0x342ece6,0x00b6034 } },
    /* 224 */
    { { 0x2d8356e,0x1578c09,0x226f4d2,0x3b74c51,0x0f83666,0x0323b59,
        0x1ddf61d,0x1ed8508,0x3c52667,0x0e5b91c,0x1e9b18b,0x352bdfa,
        0x13f75da,0x352aa4e,0x00fceff },
      { 0x1c731d5,0x04e2844,0x01d9843,0x286cbc5,0x105bcb3,0x05edd9c,
        0x21fa956,0x3b1ec83,0x01288cc,0x22fbf3a,0x10f1b56,0x081cf72,
        0x15cb758,0x18687c1,0x00f5722 } },
    /* 225 */
    { { 0x2973088,0x1209dcd,0x3980f31,0x0221aa7,0x1c008e7,0x011b098,
        0x395947e,0x2f2806d,0x27dca76,0x037c79a,0x31acddf,0x2bf6219,
        0x0d8f4ab,0x13644d9,0x00ff705 },
      { 0x2260594,0x18d51f8,0x277e2cf,0x1cb5cec,0x2468a53,0x3e6f4d7,
        0x019e24e,0x0f30f1d,0x0202404,0x34ad287,0x090b39c,0x23c11ea,
        0x1a2e3a2,0x3a851be,0x00dca2c } },
    /* 226 */
    { { 0x3277538,0x221cd94,0x3738ab7,0x0973da5,0x1a734e2,0x2c8b8b0,
        0x2e1d1e6,0x348499b,0x389ebe1,0x18b1854,0x02bb076,0x1b2b500,
        0x0f207f3,0x170cf99,0x0012088 },
      { 0x0fbfec2,0x1df55a4,0x34ae59e,0x2ab5e95,0x3f9e781,0x3411794,
        0x1410b05,0x17c3a00,0x0aaa91b,0x074ed7c,0x3fbb352,0x3477c01,
        0x3ee9ab3,0x0cfb1ca,0x0011c4b } },
    /* 227 */
    { { 0x3c3a7f3,0x2e60ca0,0x2354d32,0x33e2362,0x28083ab,0x03d3b16,
        0x3164045,0x0a41f7a,0x3f0641e,0x38635d1,0x31bbf03,0x225e2bb,
        0x0cd894e,0x1f72228,0x0093244 },
      { 0x33d5897,0x383faf3,0x0e6d561,0x0bc4d80,0x3fc3a68,0x05a9adc,
        0x0b9d73d,0x3d6031e,0x2ded29b,0x339c4ff,0x08d69e5,0x089488c,
        0x3fda40a,0x295c7fd,0x003a924 } },
    /* 228 */
    { { 0x0093bee,0x115532d,0x2ec0fb6,0x0969631,0x3a6d65a,0x0f43b4d,
        0x26994d4,0x0b51104,0x2515515,0x3695a26,0x284caa8,0x397aa30,
        0x25538b8,0x353f47c,0x0033f05 },
      { 0x3615d6e,0x37f8246,0x07dae0f,0x23dc154,0x02ded7e,0x1eef320,
        0x1631e51,0x3447f75,0x13e267f,0x353e1d1,0x3f89d62,0x369c8ff,
        0x1a21dc6,0x2b8b8f3,0x0055cbc } },
    /* 229 */
    { { 0x34e84f3,0x2f2539a,0x2c35336,0x0c53bdc,0x1728630,0x3ad5fe6,
        0x05fdeee,0x3386db6,0x272a42e,0x29fd38c,0x36f0320,0x21b2ed4,
        0x331e67f,0x28ae48c,0x00f09b6 },
      { 0x2778435,0x0fb3c55,0x32d221d,0x2660c8e,0x32977ba,0x1c12f03,
        0x1b57fb1,0x01229a8,0x38b389f,0x375ddf3,0x2c6b42c,0x3885d3e,
        0x2c55a9c,0x2ffc279,0x00404e2 } },
    /* 230 */
    { { 0x04c5ddb,0x2c4d788,0x150e9b9,0x110fbfd,0x29dbfe0,0x30ef83d,
        0x2ab4bfe,0x395bcd7,0x30d0a43,0x0e2d30f,0x0e73f9b,0x07199cc,
        0x0c9054c,0x22f4b1e,0x0092ed3 },
      { 0x386e27c,0x00fdaa8,0x0507c70,0x1beb3b6,0x0b9c4f4,0x277d519,
        0x024ec85,0x1cbaba8,0x1524295,0x112be58,0x21fc119,0x273578b,
        0x2358c27,0x280ca07,0x00aa376 } },
    /* 231 */
    { { 0x0dbc95c,0x16488cf,0x337a078,0x1abbcb8,0x0aae1aa,0x1caa151,
        0x00108d4,0x1edf701,0x3e68d03,0x1203214,0x0c7eee2,0x084c572,
        0x07752d2,0x215a3b9,0x00195d3 },
      { 0x2cd7fbe,0x06e80f6,0x052bd4b,0x07b4f83,0x24b5ac6,0x2aaded4,
        0x13c0526,0x0ffa9a3,0x08c660e,0x13c35c9,0x3145efb,0x36cfe24,
        0x0936daf,0x268e3d0,0x00a73fd } },
    /* 232 */
    { { 0x31b17ce,0x2e7bcee,0x3f31891,0x19f1849,0x1140236,0x015487f,
        0x32e58d3,0x202204a,0x049e350,0x1ce91f9,0x3f75150,0x27f212f,
        0x0d16ee4,0x1c894c4,0x004023f },
      { 0x33399fa,0x2397b6d,0x2a3ea60,0x36354ca,0x1f12632,0x117a105,
        0x22758e8,0x361844e,0x3851fc2,0x0ab92db,0x339d02f,0x1e7d6c4,
        0x19ebd38,0x0a9a036,0x00446d2 } },
    /* 233 */
    { { 0x3e164f1,0x008c092,0x19200f5,0x35a22e0,0x38d09d2,0x212b3bf,
        0x0056f19,0x3a03545,0x1f075e9,0x0e97137,0x1f496a9,0x32d1f9b,
        0x36bf738,0x35ace37,0x00899e1 },
      { 0x19eb2a6,0x21fa22d,0x338b69e,0x18e6d1f,0x1280d9d,0x1953a55,
        0x1411ea3,0x2960566,0x0fd969a,0x1f3e375,0x130742a,0x170aebd,
        0x33085ff,0x14d868d,0x00a4391 } },
    /* 234 */
    { { 0x0a4bdd2,0x39ca8ea,0x37026ac,0x346da3b,0x0c656cd,0x03136b6,
        0x233e7e9,0x0714352,0x08a9d95,0x192bb38,0x085d68e,0x20016b8,
        0x102b8ea,0x1f5dbdd,0x00fdd7a },
      { 0x0d6fa45,0x3ec29a6,0x2b8cce6,0x1c84413,0x0228f86,0x28275f7,
        0x3d8787d,0x0c19748,0x28b2ae9,0x1954850,0x2a56c36,0x3eae8f7,
        0x0aca595,0x00e42a2,0x00edbe5 } },
    /* 235 */
    { { 0x3b26c82,0x3682b6f,0x2f9cd64,0x0f254b0,0x0e5d70b,0x1f9dfda,
        0x28f365f,0x35a57d7,0x00208f2,0x19c8d38,0x112e7be,0x3e403bb,
        0x3734efa,0x24d12b3,0x0027dc6 },
      { 0x260a46a,0x13fd7b0,0x1c2880e,0x338b70c,0x27da5eb,0x29a7d54,
        0x1c5d73c,0x2130921,0x32969cc,0x2b37eda,0x2d6d4ec,0x0716bfb,
        0x0763703,0x1320889,0x00c7bbf } },
    /* 236 */
    { { 0x1fe01b2,0x2dcb1d2,0x11b89d5,0x219e4ea,0x0347851,0x3d1810e,
        0x3a3c54c,0x06dbe8e,0x03d3ab2,0x2dcfa39,0x3e57b8a,0x337a382,
        0x0426450,0x0e9f748,0x006488b },
      { 0x1dc4582,0x0e62cf7,0x06fea9e,0x2a56fb1,0x31698c1,0x15b4e10,
        0x1446ef1,0x0a689fc,0x1d87703,0x20ff497,0x2c71066,0x2c48868,
        0x2e6cf05,0x30aa9cb,0x0065b2d } },
    /* 237 */
    { { 0x1021d63,0x2217df3,0x1f0821a,0x057fa98,0x23f344b,0x173dcf9,
        0x1ba6ddc,0x22c8eb5,0x18f227a,0x0455343,0x1c55931,0x1d0dcf3,
        0x20fa19b,0x1c56618,0x004feab },
      { 0x19ec924,0x224e39f,0x2550509,0x179b51f,0x284d54a,0x2d85d41,
        0x2d1bdc1,0x1a29068,0x3826158,0x1267f85,0x3005a92,0x0769e00,
        0x379b617,0x17b5f63,0x00a70bf } },
    /* 238 */
    { { 0x22216c5,0x049437f,0x33510bc,0x141d806,0x22c37e2,0x1bc1adf,
        0x300175d,0x2e6ded8,0x0a18bfe,0x35377a3,0x382f843,0x08410ca,
        0x00afd4f,0x0be6c6b,0x008d70e },
      { 0x2e91abb,0x1cede2a,0x28f225c,0x28e18c0,0x30230dc,0x173cc2d,
        0x123ecfe,0x3c9962e,0x2c25506,0x27b5d53,0x329a5e3,0x106e231,
        0x3889b8e,0x3b0aeaf,0x00ee67c } },
    /* 239 */
    { { 0x3e46c65,0x0eb3d46,0x1d7ae18,0x23f9d59,0x2978953,0x2589ed3,
        0x073391d,0x2461e1e,0x0c19f1d,0x22fd2b1,0x0691f5c,0x2e67d8d,
        0x1fb985d,0x200dd28,0x00a68df },
      { 0x392b5fa,0x123b46f,0x1c323c4,0x104f82f,0x0a098c8,0x26fc05b,
        0x34cd557,0x0913639,0x09c115e,0x3977c34,0x3410b66,0x062b404,
        0x0213094,0x132c5e8,0x008b612 } },
    /* 240 */
    { { 0x26e3392,0x3b0ebf0,0x2e00425,0x1c285c8,0x3c07f84,0x08d5ad0,
        0x028190e,0x1669b73,0x1ffb1ef,0x053b65f,0x063028c,0x0aceb47,
        0x18988c2,0x0f09a30,0x0007072 },
      { 0x0f49e7d,0x28c0bd3,0x252270d,0x24cfc4a,0x0c5e87c,0x2165052,
        0x2cdd1d1,0x04931d2,0x3abca74,0x22b57dc,0x169fd47,0x0b928fb,
        0x17cc3e7,0x21a1ec4,0x0061593 } },
    /* 241 */
    { { 0x1aa0486,0x2e55dea,0x15577b7,0x0d6818f,0x36e41fb,0x2a411f5,
        0x17d5c7d,0x1eea6c0,0x28068a8,0x0e31d20,0x1f08ad9,0x117e973,
        0x08a28ab,0x085d30a,0x00cd9fb },
      { 0x347843d,0x1119095,0x11e3595,0x1b29584,0x134d64c,0x2ff3a35,
        0x247ea14,0x099fc4b,0x2056169,0x145dd03,0x2ed03fb,0x1250e3b,
        0x3f5135c,0x2b753f0,0x009da30 } },
    /* 242 */
    { { 0x0fa5200,0x214a0b3,0x313dc4e,0x23da866,0x3270760,0x15c9b8b,
        0x39a53df,0x1f79772,0x3c9e942,0x2984901,0x154d582,0x1685f87,
        0x2e1183e,0x1f79956,0x00b9987 },
      { 0x15254de,0x3a5cac0,0x37c56f0,0x2c7c29b,0x292a56d,0x195be2c,
        0x17e4e1a,0x0660f4a,0x052ad98,0x1267f80,0x07cfed8,0x194b4bc,
        0x01738d3,0x14ba10f,0x00c7843 } },
    /* 243 */
    { { 0x29b2d8a,0x242bc1f,0x19646ee,0x0615f3c,0x0ac8d70,0x07ca3bf,
        0x2d90317,0x2c83bdb,0x1a96812,0x39fdc35,0x31c61ee,0x2d55fd3,
        0x2375827,0x355f189,0x00f1c9b },
      { 0x21a6194,0x1f4050a,0x2b845cf,0x02c6242,0x2dd614e,0x3a4f0a9,
        0x39de100,0x24714fb,0x175e0cd,0x0be633d,0x14befc3,0x13b0318,
        0x1d68c50,0x299989e,0x00d0513 } },
    /* 244 */
    { { 0x059fb6a,0x2b6eb6a,0x3666a8e,0x39f6ca0,0x1cf8346,0x388b8d5,
        0x35e61a3,0x271adec,0x22c9963,0x20a4fb3,0x16f241c,0x0058b89,
        0x21ddafa,0x1ee6fde,0x00d2e6c },
      { 0x0075e63,0x39894d0,0x0286d0d,0x187e7b2,0x02405aa,0x3f91525,
        0x37830a8,0x2723088,0x2c7364e,0x013f406,0x104ba75,0x270f486,
        0x3520b4d,0x3852bc6,0x00d589b } },
    /* 245 */
    { { 0x262e53b,0x1da93d1,0x3676135,0x147e41d,0x335ec2f,0x1f02be5,
        0x297d139,0x22d6198,0x1fe9e59,0x13b4c80,0x1e70f60,0x2f1d4a9,
        0x2d95149,0x14d6ec4,0x00b54af },
      { 0x12c1c76,0x2930ac8,0x0dfd36e,0x31fac94,0x218f5bb,0x2828691,
        0x1466cc9,0x3645e83,0x1a4dac2,0x1549593,0x0e95fab,0x19567d2,
        0x27a3320,0x0642729,0x007487c } },
    /* 246 */
    { { 0x1e98e9c,0x2ff8df7,0x119975a,0x098a904,0x099b90b,0x336c7df,
        0x010996d,0x159d46d,0x3118b3b,0x3aacd1b,0x31f8ae1,0x214864f,
        0x398c104,0x089dae2,0x001ec4d },
      { 0x1452baa,0x2f24991,0x2572ba3,0x162b312,0x2387d18,0x147c5c7,
        0x38eff6e,0x0700251,0x37d931e,0x23cd5c1,0x254c8ca,0x3b9df37,
        0x1c9a4ff,0x0bfd547,0x00fb489 } },
    /* 247 */
    { { 0x1b8dff8,0x2f6b40b,0x05a25b1,0x3f5688a,0x1d462f4,0x2802d18,
        0x2aad8ed,0x1b46c75,0x3cf4130,0x250fefb,0x2a13fe1,0x23a1bcd,
        0x0940442,0x04605fe,0x00c8b2f },
      { 0x0d51afb,0x14a2abc,0x1d06762,0x291526c,0x2a3e2fe,0x28f77d9,
        0x3ad8f2e,0x3481a1b,0x04b4fbd,0x2836733,0x0189ff5,0x3a5f533,
        0x319a6cd,0x0f58667,0x00c3679 } },
    /* 248 */
    { { 0x1b85197,0x22426d4,0x2895ea3,0x342d324,0x3ffb17d,0x376cfcf,
        0x30878b1,0x3c3c83a,0x0ffc57c,0x0ac174a,0x1abd57e,0x2f78b9c,
        0x01b20d8,0x0a37103,0x007f2be },
      { 0x19a2d48,0x137288a,0x182d655,0x0ba0dde,0x25130ba,0x01c65c6,
        0x23205f1,0x2097621,0x2827cf2,0x2c57b98,0x03748f2,0x2db15fc,
        0x385a0d4,0x13690c0,0x00a9e3f } },
    /* 249 */
    { { 0x3fbc9c6,0x2df3b20,0x377e33e,0x31d1505,0x024a311,0x3c1d9ff,
        0x1377f74,0x00b6b20,0x2364ab7,0x184ab6b,0x2a77969,0x3f2db6c,
        0x2a6adb7,0x0a10073,0x004a6fb },
      { 0x1fc73de,0x2c74ab3,0x3d325e8,0x2346c0b,0x1d0efae,0x2076146,
        0x19c190d,0x225c4fe,0x3fafc80,0x2cf063d,0x11b7ae7,0x3dc4f9d,
        0x3c3f841,0x10d7c1f,0x000a4b3 } },
    /* 250 */
    { { 0x19b7d2e,0x28f1300,0x0b897dd,0x06b5371,0x0631c8d,0x336cc4f,
        0x09cd6e1,0x2ec1952,0x1104c07,0x07512bb,0x35f000d,0x25f84e9,
        0x1df4d8f,0x193f769,0x000e9ee },
      { 0x2346910,0x267cecf,0x0ad7eaa,0x087e8a5,0x1622f69,0x342cbfa,
        0x2aa20d0,0x206e88a,0x3991e58,0x093fb4b,0x0157180,0x3cecb5b,
        0x2e17c9a,0x1ea371f,0x00919e6 } },
    /* 251 */
    { { 0x2250533,0x13f931d,0x3ef8c72,0x395f605,0x18a2080,0x1cb25d4,
        0x2fb0f41,0x1c0ba8a,0x1eb17c0,0x266c433,0x09b7e3e,0x0e5d78f,
        0x0cdc5bf,0x1f7c734,0x0020611 },
      { 0x205ebd5,0x127986f,0x02c0fb0,0x1705b1e,0x1eb0bb5,0x2dffb42,
        0x2331b8a,0x18fc04e,0x31d6328,0x17db162,0x0d3b619,0x193bdb9,
        0x3f11662,0x2d8e694,0x0092c51 } },
    /* 252 */
    { { 0x08b364d,0x31ef20a,0x25c4a57,0x021ed07,0x14a562e,0x262a684,
        0x1d21c66,0x126e5a6,0x181f3f8,0x2a93b65,0x1eb726b,0x08fbbce,
        0x084f9a2,0x308f30a,0x0013159 },
      { 0x23f4963,0x0c7960e,0x2a81739,0x2242b69,0x3965003,0x2aca542,
        0x28a1c65,0x2ad48fb,0x149775f,0x1bbb7d2,0x0f2671b,0x3594b85,
        0x22f5563,0x2470f13,0x00fed44 } },
    /* 253 */
    { { 0x0eb453e,0x3ab70fd,0x1a5b335,0x18f2b74,0x25ff74b,0x3612a46,
        0x33d0d75,0x28cdda4,0x2b9b49b,0x22728fb,0x004c15b,0x1beb33b,
        0x1a7e41f,0x0c9b702,0x004ef19 },
      { 0x1ca3233,0x0b4c90f,0x1d4b53d,0x2428896,0x20ee405,0x151bc00,
        0x022edb5,0x1adc463,0x00109ea,0x06490a6,0x30e91e6,0x3682b76,
        0x23c50aa,0x3bd2665,0x005fe53 } },
    /* 254 */
    { { 0x0c28c65,0x3741ae4,0x247d372,0x0b04673,0x2176524,0x2c8bf20,
        0x01fb806,0x3330701,0x307b0a7,0x3999fb7,0x1261bec,0x256679c,
        0x3f22ac7,0x26e8673,0x00bc69d },
      { 0x3c06819,0x35df344,0x379d009,0x2bb8a0a,0x0635a66,0x096c6fa,
        0x1ac4a62,0x023e53b,0x0e45240,0x115f53d,0x3056af8,0x0a66b16,
        0x3c386ee,0x1130e82,0x00cc384 } },
    /* 255 */
    { { 0x14c2356,0x190ec73,0x07be490,0x145d415,0x0740a48,0x1251301,
        0x3eaf29d,0x2628190,0x079299a,0x26e95c9,0x2e05fdf,0x2ca7c5b,
        0x32d7b48,0x3d84226,0x0033fb4 },
      { 0x150f955,0x01240aa,0x3ddf867,0x137fb70,0x297e103,0x17eeda8,
        0x1320b60,0x266ec84,0x13f4322,0x0c8f5ee,0x0590e4a,0x386815e,
        0x00ce61f,0x161bd63,0x008e1d0 } },
};

/* Multiply the base point of P384 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * Stripe implementation.
 * Pre-generated: 2^0, 2^48, ...
 * Pre-generated: products of all combinations of above.
 * 8 doubles and adds (with qz=1)
 *
 * r     Resulting point.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_384_ecc_mulmod_base_15(sp_point_384* r, const sp_digit* k,
        int map, void* heap)
{
    return sp_384_ecc_mulmod_stripe_15(r, &p384_base, p384_table,
                                      k, map, heap);
}

#endif

/* Multiply the base point of P384 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * km    Scalar to multiply by.
 * r     Resulting point.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_mulmod_base_384(const mp_int* km, ecc_point* r, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_384 p;
    sp_digit kd[15];
#endif
    sp_point_384* point;
    sp_digit* k = NULL;
    int err = MP_OKAY;

    err = sp_384_point_new_15(heap, p, point);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * 15, heap, DYNAMIC_TYPE_ECC);
        if (k == NULL) {
            err = MEMORY_E;
        }
    }
#else
    k = kd;
#endif
    if (err == MP_OKAY) {
        sp_384_from_mp(k, 15, km);

            err = sp_384_ecc_mulmod_base_15(point, k, map, heap);
    }
    if (err == MP_OKAY) {
        err = sp_384_point_to_ecc_point_15(point, r);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_384_point_free_15(point, 0, heap);

    return err;
}

/* Multiply the base point of P384 by the scalar, add point a and return
 * the result. If map is true then convert result to affine coordinates.
 *
 * km      Scalar to multiply by.
 * am      Point to add to scalar mulitply result.
 * inMont  Point to add is in montogmery form.
 * r       Resulting point.
 * map     Indicates whether to convert result to affine.
 * heap    Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_mulmod_base_add_384(const mp_int* km, const ecc_point* am,
        int inMont, ecc_point* r, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_384 p;
    sp_point_384 a;
    sp_digit kd[15];
    sp_digit t[15 * 2 * 6];
#endif
    sp_point_384* point;
    sp_point_384* addP = NULL;
    sp_digit* tmp = NULL;
    sp_digit* k = NULL;
    int err = MP_OKAY;

    err = sp_384_point_new_15(heap, p, point);
    if (err == MP_OKAY) {
        err = sp_384_point_new_15(heap, a, addP);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * (15 + 15 * 2 * 6), heap, DYNAMIC_TYPE_ECC);
        if (k == NULL) {
            err = MEMORY_E;
        }
        else {
            tmp = k + 15;
        }
    }
#else
    k = kd;
    tmp = t;
#endif
    if (err == MP_OKAY) {
        sp_384_from_mp(k, 15, km);
        sp_384_point_from_ecc_point_15(addP, am);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_384_mod_mul_norm_15(addP->x, addP->x, p384_mod);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_384_mod_mul_norm_15(addP->y, addP->y, p384_mod);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_384_mod_mul_norm_15(addP->z, addP->z, p384_mod);
    }
    if (err == MP_OKAY) {
            err = sp_384_ecc_mulmod_base_15(point, k, 0, heap);
    }
    if (err == MP_OKAY) {
            sp_384_proj_point_add_15(point, point, addP, tmp);

        if (map) {
            sp_384_map_15(point, point, tmp);
        }

        err = sp_384_point_to_ecc_point_15(point, r);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_384_point_free_15(addP, 0, heap);
    sp_384_point_free_15(point, 0, heap);

    return err;
}

#if defined(WOLFSSL_VALIDATE_ECC_KEYGEN) || defined(HAVE_ECC_SIGN) || \
                                                        defined(HAVE_ECC_VERIFY)
/* Returns 1 if the number of zero.
 * Implementation is constant time.
 *
 * a  Number to check.
 * returns 1 if the number is zero and 0 otherwise.
 */
static int sp_384_iszero_15(const sp_digit* a)
{
    return (a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7] |
            a[8] | a[9] | a[10] | a[11] | a[12] | a[13] | a[14]) == 0;
}

#endif /* WOLFSSL_VALIDATE_ECC_KEYGEN | HAVE_ECC_SIGN | HAVE_ECC_VERIFY */
/* Add 1 to a. (a = a + 1)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_384_add_one_15(sp_digit* a)
{
    a[0]++;
    sp_384_norm_15(a);
}

/* Read big endian unsigned byte array into r.
 *
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  Byte array.
 * n  Number of bytes in array to read.
 */
static void sp_384_from_bin(sp_digit* r, int size, const byte* a, int n)
{
    int i;
    int j = 0;
    word32 s = 0;

    r[0] = 0;
    for (i = n-1; i >= 0; i--) {
        r[j] |= (((sp_digit)a[i]) << s);
        if (s >= 18U) {
            r[j] &= 0x3ffffff;
            s = 26U - s;
            if (j + 1 >= size) {
                break;
            }
            r[++j] = (sp_digit)a[i] >> s;
            s = 8U - s;
        }
        else {
            s += 8U;
        }
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
}

/* Generates a scalar that is in the range 1..order-1.
 *
 * rng  Random number generator.
 * k    Scalar value.
 * returns RNG failures, MEMORY_E when memory allocation fails and
 * MP_OKAY on success.
 */
static int sp_384_ecc_gen_k_15(WC_RNG* rng, sp_digit* k)
{
    int err;
    byte buf[48];

    do {
        err = wc_RNG_GenerateBlock(rng, buf, sizeof(buf));
        if (err == 0) {
            sp_384_from_bin(k, 15, buf, (int)sizeof(buf));
            if (sp_384_cmp_15(k, p384_order2) < 0) {
                sp_384_add_one_15(k);
                break;
            }
        }
    }
    while (err == 0);

    return err;
}

/* Makes a random EC key pair.
 *
 * rng   Random number generator.
 * priv  Generated private value.
 * pub   Generated public point.
 * heap  Heap to use for allocation.
 * returns ECC_INF_E when the point does not have the correct order, RNG
 * failures, MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_make_key_384(WC_RNG* rng, mp_int* priv, ecc_point* pub, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_384 p;
    sp_digit kd[15];
#ifdef WOLFSSL_VALIDATE_ECC_KEYGEN
    sp_point_384 inf;
#endif
#endif
    sp_point_384* point;
    sp_digit* k = NULL;
#ifdef WOLFSSL_VALIDATE_ECC_KEYGEN
    sp_point_384* infinity;
#endif
    int err;

    (void)heap;

    err = sp_384_point_new_15(heap, p, point);
#ifdef WOLFSSL_VALIDATE_ECC_KEYGEN
    if (err == MP_OKAY) {
        err = sp_384_point_new_15(heap, inf, infinity);
    }
#endif
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * 15, heap,
                                                              DYNAMIC_TYPE_ECC);
        if (k == NULL) {
            err = MEMORY_E;
        }
    }
#else
    k = kd;
#endif

    if (err == MP_OKAY) {
        err = sp_384_ecc_gen_k_15(rng, k);
    }
    if (err == MP_OKAY) {
            err = sp_384_ecc_mulmod_base_15(point, k, 1, NULL);
    }

#ifdef WOLFSSL_VALIDATE_ECC_KEYGEN
    if (err == MP_OKAY) {
            err = sp_384_ecc_mulmod_15(infinity, point, p384_order, 1, NULL);
    }
    if (err == MP_OKAY) {
        if ((sp_384_iszero_15(point->x) == 0) || (sp_384_iszero_15(point->y) == 0)) {
            err = ECC_INF_E;
        }
    }
#endif

    if (err == MP_OKAY) {
        err = sp_384_to_mp(k, priv);
    }
    if (err == MP_OKAY) {
        err = sp_384_point_to_ecc_point_15(point, pub);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
#ifdef WOLFSSL_VALIDATE_ECC_KEYGEN
    sp_384_point_free_15(infinity, 1, heap);
#endif
    sp_384_point_free_15(point, 1, heap);

    return err;
}

#ifdef HAVE_ECC_DHE
/* Write r as big endian to byte array.
 * Fixed length number of bytes written: 48
 *
 * r  A single precision integer.
 * a  Byte array.
 */
static void sp_384_to_bin(sp_digit* r, byte* a)
{
    int i;
    int j;
    int s = 0;
    int b;

    for (i=0; i<14; i++) {
        r[i+1] += r[i] >> 26;
        r[i] &= 0x3ffffff;
    }
    j = 384 / 8 - 1;
    a[j] = 0;
    for (i=0; i<15 && j>=0; i++) {
        b = 0;
        /* lint allow cast of mismatch sp_digit and int */
        a[j--] |= (byte)(r[i] << s); /*lint !e9033*/
        b += 8 - s;
        if (j < 0) {
            break;
        }
        while (b < 26) {
            a[j--] = (byte)(r[i] >> b);
            b += 8;
            if (j < 0) {
                break;
            }
        }
        s = 8 - (b - 26);
        if (j >= 0) {
            a[j] = 0;
        }
        if (s != 0) {
            j++;
        }
    }
}

/* Multiply the point by the scalar and serialize the X ordinate.
 * The number is 0 padded to maximum size on output.
 *
 * priv    Scalar to multiply the point by.
 * pub     Point to multiply.
 * out     Buffer to hold X ordinate.
 * outLen  On entry, size of the buffer in bytes.
 *         On exit, length of data in buffer in bytes.
 * heap    Heap to use for allocation.
 * returns BUFFER_E if the buffer is to small for output size,
 * MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_secret_gen_384(const mp_int* priv, const ecc_point* pub, byte* out,
                          word32* outLen, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_384 p;
    sp_digit kd[15];
#endif
    sp_point_384* point = NULL;
    sp_digit* k = NULL;
    int err = MP_OKAY;

    if (*outLen < 48U) {
        err = BUFFER_E;
    }

    if (err == MP_OKAY) {
        err = sp_384_point_new_15(heap, p, point);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * 15, heap,
                                                              DYNAMIC_TYPE_ECC);
        if (k == NULL)
            err = MEMORY_E;
    }
#else
    k = kd;
#endif

    if (err == MP_OKAY) {
        sp_384_from_mp(k, 15, priv);
        sp_384_point_from_ecc_point_15(point, pub);
            err = sp_384_ecc_mulmod_15(point, point, k, 1, heap);
    }
    if (err == MP_OKAY) {
        sp_384_to_bin(point->x, out);
        *outLen = 48;
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_384_point_free_15(point, 0, heap);

    return err;
}
#endif /* HAVE_ECC_DHE */

#if defined(HAVE_ECC_SIGN) || defined(HAVE_ECC_VERIFY)
#endif
#if defined(HAVE_ECC_SIGN) || defined(HAVE_ECC_VERIFY)
/* Multiply a by scalar b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_384_mul_d_15(sp_digit* r, const sp_digit* a,
    sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 15; i++) {
        t += tb * a[i];
        r[i] = t & 0x3ffffff;
        t >>= 26;
    }
    r[15] = (sp_digit)t;
#else
    int64_t tb = b;
    int64_t t[15];

    t[ 0] = tb * a[ 0];
    t[ 1] = tb * a[ 1];
    t[ 2] = tb * a[ 2];
    t[ 3] = tb * a[ 3];
    t[ 4] = tb * a[ 4];
    t[ 5] = tb * a[ 5];
    t[ 6] = tb * a[ 6];
    t[ 7] = tb * a[ 7];
    t[ 8] = tb * a[ 8];
    t[ 9] = tb * a[ 9];
    t[10] = tb * a[10];
    t[11] = tb * a[11];
    t[12] = tb * a[12];
    t[13] = tb * a[13];
    t[14] = tb * a[14];
    r[ 0] =                           (t[ 0] & 0x3ffffff);
    r[ 1] = (sp_digit)(t[ 0] >> 26) + (t[ 1] & 0x3ffffff);
    r[ 2] = (sp_digit)(t[ 1] >> 26) + (t[ 2] & 0x3ffffff);
    r[ 3] = (sp_digit)(t[ 2] >> 26) + (t[ 3] & 0x3ffffff);
    r[ 4] = (sp_digit)(t[ 3] >> 26) + (t[ 4] & 0x3ffffff);
    r[ 5] = (sp_digit)(t[ 4] >> 26) + (t[ 5] & 0x3ffffff);
    r[ 6] = (sp_digit)(t[ 5] >> 26) + (t[ 6] & 0x3ffffff);
    r[ 7] = (sp_digit)(t[ 6] >> 26) + (t[ 7] & 0x3ffffff);
    r[ 8] = (sp_digit)(t[ 7] >> 26) + (t[ 8] & 0x3ffffff);
    r[ 9] = (sp_digit)(t[ 8] >> 26) + (t[ 9] & 0x3ffffff);
    r[10] = (sp_digit)(t[ 9] >> 26) + (t[10] & 0x3ffffff);
    r[11] = (sp_digit)(t[10] >> 26) + (t[11] & 0x3ffffff);
    r[12] = (sp_digit)(t[11] >> 26) + (t[12] & 0x3ffffff);
    r[13] = (sp_digit)(t[12] >> 26) + (t[13] & 0x3ffffff);
    r[14] = (sp_digit)(t[13] >> 26) + (t[14] & 0x3ffffff);
    r[15] = (sp_digit)(t[14] >> 26);
#endif /* WOLFSSL_SP_SMALL */
}

#ifdef WOLFSSL_SP_DIV_32
static WC_INLINE sp_digit sp_384_div_word_15(sp_digit d1, sp_digit d0,
    sp_digit dv)
{
    sp_digit d;
    sp_digit r;
    sp_digit t;

    /* All 26 bits from d1 and top 5 bits from d0. */
    d = (d1 << 5) | (d0 >> 21);
    r = d / dv;
    d -= r * dv;
    /* Up to 6 bits in r */
    /* Next 5 bits from d0. */
    r <<= 5;
    d <<= 5;
    d |= (d0 >> 16) & ((1 << 5) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 11 bits in r */
    /* Next 5 bits from d0. */
    r <<= 5;
    d <<= 5;
    d |= (d0 >> 11) & ((1 << 5) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 16 bits in r */
    /* Next 5 bits from d0. */
    r <<= 5;
    d <<= 5;
    d |= (d0 >> 6) & ((1 << 5) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 21 bits in r */
    /* Next 5 bits from d0. */
    r <<= 5;
    d <<= 5;
    d |= (d0 >> 1) & ((1 << 5) - 1);
    t = d / dv;
    d -= t * dv;
    r += t;
    /* Up to 26 bits in r */
    /* Remaining 1 bits from d0. */
    r <<= 1;
    d <<= 1;
    d |= d0 & ((1 << 1) - 1);
    t = d / dv;
    r += t;

    return r;
}
#endif /* WOLFSSL_SP_DIV_32 */

/* Divide d in a and put remainder into r (m*d + r = a)
 * m is not calculated as it is not needed at this time.
 *
 * a  Number to be divided.
 * d  Number to divide with.
 * m  Multiplier result.
 * r  Remainder from the division.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_384_div_15(const sp_digit* a, const sp_digit* d,
        const sp_digit* m, sp_digit* r)
{
    int i;
#ifndef WOLFSSL_SP_DIV_32
    int64_t d1;
#endif
    sp_digit dv;
    sp_digit r1;
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit t1d[30];
    sp_digit t2d[15 + 1];
#endif
    sp_digit* t1;
    sp_digit* t2;
    int err = MP_OKAY;

    (void)m;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * (3 * 15 + 1), NULL,
                                                       DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t1 = td;
        t2 = td + 2 * 15;
#else
        t1 = t1d;
        t2 = t2d;
#endif

        dv = d[14];
        XMEMCPY(t1, a, sizeof(*t1) * 2U * 15U);
        for (i=14; i>=0; i--) {
            t1[15 + i] += t1[15 + i - 1] >> 26;
            t1[15 + i - 1] &= 0x3ffffff;
#ifndef WOLFSSL_SP_DIV_32
            d1 = t1[15 + i];
            d1 <<= 26;
            d1 += t1[15 + i - 1];
            r1 = (sp_digit)(d1 / dv);
#else
            r1 = sp_384_div_word_15(t1[15 + i], t1[15 + i - 1], dv);
#endif

            sp_384_mul_d_15(t2, d, r1);
            (void)sp_384_sub_15(&t1[i], &t1[i], t2);
            t1[15 + i] -= t2[15];
            t1[15 + i] += t1[15 + i - 1] >> 26;
            t1[15 + i - 1] &= 0x3ffffff;
            r1 = (((-t1[15 + i]) << 26) - t1[15 + i - 1]) / dv;
            r1++;
            sp_384_mul_d_15(t2, d, r1);
            (void)sp_384_add_15(&t1[i], &t1[i], t2);
            t1[15 + i] += t1[15 + i - 1] >> 26;
            t1[15 + i - 1] &= 0x3ffffff;
        }
        t1[15 - 1] += t1[15 - 2] >> 26;
        t1[15 - 2] &= 0x3ffffff;
        r1 = t1[15 - 1] / dv;

        sp_384_mul_d_15(t2, d, r1);
        (void)sp_384_sub_15(t1, t1, t2);
        XMEMCPY(r, t1, sizeof(*r) * 2U * 15U);
        for (i=0; i<14; i++) {
            r[i+1] += r[i] >> 26;
            r[i] &= 0x3ffffff;
        }
        sp_384_cond_add_15(r, r, d, 0 - ((r[14] < 0) ?
                    (sp_digit)1 : (sp_digit)0));
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
}

/* Reduce a modulo m into r. (r = a mod m)
 *
 * r  A single precision number that is the reduced result.
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_384_mod_15(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    return sp_384_div_15(a, m, NULL, r);
}

#endif
#if defined(HAVE_ECC_SIGN) || defined(HAVE_ECC_VERIFY)
#ifdef WOLFSSL_SP_SMALL
/* Order-2 for the P384 curve. */
static const uint32_t p384_order_minus_2[12] = {
    0xccc52971U,0xecec196aU,0x48b0a77aU,0x581a0db2U,0xf4372ddfU,0xc7634d81U,
    0xffffffffU,0xffffffffU,0xffffffffU,0xffffffffU,0xffffffffU,0xffffffffU
};
#else
/* The low half of the order-2 of the P384 curve. */
static const sp_int_digit p384_order_low[6] = {
    0xccc52971U,0xecec196aU,0x48b0a77aU,0x581a0db2U,0xf4372ddfU,0xc7634d81U
    
};
#endif /* WOLFSSL_SP_SMALL */

/* Multiply two number mod the order of P384 curve. (r = a * b mod order)
 *
 * r  Result of the multiplication.
 * a  First operand of the multiplication.
 * b  Second operand of the multiplication.
 */
static void sp_384_mont_mul_order_15(sp_digit* r, const sp_digit* a, const sp_digit* b)
{
    sp_384_mul_15(r, a, b);
    sp_384_mont_reduce_order_15(r, p384_order, p384_mp_order);
}

/* Square number mod the order of P384 curve. (r = a * a mod order)
 *
 * r  Result of the squaring.
 * a  Number to square.
 */
static void sp_384_mont_sqr_order_15(sp_digit* r, const sp_digit* a)
{
    sp_384_sqr_15(r, a);
    sp_384_mont_reduce_order_15(r, p384_order, p384_mp_order);
}

#ifndef WOLFSSL_SP_SMALL
/* Square number mod the order of P384 curve a number of times.
 * (r = a ^ n mod order)
 *
 * r  Result of the squaring.
 * a  Number to square.
 */
static void sp_384_mont_sqr_n_order_15(sp_digit* r, const sp_digit* a, int n)
{
    int i;

    sp_384_mont_sqr_order_15(r, a);
    for (i=1; i<n; i++) {
        sp_384_mont_sqr_order_15(r, r);
    }
}
#endif /* !WOLFSSL_SP_SMALL */

/* Invert the number, in Montgomery form, modulo the order of the P384 curve.
 * (r = 1 / a mod order)
 *
 * r   Inverse result.
 * a   Number to invert.
 * td  Temporary data.
 */

#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_384_mont_inv_order_15_ctx {
    int state;
    int i;
} sp_384_mont_inv_order_15_ctx;
static int sp_384_mont_inv_order_15_nb(sp_ecc_ctx_t* sp_ctx, sp_digit* r, const sp_digit* a,
        sp_digit* t)
{
    int err = FP_WOULDBLOCK;
    sp_384_mont_inv_order_15_ctx* ctx = (sp_384_mont_inv_order_15_ctx*)sp_ctx;
    
    typedef char ctx_size_test[sizeof(sp_384_mont_inv_order_15_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    switch (ctx->state) {
    case 0:
        XMEMCPY(t, a, sizeof(sp_digit) * 15);
        ctx->i = 382;
        ctx->state = 1;
        break;
    case 1:
        sp_384_mont_sqr_order_15(t, t);
        if ((p384_order_minus_2[ctx->i / 32] & ((sp_int_digit)1 << (ctx->i % 32))) != 0) {
            sp_384_mont_mul_order_15(t, t, a);
        }
        ctx->i--;
        if (ctx->i == 0) {
            ctx->state = 2;
        }
        break;
    case 2:
        XMEMCPY(r, t, sizeof(sp_digit) * 15U);
        err = MP_OKAY;
        break;
    }
    return err;
}
#endif /* WOLFSSL_SP_NONBLOCK */

static void sp_384_mont_inv_order_15(sp_digit* r, const sp_digit* a,
        sp_digit* td)
{
#ifdef WOLFSSL_SP_SMALL
    sp_digit* t = td;
    int i;

    XMEMCPY(t, a, sizeof(sp_digit) * 15);
    for (i=382; i>=0; i--) {
        sp_384_mont_sqr_order_15(t, t);
        if ((p384_order_minus_2[i / 32] & ((sp_int_digit)1 << (i % 32))) != 0) {
            sp_384_mont_mul_order_15(t, t, a);
        }
    }
    XMEMCPY(r, t, sizeof(sp_digit) * 15U);
#else
    sp_digit* t = td;
    sp_digit* t2 = td + 2 * 15;
    sp_digit* t3 = td + 4 * 15;
    int i;

    /* t = a^2 */
    sp_384_mont_sqr_order_15(t, a);
    /* t = a^3 = t * a */
    sp_384_mont_mul_order_15(t, t, a);
    /* t2= a^c = t ^ 2 ^ 2 */
    sp_384_mont_sqr_n_order_15(t2, t, 2);
    /* t = a^f = t2 * t */
    sp_384_mont_mul_order_15(t, t2, t);
    /* t2= a^f0 = t ^ 2 ^ 4 */
    sp_384_mont_sqr_n_order_15(t2, t, 4);
    /* t = a^ff = t2 * t */
    sp_384_mont_mul_order_15(t, t2, t);
    /* t2= a^ff00 = t ^ 2 ^ 8 */
    sp_384_mont_sqr_n_order_15(t2, t, 8);
    /* t3= a^ffff = t2 * t */
    sp_384_mont_mul_order_15(t3, t2, t);
    /* t2= a^ffff0000 = t3 ^ 2 ^ 16 */
    sp_384_mont_sqr_n_order_15(t2, t3, 16);
    /* t = a^ffffffff = t2 * t3 */
    sp_384_mont_mul_order_15(t, t2, t3);
    /* t2= a^ffffffff0000 = t ^ 2 ^ 16  */
    sp_384_mont_sqr_n_order_15(t2, t, 16);
    /* t = a^ffffffffffff = t2 * t3 */
    sp_384_mont_mul_order_15(t, t2, t3);
    /* t2= a^ffffffffffff000000000000 = t ^ 2 ^ 48  */
    sp_384_mont_sqr_n_order_15(t2, t, 48);
    /* t= a^fffffffffffffffffffffffff = t2 * t */
    sp_384_mont_mul_order_15(t, t2, t);
    /* t2= a^ffffffffffffffffffffffff000000000000000000000000 */
    sp_384_mont_sqr_n_order_15(t2, t, 96);
    /* t2= a^ffffffffffffffffffffffffffffffffffffffffffffffff = t2 * t */
    sp_384_mont_mul_order_15(t2, t2, t);
    for (i=191; i>=1; i--) {
        sp_384_mont_sqr_order_15(t2, t2);
        if ((p384_order_low[i / 32] & ((sp_int_digit)1 << (i % 32))) != 0) {
            sp_384_mont_mul_order_15(t2, t2, a);
        }
    }
    sp_384_mont_sqr_order_15(t2, t2);
    sp_384_mont_mul_order_15(r, t2, a);
#endif /* WOLFSSL_SP_SMALL */
}

#endif /* HAVE_ECC_SIGN | HAVE_ECC_VERIFY */
#ifdef HAVE_ECC_SIGN
#ifndef SP_ECC_MAX_SIG_GEN
#define SP_ECC_MAX_SIG_GEN  64
#endif

/* Calculate second signature value S from R, k and private value.
 *
 * s = (r * x + e) / k
 *
 * s    Signature value.
 * r    First signature value.
 * k    Ephemeral private key.
 * x    Private key as a number.
 * e    Hash of message as a number.
 * tmp  Temporary storage for intermediate numbers.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_384_calc_s_15(sp_digit* s, const sp_digit* r, sp_digit* k,
    sp_digit* x, const sp_digit* e, sp_digit* tmp)
{
    int err;
    sp_digit carry;
    int32_t c;
    sp_digit* kInv = k;

    /* Conv k to Montgomery form (mod order) */
        sp_384_mul_15(k, k, p384_norm_order);
    err = sp_384_mod_15(k, k, p384_order);
    if (err == MP_OKAY) {
        sp_384_norm_15(k);

        /* kInv = 1/k mod order */
            sp_384_mont_inv_order_15(kInv, k, tmp);
        sp_384_norm_15(kInv);

        /* s = r * x + e */
            sp_384_mul_15(x, x, r);
        err = sp_384_mod_15(x, x, p384_order);
    }
    if (err == MP_OKAY) {
        sp_384_norm_15(x);
        carry = sp_384_add_15(s, e, x);
        sp_384_cond_sub_15(s, s, p384_order, 0 - carry);
        sp_384_norm_15(s);
        c = sp_384_cmp_15(s, p384_order);
        sp_384_cond_sub_15(s, s, p384_order, 0L - (sp_digit)(c >= 0));
        sp_384_norm_15(s);

        /* s = s * k^-1 mod order */
            sp_384_mont_mul_order_15(s, s, kInv);
        sp_384_norm_15(s);
    }

    return err;
}

/* Sign the hash using the private key.
 *   e = [hash, 384 bits] from binary
 *   r = (k.G)->x mod order
 *   s = (r * x + e) / k mod order
 * The hash is truncated to the first 384 bits.
 *
 * hash     Hash to sign.
 * hashLen  Length of the hash data.
 * rng      Random number generator.
 * priv     Private part of key - scalar.
 * rm       First part of result as an mp_int.
 * sm       Sirst part of result as an mp_int.
 * heap     Heap to use for allocation.
 * returns RNG failures, MEMORY_E when memory allocation fails and
 * MP_OKAY on success.
 */
#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_ecc_sign_384_ctx {
    int state;
    union {
        sp_384_ecc_mulmod_15_ctx mulmod_ctx;
        sp_384_mont_inv_order_15_ctx mont_inv_order_ctx;
    };
    sp_digit e[2*15];
    sp_digit x[2*15];
    sp_digit k[2*15];
    sp_digit r[2*15];
    sp_digit tmp[3 * 2*15];
    sp_point_384 point;
    sp_digit* s;
    sp_digit* kInv;
    int i;
} sp_ecc_sign_384_ctx;

int sp_ecc_sign_384_nb(sp_ecc_ctx_t* sp_ctx, const byte* hash, word32 hashLen, WC_RNG* rng, mp_int* priv,
                    mp_int* rm, mp_int* sm, mp_int* km, void* heap)
{
    int err = FP_WOULDBLOCK;
    sp_ecc_sign_384_ctx* ctx = (sp_ecc_sign_384_ctx*)sp_ctx->data;

    typedef char ctx_size_test[sizeof(sp_ecc_sign_384_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    (void)heap;

    switch (ctx->state) {
    case 0: /* INIT */
        ctx->s = ctx->e;
        ctx->kInv = ctx->k;
        if (hashLen > 48U) {
            hashLen = 48U;
        }

        sp_384_from_bin(ctx->e, 15, hash, (int)hashLen);

        ctx->i = SP_ECC_MAX_SIG_GEN;
        ctx->state = 1;
        break;
    case 1: /* GEN */
        sp_384_from_mp(ctx->x, 15, priv);
        /* New random point. */
        if (km == NULL || mp_iszero(km)) {
            err = sp_384_ecc_gen_k_15(rng, ctx->k);
        }
        else {
            sp_384_from_mp(ctx->k, 15, km);
            mp_zero(km);
        }
        XMEMSET(&ctx->mulmod_ctx, 0, sizeof(ctx->mulmod_ctx));
        ctx->state = 2;
        break; 
    case 2: /* MULMOD */
        err = sp_384_ecc_mulmod_15_nb((sp_ecc_ctx_t*)&ctx->mulmod_ctx, 
            &ctx->point, &p384_base, ctx->k, 1, heap);
        if (err == MP_OKAY) {
            ctx->state = 3;
        }
        break;
    case 3: /* MODORDER */
    {
        int32_t c;
        /* r = point->x mod order */
        XMEMCPY(ctx->r, ctx->point.x, sizeof(sp_digit) * 15U);
        sp_384_norm_15(ctx->r);
        c = sp_384_cmp_15(ctx->r, p384_order);
        sp_384_cond_sub_15(ctx->r, ctx->r, p384_order, 0L - (sp_digit)(c >= 0));
        sp_384_norm_15(ctx->r);
        ctx->state = 4;
        break;
    }
    case 4: /* KMODORDER */
        /* Conv k to Montgomery form (mod order) */
        sp_384_mul_15(ctx->k, ctx->k, p384_norm_order);
        err = sp_384_mod_15(ctx->k, ctx->k, p384_order);
        if (err == MP_OKAY) {
            sp_384_norm_15(ctx->k);
            XMEMSET(&ctx->mont_inv_order_ctx, 0, sizeof(ctx->mont_inv_order_ctx));
            ctx->state = 5;
        }
        break;
    case 5: /* KINV */
        /* kInv = 1/k mod order */
        err = sp_384_mont_inv_order_15_nb((sp_ecc_ctx_t*)&ctx->mont_inv_order_ctx, ctx->kInv, ctx->k, ctx->tmp);
        if (err == MP_OKAY) {
            XMEMSET(&ctx->mont_inv_order_ctx, 0, sizeof(ctx->mont_inv_order_ctx));
            ctx->state = 6;
        }
        break;
    case 6: /* KINVNORM */
        sp_384_norm_15(ctx->kInv);
        ctx->state = 7;
        break;
    case 7: /* R */
        /* s = r * x + e */
        sp_384_mul_15(ctx->x, ctx->x, ctx->r);
        ctx->state = 8;
        break;
    case 8: /* S1 */
        err = sp_384_mod_15(ctx->x, ctx->x, p384_order);
        if (err == MP_OKAY)
            ctx->state = 9;
        break;
    case 9: /* S2 */
    {
        sp_digit carry;
        int32_t c;
        sp_384_norm_15(ctx->x);
        carry = sp_384_add_15(ctx->s, ctx->e, ctx->x);
        sp_384_cond_sub_15(ctx->s, ctx->s, p384_order, 0 - carry);
        sp_384_norm_15(ctx->s);
        c = sp_384_cmp_15(ctx->s, p384_order);
        sp_384_cond_sub_15(ctx->s, ctx->s, p384_order, 0L - (sp_digit)(c >= 0));
        sp_384_norm_15(ctx->s);

        /* s = s * k^-1 mod order */
        sp_384_mont_mul_order_15(ctx->s, ctx->s, ctx->kInv);
        sp_384_norm_15(ctx->s);

        /* Check that signature is usable. */
        if (sp_384_iszero_15(ctx->s) == 0) {
            ctx->state = 10;
            break;
        }

        /* not usable gen, try again */
        ctx->i--;
        if (ctx->i == 0) {
            err = RNG_FAILURE_E;
        }
        ctx->state = 1;
        break;
    }
    case 10: /* RES */
        err = sp_384_to_mp(ctx->r, rm);
        if (err == MP_OKAY) {
            err = sp_384_to_mp(ctx->s, sm);
        }
        break;
    }

    if (err == MP_OKAY && ctx->state != 10) {
        err = FP_WOULDBLOCK;
    }
    if (err != FP_WOULDBLOCK) {
        XMEMSET(ctx->e, 0, sizeof(sp_digit) * 2U * 15U);
        XMEMSET(ctx->x, 0, sizeof(sp_digit) * 2U * 15U);
        XMEMSET(ctx->k, 0, sizeof(sp_digit) * 2U * 15U);
        XMEMSET(ctx->r, 0, sizeof(sp_digit) * 2U * 15U);
        XMEMSET(ctx->tmp, 0, sizeof(sp_digit) * 3U * 2U * 15U);
    }

    return err;
}
#endif /* WOLFSSL_SP_NONBLOCK */

int sp_ecc_sign_384(const byte* hash, word32 hashLen, WC_RNG* rng,
    const mp_int* priv, mp_int* rm, mp_int* sm, mp_int* km, void* heap)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* d = NULL;
#else
    sp_digit ed[2*15];
    sp_digit xd[2*15];
    sp_digit kd[2*15];
    sp_digit rd[2*15];
    sp_digit td[3 * 2*15];
    sp_point_384 p;
#endif
    sp_digit* e = NULL;
    sp_digit* x = NULL;
    sp_digit* k = NULL;
    sp_digit* r = NULL;
    sp_digit* tmp = NULL;
    sp_point_384* point = NULL;
    sp_digit* s = NULL;
    int32_t c;
    int err = MP_OKAY;
    int i;

    (void)heap;

    err = sp_384_point_new_15(heap, p, point);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 7 * 2 * 15, heap,
                                                              DYNAMIC_TYPE_ECC);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        e = d + 0 * 15;
        x = d + 2 * 15;
        k = d + 4 * 15;
        r = d + 6 * 15;
        tmp = d + 8 * 15;
#else
        e = ed;
        x = xd;
        k = kd;
        r = rd;
        tmp = td;
#endif
        s = e;

        if (hashLen > 48U) {
            hashLen = 48U;
        }

        sp_384_from_bin(e, 15, hash, (int)hashLen);
    }

    for (i = SP_ECC_MAX_SIG_GEN; err == MP_OKAY && i > 0; i--) {
        /* New random point. */
        if (km == NULL || mp_iszero(km)) {
            err = sp_384_ecc_gen_k_15(rng, k);
        }
        else {
            sp_384_from_mp(k, 15, km);
            mp_zero(km);
        }
        if (err == MP_OKAY) {
                err = sp_384_ecc_mulmod_base_15(point, k, 1, heap);
        }
        if (err == MP_OKAY) {
            /* r = point->x mod order */
            XMEMCPY(r, point->x, sizeof(sp_digit) * 15U);
            sp_384_norm_15(r);
            c = sp_384_cmp_15(r, p384_order);
            sp_384_cond_sub_15(r, r, p384_order, 0L - (sp_digit)(c >= 0));
            sp_384_norm_15(r);

            sp_384_from_mp(x, 15, priv);

            err = sp_384_calc_s_15(s, r, k, x, e, tmp);
        }

        /* Check that signature is usable. */
        if ((err == MP_OKAY) && (sp_384_iszero_15(s) == 0)) {
            break;
        }
    }

    if (i == 0) {
        err = RNG_FAILURE_E;
    }

    if (err == MP_OKAY) {
        err = sp_384_to_mp(r, rm);
    }
    if (err == MP_OKAY) {
        err = sp_384_to_mp(s, sm);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL) {
        XMEMSET(d, 0, sizeof(sp_digit) * 8 * 15);
        XFREE(d, heap, DYNAMIC_TYPE_ECC);
    }
#else
    XMEMSET(e, 0, sizeof(sp_digit) * 2U * 15U);
    XMEMSET(x, 0, sizeof(sp_digit) * 2U * 15U);
    XMEMSET(k, 0, sizeof(sp_digit) * 2U * 15U);
    XMEMSET(r, 0, sizeof(sp_digit) * 2U * 15U);
    XMEMSET(r, 0, sizeof(sp_digit) * 2U * 15U);
    XMEMSET(tmp, 0, sizeof(sp_digit) * 3U * 2U * 15U);
#endif
    sp_384_point_free_15(point, 1, heap);

    return err;
}
#endif /* HAVE_ECC_SIGN */

#ifdef HAVE_ECC_VERIFY

/* Add point p1 into point p2. Handles p1 == p2 and result at infinity.
 *
 * p1   First point to add and holds result.
 * p2   Second point to add.
 * tmp  Temporary storage for intermediate numbers.
 */
static void sp_384_add_points_15(sp_point_384* p1, const sp_point_384* p2,
    sp_digit* tmp)
{

        sp_384_proj_point_add_15(p1, p1, p2, tmp);
    if (sp_384_iszero_15(p1->z)) {
        if (sp_384_iszero_15(p1->x) && sp_384_iszero_15(p1->y)) {
                sp_384_proj_point_dbl_15(p1, p2, tmp);
        }
        else {
            /* Y ordinate is not used from here - don't set. */
            p1->x[0] = 0;
            p1->x[1] = 0;
            p1->x[2] = 0;
            p1->x[3] = 0;
            p1->x[4] = 0;
            p1->x[5] = 0;
            p1->x[6] = 0;
            p1->x[7] = 0;
            p1->x[8] = 0;
            p1->x[9] = 0;
            p1->x[10] = 0;
            p1->x[11] = 0;
            p1->x[12] = 0;
            p1->x[13] = 0;
            p1->x[14] = 0;
            XMEMCPY(p1->z, p384_norm_mod, sizeof(p384_norm_mod));
        }
    }
}

/* Calculate the verification point: [e/s]G + [r/s]Q
 *
 * p1    Calculated point.
 * p2    Public point and temporary.
 * s     Second part of signature as a number.
 * u1    Temporary number.
 * u2    Temproray number.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_384_calc_vfy_point_15(sp_point_384* p1, sp_point_384* p2,
    sp_digit* s, sp_digit* u1, sp_digit* u2, sp_digit* tmp, void* heap)
{
    int err;

    sp_384_norm_15(s);
        sp_384_mont_inv_order_15(s, s, tmp);
        sp_384_mont_mul_order_15(u1, u1, s);
        sp_384_mont_mul_order_15(u2, u2, s);
        err = sp_384_ecc_mulmod_base_15(p1, u1, 0, heap);
    if (err == MP_OKAY) {
            err = sp_384_ecc_mulmod_15(p2, p2, u2, 0, heap);
    }

    if (err == MP_OKAY) {
        sp_384_add_points_15(p1, p2, tmp);
    }

    return err;
}

/* Verify the signature values with the hash and public key.
 *   e = Truncate(hash, 384)
 *   u1 = e/s mod order
 *   u2 = r/s mod order
 *   r == (u1.G + u2.Q)->x mod order
 * Optimization: Leave point in projective form.
 *   (x, y, 1) == (x' / z'*z', y' / z'*z'*z', z' / z')
 *   (r + n*order).z'.z' mod prime == (u1.G + u2.Q)->x'
 * The hash is truncated to the first 384 bits.
 *
 * hash     Hash to sign.
 * hashLen  Length of the hash data.
 * rng      Random number generator.
 * priv     Private part of key - scalar.
 * rm       First part of result as an mp_int.
 * sm       Sirst part of result as an mp_int.
 * heap     Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_ecc_verify_384_ctx {
    int state;
    union {
        sp_384_ecc_mulmod_15_ctx mulmod_ctx;
        sp_384_mont_inv_order_15_ctx mont_inv_order_ctx;
        sp_384_proj_point_dbl_15_ctx dbl_ctx;
        sp_384_proj_point_add_15_ctx add_ctx;
    };
    sp_digit u1[2*15];
    sp_digit u2[2*15];
    sp_digit s[2*15];
    sp_digit tmp[2*15 * 5];
    sp_point_384 p1;
    sp_point_384 p2;
} sp_ecc_verify_384_ctx;

int sp_ecc_verify_384_nb(sp_ecc_ctx_t* sp_ctx, const byte* hash, word32 hashLen, mp_int* pX,
    mp_int* pY, mp_int* pZ, mp_int* r, mp_int* sm, int* res, void* heap)
{
    int err = FP_WOULDBLOCK;
    sp_ecc_verify_384_ctx* ctx = (sp_ecc_verify_384_ctx*)sp_ctx->data;

    typedef char ctx_size_test[sizeof(sp_ecc_verify_384_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    switch (ctx->state) {
    case 0: /* INIT */
        if (hashLen > 48U) {
            hashLen = 48U;
        }

        sp_384_from_bin(ctx->u1, 15, hash, (int)hashLen);
        sp_384_from_mp(ctx->u2, 15, r);
        sp_384_from_mp(ctx->s, 15, sm);
        sp_384_from_mp(ctx->p2.x, 15, pX);
        sp_384_from_mp(ctx->p2.y, 15, pY);
        sp_384_from_mp(ctx->p2.z, 15, pZ);
        sp_384_mul_15(ctx->s, ctx->s, p384_norm_order);
        err = sp_384_mod_15(ctx->s, ctx->s, p384_order);
        if (err == MP_OKAY)
            ctx->state = 1;
        break;
    case 1: /* NORMS1 */
        sp_384_norm_15(ctx->s);
        XMEMSET(&ctx->mont_inv_order_ctx, 0, sizeof(ctx->mont_inv_order_ctx));
        ctx->state = 2;
        break;
    case 2: /* NORMS2 */
        err = sp_384_mont_inv_order_15_nb((sp_ecc_ctx_t*)&ctx->mont_inv_order_ctx, ctx->s, ctx->s, ctx->tmp);
        if (err == MP_OKAY) {
            ctx->state = 3;
        }
        break;
    case 3: /* NORMS3 */
        sp_384_mont_mul_order_15(ctx->u1, ctx->u1, ctx->s);
        ctx->state = 4;
        break;
    case 4: /* NORMS4 */
        sp_384_mont_mul_order_15(ctx->u2, ctx->u2, ctx->s);
        XMEMSET(&ctx->mulmod_ctx, 0, sizeof(ctx->mulmod_ctx));
        ctx->state = 5;
        break;
    case 5: /* MULBASE */
        err = sp_384_ecc_mulmod_15_nb((sp_ecc_ctx_t*)&ctx->mulmod_ctx, &ctx->p1, &p384_base, ctx->u1, 0, heap);
        if (err == MP_OKAY) {
            XMEMSET(&ctx->mulmod_ctx, 0, sizeof(ctx->mulmod_ctx));
            ctx->state = 6;
        }
        break;
    case 6: /* MULMOD */
        err = sp_384_ecc_mulmod_15_nb((sp_ecc_ctx_t*)&ctx->mulmod_ctx, &ctx->p2, &ctx->p2, ctx->u2, 0, heap);
        if (err == MP_OKAY) {
            XMEMSET(&ctx->add_ctx, 0, sizeof(ctx->add_ctx));
            ctx->state = 7;
        }
        break;
    case 7: /* ADD */
        err = sp_384_proj_point_add_15_nb((sp_ecc_ctx_t*)&ctx->add_ctx, &ctx->p1, &ctx->p1, &ctx->p2, ctx->tmp);
        if (err == MP_OKAY)
            ctx->state = 8;
        break;
    case 8: /* DBLPREP */
        if (sp_384_iszero_15(ctx->p1.z)) {
            if (sp_384_iszero_15(ctx->p1.x) && sp_384_iszero_15(ctx->p1.y)) {
                XMEMSET(&ctx->dbl_ctx, 0, sizeof(ctx->dbl_ctx));
                ctx->state = 9;
                break;
            }
            else {
                /* Y ordinate is not used from here - don't set. */
                int i;
                for (i=0; i<15; i++) {
                    ctx->p1.x[i] = 0;
                }
                XMEMCPY(ctx->p1.z, p384_norm_mod, sizeof(p384_norm_mod));
            }
        }
        ctx->state = 10;
        break;
    case 9: /* DBL */
        err = sp_384_proj_point_dbl_15_nb((sp_ecc_ctx_t*)&ctx->dbl_ctx, &ctx->p1, 
            &ctx->p2, ctx->tmp);
        if (err == MP_OKAY) {
            ctx->state = 10;
        }
        break;
    case 10: /* MONT */
        /* (r + n*order).z'.z' mod prime == (u1.G + u2.Q)->x' */
        /* Reload r and convert to Montgomery form. */
        sp_384_from_mp(ctx->u2, 15, r);
        err = sp_384_mod_mul_norm_15(ctx->u2, ctx->u2, p384_mod);
        if (err == MP_OKAY)
            ctx->state = 11;
        break;
    case 11: /* SQR */
        /* u1 = r.z'.z' mod prime */
        sp_384_mont_sqr_15(ctx->p1.z, ctx->p1.z, p384_mod, p384_mp_mod);
        ctx->state = 12;
        break;
    case 12: /* MUL */
        sp_384_mont_mul_15(ctx->u1, ctx->u2, ctx->p1.z, p384_mod, p384_mp_mod);
        ctx->state = 13;
        break;
    case 13: /* RES */
        err = MP_OKAY; /* math okay, now check result */
        *res = (int)(sp_384_cmp_15(ctx->p1.x, ctx->u1) == 0);
        if (*res == 0) {
            sp_digit carry;
            int32_t c;

            /* Reload r and add order. */
            sp_384_from_mp(ctx->u2, 15, r);
            carry = sp_384_add_15(ctx->u2, ctx->u2, p384_order);
            /* Carry means result is greater than mod and is not valid. */
            if (carry == 0) {
                sp_384_norm_15(ctx->u2);

                /* Compare with mod and if greater or equal then not valid. */
                c = sp_384_cmp_15(ctx->u2, p384_mod);
                if (c < 0) {
                    /* Convert to Montogomery form */
                    err = sp_384_mod_mul_norm_15(ctx->u2, ctx->u2, p384_mod);
                    if (err == MP_OKAY) {
                        /* u1 = (r + 1*order).z'.z' mod prime */
                        sp_384_mont_mul_15(ctx->u1, ctx->u2, ctx->p1.z, p384_mod,
                                                                  p384_mp_mod);
                        *res = (int)(sp_384_cmp_15(ctx->p1.x, ctx->u1) == 0);
                    }
                }
            }
        }
        break;
    }

    if (err == MP_OKAY && ctx->state != 13) {
        err = FP_WOULDBLOCK;
    }

    return err;
}
#endif /* WOLFSSL_SP_NONBLOCK */

int sp_ecc_verify_384(const byte* hash, word32 hashLen, const mp_int* pX,
    const mp_int* pY, const mp_int* pZ, const mp_int* r, const mp_int* sm,
    int* res, void* heap)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* d = NULL;
#else
    sp_digit u1d[2*15];
    sp_digit u2d[2*15];
    sp_digit sd[2*15];
    sp_digit tmpd[2*15 * 5];
    sp_point_384 p1d;
    sp_point_384 p2d;
#endif
    sp_digit* u1 = NULL;
    sp_digit* u2 = NULL;
    sp_digit* s = NULL;
    sp_digit* tmp = NULL;
    sp_point_384* p1;
    sp_point_384* p2 = NULL;
    sp_digit carry;
    int32_t c = 0;
    int err;

    err = sp_384_point_new_15(heap, p1d, p1);
    if (err == MP_OKAY) {
        err = sp_384_point_new_15(heap, p2d, p2);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 16 * 15, heap,
                                                              DYNAMIC_TYPE_ECC);
        if (d == NULL) {
            err = MEMORY_E;
        }
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        u1  = d + 0 * 15;
        u2  = d + 2 * 15;
        s   = d + 4 * 15;
        tmp = d + 6 * 15;
#else
        u1 = u1d;
        u2 = u2d;
        s  = sd;
        tmp = tmpd;
#endif

        if (hashLen > 48U) {
            hashLen = 48U;
        }

        sp_384_from_bin(u1, 15, hash, (int)hashLen);
        sp_384_from_mp(u2, 15, r);
        sp_384_from_mp(s, 15, sm);
        sp_384_from_mp(p2->x, 15, pX);
        sp_384_from_mp(p2->y, 15, pY);
        sp_384_from_mp(p2->z, 15, pZ);

            sp_384_mul_15(s, s, p384_norm_order);
        err = sp_384_mod_15(s, s, p384_order);
    }
    if (err == MP_OKAY) {
        err = sp_384_calc_vfy_point_15(p1, p2, s, u1, u2, tmp,
            heap);
    }
    if (err == MP_OKAY) {
        /* (r + n*order).z'.z' mod prime == (u1.G + u2.Q)->x' */
        /* Reload r and convert to Montgomery form. */
        sp_384_from_mp(u2, 15, r);
        err = sp_384_mod_mul_norm_15(u2, u2, p384_mod);
    }

    if (err == MP_OKAY) {
        /* u1 = r.z'.z' mod prime */
        sp_384_mont_sqr_15(p1->z, p1->z, p384_mod, p384_mp_mod);
        sp_384_mont_mul_15(u1, u2, p1->z, p384_mod, p384_mp_mod);
        *res = (sp_384_cmp_15(p1->x, u1) == 0);
        if (*res == 0) {
            /* Reload r and add order. */
            sp_384_from_mp(u2, 15, r);
            carry = sp_384_add_15(u2, u2, p384_order);
            /* Carry means result is greater than mod and is not valid. */
            if (carry == 0) {
                sp_384_norm_15(u2);

                /* Compare with mod and if greater or equal then not valid. */
                c = sp_384_cmp_15(u2, p384_mod);
            }
         }
         if ((*res == 0) && (c < 0)) {
            /* Convert to Montogomery form */
            err = sp_384_mod_mul_norm_15(u2, u2, p384_mod);
            if (err == MP_OKAY) {
                /* u1 = (r + 1*order).z'.z' mod prime */
                sp_384_mont_mul_15(u1, u2, p1->z, p384_mod,
                    p384_mp_mod);
                *res = (sp_384_cmp_15(p1->x, u1) == 0);
            }
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL)
        XFREE(d, heap, DYNAMIC_TYPE_ECC);
#endif
    sp_384_point_free_15(p1, 0, heap);
    sp_384_point_free_15(p2, 0, heap);

    return err;
}
#endif /* HAVE_ECC_VERIFY */

#ifdef HAVE_ECC_CHECK_KEY
/* Check that the x and y oridinates are a valid point on the curve.
 *
 * point  EC point.
 * heap   Heap to use if dynamically allocating.
 * returns MEMORY_E if dynamic memory allocation fails, MP_VAL if the point is
 * not on the curve and MP_OKAY otherwise.
 */
static int sp_384_ecc_is_point_15(const sp_point_384* point, void* heap)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* d = NULL;
#else
    sp_digit t1d[2*15];
    sp_digit t2d[2*15];
#endif
    sp_digit* t1;
    sp_digit* t2;
    int err = MP_OKAY;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 15 * 4, heap, DYNAMIC_TYPE_ECC);
    if (d == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t1 = d + 0 * 15;
        t2 = d + 2 * 15;
#else
        (void)heap;

        t1 = t1d;
        t2 = t2d;
#endif

        sp_384_sqr_15(t1, point->y);
        (void)sp_384_mod_15(t1, t1, p384_mod);
        sp_384_sqr_15(t2, point->x);
        (void)sp_384_mod_15(t2, t2, p384_mod);
        sp_384_mul_15(t2, t2, point->x);
        (void)sp_384_mod_15(t2, t2, p384_mod);
        (void)sp_384_sub_15(t2, p384_mod, t2);
        sp_384_mont_add_15(t1, t1, t2, p384_mod);

        sp_384_mont_add_15(t1, t1, point->x, p384_mod);
        sp_384_mont_add_15(t1, t1, point->x, p384_mod);
        sp_384_mont_add_15(t1, t1, point->x, p384_mod);

        if (sp_384_cmp_15(t1, p384_b) != 0) {
            err = MP_VAL;
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL) {
        XFREE(d, heap, DYNAMIC_TYPE_ECC);
    }
#endif

    return err;
}

/* Check that the x and y oridinates are a valid point on the curve.
 *
 * pX  X ordinate of EC point.
 * pY  Y ordinate of EC point.
 * returns MEMORY_E if dynamic memory allocation fails, MP_VAL if the point is
 * not on the curve and MP_OKAY otherwise.
 */
int sp_ecc_is_point_384(const mp_int* pX, const mp_int* pY)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_384 pubd;
#endif
    sp_point_384* pub;
    byte one[1] = { 1 };
    int err;

    err = sp_384_point_new_15(NULL, pubd, pub);
    if (err == MP_OKAY) {
        sp_384_from_mp(pub->x, 15, pX);
        sp_384_from_mp(pub->y, 15, pY);
        sp_384_from_bin(pub->z, 15, one, (int)sizeof(one));

        err = sp_384_ecc_is_point_15(pub, NULL);
    }

    sp_384_point_free_15(pub, 0, NULL);

    return err;
}

/* Check that the private scalar generates the EC point (px, py), the point is
 * on the curve and the point has the correct order.
 *
 * pX     X ordinate of EC point.
 * pY     Y ordinate of EC point.
 * privm  Private scalar that generates EC point.
 * returns MEMORY_E if dynamic memory allocation fails, MP_VAL if the point is
 * not on the curve, ECC_INF_E if the point does not have the correct order,
 * ECC_PRIV_KEY_E when the private scalar doesn't generate the EC point and
 * MP_OKAY otherwise.
 */
int sp_ecc_check_key_384(const mp_int* pX, const mp_int* pY,
    const mp_int* privm, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit privd[15];
    sp_point_384 pubd;
    sp_point_384 pd;
#endif
    sp_digit* priv = NULL;
    sp_point_384* pub;
    sp_point_384* p = NULL;
    byte one[1] = { 1 };
    int err;

    err = sp_384_point_new_15(heap, pubd, pub);
    if (err == MP_OKAY) {
        err = sp_384_point_new_15(heap, pd, p);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        priv = (sp_digit*)XMALLOC(sizeof(sp_digit) * 15, heap,
                                                              DYNAMIC_TYPE_ECC);
        if (priv == NULL) {
            err = MEMORY_E;
        }
    }
#endif

    if (err == MP_OKAY) {
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
        priv = privd;
#endif

        sp_384_from_mp(pub->x, 15, pX);
        sp_384_from_mp(pub->y, 15, pY);
        sp_384_from_bin(pub->z, 15, one, (int)sizeof(one));
        sp_384_from_mp(priv, 15, privm);

        /* Check point at infinitiy. */
        if ((sp_384_iszero_15(pub->x) != 0) &&
            (sp_384_iszero_15(pub->y) != 0)) {
            err = ECC_INF_E;
        }
    }

    /* Check range of X and Y */
    if ((err == MP_OKAY) &&
            ((sp_384_cmp_15(pub->x, p384_mod) >= 0) ||
             (sp_384_cmp_15(pub->y, p384_mod) >= 0))) {
        err = ECC_OUT_OF_RANGE_E;
    }

    if (err == MP_OKAY) {
        /* Check point is on curve */
        err = sp_384_ecc_is_point_15(pub, heap);
    }

    if (err == MP_OKAY) {
        /* Point * order = infinity */
            err = sp_384_ecc_mulmod_15(p, pub, p384_order, 1, heap);
    }
    /* Check result is infinity */
    if ((err == MP_OKAY) && ((sp_384_iszero_15(p->x) == 0) ||
                             (sp_384_iszero_15(p->y) == 0))) {
        err = ECC_INF_E;
    }

    if (err == MP_OKAY) {
        /* Base * private = point */
            err = sp_384_ecc_mulmod_base_15(p, priv, 1, heap);
    }
    /* Check result is public key */
    if ((err == MP_OKAY) && ((sp_384_cmp_15(p->x, pub->x) != 0) ||
                             (sp_384_cmp_15(p->y, pub->y) != 0))) {
        err = ECC_PRIV_KEY_E;
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (priv != NULL) {
        XFREE(priv, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_384_point_free_15(p, 0, heap);
    sp_384_point_free_15(pub, 0, heap);

    return err;
}
#endif
#ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
/* Add two projective EC points together.
 * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
 *
 * pX   First EC point's X ordinate.
 * pY   First EC point's Y ordinate.
 * pZ   First EC point's Z ordinate.
 * qX   Second EC point's X ordinate.
 * qY   Second EC point's Y ordinate.
 * qZ   Second EC point's Z ordinate.
 * rX   Resultant EC point's X ordinate.
 * rY   Resultant EC point's Y ordinate.
 * rZ   Resultant EC point's Z ordinate.
 * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
 */
int sp_ecc_proj_add_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                              mp_int* qX, mp_int* qY, mp_int* qZ,
                              mp_int* rX, mp_int* rY, mp_int* rZ)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit tmpd[2 * 15 * 5];
    sp_point_384 pd;
    sp_point_384 qd;
#endif
    sp_digit* tmp;
    sp_point_384* p;
    sp_point_384* q = NULL;
    int err;

    err = sp_384_point_new_15(NULL, pd, p);
    if (err == MP_OKAY) {
        err = sp_384_point_new_15(NULL, qd, q);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 15 * 5, NULL,
                                                              DYNAMIC_TYPE_ECC);
        if (tmp == NULL) {
            err = MEMORY_E;
        }
    }
#else
    tmp = tmpd;
#endif

    if (err == MP_OKAY) {
        sp_384_from_mp(p->x, 15, pX);
        sp_384_from_mp(p->y, 15, pY);
        sp_384_from_mp(p->z, 15, pZ);
        sp_384_from_mp(q->x, 15, qX);
        sp_384_from_mp(q->y, 15, qY);
        sp_384_from_mp(q->z, 15, qZ);

            sp_384_proj_point_add_15(p, p, q, tmp);
    }

    if (err == MP_OKAY) {
        err = sp_384_to_mp(p->x, rX);
    }
    if (err == MP_OKAY) {
        err = sp_384_to_mp(p->y, rY);
    }
    if (err == MP_OKAY) {
        err = sp_384_to_mp(p->z, rZ);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (tmp != NULL) {
        XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_384_point_free_15(q, 0, NULL);
    sp_384_point_free_15(p, 0, NULL);

    return err;
}

/* Double a projective EC point.
 * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
 *
 * pX   EC point's X ordinate.
 * pY   EC point's Y ordinate.
 * pZ   EC point's Z ordinate.
 * rX   Resultant EC point's X ordinate.
 * rY   Resultant EC point's Y ordinate.
 * rZ   Resultant EC point's Z ordinate.
 * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
 */
int sp_ecc_proj_dbl_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                              mp_int* rX, mp_int* rY, mp_int* rZ)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit tmpd[2 * 15 * 2];
    sp_point_384 pd;
#endif
    sp_digit* tmp;
    sp_point_384* p;
    int err;

    err = sp_384_point_new_15(NULL, pd, p);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 15 * 2, NULL,
                                                              DYNAMIC_TYPE_ECC);
        if (tmp == NULL) {
            err = MEMORY_E;
        }
    }
#else
    tmp = tmpd;
#endif

    if (err == MP_OKAY) {
        sp_384_from_mp(p->x, 15, pX);
        sp_384_from_mp(p->y, 15, pY);
        sp_384_from_mp(p->z, 15, pZ);

            sp_384_proj_point_dbl_15(p, p, tmp);
    }

    if (err == MP_OKAY) {
        err = sp_384_to_mp(p->x, rX);
    }
    if (err == MP_OKAY) {
        err = sp_384_to_mp(p->y, rY);
    }
    if (err == MP_OKAY) {
        err = sp_384_to_mp(p->z, rZ);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (tmp != NULL) {
        XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_384_point_free_15(p, 0, NULL);

    return err;
}

/* Map a projective EC point to affine in place.
 * pZ will be one.
 *
 * pX   EC point's X ordinate.
 * pY   EC point's Y ordinate.
 * pZ   EC point's Z ordinate.
 * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
 */
int sp_ecc_map_384(mp_int* pX, mp_int* pY, mp_int* pZ)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit tmpd[2 * 15 * 6];
    sp_point_384 pd;
#endif
    sp_digit* tmp;
    sp_point_384* p;
    int err;

    err = sp_384_point_new_15(NULL, pd, p);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 15 * 6, NULL,
                                                              DYNAMIC_TYPE_ECC);
        if (tmp == NULL) {
            err = MEMORY_E;
        }
    }
#else
    tmp = tmpd;
#endif
    if (err == MP_OKAY) {
        sp_384_from_mp(p->x, 15, pX);
        sp_384_from_mp(p->y, 15, pY);
        sp_384_from_mp(p->z, 15, pZ);

        sp_384_map_15(p, p, tmp);
    }

    if (err == MP_OKAY) {
        err = sp_384_to_mp(p->x, pX);
    }
    if (err == MP_OKAY) {
        err = sp_384_to_mp(p->y, pY);
    }
    if (err == MP_OKAY) {
        err = sp_384_to_mp(p->z, pZ);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (tmp != NULL) {
        XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_384_point_free_15(p, 0, NULL);

    return err;
}
#endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
#ifdef HAVE_COMP_KEY
/* Find the square root of a number mod the prime of the curve.
 *
 * y  The number to operate on and the result.
 * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
 */
static int sp_384_mont_sqrt_15(sp_digit* y)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* d;
#else
    sp_digit t1d[2 * 15];
    sp_digit t2d[2 * 15];
    sp_digit t3d[2 * 15];
    sp_digit t4d[2 * 15];
    sp_digit t5d[2 * 15];
#endif
    sp_digit* t1;
    sp_digit* t2;
    sp_digit* t3;
    sp_digit* t4;
    sp_digit* t5;
    int err = MP_OKAY;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 5 * 2 * 15, NULL, DYNAMIC_TYPE_ECC);
    if (d == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t1 = d + 0 * 15;
        t2 = d + 2 * 15;
        t3 = d + 4 * 15;
        t4 = d + 6 * 15;
        t5 = d + 8 * 15;
#else
        t1 = t1d;
        t2 = t2d;
        t3 = t3d;
        t4 = t4d;
        t5 = t5d;
#endif

        {
            /* t2 = y ^ 0x2 */
            sp_384_mont_sqr_15(t2, y, p384_mod, p384_mp_mod);
            /* t1 = y ^ 0x3 */
            sp_384_mont_mul_15(t1, t2, y, p384_mod, p384_mp_mod);
            /* t5 = y ^ 0xc */
            sp_384_mont_sqr_n_15(t5, t1, 2, p384_mod, p384_mp_mod);
            /* t1 = y ^ 0xf */
            sp_384_mont_mul_15(t1, t1, t5, p384_mod, p384_mp_mod);
            /* t2 = y ^ 0x1e */
            sp_384_mont_sqr_15(t2, t1, p384_mod, p384_mp_mod);
            /* t3 = y ^ 0x1f */
            sp_384_mont_mul_15(t3, t2, y, p384_mod, p384_mp_mod);
            /* t2 = y ^ 0x3e0 */
            sp_384_mont_sqr_n_15(t2, t3, 5, p384_mod, p384_mp_mod);
            /* t1 = y ^ 0x3ff */
            sp_384_mont_mul_15(t1, t3, t2, p384_mod, p384_mp_mod);
            /* t2 = y ^ 0x7fe0 */
            sp_384_mont_sqr_n_15(t2, t1, 5, p384_mod, p384_mp_mod);
            /* t3 = y ^ 0x7fff */
            sp_384_mont_mul_15(t3, t3, t2, p384_mod, p384_mp_mod);
            /* t2 = y ^ 0x3fff800 */
            sp_384_mont_sqr_n_15(t2, t3, 15, p384_mod, p384_mp_mod);
            /* t4 = y ^ 0x3ffffff */
            sp_384_mont_mul_15(t4, t3, t2, p384_mod, p384_mp_mod);
            /* t2 = y ^ 0xffffffc000000 */
            sp_384_mont_sqr_n_15(t2, t4, 30, p384_mod, p384_mp_mod);
            /* t1 = y ^ 0xfffffffffffff */
            sp_384_mont_mul_15(t1, t4, t2, p384_mod, p384_mp_mod);
            /* t2 = y ^ 0xfffffffffffffff000000000000000 */
            sp_384_mont_sqr_n_15(t2, t1, 60, p384_mod, p384_mp_mod);
            /* t1 = y ^ 0xffffffffffffffffffffffffffffff */
            sp_384_mont_mul_15(t1, t1, t2, p384_mod, p384_mp_mod);
            /* t2 = y ^ 0xffffffffffffffffffffffffffffff000000000000000000000000000000 */
            sp_384_mont_sqr_n_15(t2, t1, 120, p384_mod, p384_mp_mod);
            /* t1 = y ^ 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff */
            sp_384_mont_mul_15(t1, t1, t2, p384_mod, p384_mp_mod);
            /* t2 = y ^ 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8000 */
            sp_384_mont_sqr_n_15(t2, t1, 15, p384_mod, p384_mp_mod);
            /* t1 = y ^ 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff */
            sp_384_mont_mul_15(t1, t3, t2, p384_mod, p384_mp_mod);
            /* t2 = y ^ 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80000000 */
            sp_384_mont_sqr_n_15(t2, t1, 31, p384_mod, p384_mp_mod);
            /* t1 = y ^ 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffffff */
            sp_384_mont_mul_15(t1, t4, t2, p384_mod, p384_mp_mod);
            /* t2 = y ^ 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffffff0 */
            sp_384_mont_sqr_n_15(t2, t1, 4, p384_mod, p384_mp_mod);
            /* t1 = y ^ 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffffffc */
            sp_384_mont_mul_15(t1, t5, t2, p384_mod, p384_mp_mod);
            /* t2 = y ^ 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000 */
            sp_384_mont_sqr_n_15(t2, t1, 62, p384_mod, p384_mp_mod);
            /* t1 = y ^ 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000001 */
            sp_384_mont_mul_15(t1, y, t2, p384_mod, p384_mp_mod);
            /* t2 = y ^ 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffffffc00000000000000040000000 */
            sp_384_mont_sqr_n_15(y, t1, 30, p384_mod, p384_mp_mod);
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL) {
        XFREE(d, NULL, DYNAMIC_TYPE_ECC);
    }
#endif

    return err;
}


/* Uncompress the point given the X ordinate.
 *
 * xm    X ordinate.
 * odd   Whether the Y ordinate is odd.
 * ym    Calculated Y ordinate.
 * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
 */
int sp_ecc_uncompress_384(mp_int* xm, int odd, mp_int* ym)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* d;
#else
    sp_digit xd[2 * 15];
    sp_digit yd[2 * 15];
#endif
    sp_digit* x = NULL;
    sp_digit* y = NULL;
    int err = MP_OKAY;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    d = (sp_digit*)XMALLOC(sizeof(sp_digit) * 4 * 15, NULL, DYNAMIC_TYPE_ECC);
    if (d == NULL) {
        err = MEMORY_E;
    }
#endif

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        x = d + 0 * 15;
        y = d + 2 * 15;
#else
        x = xd;
        y = yd;
#endif

        sp_384_from_mp(x, 15, xm);
        err = sp_384_mod_mul_norm_15(x, x, p384_mod);
    }
    if (err == MP_OKAY) {
        /* y = x^3 */
        {
            sp_384_mont_sqr_15(y, x, p384_mod, p384_mp_mod);
            sp_384_mont_mul_15(y, y, x, p384_mod, p384_mp_mod);
        }
        /* y = x^3 - 3x */
        sp_384_mont_sub_15(y, y, x, p384_mod);
        sp_384_mont_sub_15(y, y, x, p384_mod);
        sp_384_mont_sub_15(y, y, x, p384_mod);
        /* y = x^3 - 3x + b */
        err = sp_384_mod_mul_norm_15(x, p384_b, p384_mod);
    }
    if (err == MP_OKAY) {
        sp_384_mont_add_15(y, y, x, p384_mod);
        /* y = sqrt(x^3 - 3x + b) */
        err = sp_384_mont_sqrt_15(y);
    }
    if (err == MP_OKAY) {
        XMEMSET(y + 15, 0, 15U * sizeof(sp_digit));
        sp_384_mont_reduce_15(y, p384_mod, p384_mp_mod);
        if ((((word32)y[0] ^ (word32)odd) & 1U) != 0U) {
            sp_384_mont_sub_15(y, p384_mod, y, p384_mod);
        }

        err = sp_384_to_mp(y, ym);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (d != NULL) {
        XFREE(d, NULL, DYNAMIC_TYPE_ECC);
    }
#endif

    return err;
}
#endif
#endif /* WOLFSSL_SP_384 */
#ifdef WOLFSSL_SP_1024

/* Point structure to use. */
typedef struct sp_point_1024 {
    /* X ordinate of point. */
    sp_digit x[2 * 52];
    /* Y ordinate of point. */
    sp_digit y[2 * 52];
    /* Z ordinate of point. */
    sp_digit z[2 * 52];
    /* Indicates point is at infinity. */
    int infinity;
} sp_point_1024;

#ifndef WOLFSSL_SP_SMALL
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_1024_mul_26(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int i;
    int j;
    int64_t t[52];

    XMEMSET(t, 0, sizeof(t));
    for (i=0; i<26; i++) {
        for (j=0; j<26; j++) {
            t[i+j] += ((int64_t)a[i]) * b[j];
        }
    }
    for (i=0; i<51; i++) {
        r[i] = t[i] & 0xfffff;
        t[i+1] += t[i] >> 20;
    }
    r[51] = (sp_digit)t[51];
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_1024_sqr_26(sp_digit* r, const sp_digit* a)
{
    int i;
    int j;
    int64_t t[52];

    XMEMSET(t, 0, sizeof(t));
    for (i=0; i<26; i++) {
        for (j=0; j<i; j++) {
            t[i+j] += (((int64_t)a[i]) * a[j]) * 2;
        }
        t[i+i] += ((int64_t)a[i]) * a[i];
    }
    for (i=0; i<51; i++) {
        r[i] = t[i] & 0xfffff;
        t[i+1] += t[i] >> 20;
    }
    r[51] = (sp_digit)t[51];
}

/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_1024_add_26(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 24; i += 8) {
        r[i + 0] = a[i + 0] + b[i + 0];
        r[i + 1] = a[i + 1] + b[i + 1];
        r[i + 2] = a[i + 2] + b[i + 2];
        r[i + 3] = a[i + 3] + b[i + 3];
        r[i + 4] = a[i + 4] + b[i + 4];
        r[i + 5] = a[i + 5] + b[i + 5];
        r[i + 6] = a[i + 6] + b[i + 6];
        r[i + 7] = a[i + 7] + b[i + 7];
    }
    r[24] = a[24] + b[24];
    r[25] = a[25] + b[25];

    return 0;
}

/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_1024_add_52(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 48; i += 8) {
        r[i + 0] = a[i + 0] + b[i + 0];
        r[i + 1] = a[i + 1] + b[i + 1];
        r[i + 2] = a[i + 2] + b[i + 2];
        r[i + 3] = a[i + 3] + b[i + 3];
        r[i + 4] = a[i + 4] + b[i + 4];
        r[i + 5] = a[i + 5] + b[i + 5];
        r[i + 6] = a[i + 6] + b[i + 6];
        r[i + 7] = a[i + 7] + b[i + 7];
    }
    r[48] = a[48] + b[48];
    r[49] = a[49] + b[49];
    r[50] = a[50] + b[50];
    r[51] = a[51] + b[51];

    return 0;
}

/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_1024_sub_52(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 48; i += 8) {
        r[i + 0] = a[i + 0] - b[i + 0];
        r[i + 1] = a[i + 1] - b[i + 1];
        r[i + 2] = a[i + 2] - b[i + 2];
        r[i + 3] = a[i + 3] - b[i + 3];
        r[i + 4] = a[i + 4] - b[i + 4];
        r[i + 5] = a[i + 5] - b[i + 5];
        r[i + 6] = a[i + 6] - b[i + 6];
        r[i + 7] = a[i + 7] - b[i + 7];
    }
    r[48] = a[48] - b[48];
    r[49] = a[49] - b[49];
    r[50] = a[50] - b[50];
    r[51] = a[51] - b[51];

    return 0;
}

/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_1024_mul_52(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    sp_digit* z0 = r;
    sp_digit z1[52];
    sp_digit* a1 = z1;
    sp_digit b1[26];
    sp_digit* z2 = r + 52;
    (void)sp_1024_add_26(a1, a, &a[26]);
    (void)sp_1024_add_26(b1, b, &b[26]);
    sp_1024_mul_26(z2, &a[26], &b[26]);
    sp_1024_mul_26(z0, a, b);
    sp_1024_mul_26(z1, a1, b1);
    (void)sp_1024_sub_52(z1, z1, z2);
    (void)sp_1024_sub_52(z1, z1, z0);
    (void)sp_1024_add_52(r + 26, r + 26, z1);
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_1024_sqr_52(sp_digit* r, const sp_digit* a)
{
    sp_digit* z0 = r;
    sp_digit z1[52];
    sp_digit* a1 = z1;
    sp_digit* z2 = r + 52;
    (void)sp_1024_add_26(a1, a, &a[26]);
    sp_1024_sqr_26(z2, &a[26]);
    sp_1024_sqr_26(z0, a);
    sp_1024_sqr_26(z1, a1);
    (void)sp_1024_sub_52(z1, z1, z2);
    (void)sp_1024_sub_52(z1, z1, z0);
    (void)sp_1024_add_52(r + 26, r + 26, z1);
}

#else
/* Multiply a and b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static void sp_1024_mul_52(sp_digit* r, const sp_digit* a,
    const sp_digit* b)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[51]) * b[51];
    r[103] = (sp_digit)(c >> 20);
    c = (c & 0xfffff) << 20;
    for (k = 101; k >= 0; k--) {
        for (i = 51; i >= 0; i--) {
            j = k - i;
            if (j >= 52) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * b[j];
        }
        r[k + 2] += c >> 40;
        r[k + 1] = (c >> 20) & 0xfffff;
        c = (c & 0xfffff) << 20;
    }
    r[0] = (sp_digit)(c >> 20);
}

/* Square a and put result in r. (r = a * a)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 */
SP_NOINLINE static void sp_1024_sqr_52(sp_digit* r, const sp_digit* a)
{
    int i;
    int j;
    int k;
    int64_t c;

    c = ((int64_t)a[51]) * a[51];
    r[103] = (sp_digit)(c >> 20);
    c = (c & 0xfffff) << 20;
    for (k = 101; k >= 0; k--) {
        for (i = 51; i >= 0; i--) {
            j = k - i;
            if (j >= 52 || i <= j) {
                break;
            }
            if (j < 0) {
                continue;
            }

            c += ((int64_t)a[i]) * a[j] * 2;
        }
        if (i == j) {
           c += ((int64_t)a[i]) * a[i];
        }

        r[k + 2] += c >> 40;
        r[k + 1] = (c >> 20) & 0xfffff;
        c = (c & 0xfffff) << 20;
    }
    r[0] = (sp_digit)(c >> 20);
}

#endif /* !WOLFSSL_SP_SMALL */
/* The modulus (prime) of the curve P1024. */
static const sp_digit p1024_mod[52] = {
    0x85feb,0x7afea,0x66d80,0xce876,0x0ac7a,0xc5df1,0xdb080,0x89857,0x3e823,
    0x1ffce,0x6971f,0xd6af5,0xa9f94,0x3c09a,0xc521c,0xa7cf3,0x52a82,0xa8318,
    0x6aff4,0x1ce1b,0xd6568,0x2ac5c,0xcd451,0x326b4,0xc6487,0xd0e26,0x666a6,
    0x27f4a,0x9356d,0xc88a1,0x39ff7,0xe791b,0x59cb0,0xd531a,0x28730,0x0f1b2,
    0x7e2fc,0x0aab2,0xa2ef4,0xb3e01,0xae358,0x61be9,0xcb482,0x0ce19,0xa416c,
    0xd0657,0x198da,0x65c61,0x63fda,0x1f0a5,0x97abb,0x00009
};
/* The Montogmery normalizer for modulus of the curve P1024. */
static const sp_digit p1024_norm_mod[52] = {
    0x7a015,0x85015,0x9927f,0x31789,0xf5385,0x3a20e,0x24f7f,0x767a8,0xc17dc,
    0xe0031,0x968e0,0x2950a,0x5606b,0xc3f65,0x3ade3,0x5830c,0xad57d,0x57ce7,
    0x9500b,0xe31e4,0x29a97,0xd53a3,0x32bae,0xcd94b,0x39b78,0x2f1d9,0x99959,
    0xd80b5,0x6ca92,0x3775e,0xc6008,0x186e4,0xa634f,0x2ace5,0xd78cf,0xf0e4d,
    0x81d03,0xf554d,0x5d10b,0x4c1fe,0x51ca7,0x9e416,0x34b7d,0xf31e6,0x5be93,
    0x2f9a8,0xe6725,0x9a39e,0x9c025,0xe0f5a,0x68544,0x00006
};
/* The Montogmery multiplier for modulus of the curve P1024. */
static sp_digit p1024_mp_mod = 0xf2f3d;
#ifdef WOLFSSL_SP_SMALL
/* The order of the curve P1024. */
static const sp_digit p1024_order[52] = {
    0xa17fb,0x1ebfa,0x99b60,0xb3a1d,0x42b1e,0x3177c,0xf6c20,0xe2615,0x8fa08,
    0xc7ff3,0x5a5c7,0x35abd,0xaa7e5,0x0f026,0xf1487,0xa9f3c,0x14aa0,0x2a0c6,
    0xdabfd,0x07386,0x3595a,0x4ab17,0x33514,0xcc9ad,0xb1921,0xb4389,0x999a9,
    0x49fd2,0x64d5b,0xf2228,0xce7fd,0x39e46,0x9672c,0x354c6,0x8a1cc,0x03c6c,
    0x9f8bf,0x02aac,0x68bbd,0x2cf80,0x6b8d6,0x986fa,0x72d20,0x03386,0xe905b,
    0xb4195,0x46636,0x99718,0x58ff6,0xc7c29,0x65eae,0x00002
};
#endif
/* The base point of curve P1024. */
static const sp_point_1024 p1024_base = {
    /* X ordinate */
    {
        0x63895,0xabeae,0x80dc8,0x09798,0x4967e,0xec46c,0x3ec80,0xb63f7,0x163a5,
        0x87ee9,0x0728d,0xb4cc8,0xdd5cf,0x66910,0x14dba,0xa7c15,0x0de74,0x397a6,
        0x702c3,0xf2e1a,0x48b72,0x7c865,0xccb33,0x5dd5b,0x0af76,0x90976,0x06ce8,
        0xd9e74,0x5718b,0x9dfa5,0x22cdb,0x43d5f,0x09e10,0x9030b,0xb10db,0x2308a,
        0x0f6ce,0xedb6c,0xcbfb5,0xb6ff7,0x2f204,0xc698b,0xaec69,0x2fd60,0xa2b1a,
        0xd9b52,0x0053e,0x0a799,0xc29ad,0xee332,0x3fc09,0x00005,
        0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L
    },
    /* Y ordinate */
    {
        0xf16d7,0xd71be,0x5573f,0xdcde7,0x06a67,0xb9b57,0x636ad,0xd5bb4,0xdad5a,
        0xa980b,0x9cb99,0x5ad7e,0x21351,0xa4d5f,0x79fc5,0x492d9,0xaa989,0x80164,
        0xc6f1e,0x2fe0a,0x5b765,0xd696b,0xc6cca,0xad547,0xae117,0xb970d,0x9e032,
        0xff0ca,0xe416c,0x140b2,0xccf9a,0x6b598,0xe55f6,0xe5f0d,0x7f7f5,0xc2b9e,
        0x4654e,0xea69f,0x178f5,0x1e141,0x78d82,0x963d7,0x29906,0x20160,0x5d3e8,
        0x34a13,0x05336,0xf9f1f,0x009f1,0x063f6,0xa8249,0x00000,
        0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L
    },
    /* Z ordinate */
    {
        0x00001,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,
        0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,
        0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,
        0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,
        0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,
        0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,0x00000,
        0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L
    },
    /* infinity */
    0
};

/* Normalize the values in each word to 20.
 *
 * a  Array of sp_digit to normalize.
 */
static void sp_1024_norm_52(sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    for (i = 0; i < 51; i++) {
        a[i+1] += a[i] >> 20;
        a[i] &= 0xfffff;
    }
#else
    int i;
    for (i = 0; i < 48; i += 8) {
        a[i+1] += a[i+0] >> 20; a[i+0] &= 0xfffff;
        a[i+2] += a[i+1] >> 20; a[i+1] &= 0xfffff;
        a[i+3] += a[i+2] >> 20; a[i+2] &= 0xfffff;
        a[i+4] += a[i+3] >> 20; a[i+3] &= 0xfffff;
        a[i+5] += a[i+4] >> 20; a[i+4] &= 0xfffff;
        a[i+6] += a[i+5] >> 20; a[i+5] &= 0xfffff;
        a[i+7] += a[i+6] >> 20; a[i+6] &= 0xfffff;
        a[i+8] += a[i+7] >> 20; a[i+7] &= 0xfffff;
        a[i+9] += a[i+8] >> 20; a[i+8] &= 0xfffff;
    }
    a[48+1] += a[48] >> 20;
    a[48] &= 0xfffff;
    a[49+1] += a[49] >> 20;
    a[49] &= 0xfffff;
    a[50+1] += a[50] >> 20;
    a[50] &= 0xfffff;
#endif
}

/* Multiply a by scalar b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_1024_mul_d_52(sp_digit* r, const sp_digit* a,
    sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 52; i++) {
        t += tb * a[i];
        r[i] = t & 0xfffff;
        t >>= 20;
    }
    r[52] = (sp_digit)t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] = t[0] & 0xfffff;
    for (i = 0; i < 48; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] = (sp_digit)(t[0] >> 20) + (t[1] & 0xfffff);
        t[2] = tb * a[i+2];
        r[i+2] = (sp_digit)(t[1] >> 20) + (t[2] & 0xfffff);
        t[3] = tb * a[i+3];
        r[i+3] = (sp_digit)(t[2] >> 20) + (t[3] & 0xfffff);
        t[4] = tb * a[i+4];
        r[i+4] = (sp_digit)(t[3] >> 20) + (t[4] & 0xfffff);
        t[5] = tb * a[i+5];
        r[i+5] = (sp_digit)(t[4] >> 20) + (t[5] & 0xfffff);
        t[6] = tb * a[i+6];
        r[i+6] = (sp_digit)(t[5] >> 20) + (t[6] & 0xfffff);
        t[7] = tb * a[i+7];
        r[i+7] = (sp_digit)(t[6] >> 20) + (t[7] & 0xfffff);
        t[0] = tb * a[i+8];
        r[i+8] = (sp_digit)(t[7] >> 20) + (t[0] & 0xfffff);
    }
    t[1] = tb * a[49];
    r[49] = (sp_digit)(t[0] >> 20) + (t[1] & 0xfffff);
    t[2] = tb * a[50];
    r[50] = (sp_digit)(t[1] >> 20) + (t[2] & 0xfffff);
    t[3] = tb * a[51];
    r[51] = (sp_digit)(t[2] >> 20) + (t[3] & 0xfffff);
    r[52] =  (sp_digit)(t[3] >> 20);
#endif /* WOLFSSL_SP_SMALL */
}

/* Multiply a by scalar b into r. (r = a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_1024_mul_d_104(sp_digit* r, const sp_digit* a,
    sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 104; i++) {
        t += tb * a[i];
        r[i] = t & 0xfffff;
        t >>= 20;
    }
    r[104] = (sp_digit)t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] = t[0] & 0xfffff;
    for (i = 0; i < 104; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] = (sp_digit)(t[0] >> 20) + (t[1] & 0xfffff);
        t[2] = tb * a[i+2];
        r[i+2] = (sp_digit)(t[1] >> 20) + (t[2] & 0xfffff);
        t[3] = tb * a[i+3];
        r[i+3] = (sp_digit)(t[2] >> 20) + (t[3] & 0xfffff);
        t[4] = tb * a[i+4];
        r[i+4] = (sp_digit)(t[3] >> 20) + (t[4] & 0xfffff);
        t[5] = tb * a[i+5];
        r[i+5] = (sp_digit)(t[4] >> 20) + (t[5] & 0xfffff);
        t[6] = tb * a[i+6];
        r[i+6] = (sp_digit)(t[5] >> 20) + (t[6] & 0xfffff);
        t[7] = tb * a[i+7];
        r[i+7] = (sp_digit)(t[6] >> 20) + (t[7] & 0xfffff);
        t[0] = tb * a[i+8];
        r[i+8] = (sp_digit)(t[7] >> 20) + (t[0] & 0xfffff);
    }
    r[104] =  (sp_digit)(t[7] >> 20);
#endif /* WOLFSSL_SP_SMALL */
}

/* Conditionally add a and b using the mask m.
 * m is -1 to add and 0 when not.
 *
 * r  A single precision number representing conditional add result.
 * a  A single precision number to add with.
 * b  A single precision number to add.
 * m  Mask value to apply.
 */
static void sp_1024_cond_add_52(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 52; i++) {
        r[i] = a[i] + (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 48; i += 8) {
        r[i + 0] = a[i + 0] + (b[i + 0] & m);
        r[i + 1] = a[i + 1] + (b[i + 1] & m);
        r[i + 2] = a[i + 2] + (b[i + 2] & m);
        r[i + 3] = a[i + 3] + (b[i + 3] & m);
        r[i + 4] = a[i + 4] + (b[i + 4] & m);
        r[i + 5] = a[i + 5] + (b[i + 5] & m);
        r[i + 6] = a[i + 6] + (b[i + 6] & m);
        r[i + 7] = a[i + 7] + (b[i + 7] & m);
    }
    r[48] = a[48] + (b[48] & m);
    r[49] = a[49] + (b[49] & m);
    r[50] = a[50] + (b[50] & m);
    r[51] = a[51] + (b[51] & m);
#endif /* WOLFSSL_SP_SMALL */
}

#ifdef WOLFSSL_SP_SMALL
/* Sub b from a into r. (r = a - b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_1024_sub_52(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 52; i++) {
        r[i] = a[i] - b[i];
    }

    return 0;
}

#endif
#ifdef WOLFSSL_SP_SMALL
/* Add b to a into r. (r = a + b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A single precision integer.
 */
SP_NOINLINE static int sp_1024_add_52(sp_digit* r, const sp_digit* a,
        const sp_digit* b)
{
    int i;

    for (i = 0; i < 52; i++) {
        r[i] = a[i] + b[i];
    }

    return 0;
}
#endif
SP_NOINLINE static void sp_1024_rshift_52(sp_digit* r, const sp_digit* a,
        byte n)
{
    int i;

#ifdef WOLFSSL_SP_SMALL
    for (i=0; i<51; i++) {
        r[i] = ((a[i] >> n) | (a[i + 1] << (20 - n))) & 0xfffff;
    }
#else
    for (i=0; i<48; i += 8) {
        r[i+0] = ((a[i+0] >> n) | (a[i+1] << (20 - n))) & 0xfffff;
        r[i+1] = ((a[i+1] >> n) | (a[i+2] << (20 - n))) & 0xfffff;
        r[i+2] = ((a[i+2] >> n) | (a[i+3] << (20 - n))) & 0xfffff;
        r[i+3] = ((a[i+3] >> n) | (a[i+4] << (20 - n))) & 0xfffff;
        r[i+4] = ((a[i+4] >> n) | (a[i+5] << (20 - n))) & 0xfffff;
        r[i+5] = ((a[i+5] >> n) | (a[i+6] << (20 - n))) & 0xfffff;
        r[i+6] = ((a[i+6] >> n) | (a[i+7] << (20 - n))) & 0xfffff;
        r[i+7] = ((a[i+7] >> n) | (a[i+8] << (20 - n))) & 0xfffff;
    }
    r[48] = ((a[48] >> n) | (a[49] << (20 - n))) & 0xfffff;
    r[49] = ((a[49] >> n) | (a[50] << (20 - n))) & 0xfffff;
    r[50] = ((a[50] >> n) | (a[51] << (20 - n))) & 0xfffff;
#endif
    r[51] = a[51] >> n;
}

#ifdef WOLFSSL_SP_DIV_32
static WC_INLINE sp_digit sp_1024_div_word_52(sp_digit d1, sp_digit d0,
    sp_digit dv)
{
    sp_digit d;
    sp_digit r;
    sp_digit t;

    /* All 20 bits from d1 and top 11 bits from d0. */
    d = (d1 << 11) | (d0 >> 9);
    r = d / dv;
    d -= r * dv;
    /* Up to 12 bits in r */
    /* Remaining 9 bits from d0. */
    r <<= 9;
    d <<= 9;
    d |= d0 & ((1 << 9) - 1);
    t = d / dv;
    r += t;

    return r;
}
#endif /* WOLFSSL_SP_DIV_32 */

/* Divide d in a and put remainder into r (m*d + r = a)
 * m is not calculated as it is not needed at this time.
 *
 * a  Nmber to be divided.
 * d  Number to divide with.
 * m  Multiplier result.
 * r  Remainder from the division.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_1024_div_52(const sp_digit* a, const sp_digit* d,
        const sp_digit* m, sp_digit* r)
{
    int i;
#ifndef WOLFSSL_SP_DIV_32
    int64_t d1;
#endif
    sp_digit dv;
    sp_digit r1;
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    sp_digit* td;
#else
    sp_digit t1d[104 + 1];
    sp_digit t2d[52 + 1];
    sp_digit sdd[52 + 1];
#endif
    sp_digit* t1;
    sp_digit* t2;
    sp_digit* sd;
    int err = MP_OKAY;

    (void)m;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    td = (sp_digit*)XMALLOC(sizeof(sp_digit) * (4 * 52 + 3), NULL,
                                                       DYNAMIC_TYPE_TMP_BUFFER);
    if (td == NULL) {
        err = MEMORY_E;
    }
#endif

    (void)m;

    if (err == MP_OKAY) {
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
        t1 = td;
        t2 = td + 104 + 1;
        sd = t2 + 52 + 1;
#else
        t1 = t1d;
        t2 = t2d;
        sd = sdd;
#endif

        sp_1024_mul_d_52(sd, d, 1L << 16);
        sp_1024_mul_d_104(t1, a, 1L << 16);
        dv = sd[51];
        for (i=52; i>=0; i--) {
            t1[52 + i] += t1[52 + i - 1] >> 20;
            t1[52 + i - 1] &= 0xfffff;
#ifndef WOLFSSL_SP_DIV_32
            d1 = t1[52 + i];
            d1 <<= 20;
            d1 += t1[52 + i - 1];
            r1 = (sp_digit)(d1 / dv);
#else
            r1 = sp_1024_div_word_52(t1[52 + i], t1[52 + i - 1], dv);
#endif

            sp_1024_mul_d_52(t2, sd, r1);
            (void)sp_1024_sub_52(&t1[i], &t1[i], t2);
            t1[52 + i] -= t2[52];
            t1[52 + i] += t1[52 + i - 1] >> 20;
            t1[52 + i - 1] &= 0xfffff;
            r1 = (((-t1[52 + i]) << 20) - t1[52 + i - 1]) / dv;
            r1 -= t1[52 + i];
            sp_1024_mul_d_52(t2, sd, r1);
            (void)sp_1024_add_52(&t1[i], &t1[i], t2);
            t1[52 + i] += t1[52 + i - 1] >> 20;
            t1[52 + i - 1] &= 0xfffff;
        }
        t1[52 - 1] += t1[52 - 2] >> 20;
        t1[52 - 2] &= 0xfffff;
        r1 = t1[52 - 1] / dv;

        sp_1024_mul_d_52(t2, sd, r1);
        sp_1024_sub_52(t1, t1, t2);
        XMEMCPY(r, t1, sizeof(*r) * 2U * 52U);
        for (i=0; i<51; i++) {
            r[i+1] += r[i] >> 20;
            r[i] &= 0xfffff;
        }
        sp_1024_cond_add_52(r, r, sd, 0 - ((r[51] < 0) ?
                    (sp_digit)1 : (sp_digit)0));

        sp_1024_norm_52(r);
        sp_1024_rshift_52(r, r, 16);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (td != NULL) {
        XFREE(td, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    }
#endif

    return err;
}

/* Reduce a modulo m into r. (r = a mod m)
 *
 * r  A single precision number that is the reduced result.
 * a  A single precision number that is to be reduced.
 * m  A single precision number that is the modulus to reduce with.
 * returns MEMORY_E when unable to allocate memory and MP_OKAY otherwise.
 */
static int sp_1024_mod_52(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    return sp_1024_div_52(a, m, NULL, r);
}

/* Multiply a number by Montogmery normalizer mod modulus (prime).
 *
 * r  The resulting Montgomery form number.
 * a  The number to convert.
 * m  The modulus (prime).
 * returns MEMORY_E when memory allocation fails and MP_OKAY otherwise.
 */
static int sp_1024_mod_mul_norm_52(sp_digit* r, const sp_digit* a,
        const sp_digit* m)
{
    sp_1024_mul_52(r, a, p1024_norm_mod);
    return sp_1024_mod_52(r, r, m);
}

/* Create a new point.
 *
 * heap  [in]   Buffer to allocate dynamic memory from.
 * sp    [in]   Data for point - only if not allocating.
 * p     [out]  New point.
 * returns MEMORY_E when dynamic memory allocation fails and 0 otherwise. 
 */
static int sp_1024_point_new_ex_52(void* heap, sp_point_1024* sp,
        sp_point_1024** p)
{
    int ret = MP_OKAY;
    (void)heap;
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    (void)sp;
    *p = (sp_point_1024*)XMALLOC(sizeof(sp_point_1024), heap, DYNAMIC_TYPE_ECC);
#else
    *p = sp;
#endif
    if (*p == NULL) {
        ret = MEMORY_E;
    }
    return ret;
}

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
/* Allocate memory for point and return error. */
#define sp_1024_point_new_52(heap, sp, p) sp_1024_point_new_ex_52((heap), NULL, &(p))
#else
/* Set pointer to data and return no error. */
#define sp_1024_point_new_52(heap, sp, p) sp_1024_point_new_ex_52((heap), &(sp), &(p))
#endif


/* Free the point.
 *
 * p      [in,out]  Point to free.
 * clear  [in]      Indicates whether to zeroize point.
 * heap   [in]      Buffer from which dynamic memory was allocate from.
 */
static void sp_1024_point_free_52(sp_point_1024* p, int clear, void* heap)
{
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
/* If valid pointer then clear point data if requested and free data. */
    if (p != NULL) {
        if (clear != 0) {
            XMEMSET(p, 0, sizeof(*p));
        }
        XFREE(p, heap, DYNAMIC_TYPE_ECC);
    }
#else
/* Clear point data if requested. */
    if (clear != 0) {
        XMEMSET(p, 0, sizeof(*p));
    }
#endif
    (void)heap;
}

/* Convert an mp_int to an array of sp_digit.
 *
 * r  A single precision integer.
 * size  Maximum number of bytes to convert
 * a  A multi-precision integer.
 */
static void sp_1024_from_mp(sp_digit* r, int size, const mp_int* a)
{
#if DIGIT_BIT == 20
    int j;

    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);

    for (j = a->used; j < size; j++) {
        r[j] = 0;
    }
#elif DIGIT_BIT > 20
    int i;
    int j = 0;
    word32 s = 0;

    r[0] = 0;
    for (i = 0; i < a->used && j < size; i++) {
        r[j] |= ((sp_digit)a->dp[i] << s);
        r[j] &= 0xfffff;
        s = 20U - s;
        if (j + 1 >= size) {
            break;
        }
        /* lint allow cast of mismatch word32 and mp_digit */
        r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
        while ((s + 20U) <= (word32)DIGIT_BIT) {
            s += 20U;
            r[j] &= 0xfffff;
            if (j + 1 >= size) {
                break;
            }
            if (s < (word32)DIGIT_BIT) {
                /* lint allow cast of mismatch word32 and mp_digit */
                r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
            }
            else {
                r[++j] = 0L;
            }
        }
        s = (word32)DIGIT_BIT - s;
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#else
    int i;
    int j = 0;
    int s = 0;

    r[0] = 0;
    for (i = 0; i < a->used && j < size; i++) {
        r[j] |= ((sp_digit)a->dp[i]) << s;
        if (s + DIGIT_BIT >= 20) {
            r[j] &= 0xfffff;
            if (j + 1 >= size) {
                break;
            }
            s = 20 - s;
            if (s == DIGIT_BIT) {
                r[++j] = 0;
                s = 0;
            }
            else {
                r[++j] = a->dp[i] >> s;
                s = DIGIT_BIT - s;
            }
        }
        else {
            s += DIGIT_BIT;
        }
    }

    for (j++; j < size; j++) {
        r[j] = 0;
    }
#endif
}

/* Convert a point of type ecc_point to type sp_point_1024.
 *
 * p   Point of type sp_point_1024 (result).
 * pm  Point of type ecc_point.
 */
static void sp_1024_point_from_ecc_point_52(sp_point_1024* p,
        const ecc_point* pm)
{
    XMEMSET(p->x, 0, sizeof(p->x));
    XMEMSET(p->y, 0, sizeof(p->y));
    XMEMSET(p->z, 0, sizeof(p->z));
    sp_1024_from_mp(p->x, 52, pm->x);
    sp_1024_from_mp(p->y, 52, pm->y);
    sp_1024_from_mp(p->z, 52, pm->z);
    p->infinity = 0;
}

/* Convert an array of sp_digit to an mp_int.
 *
 * a  A single precision integer.
 * r  A multi-precision integer.
 */
static int sp_1024_to_mp(const sp_digit* a, mp_int* r)
{
    int err;

    err = mp_grow(r, (1024 + DIGIT_BIT - 1) / DIGIT_BIT);
    if (err == MP_OKAY) { /*lint !e774 case where err is always MP_OKAY*/
#if DIGIT_BIT == 20
        XMEMCPY(r->dp, a, sizeof(sp_digit) * 52);
        r->used = 52;
        mp_clamp(r);
#elif DIGIT_BIT < 20
        int i;
        int j = 0;
        int s = 0;

        r->dp[0] = 0;
        for (i = 0; i < 52; i++) {
            r->dp[j] |= (mp_digit)(a[i] << s);
            r->dp[j] &= ((sp_digit)1 << DIGIT_BIT) - 1;
            s = DIGIT_BIT - s;
            r->dp[++j] = (mp_digit)(a[i] >> s);
            while (s + DIGIT_BIT <= 20) {
                s += DIGIT_BIT;
                r->dp[j++] &= ((sp_digit)1 << DIGIT_BIT) - 1;
                if (s == SP_WORD_SIZE) {
                    r->dp[j] = 0;
                }
                else {
                    r->dp[j] = (mp_digit)(a[i] >> s);
                }
            }
            s = 20 - s;
        }
        r->used = (1024 + DIGIT_BIT - 1) / DIGIT_BIT;
        mp_clamp(r);
#else
        int i;
        int j = 0;
        int s = 0;

        r->dp[0] = 0;
        for (i = 0; i < 52; i++) {
            r->dp[j] |= ((mp_digit)a[i]) << s;
            if (s + 20 >= DIGIT_BIT) {
    #if DIGIT_BIT != 32 && DIGIT_BIT != 64
                r->dp[j] &= ((sp_digit)1 << DIGIT_BIT) - 1;
    #endif
                s = DIGIT_BIT - s;
                r->dp[++j] = a[i] >> s;
                s = 20 - s;
            }
            else {
                s += 20;
            }
        }
        r->used = (1024 + DIGIT_BIT - 1) / DIGIT_BIT;
        mp_clamp(r);
#endif
    }

    return err;
}

/* Convert a point of type sp_point_1024 to type ecc_point.
 *
 * p   Point of type sp_point_1024.
 * pm  Point of type ecc_point (result).
 * returns MEMORY_E when allocation of memory in ecc_point fails otherwise
 * MP_OKAY.
 */
static int sp_1024_point_to_ecc_point_52(const sp_point_1024* p, ecc_point* pm)
{
    int err;

    err = sp_1024_to_mp(p->x, pm->x);
    if (err == MP_OKAY) {
        err = sp_1024_to_mp(p->y, pm->y);
    }
    if (err == MP_OKAY) {
        err = sp_1024_to_mp(p->z, pm->z);
    }

    return err;
}

/* Compare a with b in constant time.
 *
 * a  A single precision integer.
 * b  A single precision integer.
 * return -ve, 0 or +ve if a is less than, equal to or greater than b
 * respectively.
 */
static sp_digit sp_1024_cmp_52(const sp_digit* a, const sp_digit* b)
{
    sp_digit r = 0;
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=51; i>=0; i--) {
        r |= (a[i] - b[i]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#else
    int i;

    r |= (a[51] - b[51]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[50] - b[50]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[49] - b[49]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    r |= (a[48] - b[48]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    for (i = 40; i >= 0; i -= 8) {
        r |= (a[i + 7] - b[i + 7]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 6] - b[i + 6]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 5] - b[i + 5]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 4] - b[i + 4]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 3] - b[i + 3]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 2] - b[i + 2]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 1] - b[i + 1]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
        r |= (a[i + 0] - b[i + 0]) & (0 - ((r == 0) ? (sp_digit)1 : (sp_digit)0));
    }
#endif /* WOLFSSL_SP_SMALL */

    return r;
}

/* Conditionally subtract b from a using the mask m.
 * m is -1 to subtract and 0 when not.
 *
 * r  A single precision number representing condition subtract result.
 * a  A single precision number to subtract from.
 * b  A single precision number to subtract.
 * m  Mask value to apply.
 */
static void sp_1024_cond_sub_52(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit m)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 52; i++) {
        r[i] = a[i] - (b[i] & m);
    }
#else
    int i;

    for (i = 0; i < 48; i += 8) {
        r[i + 0] = a[i + 0] - (b[i + 0] & m);
        r[i + 1] = a[i + 1] - (b[i + 1] & m);
        r[i + 2] = a[i + 2] - (b[i + 2] & m);
        r[i + 3] = a[i + 3] - (b[i + 3] & m);
        r[i + 4] = a[i + 4] - (b[i + 4] & m);
        r[i + 5] = a[i + 5] - (b[i + 5] & m);
        r[i + 6] = a[i + 6] - (b[i + 6] & m);
        r[i + 7] = a[i + 7] - (b[i + 7] & m);
    }
    r[48] = a[48] - (b[48] & m);
    r[49] = a[49] - (b[49] & m);
    r[50] = a[50] - (b[50] & m);
    r[51] = a[51] - (b[51] & m);
#endif /* WOLFSSL_SP_SMALL */
}

/* Mul a by scalar b and add into r. (r += a * b)
 *
 * r  A single precision integer.
 * a  A single precision integer.
 * b  A scalar.
 */
SP_NOINLINE static void sp_1024_mul_add_52(sp_digit* r, const sp_digit* a,
        const sp_digit b)
{
#ifdef WOLFSSL_SP_SMALL
    int64_t tb = b;
    int64_t t = 0;
    int i;

    for (i = 0; i < 52; i++) {
        t += (tb * a[i]) + r[i];
        r[i] = t & 0xfffff;
        t >>= 20;
    }
    r[52] += t;
#else
    int64_t tb = b;
    int64_t t[8];
    int i;

    t[0] = tb * a[0]; r[0] += (sp_digit)(t[0] & 0xfffff);
    for (i = 0; i < 48; i += 8) {
        t[1] = tb * a[i+1];
        r[i+1] += (sp_digit)((t[0] >> 20) + (t[1] & 0xfffff));
        t[2] = tb * a[i+2];
        r[i+2] += (sp_digit)((t[1] >> 20) + (t[2] & 0xfffff));
        t[3] = tb * a[i+3];
        r[i+3] += (sp_digit)((t[2] >> 20) + (t[3] & 0xfffff));
        t[4] = tb * a[i+4];
        r[i+4] += (sp_digit)((t[3] >> 20) + (t[4] & 0xfffff));
        t[5] = tb * a[i+5];
        r[i+5] += (sp_digit)((t[4] >> 20) + (t[5] & 0xfffff));
        t[6] = tb * a[i+6];
        r[i+6] += (sp_digit)((t[5] >> 20) + (t[6] & 0xfffff));
        t[7] = tb * a[i+7];
        r[i+7] += (sp_digit)((t[6] >> 20) + (t[7] & 0xfffff));
        t[0] = tb * a[i+8];
        r[i+8] += (sp_digit)((t[7] >> 20) + (t[0] & 0xfffff));
    }
    t[1] = tb * a[49]; r[49] += (sp_digit)((t[0] >> 20) + (t[1] & 0xfffff));
    t[2] = tb * a[50]; r[50] += (sp_digit)((t[1] >> 20) + (t[2] & 0xfffff));
    t[3] = tb * a[51]; r[51] += (sp_digit)((t[2] >> 20) + (t[3] & 0xfffff));
    r[52] +=  (sp_digit)(t[3] >> 20);
#endif /* WOLFSSL_SP_SMALL */
}

/* Shift the result in the high 1024 bits down to the bottom.
 *
 * r  A single precision number.
 * a  A single precision number.
 */
static void sp_1024_mont_shift_52(sp_digit* r, const sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;
    int64_t n = a[51] >> 4;
    n += ((int64_t)a[52]) << 16;

    for (i = 0; i < 51; i++) {
        r[i] = n & 0xfffff;
        n >>= 20;
        n += ((int64_t)a[53 + i]) << 16;
    }
    r[51] = (sp_digit)n;
#else
    int i;
    int64_t n = a[51] >> 4;
    n += ((int64_t)a[52]) << 16;
    for (i = 0; i < 48; i += 8) {
        r[i + 0] = n & 0xfffff;
        n >>= 20; n += ((int64_t)a[i + 53]) << 16;
        r[i + 1] = n & 0xfffff;
        n >>= 20; n += ((int64_t)a[i + 54]) << 16;
        r[i + 2] = n & 0xfffff;
        n >>= 20; n += ((int64_t)a[i + 55]) << 16;
        r[i + 3] = n & 0xfffff;
        n >>= 20; n += ((int64_t)a[i + 56]) << 16;
        r[i + 4] = n & 0xfffff;
        n >>= 20; n += ((int64_t)a[i + 57]) << 16;
        r[i + 5] = n & 0xfffff;
        n >>= 20; n += ((int64_t)a[i + 58]) << 16;
        r[i + 6] = n & 0xfffff;
        n >>= 20; n += ((int64_t)a[i + 59]) << 16;
        r[i + 7] = n & 0xfffff;
        n >>= 20; n += ((int64_t)a[i + 60]) << 16;
    }
    r[48] = n & 0xfffff; n >>= 20; n += ((int64_t)a[101]) << 16;
    r[49] = n & 0xfffff; n >>= 20; n += ((int64_t)a[102]) << 16;
    r[50] = n & 0xfffff; n >>= 20; n += ((int64_t)a[103]) << 16;
    r[51] = (sp_digit)n;
#endif /* WOLFSSL_SP_SMALL */
    XMEMSET(&r[52], 0, sizeof(*r) * 52U);
}

/* Reduce the number back to 1024 bits using Montgomery reduction.
 *
 * a   A single precision number to reduce in place.
 * m   The single precision number representing the modulus.
 * mp  The digit representing the negative inverse of m mod 2^n.
 */
static void sp_1024_mont_reduce_52(sp_digit* a, const sp_digit* m, sp_digit mp)
{
    int i;
    sp_digit mu;

    sp_1024_norm_52(a + 52);

#ifdef WOLFSSL_SP_DH
    if (mp != 1) {
        for (i=0; i<51; i++) {
            mu = (a[i] * mp) & 0xfffff;
            sp_1024_mul_add_52(a+i, m, mu);
            a[i+1] += a[i] >> 20;
        }
        mu = (a[i] * mp) & 0xfL;
        sp_1024_mul_add_52(a+i, m, mu);
        a[i+1] += a[i] >> 20;
        a[i] &= 0xfffff;
    }
    else {
        for (i=0; i<51; i++) {
            mu = a[i] & 0xfffff;
            sp_1024_mul_add_52(a+i, m, mu);
            a[i+1] += a[i] >> 20;
        }
        mu = a[i] & 0xfL;
        sp_1024_mul_add_52(a+i, m, mu);
        a[i+1] += a[i] >> 20;
        a[i] &= 0xfffff;
    }
#else
    for (i=0; i<51; i++) {
        mu = (a[i] * mp) & 0xfffff;
        sp_1024_mul_add_52(a+i, m, mu);
        a[i+1] += a[i] >> 20;
    }
    mu = (a[i] * mp) & 0xfL;
    sp_1024_mul_add_52(a+i, m, mu);
    a[i+1] += a[i] >> 20;
    a[i] &= 0xfffff;
#endif

    sp_1024_mont_shift_52(a, a);
    sp_1024_cond_sub_52(a, a, m, 0 - (((a[51] >> 4) > 0) ?
            (sp_digit)1 : (sp_digit)0));
    sp_1024_norm_52(a);
}

/* Multiply two Montogmery form numbers mod the modulus (prime).
 * (r = a * b mod m)
 *
 * r   Result of multiplication.
 * a   First number to multiply in Montogmery form.
 * b   Second number to multiply in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_1024_mont_mul_52(sp_digit* r, const sp_digit* a,
        const sp_digit* b, const sp_digit* m, sp_digit mp)
{
    sp_1024_mul_52(r, a, b);
    sp_1024_mont_reduce_52(r, m, mp);
}

/* Square the Montgomery form number. (r = a * a mod m)
 *
 * r   Result of squaring.
 * a   Number to square in Montogmery form.
 * m   Modulus (prime).
 * mp  Montogmery mulitplier.
 */
static void sp_1024_mont_sqr_52(sp_digit* r, const sp_digit* a,
        const sp_digit* m, sp_digit mp)
{
    sp_1024_sqr_52(r, a);
    sp_1024_mont_reduce_52(r, m, mp);
}

/* Mod-2 for the P1024 curve. */
static const uint8_t p1024_mod_minus_2[] = {
     6,0x06,  7,0x0f,  7,0x0b,  6,0x0c,  7,0x1e,  9,0x09,  7,0x0c,  7,0x1f, 
     6,0x16,  6,0x06,  7,0x0e,  8,0x10,  6,0x03,  8,0x11,  6,0x0d,  7,0x14, 
     9,0x12,  6,0x0f,  7,0x04,  9,0x0d,  6,0x00,  7,0x13,  6,0x01,  6,0x07, 
     8,0x0d,  8,0x00,  6,0x06,  9,0x17,  6,0x14,  6,0x15,  6,0x11,  6,0x0b, 
     9,0x0c,  6,0x1e, 13,0x14,  7,0x0e,  6,0x1d, 12,0x0a,  6,0x0b,  8,0x07, 
     6,0x18,  6,0x0f,  6,0x10,  8,0x1c,  7,0x16,  7,0x02,  6,0x01,  6,0x13, 
    10,0x15,  7,0x06,  8,0x14,  6,0x0c,  6,0x19,  7,0x10,  6,0x19,  6,0x19, 
     9,0x16,  7,0x19,  6,0x1f,  6,0x17,  6,0x12,  8,0x02,  6,0x01,  6,0x04, 
     6,0x15,  7,0x16,  6,0x04,  6,0x1f,  6,0x09,  7,0x06,  7,0x13,  7,0x09, 
     6,0x0d, 10,0x18,  6,0x06,  6,0x11,  6,0x04,  6,0x01,  6,0x13,  8,0x06, 
     6,0x0d,  8,0x13,  7,0x08,  6,0x08,  6,0x05,  7,0x0c,  7,0x0e,  7,0x15, 
     6,0x05,  7,0x14, 10,0x19,  6,0x10,  6,0x16,  6,0x15,  7,0x1f,  6,0x14, 
     6,0x0a, 10,0x11,  6,0x01,  7,0x05,  7,0x08,  8,0x0a,  7,0x1e,  7,0x1c, 
     6,0x1c,  7,0x09, 10,0x18,  7,0x1c, 10,0x06,  6,0x0a,  6,0x07,  6,0x19, 
     7,0x06,  6,0x0d,  7,0x0f,  7,0x0b,  7,0x05,  6,0x11,  6,0x1c,  7,0x1f, 
     6,0x1e,  7,0x18,  6,0x1e,  6,0x00,  6,0x03,  6,0x02,  7,0x10,  6,0x0b, 
     6,0x1b,  7,0x10,  6,0x00,  8,0x11,  7,0x1b,  6,0x18,  6,0x01,  7,0x0c, 
     7,0x1d,  7,0x13,  6,0x08,  7,0x1b,  8,0x13,  7,0x16, 13,0x1d,  7,0x1f, 
     6,0x0a,  6,0x01,  7,0x1f,  6,0x14,  1,0x01, 
};

/* Invert the number, in Montgomery form, modulo the modulus (prime) of the
 * P1024 curve. (r = 1 / a mod m)
 *
 * r   Inverse result.
 * a   Number to invert.
 * td  Temporary data.
 */
static void sp_1024_mont_inv_52(sp_digit* r, const sp_digit* a,
        sp_digit* td)
{
    sp_digit* t = td;
    int i;
    int j;
    sp_digit table[32][2 * 52];

    XMEMCPY(table[0], a, sizeof(sp_digit) * 52);
    for (i = 1; i < 6; i++) {
        sp_1024_mont_sqr_52(table[0], table[0], p1024_mod, p1024_mp_mod);
    }
    for (i = 1; i < 32; i++) {
        sp_1024_mont_mul_52(table[i], table[i-1], a, p1024_mod, p1024_mp_mod);
    }

    XMEMCPY(t, table[p1024_mod_minus_2[1]], sizeof(sp_digit) * 52);
    for (i = 2; i < (int)sizeof(p1024_mod_minus_2) - 2; i += 2) {
        for (j = 0; j < p1024_mod_minus_2[i]; j++) {
            sp_1024_mont_sqr_52(t, t, p1024_mod, p1024_mp_mod);
        }
        sp_1024_mont_mul_52(t, t, table[p1024_mod_minus_2[i+1]], p1024_mod,
            p1024_mp_mod);
    }
    sp_1024_mont_sqr_52(t, t, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(r, t, a, p1024_mod, p1024_mp_mod);
}

/* Map the Montgomery form projective coordinate point to an affine point.
 *
 * r  Resulting affine coordinate point.
 * p  Montgomery form projective coordinate point.
 * t  Temporary ordinate data.
 */
static void sp_1024_map_52(sp_point_1024* r, const sp_point_1024* p,
        sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*52;
    int32_t n;

    sp_1024_mont_inv_52(t1, p->z, t + 2*52);

    sp_1024_mont_sqr_52(t2, t1, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(t1, t2, t1, p1024_mod, p1024_mp_mod);

    /* x /= z^2 */
    sp_1024_mont_mul_52(r->x, p->x, t2, p1024_mod, p1024_mp_mod);
    XMEMSET(r->x + 52, 0, sizeof(r->x) / 2U);
    sp_1024_mont_reduce_52(r->x, p1024_mod, p1024_mp_mod);
    /* Reduce x to less than modulus */
    n = sp_1024_cmp_52(r->x, p1024_mod);
    sp_1024_cond_sub_52(r->x, r->x, p1024_mod, 0 - ((n >= 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_1024_norm_52(r->x);

    /* y /= z^3 */
    sp_1024_mont_mul_52(r->y, p->y, t1, p1024_mod, p1024_mp_mod);
    XMEMSET(r->y + 52, 0, sizeof(r->y) / 2U);
    sp_1024_mont_reduce_52(r->y, p1024_mod, p1024_mp_mod);
    /* Reduce y to less than modulus */
    n = sp_1024_cmp_52(r->y, p1024_mod);
    sp_1024_cond_sub_52(r->y, r->y, p1024_mod, 0 - ((n >= 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_1024_norm_52(r->y);

    XMEMSET(r->z, 0, sizeof(r->z));
    r->z[0] = 1;

}

/* Add two Montgomery form numbers (r = a + b % m).
 *
 * r   Result of addition.
 * a   First number to add in Montogmery form.
 * b   Second number to add in Montogmery form.
 * m   Modulus (prime).
 */
static void sp_1024_mont_add_52(sp_digit* r, const sp_digit* a, const sp_digit* b,
        const sp_digit* m)
{
    (void)sp_1024_add_52(r, a, b);
    sp_1024_norm_52(r);
    sp_1024_cond_sub_52(r, r, m, 0 - (((r[51] >> 4) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_1024_norm_52(r);
    sp_1024_cond_sub_52(r, r, m, 0 - (((r[51] >> 4) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_1024_norm_52(r);
}

/* Double a Montgomery form number (r = a + a % m).
 *
 * r   Result of doubling.
 * a   Number to double in Montogmery form.
 * m   Modulus (prime).
 */
static void sp_1024_mont_dbl_52(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    (void)sp_1024_add_52(r, a, a);
    sp_1024_norm_52(r);
    sp_1024_cond_sub_52(r, r, m, 0 - (((r[51] >> 4) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_1024_norm_52(r);
    sp_1024_cond_sub_52(r, r, m, 0 - (((r[51] >> 4) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_1024_norm_52(r);
}

/* Triple a Montgomery form number (r = a + a + a % m).
 *
 * r   Result of Tripling.
 * a   Number to triple in Montogmery form.
 * m   Modulus (prime).
 */
static void sp_1024_mont_tpl_52(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    (void)sp_1024_add_52(r, a, a);
    sp_1024_norm_52(r);
    sp_1024_cond_sub_52(r, r, m, 0 - (((r[51] >> 4) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_1024_norm_52(r);
    sp_1024_cond_sub_52(r, r, m, 0 - (((r[51] >> 4) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    (void)sp_1024_add_52(r, r, a);
    sp_1024_norm_52(r);
    sp_1024_cond_sub_52(r, r, m, 0 - (((r[51] >> 4) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_1024_norm_52(r);
    sp_1024_cond_sub_52(r, r, m, 0 - (((r[51] >> 4) > 0) ?
                (sp_digit)1 : (sp_digit)0));
    sp_1024_norm_52(r);
}

/* Subtract two Montgomery form numbers (r = a - b % m).
 *
 * r   Result of subtration.
 * a   Number to subtract from in Montogmery form.
 * b   Number to subtract with in Montogmery form.
 * m   Modulus (prime).
 */
static void sp_1024_mont_sub_52(sp_digit* r, const sp_digit* a, const sp_digit* b,
        const sp_digit* m)
{
    (void)sp_1024_sub_52(r, a, b);
    sp_1024_cond_add_52(r, r, m, r[51] >> 4);
    sp_1024_norm_52(r);
    sp_1024_cond_add_52(r, r, m, r[51] >> 4);
    sp_1024_norm_52(r);
}

/* Shift number left one bit.
 * Bottom bit is lost.
 *
 * r  Result of shift.
 * a  Number to shift.
 */
SP_NOINLINE static void sp_1024_rshift1_52(sp_digit* r, const sp_digit* a)
{
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i=0; i<51; i++) {
        r[i] = (a[i] >> 1) + ((a[i + 1] << 19) & 0xfffff);
    }
#else
    r[0] = (a[0] >> 1) + ((a[1] << 19) & 0xfffff);
    r[1] = (a[1] >> 1) + ((a[2] << 19) & 0xfffff);
    r[2] = (a[2] >> 1) + ((a[3] << 19) & 0xfffff);
    r[3] = (a[3] >> 1) + ((a[4] << 19) & 0xfffff);
    r[4] = (a[4] >> 1) + ((a[5] << 19) & 0xfffff);
    r[5] = (a[5] >> 1) + ((a[6] << 19) & 0xfffff);
    r[6] = (a[6] >> 1) + ((a[7] << 19) & 0xfffff);
    r[7] = (a[7] >> 1) + ((a[8] << 19) & 0xfffff);
    r[8] = (a[8] >> 1) + ((a[9] << 19) & 0xfffff);
    r[9] = (a[9] >> 1) + ((a[10] << 19) & 0xfffff);
    r[10] = (a[10] >> 1) + ((a[11] << 19) & 0xfffff);
    r[11] = (a[11] >> 1) + ((a[12] << 19) & 0xfffff);
    r[12] = (a[12] >> 1) + ((a[13] << 19) & 0xfffff);
    r[13] = (a[13] >> 1) + ((a[14] << 19) & 0xfffff);
    r[14] = (a[14] >> 1) + ((a[15] << 19) & 0xfffff);
    r[15] = (a[15] >> 1) + ((a[16] << 19) & 0xfffff);
    r[16] = (a[16] >> 1) + ((a[17] << 19) & 0xfffff);
    r[17] = (a[17] >> 1) + ((a[18] << 19) & 0xfffff);
    r[18] = (a[18] >> 1) + ((a[19] << 19) & 0xfffff);
    r[19] = (a[19] >> 1) + ((a[20] << 19) & 0xfffff);
    r[20] = (a[20] >> 1) + ((a[21] << 19) & 0xfffff);
    r[21] = (a[21] >> 1) + ((a[22] << 19) & 0xfffff);
    r[22] = (a[22] >> 1) + ((a[23] << 19) & 0xfffff);
    r[23] = (a[23] >> 1) + ((a[24] << 19) & 0xfffff);
    r[24] = (a[24] >> 1) + ((a[25] << 19) & 0xfffff);
    r[25] = (a[25] >> 1) + ((a[26] << 19) & 0xfffff);
    r[26] = (a[26] >> 1) + ((a[27] << 19) & 0xfffff);
    r[27] = (a[27] >> 1) + ((a[28] << 19) & 0xfffff);
    r[28] = (a[28] >> 1) + ((a[29] << 19) & 0xfffff);
    r[29] = (a[29] >> 1) + ((a[30] << 19) & 0xfffff);
    r[30] = (a[30] >> 1) + ((a[31] << 19) & 0xfffff);
    r[31] = (a[31] >> 1) + ((a[32] << 19) & 0xfffff);
    r[32] = (a[32] >> 1) + ((a[33] << 19) & 0xfffff);
    r[33] = (a[33] >> 1) + ((a[34] << 19) & 0xfffff);
    r[34] = (a[34] >> 1) + ((a[35] << 19) & 0xfffff);
    r[35] = (a[35] >> 1) + ((a[36] << 19) & 0xfffff);
    r[36] = (a[36] >> 1) + ((a[37] << 19) & 0xfffff);
    r[37] = (a[37] >> 1) + ((a[38] << 19) & 0xfffff);
    r[38] = (a[38] >> 1) + ((a[39] << 19) & 0xfffff);
    r[39] = (a[39] >> 1) + ((a[40] << 19) & 0xfffff);
    r[40] = (a[40] >> 1) + ((a[41] << 19) & 0xfffff);
    r[41] = (a[41] >> 1) + ((a[42] << 19) & 0xfffff);
    r[42] = (a[42] >> 1) + ((a[43] << 19) & 0xfffff);
    r[43] = (a[43] >> 1) + ((a[44] << 19) & 0xfffff);
    r[44] = (a[44] >> 1) + ((a[45] << 19) & 0xfffff);
    r[45] = (a[45] >> 1) + ((a[46] << 19) & 0xfffff);
    r[46] = (a[46] >> 1) + ((a[47] << 19) & 0xfffff);
    r[47] = (a[47] >> 1) + ((a[48] << 19) & 0xfffff);
    r[48] = (a[48] >> 1) + ((a[49] << 19) & 0xfffff);
    r[49] = (a[49] >> 1) + ((a[50] << 19) & 0xfffff);
    r[50] = (a[50] >> 1) + ((a[51] << 19) & 0xfffff);
#endif
    r[51] = a[51] >> 1;
}

/* Divide the number by 2 mod the modulus (prime). (r = a / 2 % m)
 *
 * r  Result of division by 2.
 * a  Number to divide.
 * m  Modulus (prime).
 */
static void sp_1024_div2_52(sp_digit* r, const sp_digit* a, const sp_digit* m)
{
    sp_1024_cond_add_52(r, a, m, 0 - (a[0] & 1));
    sp_1024_norm_52(r);
    sp_1024_rshift1_52(r, r);
}

/* Double the Montgomery form projective point p.
 *
 * r  Result of doubling point.
 * p  Point to double.
 * t  Temporary ordinate data.
 */
#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_1024_proj_point_dbl_52_ctx {
    int state;
    sp_digit* t1;
    sp_digit* t2;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;
} sp_1024_proj_point_dbl_52_ctx;

static int sp_1024_proj_point_dbl_52_nb(sp_ecc_ctx_t* sp_ctx, sp_point_1024* r, const sp_point_1024* p, sp_digit* t)
{
    int err = FP_WOULDBLOCK;
    sp_1024_proj_point_dbl_52_ctx* ctx = (sp_1024_proj_point_dbl_52_ctx*)sp_ctx->data;

    typedef char ctx_size_test[sizeof(sp_1024_proj_point_dbl_52_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    switch (ctx->state) {
    case 0:
        ctx->t1 = t;
        ctx->t2 = t + 2*52;
        ctx->x = r->x;
        ctx->y = r->y;
        ctx->z = r->z;

        /* Put infinity into result. */
        if (r != p) {
            r->infinity = p->infinity;
        }
        ctx->state = 1;
        break;
    case 1:
        /* T1 = Z * Z */
        sp_1024_mont_sqr_52(ctx->t1, p->z, p1024_mod, p1024_mp_mod);
        ctx->state = 2;
        break;
    case 2:
        /* Z = Y * Z */
        sp_1024_mont_mul_52(ctx->z, p->y, p->z, p1024_mod, p1024_mp_mod);
        ctx->state = 3;
        break;
    case 3:
        /* Z = 2Z */
        sp_1024_mont_dbl_52(ctx->z, ctx->z, p1024_mod);
        ctx->state = 4;
        break;
    case 4:
        /* T2 = X - T1 */
        sp_1024_mont_sub_52(ctx->t2, p->x, ctx->t1, p1024_mod);
        ctx->state = 5;
        break;
    case 5:
        /* T1 = X + T1 */
        sp_1024_mont_add_52(ctx->t1, p->x, ctx->t1, p1024_mod);
        ctx->state = 6;
        break;
    case 6:
        /* T2 = T1 * T2 */
        sp_1024_mont_mul_52(ctx->t2, ctx->t1, ctx->t2, p1024_mod, p1024_mp_mod);
        ctx->state = 7;
        break;
    case 7:
        /* T1 = 3T2 */
        sp_1024_mont_tpl_52(ctx->t1, ctx->t2, p1024_mod);
        ctx->state = 8;
        break;
    case 8:
        /* Y = 2Y */
        sp_1024_mont_dbl_52(ctx->y, p->y, p1024_mod);
        ctx->state = 9;
        break;
    case 9:
        /* Y = Y * Y */
        sp_1024_mont_sqr_52(ctx->y, ctx->y, p1024_mod, p1024_mp_mod);
        ctx->state = 10;
        break;
    case 10:
        /* T2 = Y * Y */
        sp_1024_mont_sqr_52(ctx->t2, ctx->y, p1024_mod, p1024_mp_mod);
        ctx->state = 11;
        break;
    case 11:
        /* T2 = T2/2 */
        sp_1024_div2_52(ctx->t2, ctx->t2, p1024_mod);
        ctx->state = 12;
        break;
    case 12:
        /* Y = Y * X */
        sp_1024_mont_mul_52(ctx->y, ctx->y, p->x, p1024_mod, p1024_mp_mod);
        ctx->state = 13;
        break;
    case 13:
        /* X = T1 * T1 */
        sp_1024_mont_sqr_52(ctx->x, ctx->t1, p1024_mod, p1024_mp_mod);
        ctx->state = 14;
        break;
    case 14:
        /* X = X - Y */
        sp_1024_mont_sub_52(ctx->x, ctx->x, ctx->y, p1024_mod);
        ctx->state = 15;
        break;
    case 15:
        /* X = X - Y */
        sp_1024_mont_sub_52(ctx->x, ctx->x, ctx->y, p1024_mod);
        ctx->state = 16;
        break;
    case 16:
        /* Y = Y - X */
        sp_1024_mont_sub_52(ctx->y, ctx->y, ctx->x, p1024_mod);
        ctx->state = 17;
        break;
    case 17:
        /* Y = Y * T1 */
        sp_1024_mont_mul_52(ctx->y, ctx->y, ctx->t1, p1024_mod, p1024_mp_mod);
        ctx->state = 18;
        break;
    case 18:
        /* Y = Y - T2 */
        sp_1024_mont_sub_52(ctx->y, ctx->y, ctx->t2, p1024_mod);
        ctx->state = 19;
        /* fall-through */
    case 19:
        err = MP_OKAY;
        break;
    }

    if (err == MP_OKAY && ctx->state != 19) {
        err = FP_WOULDBLOCK;
    }

    return err;
}
#endif /* WOLFSSL_SP_NONBLOCK */

static void sp_1024_proj_point_dbl_52(sp_point_1024* r,
        const sp_point_1024* p, sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*52;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;

    x = r->x;
    y = r->y;
    z = r->z;
    /* Put infinity into result. */
    if (r != p) {
        r->infinity = p->infinity;
    }

    /* T1 = Z * Z */
    sp_1024_mont_sqr_52(t1, p->z, p1024_mod, p1024_mp_mod);
    /* Z = Y * Z */
    sp_1024_mont_mul_52(z, p->y, p->z, p1024_mod, p1024_mp_mod);
    /* Z = 2Z */
    sp_1024_mont_dbl_52(z, z, p1024_mod);
    /* T2 = X - T1 */
    sp_1024_mont_sub_52(t2, p->x, t1, p1024_mod);
    /* T1 = X + T1 */
    sp_1024_mont_add_52(t1, p->x, t1, p1024_mod);
    /* T2 = T1 * T2 */
    sp_1024_mont_mul_52(t2, t1, t2, p1024_mod, p1024_mp_mod);
    /* T1 = 3T2 */
    sp_1024_mont_tpl_52(t1, t2, p1024_mod);
    /* Y = 2Y */
    sp_1024_mont_dbl_52(y, p->y, p1024_mod);
    /* Y = Y * Y */
    sp_1024_mont_sqr_52(y, y, p1024_mod, p1024_mp_mod);
    /* T2 = Y * Y */
    sp_1024_mont_sqr_52(t2, y, p1024_mod, p1024_mp_mod);
    /* T2 = T2/2 */
    sp_1024_div2_52(t2, t2, p1024_mod);
    /* Y = Y * X */
    sp_1024_mont_mul_52(y, y, p->x, p1024_mod, p1024_mp_mod);
    /* X = T1 * T1 */
    sp_1024_mont_sqr_52(x, t1, p1024_mod, p1024_mp_mod);
    /* X = X - Y */
    sp_1024_mont_sub_52(x, x, y, p1024_mod);
    /* X = X - Y */
    sp_1024_mont_sub_52(x, x, y, p1024_mod);
    /* Y = Y - X */
    sp_1024_mont_sub_52(y, y, x, p1024_mod);
    /* Y = Y * T1 */
    sp_1024_mont_mul_52(y, y, t1, p1024_mod, p1024_mp_mod);
    /* Y = Y - T2 */
    sp_1024_mont_sub_52(y, y, t2, p1024_mod);
}

/* Compare two numbers to determine if they are equal.
 * Constant time implementation.
 *
 * a  First number to compare.
 * b  Second number to compare.
 * returns 1 when equal and 0 otherwise.
 */
static int sp_1024_cmp_equal_52(const sp_digit* a, const sp_digit* b)
{
    return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2]) | (a[3] ^ b[3]) |
            (a[4] ^ b[4]) | (a[5] ^ b[5]) | (a[6] ^ b[6]) | (a[7] ^ b[7]) |
            (a[8] ^ b[8]) | (a[9] ^ b[9]) | (a[10] ^ b[10]) | (a[11] ^ b[11]) |
            (a[12] ^ b[12]) | (a[13] ^ b[13]) | (a[14] ^ b[14]) | (a[15] ^ b[15]) |
            (a[16] ^ b[16]) | (a[17] ^ b[17]) | (a[18] ^ b[18]) | (a[19] ^ b[19]) |
            (a[20] ^ b[20]) | (a[21] ^ b[21]) | (a[22] ^ b[22]) | (a[23] ^ b[23]) |
            (a[24] ^ b[24]) | (a[25] ^ b[25]) | (a[26] ^ b[26]) | (a[27] ^ b[27]) |
            (a[28] ^ b[28]) | (a[29] ^ b[29]) | (a[30] ^ b[30]) | (a[31] ^ b[31]) |
            (a[32] ^ b[32]) | (a[33] ^ b[33]) | (a[34] ^ b[34]) | (a[35] ^ b[35]) |
            (a[36] ^ b[36]) | (a[37] ^ b[37]) | (a[38] ^ b[38]) | (a[39] ^ b[39]) |
            (a[40] ^ b[40]) | (a[41] ^ b[41]) | (a[42] ^ b[42]) | (a[43] ^ b[43]) |
            (a[44] ^ b[44]) | (a[45] ^ b[45]) | (a[46] ^ b[46]) | (a[47] ^ b[47]) |
            (a[48] ^ b[48]) | (a[49] ^ b[49]) | (a[50] ^ b[50]) | (a[51] ^ b[51])) == 0;
}

/* Add two Montgomery form projective points.
 *
 * r  Result of addition.
 * p  First point to add.
 * q  Second point to add.
 * t  Temporary ordinate data.
 */

#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_1024_proj_point_add_52_ctx {
    int state;
    sp_1024_proj_point_dbl_52_ctx dbl_ctx;
    const sp_point_1024* ap[2];
    sp_point_1024* rp[2];
    sp_digit* t1;
    sp_digit* t2;
    sp_digit* t3;
    sp_digit* t4;
    sp_digit* t5;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;
} sp_1024_proj_point_add_52_ctx;

static int sp_1024_proj_point_add_52_nb(sp_ecc_ctx_t* sp_ctx, sp_point_1024* r, 
    const sp_point_1024* p, const sp_point_1024* q, sp_digit* t)
{
    int err = FP_WOULDBLOCK;
    sp_1024_proj_point_add_52_ctx* ctx = (sp_1024_proj_point_add_52_ctx*)sp_ctx->data;

    /* Ensure only the first point is the same as the result. */
    if (q == r) {
        const sp_point_1024* a = p;
        p = q;
        q = a;
    }

    typedef char ctx_size_test[sizeof(sp_1024_proj_point_add_52_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    switch (ctx->state) {
    case 0: /* INIT */
        ctx->t1 = t;
        ctx->t2 = t + 2*52;
        ctx->t3 = t + 4*52;
        ctx->t4 = t + 6*52;
        ctx->t5 = t + 8*52;

        ctx->state = 1;
        break;
    case 1:
        /* Check double */
        (void)sp_1024_sub_52(ctx->t1, p1024_mod, q->y);
        sp_1024_norm_52(ctx->t1);
        if ((sp_1024_cmp_equal_52(p->x, q->x) & sp_1024_cmp_equal_52(p->z, q->z) &
            (sp_1024_cmp_equal_52(p->y, q->y) | sp_1024_cmp_equal_52(p->y, ctx->t1))) != 0)
        {
            XMEMSET(&ctx->dbl_ctx, 0, sizeof(ctx->dbl_ctx));
            ctx->state = 2;
        }
        else {
            ctx->state = 3;
        }
        break;
    case 2:
        err = sp_1024_proj_point_dbl_52_nb((sp_ecc_ctx_t*)&ctx->dbl_ctx, r, p, t);
        if (err == MP_OKAY)
            ctx->state = 27; /* done */
        break;
    case 3:
    {
        int i;
        ctx->rp[0] = r;

        /*lint allow cast to different type of pointer*/
        ctx->rp[1] = (sp_point_1024*)t; /*lint !e9087 !e740*/
        XMEMSET(ctx->rp[1], 0, sizeof(sp_point_1024));
        ctx->x = ctx->rp[p->infinity | q->infinity]->x;
        ctx->y = ctx->rp[p->infinity | q->infinity]->y;
        ctx->z = ctx->rp[p->infinity | q->infinity]->z;

        ctx->ap[0] = p;
        ctx->ap[1] = q;
        for (i=0; i<52; i++) {
            r->x[i] = ctx->ap[p->infinity]->x[i];
        }
        for (i=0; i<52; i++) {
            r->y[i] = ctx->ap[p->infinity]->y[i];
        }
        for (i=0; i<52; i++) {
            r->z[i] = ctx->ap[p->infinity]->z[i];
        }
        r->infinity = ctx->ap[p->infinity]->infinity;

        ctx->state = 4;
        break;
    }
    case 4:
        /* U1 = X1*Z2^2 */
        sp_1024_mont_sqr_52(ctx->t1, q->z, p1024_mod, p1024_mp_mod);
        ctx->state = 5;
        break;
    case 5:
        sp_1024_mont_mul_52(ctx->t3, ctx->t1, q->z, p1024_mod, p1024_mp_mod);
        ctx->state = 6;
        break;
    case 6:
        sp_1024_mont_mul_52(ctx->t1, ctx->t1, ctx->x, p1024_mod, p1024_mp_mod);
        ctx->state = 7;
        break;
    case 7:
        /* U2 = X2*Z1^2 */
        sp_1024_mont_sqr_52(ctx->t2, ctx->z, p1024_mod, p1024_mp_mod);
        ctx->state = 8;
        break;
    case 8:
        sp_1024_mont_mul_52(ctx->t4, ctx->t2, ctx->z, p1024_mod, p1024_mp_mod);
        ctx->state = 9;
        break;
    case 9:
        sp_1024_mont_mul_52(ctx->t2, ctx->t2, q->x, p1024_mod, p1024_mp_mod);
        ctx->state = 10;
        break;
    case 10:
        /* S1 = Y1*Z2^3 */
        sp_1024_mont_mul_52(ctx->t3, ctx->t3, ctx->y, p1024_mod, p1024_mp_mod);
        ctx->state = 11;
        break;
    case 11:
        /* S2 = Y2*Z1^3 */
        sp_1024_mont_mul_52(ctx->t4, ctx->t4, q->y, p1024_mod, p1024_mp_mod);
        ctx->state = 12;
        break;
    case 12:
        /* H = U2 - U1 */
        sp_1024_mont_sub_52(ctx->t2, ctx->t2, ctx->t1, p1024_mod);
        ctx->state = 13;
        break;
    case 13:
        /* R = S2 - S1 */
        sp_1024_mont_sub_52(ctx->t4, ctx->t4, ctx->t3, p1024_mod);
        ctx->state = 14;
        break;
    case 14:
        /* Z3 = H*Z1*Z2 */
        sp_1024_mont_mul_52(ctx->z, ctx->z, q->z, p1024_mod, p1024_mp_mod);
        ctx->state = 15;
        break;
    case 15:
        sp_1024_mont_mul_52(ctx->z, ctx->z, ctx->t2, p1024_mod, p1024_mp_mod);
        ctx->state = 16;
        break;
    case 16:
        /* X3 = R^2 - H^3 - 2*U1*H^2 */
        sp_1024_mont_sqr_52(ctx->x, ctx->t4, p1024_mod, p1024_mp_mod);
        ctx->state = 17;
        break;
    case 17:
        sp_1024_mont_sqr_52(ctx->t5, ctx->t2, p1024_mod, p1024_mp_mod);
        ctx->state = 18;
        break;
    case 18:
        sp_1024_mont_mul_52(ctx->y, ctx->t1, ctx->t5, p1024_mod, p1024_mp_mod);
        ctx->state = 19;
        break;
    case 19:
        sp_1024_mont_mul_52(ctx->t5, ctx->t5, ctx->t2, p1024_mod, p1024_mp_mod);
        ctx->state = 20;
        break;
    case 20:
        sp_1024_mont_sub_52(ctx->x, ctx->x, ctx->t5, p1024_mod);
        ctx->state = 21;
        break;
    case 21:
        sp_1024_mont_dbl_52(ctx->t1, ctx->y, p1024_mod);
        ctx->state = 22;
        break;
    case 22:
        sp_1024_mont_sub_52(ctx->x, ctx->x, ctx->t1, p1024_mod);
        ctx->state = 23;
        break;
    case 23:
        /* Y3 = R*(U1*H^2 - X3) - S1*H^3 */
        sp_1024_mont_sub_52(ctx->y, ctx->y, ctx->x, p1024_mod);
        ctx->state = 24;
        break;
    case 24:
        sp_1024_mont_mul_52(ctx->y, ctx->y, ctx->t4, p1024_mod, p1024_mp_mod);
        ctx->state = 25;
        break;
    case 25:
        sp_1024_mont_mul_52(ctx->t5, ctx->t5, ctx->t3, p1024_mod, p1024_mp_mod);
        ctx->state = 26;
        break;
    case 26:
        sp_1024_mont_sub_52(ctx->y, ctx->y, ctx->t5, p1024_mod);
        ctx->state = 27;
        /* fall-through */
    case 27:
        err = MP_OKAY;
        break;
    }

    if (err == MP_OKAY && ctx->state != 27) {
        err = FP_WOULDBLOCK;
    }
    return err;
}
#endif /* WOLFSSL_SP_NONBLOCK */

static void sp_1024_proj_point_add_52(sp_point_1024* r,
        const sp_point_1024* p, const sp_point_1024* q, sp_digit* t)
{
    const sp_point_1024* ap[2];
    sp_point_1024* rp[2];
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*52;
    sp_digit* t3 = t + 4*52;
    sp_digit* t4 = t + 6*52;
    sp_digit* t5 = t + 8*52;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;
    int i;

    /* Ensure only the first point is the same as the result. */
    if (q == r) {
        const sp_point_1024* a = p;
        p = q;
        q = a;
    }

    /* Check double */
    (void)sp_1024_mont_sub_52(t1, p1024_mod, q->y, p1024_mod);
    sp_1024_norm_52(t1);
    if ((sp_1024_cmp_equal_52(p->x, q->x) & sp_1024_cmp_equal_52(p->z, q->z) &
        (sp_1024_cmp_equal_52(p->y, q->y) | sp_1024_cmp_equal_52(p->y, t1))) != 0) {
        sp_1024_proj_point_dbl_52(r, p, t);
    }
    else {
        rp[0] = r;

        /*lint allow cast to different type of pointer*/
        rp[1] = (sp_point_1024*)t; /*lint !e9087 !e740*/
        XMEMSET(rp[1], 0, sizeof(sp_point_1024));
        x = rp[p->infinity | q->infinity]->x;
        y = rp[p->infinity | q->infinity]->y;
        z = rp[p->infinity | q->infinity]->z;

        ap[0] = p;
        ap[1] = q;
        for (i=0; i<52; i++) {
            r->x[i] = ap[p->infinity]->x[i];
        }
        for (i=0; i<52; i++) {
            r->y[i] = ap[p->infinity]->y[i];
        }
        for (i=0; i<52; i++) {
            r->z[i] = ap[p->infinity]->z[i];
        }
        r->infinity = ap[p->infinity]->infinity;

        /* U1 = X1*Z2^2 */
        sp_1024_mont_sqr_52(t1, q->z, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(t3, t1, q->z, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(t1, t1, x, p1024_mod, p1024_mp_mod);
        /* U2 = X2*Z1^2 */
        sp_1024_mont_sqr_52(t2, z, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(t4, t2, z, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(t2, t2, q->x, p1024_mod, p1024_mp_mod);
        /* S1 = Y1*Z2^3 */
        sp_1024_mont_mul_52(t3, t3, y, p1024_mod, p1024_mp_mod);
        /* S2 = Y2*Z1^3 */
        sp_1024_mont_mul_52(t4, t4, q->y, p1024_mod, p1024_mp_mod);
        /* H = U2 - U1 */
        sp_1024_mont_sub_52(t2, t2, t1, p1024_mod);
        /* R = S2 - S1 */
        sp_1024_mont_sub_52(t4, t4, t3, p1024_mod);
        /* Z3 = H*Z1*Z2 */
        sp_1024_mont_mul_52(z, z, q->z, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(z, z, t2, p1024_mod, p1024_mp_mod);
        /* X3 = R^2 - H^3 - 2*U1*H^2 */
        sp_1024_mont_sqr_52(x, t4, p1024_mod, p1024_mp_mod);
        sp_1024_mont_sqr_52(t5, t2, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(y, t1, t5, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(t5, t5, t2, p1024_mod, p1024_mp_mod);
        sp_1024_mont_sub_52(x, x, t5, p1024_mod);
        sp_1024_mont_dbl_52(t1, y, p1024_mod);
        sp_1024_mont_sub_52(x, x, t1, p1024_mod);
        /* Y3 = R*(U1*H^2 - X3) - S1*H^3 */
        sp_1024_mont_sub_52(y, y, x, p1024_mod);
        sp_1024_mont_mul_52(y, y, t4, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(t5, t5, t3, p1024_mod, p1024_mp_mod);
        sp_1024_mont_sub_52(y, y, t5, p1024_mod);
    }
}

#ifdef WOLFSSL_SP_SMALL
/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * Small implementation using add and double that is cache attack resistant but
 * allocates memory rather than use large stacks.
 * 1024 adds and doubles.
 *
 * r     Resulting point.
 * g     Point to multiply.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */

#ifdef WOLFSSL_SP_NONBLOCK
typedef struct sp_1024_ecc_mulmod_52_ctx {
    int state;
    union {
        sp_1024_proj_point_dbl_52_ctx dbl_ctx;
        sp_1024_proj_point_add_52_ctx add_ctx;
    };
    sp_point_1024 t[3];
    sp_digit tmp[2 * 52 * 5];
    sp_digit n;
    int i;
    int c;
    int y;
} sp_1024_ecc_mulmod_52_ctx;

static int sp_1024_ecc_mulmod_52_nb(sp_ecc_ctx_t* sp_ctx, sp_point_1024* r, 
    const sp_point_1024* g, const sp_digit* k, int map, void* heap)
{
    int err = FP_WOULDBLOCK;
    sp_1024_ecc_mulmod_52_ctx* ctx = (sp_1024_ecc_mulmod_52_ctx*)sp_ctx->data;

    typedef char ctx_size_test[sizeof(sp_1024_ecc_mulmod_52_ctx) >= sizeof(*sp_ctx) ? -1 : 1];
    (void)sizeof(ctx_size_test);

    switch (ctx->state) {
    case 0: /* INIT */
        XMEMSET(ctx->t, 0, sizeof(sp_point_1024) * 3);
        ctx->i = 51;
        ctx->c = 4;
        ctx->n = k[ctx->i--] << (20 - ctx->c);

        /* t[0] = {0, 0, 1} * norm */
        ctx->t[0].infinity = 1;
        ctx->state = 1;
        break;
    case 1: /* T1X */
        /* t[1] = {g->x, g->y, g->z} * norm */
        err = sp_1024_mod_mul_norm_52(ctx->t[1].x, g->x, p1024_mod);
        ctx->state = 2;
        break;
    case 2: /* T1Y */
        err = sp_1024_mod_mul_norm_52(ctx->t[1].y, g->y, p1024_mod);
        ctx->state = 3;
        break;
    case 3: /* T1Z */
        err = sp_1024_mod_mul_norm_52(ctx->t[1].z, g->z, p1024_mod);
        ctx->state = 4;
        break;
    case 4: /* ADDPREP */
        if (ctx->c == 0) {
            if (ctx->i == -1) {
                ctx->state = 7;
                break;
            }

            ctx->n = k[ctx->i--];
            ctx->c = 20;
        }
        ctx->y = (ctx->n >> 19) & 1;
        ctx->n <<= 1;
        XMEMSET(&ctx->add_ctx, 0, sizeof(ctx->add_ctx));
        ctx->state = 5;
        break;
    case 5: /* ADD */
        err = sp_1024_proj_point_add_52_nb((sp_ecc_ctx_t*)&ctx->add_ctx, 
            &ctx->t[ctx->y^1], &ctx->t[0], &ctx->t[1], ctx->tmp);
        if (err == MP_OKAY) {
            XMEMCPY(&ctx->t[2], (void*)(((size_t)&ctx->t[0] & addr_mask[ctx->y^1]) +
                                        ((size_t)&ctx->t[1] & addr_mask[ctx->y])),
                    sizeof(sp_point_1024));
            XMEMSET(&ctx->dbl_ctx, 0, sizeof(ctx->dbl_ctx));
            ctx->state = 6;
        }
        break;
    case 6: /* DBL */
        err = sp_1024_proj_point_dbl_52_nb((sp_ecc_ctx_t*)&ctx->dbl_ctx, &ctx->t[2], 
            &ctx->t[2], ctx->tmp);
        if (err == MP_OKAY) {
            XMEMCPY((void*)(((size_t)&ctx->t[0] & addr_mask[ctx->y^1]) +
                            ((size_t)&ctx->t[1] & addr_mask[ctx->y])), &ctx->t[2],
                    sizeof(sp_point_1024));
            ctx->state = 4;
            ctx->c--;
        }
        break;
    case 7: /* MAP */
        if (map != 0) {
            sp_1024_map_52(r, &ctx->t[0], ctx->tmp);
        }
        else {
            XMEMCPY(r, &ctx->t[0], sizeof(sp_point_1024));
        }
        err = MP_OKAY;
        break;
    }

    if (err == MP_OKAY && ctx->state != 7) {
        err = FP_WOULDBLOCK;
    }
    if (err != FP_WOULDBLOCK) {
        ForceZero(ctx->tmp, sizeof(ctx->tmp));
        ForceZero(ctx->t, sizeof(ctx->t));
    }

    (void)heap;

    return err;
}

#endif /* WOLFSSL_SP_NONBLOCK */

static int sp_1024_ecc_mulmod_52(sp_point_1024* r, const sp_point_1024* g,
        const sp_digit* k, int map, void* heap)
{
#ifdef WOLFSSL_SP_NO_MALLOC
    sp_point_1024 t[3];
    sp_digit tmp[2 * 52 * 5];
#else
    sp_point_1024* t;
    sp_digit* tmp;
#endif
    sp_digit n;
    int i;
    int c;
    int y;
    int err = MP_OKAY;

    (void)heap;

#ifndef WOLFSSL_SP_NO_MALLOC
    t = (sp_point_1024*)XMALLOC(sizeof(sp_point_1024) * 3, heap, DYNAMIC_TYPE_ECC);
    if (t == NULL)
        err = MEMORY_E;
    tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 52 * 5, heap,
                                                              DYNAMIC_TYPE_ECC);
    if (tmp == NULL)
        err = MEMORY_E;
#endif

    if (err == MP_OKAY) {
        XMEMSET(t, 0, sizeof(sp_point_1024) * 3);

        /* t[0] = {0, 0, 1} * norm */
        t[0].infinity = 1;
        /* t[1] = {g->x, g->y, g->z} * norm */
        err = sp_1024_mod_mul_norm_52(t[1].x, g->x, p1024_mod);
    }
    if (err == MP_OKAY)
        err = sp_1024_mod_mul_norm_52(t[1].y, g->y, p1024_mod);
    if (err == MP_OKAY)
        err = sp_1024_mod_mul_norm_52(t[1].z, g->z, p1024_mod);

    if (err == MP_OKAY) {
        i = 51;
        c = 4;
        n = k[i--] << (20 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1)
                    break;

                n = k[i--];
                c = 20;
            }

            y = (n >> 19) & 1;
            n <<= 1;

            sp_1024_proj_point_add_52(&t[y^1], &t[0], &t[1], tmp);

            XMEMCPY(&t[2], (void*)(((size_t)&t[0] & addr_mask[y^1]) +
                                   ((size_t)&t[1] & addr_mask[y])),
                    sizeof(sp_point_1024));
            sp_1024_proj_point_dbl_52(&t[2], &t[2], tmp);
            XMEMCPY((void*)(((size_t)&t[0] & addr_mask[y^1]) +
                            ((size_t)&t[1] & addr_mask[y])), &t[2],
                    sizeof(sp_point_1024));
        }

        if (map != 0) {
            sp_1024_map_52(r, &t[0], tmp);
        }
        else {
            XMEMCPY(r, &t[0], sizeof(sp_point_1024));
        }
    }

#ifndef WOLFSSL_SP_NO_MALLOC
    if (tmp != NULL) {
        XMEMSET(tmp, 0, sizeof(sp_digit) * 2 * 52 * 5);
        XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
    }
    if (t != NULL) {
        XMEMSET(t, 0, sizeof(sp_point_1024) * 3);
        XFREE(t, NULL, DYNAMIC_TYPE_ECC);
    }
#else
    ForceZero(tmp, sizeof(tmp));
    ForceZero(t, sizeof(t));
#endif

    return err;
}

#elif defined(WOLFSSL_SP_CACHE_RESISTANT)
/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * Small implementation using add and double that is cache attack resistant
 * that uses large stack.
 * 1024 adds and doubles.
 *
 * r     Resulting point.
 * g     Point to multiply.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_1024_ecc_mulmod_52(sp_point_1024* r, const sp_point_1024* g,
        const sp_digit* k, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_1024 t[3];
    sp_digit tmp[2 * 52 * 5];
#else
    sp_point_1024* t;
    sp_digit* tmp;
#endif
    sp_digit n;
    int i;
    int c;
    int y;
    int err = MP_OKAY;

    (void)heap;

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    t = (sp_point_1024*)XMALLOC(sizeof(*t) * 3, heap, DYNAMIC_TYPE_ECC);
    if (t == NULL)
        err = MEMORY_E;
    tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 52 * 5, heap,
                             DYNAMIC_TYPE_ECC);
    if (tmp == NULL)
        err = MEMORY_E;
#endif

    if (err == MP_OKAY) {
        /* t[0] = {0, 0, 1} * norm */
        XMEMSET(&t[0], 0, sizeof(t[0]));
        t[0].infinity = 1;
        /* t[1] = {g->x, g->y, g->z} * norm */
        t[1].infinity = 0;
        err = sp_1024_mod_mul_norm_52(t[1].x, g->x, p1024_mod);
    }
    if (err == MP_OKAY)
        err = sp_1024_mod_mul_norm_52(t[1].y, g->y, p1024_mod);
    if (err == MP_OKAY)
        err = sp_1024_mod_mul_norm_52(t[1].z, g->z, p1024_mod);

    if (err == MP_OKAY) {
        i = 51;
        c = 4;
        n = k[i--] << (20 - c);
        for (; ; c--) {
            if (c == 0) {
                if (i == -1)
                    break;

                n = k[i--];
                c = 20;
            }

            y = (n >> 19) & 1;
            n <<= 1;

            sp_1024_proj_point_add_52(&t[y^1], &t[0], &t[1], tmp);

            XMEMCPY(&t[2], (void*)(((size_t)&t[0] & addr_mask[y^1]) +
                                 ((size_t)&t[1] & addr_mask[y])), sizeof(t[2]));
            sp_1024_proj_point_dbl_52(&t[2], &t[2], tmp);
            XMEMCPY((void*)(((size_t)&t[0] & addr_mask[y^1]) +
                          ((size_t)&t[1] & addr_mask[y])), &t[2], sizeof(t[2]));
        }

        if (map != 0) {
            sp_1024_map_52(r, &t[0], tmp);
        }
        else {
            XMEMCPY(r, &t[0], sizeof(sp_point_1024));
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (tmp != NULL) {
        XMEMSET(tmp, 0, sizeof(sp_digit) * 2 * 52 * 5);
        XFREE(tmp, heap, DYNAMIC_TYPE_ECC);
    }
    if (t != NULL) {
        XMEMSET(t, 0, sizeof(sp_point_1024) * 3);
        XFREE(t, heap, DYNAMIC_TYPE_ECC);
    }
#else
    ForceZero(tmp, sizeof(tmp));
    ForceZero(t, sizeof(t));
#endif

    return err;
}

#else
/* A table entry for pre-computed points. */
typedef struct sp_table_entry_1024 {
    sp_digit x[52];
    sp_digit y[52];
} sp_table_entry_1024;

/* Conditionally copy a into r using the mask m.
 * m is -1 to copy and 0 when not.
 *
 * r  A single precision number to copy over.
 * a  A single precision number to copy.
 * m  Mask value to apply.
 */
static void sp_1024_cond_copy_52(sp_digit* r, const sp_digit* a, const sp_digit m)
{
    sp_digit t[52];
#ifdef WOLFSSL_SP_SMALL
    int i;

    for (i = 0; i < 52; i++) {
        t[i] = r[i] ^ a[i];
    }
    for (i = 0; i < 52; i++) {
        r[i] ^= t[i] & m;
    }
#else
    t[ 0] = r[ 0] ^ a[ 0];
    t[ 1] = r[ 1] ^ a[ 1];
    t[ 2] = r[ 2] ^ a[ 2];
    t[ 3] = r[ 3] ^ a[ 3];
    t[ 4] = r[ 4] ^ a[ 4];
    t[ 5] = r[ 5] ^ a[ 5];
    t[ 6] = r[ 6] ^ a[ 6];
    t[ 7] = r[ 7] ^ a[ 7];
    t[ 8] = r[ 8] ^ a[ 8];
    t[ 9] = r[ 9] ^ a[ 9];
    t[10] = r[10] ^ a[10];
    t[11] = r[11] ^ a[11];
    t[12] = r[12] ^ a[12];
    t[13] = r[13] ^ a[13];
    t[14] = r[14] ^ a[14];
    t[15] = r[15] ^ a[15];
    t[16] = r[16] ^ a[16];
    t[17] = r[17] ^ a[17];
    t[18] = r[18] ^ a[18];
    t[19] = r[19] ^ a[19];
    t[20] = r[20] ^ a[20];
    t[21] = r[21] ^ a[21];
    t[22] = r[22] ^ a[22];
    t[23] = r[23] ^ a[23];
    t[24] = r[24] ^ a[24];
    t[25] = r[25] ^ a[25];
    t[26] = r[26] ^ a[26];
    t[27] = r[27] ^ a[27];
    t[28] = r[28] ^ a[28];
    t[29] = r[29] ^ a[29];
    t[30] = r[30] ^ a[30];
    t[31] = r[31] ^ a[31];
    t[32] = r[32] ^ a[32];
    t[33] = r[33] ^ a[33];
    t[34] = r[34] ^ a[34];
    t[35] = r[35] ^ a[35];
    t[36] = r[36] ^ a[36];
    t[37] = r[37] ^ a[37];
    t[38] = r[38] ^ a[38];
    t[39] = r[39] ^ a[39];
    t[40] = r[40] ^ a[40];
    t[41] = r[41] ^ a[41];
    t[42] = r[42] ^ a[42];
    t[43] = r[43] ^ a[43];
    t[44] = r[44] ^ a[44];
    t[45] = r[45] ^ a[45];
    t[46] = r[46] ^ a[46];
    t[47] = r[47] ^ a[47];
    t[48] = r[48] ^ a[48];
    t[49] = r[49] ^ a[49];
    t[50] = r[50] ^ a[50];
    t[51] = r[51] ^ a[51];
    r[ 0] ^= t[ 0] & m;
    r[ 1] ^= t[ 1] & m;
    r[ 2] ^= t[ 2] & m;
    r[ 3] ^= t[ 3] & m;
    r[ 4] ^= t[ 4] & m;
    r[ 5] ^= t[ 5] & m;
    r[ 6] ^= t[ 6] & m;
    r[ 7] ^= t[ 7] & m;
    r[ 8] ^= t[ 8] & m;
    r[ 9] ^= t[ 9] & m;
    r[10] ^= t[10] & m;
    r[11] ^= t[11] & m;
    r[12] ^= t[12] & m;
    r[13] ^= t[13] & m;
    r[14] ^= t[14] & m;
    r[15] ^= t[15] & m;
    r[16] ^= t[16] & m;
    r[17] ^= t[17] & m;
    r[18] ^= t[18] & m;
    r[19] ^= t[19] & m;
    r[20] ^= t[20] & m;
    r[21] ^= t[21] & m;
    r[22] ^= t[22] & m;
    r[23] ^= t[23] & m;
    r[24] ^= t[24] & m;
    r[25] ^= t[25] & m;
    r[26] ^= t[26] & m;
    r[27] ^= t[27] & m;
    r[28] ^= t[28] & m;
    r[29] ^= t[29] & m;
    r[30] ^= t[30] & m;
    r[31] ^= t[31] & m;
    r[32] ^= t[32] & m;
    r[33] ^= t[33] & m;
    r[34] ^= t[34] & m;
    r[35] ^= t[35] & m;
    r[36] ^= t[36] & m;
    r[37] ^= t[37] & m;
    r[38] ^= t[38] & m;
    r[39] ^= t[39] & m;
    r[40] ^= t[40] & m;
    r[41] ^= t[41] & m;
    r[42] ^= t[42] & m;
    r[43] ^= t[43] & m;
    r[44] ^= t[44] & m;
    r[45] ^= t[45] & m;
    r[46] ^= t[46] & m;
    r[47] ^= t[47] & m;
    r[48] ^= t[48] & m;
    r[49] ^= t[49] & m;
    r[50] ^= t[50] & m;
    r[51] ^= t[51] & m;
#endif /* WOLFSSL_SP_SMALL */
}

/* Double the Montgomery form projective point p a number of times.
 *
 * r  Result of repeated doubling of point.
 * p  Point to double.
 * n  Number of times to double
 * t  Temporary ordinate data.
 */
static void sp_1024_proj_point_dbl_n_52(sp_point_1024* p, int n,
        sp_digit* t)
{
    sp_digit* w = t;
    sp_digit* a = t + 2*52;
    sp_digit* b = t + 4*52;
    sp_digit* t1 = t + 6*52;
    sp_digit* t2 = t + 8*52;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;

    x = p->x;
    y = p->y;
    z = p->z;

    /* Y = 2*Y */
    sp_1024_mont_dbl_52(y, y, p1024_mod);
    /* W = Z^4 */
    sp_1024_mont_sqr_52(w, z, p1024_mod, p1024_mp_mod);
    sp_1024_mont_sqr_52(w, w, p1024_mod, p1024_mp_mod);

#ifndef WOLFSSL_SP_SMALL
    while (--n > 0)
#else
    while (--n >= 0)
#endif
    {
        /* A = 3*(X^2 - W) */
        sp_1024_mont_sqr_52(t1, x, p1024_mod, p1024_mp_mod);
        sp_1024_mont_sub_52(t1, t1, w, p1024_mod);
        sp_1024_mont_tpl_52(a, t1, p1024_mod);
        /* B = X*Y^2 */
        sp_1024_mont_sqr_52(t1, y, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(b, t1, x, p1024_mod, p1024_mp_mod);
        /* X = A^2 - 2B */
        sp_1024_mont_sqr_52(x, a, p1024_mod, p1024_mp_mod);
        sp_1024_mont_dbl_52(t2, b, p1024_mod);
        sp_1024_mont_sub_52(x, x, t2, p1024_mod);
        /* Z = Z*Y */
        sp_1024_mont_mul_52(z, z, y, p1024_mod, p1024_mp_mod);
        /* t2 = Y^4 */
        sp_1024_mont_sqr_52(t1, t1, p1024_mod, p1024_mp_mod);
#ifdef WOLFSSL_SP_SMALL
        if (n != 0)
        {
#endif
            /* W = W*Y^4 */
            sp_1024_mont_mul_52(w, w, t1, p1024_mod, p1024_mp_mod);
#ifdef WOLFSSL_SP_SMALL
        }
#endif
        /* y = 2*A*(B - X) - Y^4 */
        sp_1024_mont_sub_52(y, b, x, p1024_mod);
        sp_1024_mont_mul_52(y, y, a, p1024_mod, p1024_mp_mod);
        sp_1024_mont_dbl_52(y, y, p1024_mod);
        sp_1024_mont_sub_52(y, y, t1, p1024_mod);
    }
#ifndef WOLFSSL_SP_SMALL
    /* A = 3*(X^2 - W) */
    sp_1024_mont_sqr_52(t1, x, p1024_mod, p1024_mp_mod);
    sp_1024_mont_sub_52(t1, t1, w, p1024_mod);
    sp_1024_mont_tpl_52(a, t1, p1024_mod);
    /* B = X*Y^2 */
    sp_1024_mont_sqr_52(t1, y, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(b, t1, x, p1024_mod, p1024_mp_mod);
    /* X = A^2 - 2B */
    sp_1024_mont_sqr_52(x, a, p1024_mod, p1024_mp_mod);
    sp_1024_mont_dbl_52(t2, b, p1024_mod);
    sp_1024_mont_sub_52(x, x, t2, p1024_mod);
    /* Z = Z*Y */
    sp_1024_mont_mul_52(z, z, y, p1024_mod, p1024_mp_mod);
    /* t2 = Y^4 */
    sp_1024_mont_sqr_52(t1, t1, p1024_mod, p1024_mp_mod);
    /* y = 2*A*(B - X) - Y^4 */
    sp_1024_mont_sub_52(y, b, x, p1024_mod);
    sp_1024_mont_mul_52(y, y, a, p1024_mod, p1024_mp_mod);
    sp_1024_mont_dbl_52(y, y, p1024_mod);
    sp_1024_mont_sub_52(y, y, t1, p1024_mod);
#endif
    /* Y = Y/2 */
    sp_1024_div2_52(y, y, p1024_mod);
}

/* Double the Montgomery form projective point p a number of times.
 *
 * r  Result of repeated doubling of point.
 * p  Point to double.
 * n  Number of times to double
 * t  Temporary ordinate data.
 */
static void sp_1024_proj_point_dbl_n_store_52(sp_point_1024* r,
        const sp_point_1024* p, int n, int m, sp_digit* t)
{
    sp_digit* w = t;
    sp_digit* a = t + 2*52;
    sp_digit* b = t + 4*52;
    sp_digit* t1 = t + 6*52;
    sp_digit* t2 = t + 8*52;
    sp_digit* x = r[2*m].x;
    sp_digit* y = r[(1<<n)*m].y;
    sp_digit* z = r[2*m].z;
    int i;

    for (i=0; i<52; i++) {
        x[i] = p->x[i];
    }
    for (i=0; i<52; i++) {
        y[i] = p->y[i];
    }
    for (i=0; i<52; i++) {
        z[i] = p->z[i];
    }

    /* Y = 2*Y */
    sp_1024_mont_dbl_52(y, y, p1024_mod);
    /* W = Z^4 */
    sp_1024_mont_sqr_52(w, z, p1024_mod, p1024_mp_mod);
    sp_1024_mont_sqr_52(w, w, p1024_mod, p1024_mp_mod);
    for (i=1; i<=n; i++) {
        /* A = 3*(X^2 - W) */
        sp_1024_mont_sqr_52(t1, x, p1024_mod, p1024_mp_mod);
        sp_1024_mont_sub_52(t1, t1, w, p1024_mod);
        sp_1024_mont_tpl_52(a, t1, p1024_mod);
        /* B = X*Y^2 */
        sp_1024_mont_sqr_52(t2, y, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(b, t2, x, p1024_mod, p1024_mp_mod);
        x = r[(1<<i)*m].x;
        /* X = A^2 - 2B */
        sp_1024_mont_sqr_52(x, a, p1024_mod, p1024_mp_mod);
        sp_1024_mont_dbl_52(t1, b, p1024_mod);
        sp_1024_mont_sub_52(x, x, t1, p1024_mod);
        /* Z = Z*Y */
        sp_1024_mont_mul_52(r[(1<<i)*m].z, z, y, p1024_mod, p1024_mp_mod);
        z = r[(1<<i)*m].z;
        /* t2 = Y^4 */
        sp_1024_mont_sqr_52(t2, t2, p1024_mod, p1024_mp_mod);
        if (i != n) {
            /* W = W*Y^4 */
            sp_1024_mont_mul_52(w, w, t2, p1024_mod, p1024_mp_mod);
        }
        /* y = 2*A*(B - X) - Y^4 */
        sp_1024_mont_sub_52(y, b, x, p1024_mod);
        sp_1024_mont_mul_52(y, y, a, p1024_mod, p1024_mp_mod);
        sp_1024_mont_dbl_52(y, y, p1024_mod);
        sp_1024_mont_sub_52(y, y, t2, p1024_mod);

        /* Y = Y/2 */
        sp_1024_div2_52(r[(1<<i)*m].y, y, p1024_mod);
        r[(1<<i)*m].infinity = 0;
    }
}

/* Add two Montgomery form projective points.
 *
 * ra  Result of addition.
 * rs  Result of subtraction.
 * p   First point to add.
 * q   Second point to add.
 * t   Temporary ordinate data.
 */
static void sp_1024_proj_point_add_sub_52(sp_point_1024* ra,
        sp_point_1024* rs, const sp_point_1024* p, const sp_point_1024* q,
        sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*52;
    sp_digit* t3 = t + 4*52;
    sp_digit* t4 = t + 6*52;
    sp_digit* t5 = t + 8*52;
    sp_digit* t6 = t + 10*52;
    sp_digit* x = ra->x;
    sp_digit* y = ra->y;
    sp_digit* z = ra->z;
    sp_digit* xs = rs->x;
    sp_digit* ys = rs->y;
    sp_digit* zs = rs->z;


    XMEMCPY(x, p->x, sizeof(p->x) / 2);
    XMEMCPY(y, p->y, sizeof(p->y) / 2);
    XMEMCPY(z, p->z, sizeof(p->z) / 2);
    ra->infinity = 0;
    rs->infinity = 0;

    /* U1 = X1*Z2^2 */
    sp_1024_mont_sqr_52(t1, q->z, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(t3, t1, q->z, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(t1, t1, x, p1024_mod, p1024_mp_mod);
    /* U2 = X2*Z1^2 */
    sp_1024_mont_sqr_52(t2, z, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(t4, t2, z, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(t2, t2, q->x, p1024_mod, p1024_mp_mod);
    /* S1 = Y1*Z2^3 */
    sp_1024_mont_mul_52(t3, t3, y, p1024_mod, p1024_mp_mod);
    /* S2 = Y2*Z1^3 */
    sp_1024_mont_mul_52(t4, t4, q->y, p1024_mod, p1024_mp_mod);
    /* H = U2 - U1 */
    sp_1024_mont_sub_52(t2, t2, t1, p1024_mod);
    /* RS = S2 + S1 */
    sp_1024_mont_add_52(t6, t4, t3, p1024_mod);
    /* R = S2 - S1 */
    sp_1024_mont_sub_52(t4, t4, t3, p1024_mod);
    /* Z3 = H*Z1*Z2 */
    /* ZS = H*Z1*Z2 */
    sp_1024_mont_mul_52(z, z, q->z, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(z, z, t2, p1024_mod, p1024_mp_mod);
    XMEMCPY(zs, z, sizeof(p->z)/2);
    /* X3 = R^2 - H^3 - 2*U1*H^2 */
    /* XS = RS^2 - H^3 - 2*U1*H^2 */
    sp_1024_mont_sqr_52(x, t4, p1024_mod, p1024_mp_mod);
    sp_1024_mont_sqr_52(xs, t6, p1024_mod, p1024_mp_mod);
    sp_1024_mont_sqr_52(t5, t2, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(y, t1, t5, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(t5, t5, t2, p1024_mod, p1024_mp_mod);
    sp_1024_mont_sub_52(x, x, t5, p1024_mod);
    sp_1024_mont_sub_52(xs, xs, t5, p1024_mod);
    sp_1024_mont_dbl_52(t1, y, p1024_mod);
    sp_1024_mont_sub_52(x, x, t1, p1024_mod);
    sp_1024_mont_sub_52(xs, xs, t1, p1024_mod);
    /* Y3 = R*(U1*H^2 - X3) - S1*H^3 */
    /* YS = -RS*(U1*H^2 - XS) - S1*H^3 */
    sp_1024_mont_sub_52(ys, y, xs, p1024_mod);
    sp_1024_mont_sub_52(y, y, x, p1024_mod);
    sp_1024_mont_mul_52(y, y, t4, p1024_mod, p1024_mp_mod);
    sp_1024_mont_sub_52(t6, p1024_mod, t6, p1024_mod);
    sp_1024_mont_mul_52(ys, ys, t6, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(t5, t5, t3, p1024_mod, p1024_mp_mod);
    sp_1024_mont_sub_52(y, y, t5, p1024_mod);
    sp_1024_mont_sub_52(ys, ys, t5, p1024_mod);
}

/* Structure used to describe recoding of scalar multiplication. */
typedef struct ecc_recode_1024 {
    /* Index into pre-computation table. */
    uint8_t i;
    /* Use the negative of the point. */
    uint8_t neg;
} ecc_recode_1024;

/* The index into pre-computation table to use. */
static const uint8_t recode_index_52_7[130] = {
     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
    64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49,
    48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33,
    32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17,
    16, 15, 14, 13, 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,
     0,  1,
};

/* Whether to negate y-ordinate. */
static const uint8_t recode_neg_52_7[130] = {
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
     0,  0,
};

/* Recode the scalar for multiplication using pre-computed values and
 * subtraction.
 *
 * k  Scalar to multiply by.
 * v  Vector of operations to perform.
 */
static void sp_1024_ecc_recode_7_52(const sp_digit* k, ecc_recode_1024* v)
{
    int i;
    int j;
    uint8_t y;
    int carry = 0;
    int o;
    sp_digit n;

    j = 0;
    n = k[j];
    o = 0;
    for (i=0; i<147; i++) {
        y = (uint8_t)n;
        if (o + 7 < 20) {
            y &= 0x7f;
            n >>= 7;
            o += 7;
        }
        else if (o + 7 == 20) {
            n >>= 7;
            if (++j < 52)
                n = k[j];
            o = 0;
        }
        else if (++j < 52) {
            n = k[j];
            y |= (n << (20 - o)) & 0x7f;
            o -= 13;
            n >>= o;
        }

        y += (uint8_t)carry;
        v[i].i = recode_index_52_7[y];
        v[i].neg = recode_neg_52_7[y];
        carry = (y >> 7) + v[i].neg;
    }
}

/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * r     Resulting point.
 * g     Point to multiply.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_1024_ecc_mulmod_win_add_sub_52(sp_point_1024* r,
        const sp_point_1024* g, const sp_digit* k, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_1024 td[65];
    sp_point_1024 rtd;
    sp_point_1024 pd;
    sp_digit tmpd[2 * 52 * 6];
#endif
    sp_point_1024* t;
    sp_point_1024* rt;
    sp_point_1024* p = NULL;
    sp_digit* tmp;
    sp_digit* negy;
    int i;
    ecc_recode_1024 v[147];
    int err;

    (void)heap;

    err = sp_1024_point_new_52(heap, rtd, rt);
    if (err == MP_OKAY)
        err = sp_1024_point_new_52(heap, pd, p);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    t = (sp_point_1024*)XMALLOC(sizeof(sp_point_1024) * 65, heap, DYNAMIC_TYPE_ECC);
    if (t == NULL)
        err = MEMORY_E;
    tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 52 * 6, heap,
                             DYNAMIC_TYPE_ECC);
    if (tmp == NULL)
        err = MEMORY_E;
#else
    t = td;
    tmp = tmpd;
#endif


    if (err == MP_OKAY) {
        /* t[0] = {0, 0, 1} * norm */
        XMEMSET(&t[0], 0, sizeof(t[0]));
        t[0].infinity = 1;
        /* t[1] = {g->x, g->y, g->z} * norm */
        err = sp_1024_mod_mul_norm_52(t[1].x, g->x, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(t[1].y, g->y, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(t[1].z, g->z, p1024_mod);
    }

    if (err == MP_OKAY) {
        t[1].infinity = 0;
        /* t[2] ... t[64]  */
        sp_1024_proj_point_dbl_n_store_52(t, &t[ 1], 6, 1, tmp);
        sp_1024_proj_point_add_52(&t[ 3], &t[ 2], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[ 6], &t[ 3], tmp);
        sp_1024_proj_point_add_sub_52(&t[ 7], &t[ 5], &t[ 6], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[10], &t[ 5], tmp);
        sp_1024_proj_point_add_sub_52(&t[11], &t[ 9], &t[10], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[12], &t[ 6], tmp);
        sp_1024_proj_point_dbl_52(&t[14], &t[ 7], tmp);
        sp_1024_proj_point_add_sub_52(&t[15], &t[13], &t[14], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[18], &t[ 9], tmp);
        sp_1024_proj_point_add_sub_52(&t[19], &t[17], &t[18], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[20], &t[10], tmp);
        sp_1024_proj_point_dbl_52(&t[22], &t[11], tmp);
        sp_1024_proj_point_add_sub_52(&t[23], &t[21], &t[22], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[24], &t[12], tmp);
        sp_1024_proj_point_dbl_52(&t[26], &t[13], tmp);
        sp_1024_proj_point_add_sub_52(&t[27], &t[25], &t[26], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[28], &t[14], tmp);
        sp_1024_proj_point_dbl_52(&t[30], &t[15], tmp);
        sp_1024_proj_point_add_sub_52(&t[31], &t[29], &t[30], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[34], &t[17], tmp);
        sp_1024_proj_point_add_sub_52(&t[35], &t[33], &t[34], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[36], &t[18], tmp);
        sp_1024_proj_point_dbl_52(&t[38], &t[19], tmp);
        sp_1024_proj_point_add_sub_52(&t[39], &t[37], &t[38], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[40], &t[20], tmp);
        sp_1024_proj_point_dbl_52(&t[42], &t[21], tmp);
        sp_1024_proj_point_add_sub_52(&t[43], &t[41], &t[42], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[44], &t[22], tmp);
        sp_1024_proj_point_dbl_52(&t[46], &t[23], tmp);
        sp_1024_proj_point_add_sub_52(&t[47], &t[45], &t[46], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[48], &t[24], tmp);
        sp_1024_proj_point_dbl_52(&t[50], &t[25], tmp);
        sp_1024_proj_point_add_sub_52(&t[51], &t[49], &t[50], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[52], &t[26], tmp);
        sp_1024_proj_point_dbl_52(&t[54], &t[27], tmp);
        sp_1024_proj_point_add_sub_52(&t[55], &t[53], &t[54], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[56], &t[28], tmp);
        sp_1024_proj_point_dbl_52(&t[58], &t[29], tmp);
        sp_1024_proj_point_add_sub_52(&t[59], &t[57], &t[58], &t[ 1], tmp);
        sp_1024_proj_point_dbl_52(&t[60], &t[30], tmp);
        sp_1024_proj_point_dbl_52(&t[62], &t[31], tmp);
        sp_1024_proj_point_add_sub_52(&t[63], &t[61], &t[62], &t[ 1], tmp);

        negy = t[0].y;

        sp_1024_ecc_recode_7_52(k, v);

        i = 146;
        XMEMCPY(rt, &t[v[i].i], sizeof(sp_point_1024));
        for (--i; i>=0; i--) {
            sp_1024_proj_point_dbl_n_52(rt, 7, tmp);

            XMEMCPY(p, &t[v[i].i], sizeof(sp_point_1024));
            sp_1024_mont_sub_52(negy, p1024_mod, p->y, p1024_mod);
            sp_1024_norm_52(negy);
            sp_1024_cond_copy_52(p->y, negy, (sp_digit)0 - v[i].neg);
            sp_1024_proj_point_add_52(rt, rt, p, tmp);
        }

        if (map != 0) {
            sp_1024_map_52(r, rt, tmp);
        }
        else {
            XMEMCPY(r, rt, sizeof(sp_point_1024));
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (t != NULL)
        XFREE(t, heap, DYNAMIC_TYPE_ECC);
    if (tmp != NULL)
        XFREE(tmp, heap, DYNAMIC_TYPE_ECC);
#endif
    sp_1024_point_free_52(p, 0, heap);
    sp_1024_point_free_52(rt, 0, heap);

    return err;
}

#ifdef FP_ECC
#endif /* FP_ECC */
/* Add two Montgomery form projective points. The second point has a q value of
 * one.
 * Only the first point can be the same pointer as the result point.
 *
 * r  Result of addition.
 * p  First point to add.
 * q  Second point to add.
 * t  Temporary ordinate data.
 */
static void sp_1024_proj_point_add_qz1_52(sp_point_1024* r, const sp_point_1024* p,
        const sp_point_1024* q, sp_digit* t)
{
    const sp_point_1024* ap[2];
    sp_point_1024* rp[2];
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2*52;
    sp_digit* t3 = t + 4*52;
    sp_digit* t4 = t + 6*52;
    sp_digit* t5 = t + 8*52;
    sp_digit* x;
    sp_digit* y;
    sp_digit* z;
    int i;

    /* Check double */
    (void)sp_1024_mont_sub_52(t1, p1024_mod, q->y, p1024_mod);
    sp_1024_norm_52(t1);
    if ((sp_1024_cmp_equal_52(p->x, q->x) & sp_1024_cmp_equal_52(p->z, q->z) &
        (sp_1024_cmp_equal_52(p->y, q->y) | sp_1024_cmp_equal_52(p->y, t1))) != 0) {
        sp_1024_proj_point_dbl_52(r, p, t);
    }
    else {
        rp[0] = r;

        /*lint allow cast to different type of pointer*/
        rp[1] = (sp_point_1024*)t; /*lint !e9087 !e740*/
        XMEMSET(rp[1], 0, sizeof(sp_point_1024));
        x = rp[p->infinity | q->infinity]->x;
        y = rp[p->infinity | q->infinity]->y;
        z = rp[p->infinity | q->infinity]->z;

        ap[0] = p;
        ap[1] = q;
        for (i=0; i<52; i++) {
            r->x[i] = ap[p->infinity]->x[i];
        }
        for (i=0; i<52; i++) {
            r->y[i] = ap[p->infinity]->y[i];
        }
        for (i=0; i<52; i++) {
            r->z[i] = ap[p->infinity]->z[i];
        }
        r->infinity = ap[p->infinity]->infinity;

        /* U2 = X2*Z1^2 */
        sp_1024_mont_sqr_52(t2, z, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(t4, t2, z, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(t2, t2, q->x, p1024_mod, p1024_mp_mod);
        /* S2 = Y2*Z1^3 */
        sp_1024_mont_mul_52(t4, t4, q->y, p1024_mod, p1024_mp_mod);
        /* H = U2 - X1 */
        sp_1024_mont_sub_52(t2, t2, x, p1024_mod);
        /* R = S2 - Y1 */
        sp_1024_mont_sub_52(t4, t4, y, p1024_mod);
        /* Z3 = H*Z1 */
        sp_1024_mont_mul_52(z, z, t2, p1024_mod, p1024_mp_mod);
        /* X3 = R^2 - H^3 - 2*X1*H^2 */
        sp_1024_mont_sqr_52(t1, t4, p1024_mod, p1024_mp_mod);
        sp_1024_mont_sqr_52(t5, t2, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(t3, x, t5, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(t5, t5, t2, p1024_mod, p1024_mp_mod);
        sp_1024_mont_sub_52(x, t1, t5, p1024_mod);
        sp_1024_mont_dbl_52(t1, t3, p1024_mod);
        sp_1024_mont_sub_52(x, x, t1, p1024_mod);
        /* Y3 = R*(X1*H^2 - X3) - Y1*H^3 */
        sp_1024_mont_sub_52(t3, t3, x, p1024_mod);
        sp_1024_mont_mul_52(t3, t3, t4, p1024_mod, p1024_mp_mod);
        sp_1024_mont_mul_52(t5, t5, y, p1024_mod, p1024_mp_mod);
        sp_1024_mont_sub_52(y, t3, t5, p1024_mod);
    }
}

#if defined(FP_ECC) || !defined(WOLFSSL_SP_SMALL)
/* Convert the projective point to affine.
 * Ordinates are in Montgomery form.
 *
 * a  Point to convert.
 * t  Temporary data.
 */
static void sp_1024_proj_to_affine_52(sp_point_1024* a, sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2 * 52;
    sp_digit* tmp = t + 4 * 52;

    sp_1024_mont_inv_52(t1, a->z, tmp);

    sp_1024_mont_sqr_52(t2, t1, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(t1, t2, t1, p1024_mod, p1024_mp_mod);

    sp_1024_mont_mul_52(a->x, a->x, t2, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(a->y, a->y, t1, p1024_mod, p1024_mp_mod);
    XMEMCPY(a->z, p1024_norm_mod, sizeof(p1024_norm_mod));
}

/* Generate the pre-computed table of points for the base point.
 *
 * width = 8
 * 256 entries
 * 128 bits between
 *
 * a      The base point.
 * table  Place to store generated point data.
 * tmp    Temporary data.
 * heap  Heap to use for allocation.
 */
static int sp_1024_gen_stripe_table_52(const sp_point_1024* a,
        sp_table_entry_1024* table, sp_digit* tmp, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_1024 td;
    sp_point_1024 s1d;
    sp_point_1024 s2d;
#endif
    sp_point_1024* t;
    sp_point_1024* s1 = NULL;
    sp_point_1024* s2 = NULL;
    int i;
    int j;
    int err;

    (void)heap;

    err = sp_1024_point_new_52(heap, td, t);
    if (err == MP_OKAY) {
        err = sp_1024_point_new_52(heap, s1d, s1);
    }
    if (err == MP_OKAY) {
        err = sp_1024_point_new_52(heap, s2d, s2);
    }

    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(t->x, a->x, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(t->y, a->y, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(t->z, a->z, p1024_mod);
    }
    if (err == MP_OKAY) {
        t->infinity = 0;
        sp_1024_proj_to_affine_52(t, tmp);

        XMEMCPY(s1->z, p1024_norm_mod, sizeof(p1024_norm_mod));
        s1->infinity = 0;
        XMEMCPY(s2->z, p1024_norm_mod, sizeof(p1024_norm_mod));
        s2->infinity = 0;

        /* table[0] = {0, 0, infinity} */
        XMEMSET(&table[0], 0, sizeof(sp_table_entry_1024));
        /* table[1] = Affine version of 'a' in Montgomery form */
        XMEMCPY(table[1].x, t->x, sizeof(table->x));
        XMEMCPY(table[1].y, t->y, sizeof(table->y));

        for (i=1; i<8; i++) {
            sp_1024_proj_point_dbl_n_52(t, 128, tmp);
            sp_1024_proj_to_affine_52(t, tmp);
            XMEMCPY(table[1<<i].x, t->x, sizeof(table->x));
            XMEMCPY(table[1<<i].y, t->y, sizeof(table->y));
        }

        for (i=1; i<8; i++) {
            XMEMCPY(s1->x, table[1<<i].x, sizeof(table->x));
            XMEMCPY(s1->y, table[1<<i].y, sizeof(table->y));
            for (j=(1<<i)+1; j<(1<<(i+1)); j++) {
                XMEMCPY(s2->x, table[j-(1<<i)].x, sizeof(table->x));
                XMEMCPY(s2->y, table[j-(1<<i)].y, sizeof(table->y));
                sp_1024_proj_point_add_qz1_52(t, s1, s2, tmp);
                sp_1024_proj_to_affine_52(t, tmp);
                XMEMCPY(table[j].x, t->x, sizeof(table->x));
                XMEMCPY(table[j].y, t->y, sizeof(table->y));
            }
        }
    }

    sp_1024_point_free_52(s2, 0, heap);
    sp_1024_point_free_52(s1, 0, heap);
    sp_1024_point_free_52( t, 0, heap);

    return err;
}

#endif /* FP_ECC | !WOLFSSL_SP_SMALL */
/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * Stripe implementation.
 * Pre-generated: 2^0, 2^128, ...
 * Pre-generated: products of all combinations of above.
 * 8 doubles and adds (with qz=1)
 *
 * r     Resulting point.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_1024_ecc_mulmod_stripe_52(sp_point_1024* r,
        const sp_point_1024* g, const sp_table_entry_1024* table,
        const sp_digit* k, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_1024 rtd;
    sp_point_1024 pd;
    sp_digit td[2 * 52 * 5];
#endif
    sp_point_1024* rt;
    sp_point_1024* p = NULL;
    sp_digit* t;
    int i;
    int j;
    int y;
    int x;
    int err;

    (void)g;
    (void)heap;


    err = sp_1024_point_new_52(heap, rtd, rt);
    if (err == MP_OKAY) {
        err = sp_1024_point_new_52(heap, pd, p);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    t = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 52 * 5, heap,
                           DYNAMIC_TYPE_ECC);
    if (t == NULL) {
        err = MEMORY_E;
    }
#else
    t = td;
#endif

    if (err == MP_OKAY) {
        XMEMCPY(p->z, p1024_norm_mod, sizeof(p1024_norm_mod));
        XMEMCPY(rt->z, p1024_norm_mod, sizeof(p1024_norm_mod));

        y = 0;
        x = 127;
        for (j = 0; j < 8; j++) {
            y |= ((k[x / 20] >> (x % 20)) & 1) << j;
            x += 128;
        }
        XMEMCPY(rt->x, table[y].x, sizeof(table[y].x));
        XMEMCPY(rt->y, table[y].y, sizeof(table[y].y));
        rt->infinity = !y;
        for (i = 126; i >= 0; i--) {
            y = 0;
            x = i;
            for (j=0; j<8; j++) {
                y |= ((k[x / 20] >> (x % 20)) & 1) << j;
                x += 128;
            }

            sp_1024_proj_point_dbl_52(rt, rt, t);
            XMEMCPY(p->x, table[y].x, sizeof(table[y].x));
            XMEMCPY(p->y, table[y].y, sizeof(table[y].y));
            p->infinity = !y;
            sp_1024_proj_point_add_qz1_52(rt, rt, p, t);
        }

        if (map != 0) {
            sp_1024_map_52(r, rt, t);
        }
        else {
            XMEMCPY(r, rt, sizeof(sp_point_1024));
        }
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (t != NULL) {
        XFREE(t, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_1024_point_free_52(p, 0, heap);
    sp_1024_point_free_52(rt, 0, heap);

    return err;
}

#ifdef FP_ECC
#ifndef FP_ENTRIES
    #define FP_ENTRIES 16
#endif

/* Cache entry - holds precomputation tables for a point. */
typedef struct sp_cache_1024_t {
    /* X ordinate of point that table was generated from. */
    sp_digit x[52];
    /* Y ordinate of point that table was generated from. */
    sp_digit y[52];
    /* Precomputation table for point. */
    sp_table_entry_1024 table[256];
    /* Count of entries in table. */
    uint32_t cnt;
    /* Point and table set in entry. */
    int set;
} sp_cache_1024_t;

/* Cache of tables. */
static THREAD_LS_T sp_cache_1024_t sp_cache_1024[FP_ENTRIES];
/* Index of last entry in cache. */
static THREAD_LS_T int sp_cache_1024_last = -1;
/* Cache has been initialized. */
static THREAD_LS_T int sp_cache_1024_inited = 0;

#ifndef HAVE_THREAD_LS
    static volatile int initCacheMutex_1024 = 0;
    static wolfSSL_Mutex sp_cache_1024_lock;
#endif

/* Get the cache entry for the point.
 *
 * g      [in]   Point scalar multipling.
 * cache  [out]  Cache table to use.
 */
static void sp_ecc_get_cache_1024(const sp_point_1024* g,
        sp_cache_1024_t** cache)
{
    int i;
    int j;
    uint32_t least;

    if (sp_cache_1024_inited == 0) {
        for (i=0; i<FP_ENTRIES; i++) {
            sp_cache_1024[i].set = 0;
        }
        sp_cache_1024_inited = 1;
    }

    /* Compare point with those in cache. */
    for (i=0; i<FP_ENTRIES; i++) {
        if (!sp_cache_1024[i].set)
            continue;

        if (sp_1024_cmp_equal_52(g->x, sp_cache_1024[i].x) &
                           sp_1024_cmp_equal_52(g->y, sp_cache_1024[i].y)) {
            sp_cache_1024[i].cnt++;
            break;
        }
    }

    /* No match. */
    if (i == FP_ENTRIES) {
        /* Find empty entry. */
        i = (sp_cache_1024_last + 1) % FP_ENTRIES;
        for (; i != sp_cache_1024_last; i=(i+1)%FP_ENTRIES) {
            if (!sp_cache_1024[i].set) {
                break;
            }
        }

        /* Evict least used. */
        if (i == sp_cache_1024_last) {
            least = sp_cache_1024[0].cnt;
            for (j=1; j<FP_ENTRIES; j++) {
                if (sp_cache_1024[j].cnt < least) {
                    i = j;
                    least = sp_cache_1024[i].cnt;
                }
            }
        }

        XMEMCPY(sp_cache_1024[i].x, g->x, sizeof(sp_cache_1024[i].x));
        XMEMCPY(sp_cache_1024[i].y, g->y, sizeof(sp_cache_1024[i].y));
        sp_cache_1024[i].set = 1;
        sp_cache_1024[i].cnt = 1;
    }

    *cache = &sp_cache_1024[i];
    sp_cache_1024_last = i;
}
#endif /* FP_ECC */

/* Multiply the base point of P1024 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * r     Resulting point.
 * g     Point to multiply.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_1024_ecc_mulmod_52(sp_point_1024* r, const sp_point_1024* g,
        const sp_digit* k, int map, void* heap)
{
#ifndef FP_ECC
    return sp_1024_ecc_mulmod_win_add_sub_52(r, g, k, map, heap);
#else
    sp_digit tmp[2 * 52 * 5];
    sp_cache_1024_t* cache;
    int err = MP_OKAY;

#ifndef HAVE_THREAD_LS
    if (initCacheMutex_1024 == 0) {
         wc_InitMutex(&sp_cache_1024_lock);
         initCacheMutex_1024 = 1;
    }
    if (wc_LockMutex(&sp_cache_1024_lock) != 0)
       err = BAD_MUTEX_E;
#endif /* HAVE_THREAD_LS */

    if (err == MP_OKAY) {
        sp_ecc_get_cache_1024(g, &cache);
        if (cache->cnt == 2)
            sp_1024_gen_stripe_table_52(g, cache->table, tmp, heap);

#ifndef HAVE_THREAD_LS
        wc_UnLockMutex(&sp_cache_1024_lock);
#endif /* HAVE_THREAD_LS */

        if (cache->cnt < 2) {
            err = sp_1024_ecc_mulmod_win_add_sub_52(r, g, k, map, heap);
        }
        else {
            err = sp_1024_ecc_mulmod_stripe_52(r, g, cache->table, k,
                    map, heap);
        }
    }

    return err;
#endif
}

#endif
/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * km    Scalar to multiply by.
 * p     Point to multiply.
 * r     Resulting point.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_mulmod_1024(const mp_int* km, const ecc_point* gm, ecc_point* r,
    int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_1024 p;
    sp_digit kd[52];
#endif
    sp_point_1024* point;
    sp_digit* k = NULL;
    int err = MP_OKAY;

    err = sp_1024_point_new_52(heap, p, point);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * 52, heap,
                                                              DYNAMIC_TYPE_ECC);
        if (k == NULL)
            err = MEMORY_E;
    }
#else
    k = kd;
#endif
    if (err == MP_OKAY) {
        sp_1024_from_mp(k, 52, km);
        sp_1024_point_from_ecc_point_52(point, gm);

            err = sp_1024_ecc_mulmod_52(point, point, k, map, heap);
    }
    if (err == MP_OKAY) {
        err = sp_1024_point_to_ecc_point_52(point, r);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_1024_point_free_52(point, 0, heap);

    return err;
}

#ifdef WOLFSSL_SP_SMALL
/* Multiply the base point of P1024 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * r     Resulting point.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_1024_ecc_mulmod_base_52(sp_point_1024* r, const sp_digit* k,
        int map, void* heap)
{
    /* No pre-computed values. */
    return sp_1024_ecc_mulmod_52(r, &p1024_base, k, map, heap);
}

#elif defined(WOLFSSL_SP_CACHE_RESISTANT)
/* Multiply the base point of P1024 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * r     Resulting point.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_1024_ecc_mulmod_base_52(sp_point_1024* r, const sp_digit* k,
        int map, void* heap)
{
    /* No pre-computed values. */
    return sp_1024_ecc_mulmod_52(r, &p1024_base, k, map, heap);
}

#else
/* Striping precomputation table.
 * 8 points combined into a table of 256 points.
 * Distance of 128 between points.
 */
static const sp_table_entry_1024 p1024_table[256] = {
    /* 0 */
    { { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    /* 1 */
    { { 0x62bc2,0xc6e01,0xf9c7e,0x9289b,0x310a8,0xecc6e,0xd81dd,0x9e499,
        0x99df0,0x185d5,0xd3582,0xea286,0xb9a96,0xc5f8d,0x7d370,0x01aec,
        0x5d066,0x958cf,0x72e49,0xd7f8e,0xd3e91,0xe7297,0xf5ac2,0xda9f2,
        0x1db92,0xed862,0xa5679,0xc8675,0x14b26,0x56aac,0x5df2c,0x23338,
        0x13f99,0xd4c6a,0x88e74,0xec11b,0x3ffa8,0x14b17,0xfef12,0x1f3f9,
        0x86a27,0x4ea03,0x0e7b4,0x1b4ec,0x6bd9b,0xcd349,0x8dcee,0xafe52,
        0x9f80b,0x6a1c4,0xdfff9,0x00008 },
      { 0xc0c83,0x3ac03,0x4a475,0xcd75b,0x8abcd,0xe69d1,0x64968,0xf775b,
        0x39b88,0x52e38,0xf58f3,0x949ab,0xc803f,0x0bc15,0x679bd,0x5f702,
        0x298c2,0x168ff,0x5bf5d,0x976e8,0x8c6c7,0x6ebd9,0x1b43f,0x45e3e,
        0x18af4,0x93206,0x4e640,0x598e5,0xe67d5,0x4fed9,0x83b50,0xb0472,
        0x87517,0xfd70d,0x50cab,0xddbe4,0xf3f5a,0xd628b,0xcca47,0x78cb4,
        0x7ef30,0x08003,0xb1c49,0x8d3c6,0x74e14,0xcfd83,0x3294f,0xe256d,
        0xc01f3,0x7bde3,0xaa120,0x00002 } },
    /* 2 */
    { { 0x00955,0xae019,0x95b6d,0x656da,0x1ceb4,0xdc9cc,0x95ba5,0xe72fe,
        0x78907,0x3450c,0x040c3,0x5447a,0xea1ae,0x52ea6,0x37079,0x91191,
        0x97305,0x436d0,0x4ff73,0xd10f5,0x4bda4,0xdb007,0x070a4,0x91644,
        0x306f1,0x2cfd5,0xb2452,0xfe738,0x214b9,0x49f76,0xad678,0x1468d,
        0xcd2e4,0x18b0d,0x7b29a,0xd4928,0x15e1a,0xd7f1a,0xa1aad,0xdbba2,
        0x63a81,0x799ac,0x12233,0x9c5b8,0x80137,0xe53bc,0x2f0b0,0xf402b,
        0x13b61,0x7f0bf,0xc3eb2,0x00008 },
      { 0x3696f,0xe1e51,0xa4ad3,0x1ffa9,0xc18c8,0x50ba5,0xd1303,0x3c033,
        0xfc136,0xbc1e2,0x7a531,0x6e711,0xd53da,0xed610,0x4901a,0x42ec6,
        0xff567,0xf7e99,0x33e8d,0xd12ad,0xe3dee,0xaad73,0xdebe4,0x180f4,
        0x3b465,0xb4d98,0x02f30,0x52695,0xf9936,0x918d7,0x9aba8,0x7e279,
        0xfc79a,0xb6700,0xffe84,0xd8c20,0x640bf,0x4400d,0x1bd7b,0x5d264,
        0x21d21,0xcbc3a,0x32621,0x9442c,0x37983,0x401e8,0x00bb1,0xace65,
        0xc4310,0x3e251,0xbf416,0x00007 } },
    /* 3 */
    { { 0xd589e,0x88e3f,0xc174f,0x4a031,0x0df97,0x50179,0x49fdb,0x3e705,
        0x623e3,0x34d09,0x5924f,0x1eff1,0x58d09,0xb65ac,0xcadf9,0xeef79,
        0x9c2cf,0x623f6,0x2cc42,0x82bcd,0x252cd,0x7d903,0xddd81,0xa5f1d,
        0x4f4d9,0xbdacf,0x011b6,0x26355,0x9d061,0xd140c,0x90d2e,0x9f744,
        0x686d2,0x8c4db,0x4092e,0x0fcc6,0x6776b,0x5eef1,0xeb622,0xdf16a,
        0xc01e9,0x2a0e8,0x4bbd8,0x67418,0x76283,0x56e33,0x4e289,0x75757,
        0xa7f07,0xc6705,0x871ed,0x00009 },
      { 0x535f7,0xd5776,0xd0b76,0xb3b8b,0x22635,0x14d60,0xf6452,0x9d216,
        0x25ad9,0x75c0c,0x515bf,0xf3a75,0x5fd4d,0x9f167,0x5bc5e,0x24a62,
        0x873e7,0xb7406,0xc35ef,0x5c4a3,0x3bb2e,0x5c9a3,0x98aef,0x806b1,
        0x1b35e,0xeda97,0x3c690,0x0ca5a,0x19f5c,0x1e234,0xd898e,0xa8d5d,
        0xad9e4,0xce955,0xcecbc,0x34164,0x7248d,0xcf440,0xf6e2e,0x45c0a,
        0xb3811,0xff1ab,0xc780f,0xee821,0x73f4b,0x72ed5,0x768c2,0xd14df,
        0x637ad,0x0a371,0x97ed1,0x00003 } },
    /* 4 */
    { { 0xc2a27,0xb2755,0xf3e0b,0x5c44c,0x95958,0x8e42f,0xe60d3,0x19285,
        0x13e0f,0x0f46b,0x6273d,0xd0c07,0xac3ec,0x3c569,0x08519,0x7800f,
        0x1818a,0xab435,0x04e74,0x363bf,0x88496,0x58aa3,0x4fe92,0xb8c89,
        0x6617c,0xa0845,0xaf969,0x2aaa2,0x98bc6,0x4668d,0x80b5a,0x66c22,
        0x2f4fa,0x8ea99,0xc9df5,0x1e99b,0x93f40,0xb0b7d,0xc0e5d,0xc4c38,
        0x14fe1,0xb3e06,0xccdf6,0x151c2,0x8d531,0x43b61,0x5ece1,0x1c757,
        0x398a4,0x85df9,0x02479,0x00004 },
      { 0x55746,0x788f0,0xba251,0xe6e0f,0x00ab1,0xba004,0x697c5,0xac292,
        0x194fb,0x40e1b,0xb4f47,0x21195,0x47715,0xb7ba5,0x1d09b,0x25009,
        0x139a4,0x61b9a,0xa6748,0xaa7e7,0x3f353,0x8413b,0xeeeba,0x2443c,
        0x77192,0xd0afe,0x847bb,0x8d363,0xd1446,0xa4942,0xff63d,0x61f79,
        0x5b456,0xc1d42,0x563a1,0x46301,0xd75ff,0x270fc,0x2c93c,0xeb280,
        0x72090,0x04420,0x85c70,0xcdcbc,0x468f0,0x032e7,0x2fbfa,0xca437,
        0x79d80,0xe6c8b,0xa6fd1,0x00001 } },
    /* 5 */
    { { 0x116a3,0x1a8d5,0x67a90,0xf47f9,0x4b2f5,0x84439,0xf3b0b,0x60eba,
        0xad452,0x0ce39,0x0ccfc,0xe6176,0x21e1b,0x3f53f,0x3d2cc,0xac07e,
        0x11bb6,0x0e1ed,0xd838e,0xb0c2d,0x71c15,0x47530,0x5b845,0x920fe,
        0xd4748,0x6d70d,0x47189,0xbe2de,0xc1a20,0x276c7,0xd8a59,0x3c3fa,
        0x6ee07,0xc3c88,0x26a1c,0x1ac40,0x76e83,0xdb6f3,0xd659f,0xac501,
        0x35d1a,0x7426a,0x0da85,0x89054,0x50ae9,0xd734e,0x0a4ab,0x65dde,
        0x14750,0xdc156,0x9b7d4,0x00002 },
      { 0x4e20b,0xcbcbf,0x4b3c2,0x44c54,0xf58cc,0x3f548,0xc1f1c,0x5b0ca,
        0x09b54,0x21398,0x0f806,0x02b50,0x00c0f,0x6905e,0x89006,0xe612b,
        0x0188c,0xd7835,0xf158e,0x76b28,0x83f55,0x1dc45,0x2e0c0,0xa4549,
        0x03272,0x43298,0xff924,0x623a0,0x177a5,0xd0dc4,0xb0029,0xd12a2,
        0x0e87a,0x59278,0x41254,0xf272b,0x30d53,0xbcf90,0xe8d1e,0x24301,
        0x6ea40,0x98bae,0x37d07,0x3f2fa,0xc1e5f,0xb4126,0x31022,0x9342c,
        0x2497e,0x02538,0xd0928,0x00005 } },
    /* 6 */
    { { 0xf780d,0x7eff2,0x83a2b,0x6b1d5,0x0d7d7,0xd2682,0xaec34,0x86f74,
        0x32847,0xebe3c,0x0823f,0x22121,0x40fd4,0x5e7bf,0x17efb,0x227e4,
        0x8f8cd,0xb6a56,0x10d49,0xbbec5,0x61781,0xbce7d,0x8b753,0x2f371,
        0xe3f22,0x1f9cf,0x9de6c,0xe89fd,0x57f44,0xac9b5,0x53f3f,0xf1cc5,
        0x300bc,0x46e6f,0xd2d08,0xe6b19,0x29f0a,0x6c82a,0xbe097,0x24b8b,
        0xdbf5e,0xa7e63,0x73a5a,0x7f459,0x74cac,0xdd33c,0x23784,0xc6eb6,
        0xfee5d,0x34142,0xa26e4,0x00000 },
      { 0xa9a08,0x9faca,0x08133,0xece18,0x55246,0xf3110,0x74740,0x61393,
        0xc8170,0xe1892,0x42f02,0x41032,0xa8d8d,0x5de98,0xd203b,0x482bf,
        0xbe952,0x6b5ab,0x9ef94,0x82498,0x93769,0xd218b,0xc7ab8,0x66617,
        0x68e89,0x91d52,0xb7d2b,0x75518,0x3962e,0x8d67c,0x973fe,0x2c5c7,
        0x17c51,0x0a2b0,0x2e315,0x94694,0xcc1a2,0x4e5eb,0x0836f,0x531c7,
        0x910ce,0x50a39,0x77b9e,0x6eb4b,0x0af4f,0x120ad,0x175da,0x68cbb,
        0x636ec,0x61b92,0x9497c,0x00001 } },
    /* 7 */
    { { 0x659a8,0xc6417,0x920b0,0x28ff6,0x792cb,0x7ab9c,0x97fc7,0xb6877,
        0x67180,0x6355b,0x77593,0x58c1e,0x64caf,0x61b18,0xdb655,0x5155b,
        0xf4946,0x55780,0xe64e3,0x8b202,0x7229a,0x0ac9b,0xd60eb,0x2571b,
        0x94d78,0xf9885,0x3fa78,0x0939e,0x95dcc,0xc2d37,0x8302a,0x7b8b4,
        0xf1444,0x60b90,0x05fbf,0xb3c15,0x13ce4,0x610e8,0xc18ac,0xd59b5,
        0x4f27a,0x2239a,0xcea02,0x39737,0xb5fa3,0xff1c7,0x30b8d,0xe5787,
        0xbf7a6,0x8b517,0x6b91b,0x00009 },
      { 0xc087c,0xf49aa,0x1a991,0xb28dc,0xe6cfd,0x62f74,0x0d6ce,0x5f760,
        0x6ff9a,0xc908d,0x917f9,0xcd04f,0xfd781,0xe52db,0x5f63d,0x7796f,
        0x72180,0xe02ed,0x7db64,0x137de,0x66fa4,0x0876f,0x7160f,0x3ca1f,
        0x1ee64,0xa3327,0xc4ab8,0x20587,0x7cb9b,0x48104,0x10739,0xcba17,
        0xc5c37,0x0d598,0xf9a19,0xe125d,0xa6f20,0xb6e72,0x02d0c,0xf4f29,
        0x42204,0xfba31,0xce2dc,0x8cb97,0x142d2,0xd3c35,0xb8aa3,0xdf261,
        0xc249d,0x15cff,0x3f3d3,0x00007 } },
    /* 8 */
    { { 0xd3673,0x5be6f,0xd8685,0x4b7b5,0xf9d21,0x9b70a,0xcd330,0xdcc46,
        0x32f90,0xde8d3,0x95510,0xc0155,0xce553,0xc1251,0x09638,0x5746a,
        0xc1bc9,0x5b85c,0xd7cea,0xba8fc,0x8002e,0xfa146,0x77c4f,0x22fcd,
        0x3cb70,0xe310a,0x4ea05,0x9dfbc,0xeb699,0xfa756,0x0d04e,0x3375a,
        0xd5fd8,0x9edce,0xd9027,0xd56e4,0x3251f,0x19240,0x5f148,0x82a4c,
        0x633a4,0x5be87,0xb3410,0xd1301,0x83170,0x47e57,0xb0f72,0x93998,
        0xba1fa,0x64436,0x8934f,0x00008 },
      { 0x3eabc,0xb0471,0x09f43,0xc517f,0x1accd,0xa7dd9,0xa7c4c,0xef13c,
        0xaa63b,0x4b27d,0x58818,0x5a7a2,0x98b2e,0x5dc26,0x612d9,0x0a8cb,
        0x2f14c,0xa2e1f,0x46975,0x935c3,0xde172,0x29b8e,0x1e31f,0xd40bc,
        0xbfd6e,0xdac3c,0x32623,0x6b3f1,0x1d3f4,0x0b768,0xe6dfb,0xc115b,
        0xa4344,0x4556d,0xe31c3,0x3d985,0x8a8e4,0xc63f1,0x4eaa7,0x4bddb,
        0xb2083,0x8c55c,0xa54f5,0x0c384,0x9b16a,0xfd69d,0xca246,0x74eac,
        0x548e1,0xbb153,0xd1898,0x00000 } },
    /* 9 */
    { { 0xef043,0x61e35,0xea734,0xb5644,0x93496,0x7b67d,0xa3c10,0xd0f83,
        0xc173b,0x35d62,0x1d29c,0xb0385,0x4fad4,0xb1c1a,0x82a71,0x3f428,
        0x43b9e,0x6654b,0xd2bcf,0xf5435,0xa2abd,0x7b15a,0xdc1c7,0xdabe3,
        0x38a80,0x3b5cb,0x48167,0xa0aea,0xe15fd,0xb90eb,0xb4de7,0x86996,
        0x8f3d8,0x252bc,0x4f87e,0xe4248,0x637c4,0xed03d,0xfd8ad,0xd7a7a,
        0xde666,0x3ae5e,0x1ccb9,0x95a2a,0x180dd,0xfba39,0xd2546,0xa55cf,
        0x82e60,0xdc46f,0xbdab1,0x00002 },
      { 0xfed61,0x2bfa6,0xa4de2,0xd94e7,0x5cc8d,0x458aa,0x2f5ca,0x07122,
        0x72df1,0x773e3,0x5aff3,0xb44fe,0xd06a4,0x738e6,0xba74a,0xbc2d0,
        0x1f136,0x1d5f3,0xa470e,0xa9111,0xae102,0xff933,0x88577,0x310c7,
        0x80a50,0xac8b3,0x83fc5,0x02287,0x69f3c,0x725d0,0x92544,0xec668,
        0x84221,0x165ac,0x78f0e,0x6e8a8,0xfcfda,0x3af1a,0xaba9a,0x78cd2,
        0x3ed37,0xae018,0x26d0e,0xbd608,0x532cd,0xee641,0x661cb,0xb3234,
        0x10120,0x92b9c,0x53eb8,0x00003 } },
    /* 10 */
    { { 0x5521e,0xd610b,0x8fdca,0x02f0c,0x052e7,0x11b44,0x49c1a,0x8ffda,
        0x2680d,0xad630,0xbf36b,0x654ac,0x7cdb9,0x10a2d,0xe114c,0x7b58c,
        0x0e7e0,0x7de63,0xe5d1f,0xa8131,0xd6760,0xbe3d7,0x77f8c,0x6480d,
        0x5866b,0x19eb3,0xf0362,0x8cf37,0x75872,0xa8a75,0x5ed42,0xdd586,
        0xa2870,0x1d906,0x83f1f,0x906b2,0x4a51f,0xe23fa,0x0a879,0x543b2,
        0xc6e83,0x54f2a,0x81e77,0x6379b,0xe4f0b,0x0016e,0x0d484,0x57fbc,
        0x1b67d,0x71e62,0xda207,0x00008 },
      { 0xe65ec,0x04ecc,0xc8550,0x185e3,0xfb748,0xd10d1,0xad276,0x78797,
        0xe7bca,0xad64b,0x7e54a,0x4db07,0xf4344,0x0df0f,0x0c9be,0x17b6b,
        0x086a4,0x6c055,0xfc425,0xd5a38,0xbfd74,0x52c43,0xdb8f9,0x01c4e,
        0xe005a,0x28501,0xa57e3,0x2dfc4,0x3d517,0x5d6ee,0xe4e53,0xdb40c,
        0x50918,0x5c0c6,0xaef1e,0x61fcb,0x78575,0x5145e,0x4c6e8,0x34a22,
        0x8536a,0xa2e46,0xec0e0,0xe2270,0xc69a8,0x2b03f,0x24724,0xb3f52,
        0xebd5f,0xe2c3b,0x62f55,0x00008 } },
    /* 11 */
    { { 0x049fe,0x0f226,0xd6a39,0xc9fb2,0x8dcbb,0x92a57,0xfb7cc,0x97634,
        0xfeca4,0x93a52,0xdea58,0x0cb63,0x62b34,0x49e91,0x38a2a,0xa39f3,
        0xe41f3,0x3d949,0x6b2df,0x7e402,0xb065a,0x1c7cd,0x1a2c7,0x46828,
        0xb84a0,0xca4a9,0x31eee,0xb5037,0x563ee,0xcbb72,0x13476,0xe6d09,
        0xa678c,0xa9b94,0xcf979,0xd9f10,0xb808f,0x4d8c3,0x5b9b4,0xe0afc,
        0xda613,0x69e60,0xea5be,0xe7de3,0xf52dc,0x1ee74,0x864dc,0x3a5d6,
        0x80790,0x913bc,0x1ab28,0x00007 },
      { 0xb60ad,0xc43b5,0xf618f,0x3184c,0x04a0c,0xfb5e3,0x3020a,0xbc403,
        0x381cc,0x66d22,0xb1c0c,0x8953d,0xd33cf,0x112a8,0xe4da6,0x9c994,
        0x67a86,0xc3d19,0x7aae2,0xcd29d,0x35b7a,0x8d549,0x7fbc2,0x6c9a5,
        0x5bd13,0xf9807,0xc8427,0x373e9,0x5c9c0,0x3225f,0x18d19,0x2cbca,
        0xc018c,0x13442,0x3777d,0xa7277,0x7fbb3,0xe5ed4,0xc18eb,0x1962d,
        0x37d49,0x06704,0xdc088,0x1e092,0xcf39c,0xfff35,0x6f715,0x03e9c,
        0x60a65,0xb65e3,0xd087b,0x00008 } },
    /* 12 */
    { { 0xc1844,0x023fd,0xe2123,0xac56b,0xf105e,0xca27e,0x3486e,0xf168a,
        0x3a606,0xcb218,0x1d7a4,0x807de,0xe295f,0xf5d43,0x6327e,0x7246a,
        0x025c7,0x05c77,0xe1432,0x4e3ea,0xaf348,0xdfc7c,0x0754b,0xdf52c,
        0x39895,0xc0ec9,0x7a9ca,0x55f6d,0x082e6,0xaeddb,0xe208b,0x985df,
        0xde731,0xe4527,0x9c817,0xe1ea7,0xc313d,0xce0fb,0xcbb30,0xcc4f6,
        0x95b89,0xcd9df,0x5bb20,0xdf1ef,0x1f2ae,0x8cfb0,0xa891a,0xfc1e0,
        0xdb7ec,0x4a63e,0x25ed3,0x00002 },
      { 0xb1a85,0x4dbab,0xe1315,0x565a3,0x71e6a,0xd8dae,0x00fd3,0xab4b1,
        0x17d56,0x1ad32,0xbc78e,0x934ee,0x7d44d,0xe73d3,0x21b48,0x02153,
        0xe43cb,0xfa201,0xbc90b,0x0905b,0x02750,0x23f1d,0x1a13c,0xc8669,
        0xe5000,0x1c2a2,0x06584,0xbad26,0x008b2,0x026b6,0xcaf30,0x15d41,
        0x6ce61,0xf4527,0x712c2,0x2ffb1,0x71593,0xc4c3e,0xaf201,0x6a74c,
        0x4e13d,0xa4789,0xc0537,0xf5df0,0xe02d6,0xb1c97,0x602c2,0xa8fb7,
        0x87c7b,0xe5d08,0x12b60,0x00006 } },
    /* 13 */
    { { 0x45d6b,0xcfba2,0xfd495,0x3ff6e,0x7a2ce,0xf0cbb,0xeee5c,0xdff5f,
        0xa2ac0,0xa324d,0xf28c6,0x14f8c,0xb90c9,0x08a56,0x50d43,0x72fdb,
        0x72034,0x7913d,0x3dbf7,0xc9e90,0x1822a,0xa5ec9,0xe81cf,0x3aea3,
        0xe73c8,0x390dd,0x62891,0xa9626,0x3545b,0x6acbd,0x48bca,0xa52f6,
        0x0683a,0x6e98a,0xf6f27,0xed52f,0xca378,0x36d3a,0x1d925,0x885ac,
        0xc2c54,0xa7353,0x0bc84,0x52da0,0x7caff,0x68416,0x81c37,0x3971f,
        0x7986e,0xe1d2d,0xf7334,0x00000 },
      { 0x6067e,0x83659,0xfbb5c,0x9806a,0x938c1,0xe54e1,0xdcc33,0x39cb0,
        0x5d967,0xf9828,0x24035,0xf43d4,0x52b53,0xef909,0x1f8df,0x38c53,
        0xf571a,0xe4db0,0x0fbe8,0xa7879,0x2a39c,0x0c1ed,0x6209a,0x606f2,
        0xcc1d6,0x4a2fe,0x2b7cb,0x90b17,0x89dc8,0xbb786,0x6fbcc,0xc33ca,
        0x3ee49,0x82fe7,0x1b110,0x6c48d,0x7fcb6,0x0b7d1,0x57359,0x86e14,
        0x6b0a6,0x85935,0x53ead,0x82c40,0xb75d6,0x4d30f,0x5fac5,0xb2ae5,
        0xee949,0x72f8a,0x7636a,0x00006 } },
    /* 14 */
    { { 0xd6bea,0xbcb91,0x38063,0xcb966,0xe923e,0x263a2,0xca6ae,0xc627a,
        0xb0992,0x7e9d7,0x7af9e,0x001a7,0xbc6ed,0xaafeb,0xccf24,0x9214a,
        0x55a90,0x96780,0x3564b,0x499da,0xce027,0x999b1,0x6a500,0xe46a0,
        0x3a4e1,0xe7e41,0xe51ef,0x13f62,0xea05d,0xa843b,0xd349b,0x35e87,
        0x3159e,0x25318,0xa6338,0x19230,0xa5460,0x23e8b,0xcf260,0xb7fd1,
        0x07721,0x539b1,0xdf2fd,0x542bf,0x846b5,0x18af3,0x4f81c,0xb314f,
        0xc8965,0x7660a,0x86f98,0x00000 },
      { 0xb9850,0x548cb,0x67019,0x2c8c7,0x0a20d,0x10b73,0x70c62,0x53356,
        0x4d057,0xea408,0x324ba,0xc5950,0x43ecd,0x6ee9b,0x5f2c7,0x607fc,
        0xffa64,0x0f440,0x393d0,0x463cf,0x62dc1,0x11179,0x5e7e0,0x9c772,
        0xb8251,0x86f00,0xbd1d1,0x07365,0xc35e6,0xf72aa,0x54c2c,0xf3d85,
        0x3497d,0xdeefa,0x4dd0f,0xad11b,0xcf646,0x12268,0xeadd7,0x9f7b8,
        0x20afb,0xe507c,0xc06df,0x69d4f,0xa6309,0x45549,0xf1c72,0x76b7d,
        0xae810,0x03e61,0x81f94,0x00006 } },
    /* 15 */
    { { 0x0623b,0x63c9a,0xcad51,0xb8d47,0x767fa,0xf8295,0xc7cdb,0x81af7,
        0xab0ec,0xc22cc,0x966d5,0x38c8e,0xc469e,0xd4e41,0xd52f0,0x34430,
        0xb359c,0xa2a52,0x26075,0x01274,0x333bd,0x2dd3e,0x34124,0x9fed2,
        0x3f635,0xfacda,0x7d52f,0x3730d,0xf4df3,0x40c3e,0x6f076,0x5fff5,
        0xde57c,0x1c1bb,0x783c2,0xb3364,0xaeb8b,0x784a2,0x405d8,0xead08,
        0x7c533,0xd41ec,0x9b62b,0x1423f,0xf4b7f,0x75d4a,0x45c70,0x55431,
        0x0590a,0x4aba6,0xc9de9,0x00000 },
      { 0x5682b,0x3595d,0xed727,0x76ed8,0x32ec2,0x1c428,0x0d271,0x8b36a,
        0x4aed5,0x8fd1f,0x498a8,0x40c48,0x162ab,0x80f45,0xc6244,0x58c8f,
        0xcffe2,0x4bb79,0xbc8ca,0x359d8,0xc701a,0xab583,0x15d90,0x3fd5d,
        0x31a73,0x3caee,0x91233,0x597bc,0x202a5,0xc3e3c,0xae4b6,0x1019c,
        0x38088,0x2c299,0x51304,0x8199e,0xdf47c,0x00283,0xe920e,0xf2a00,
        0x68e58,0x3b90d,0x775ae,0xdf41a,0x269e2,0x1c30b,0xca587,0xb8d2e,
        0xde396,0x0ebb1,0x33dca,0x00007 } },
    /* 16 */
    { { 0x9213a,0xd04b5,0x5b495,0x200ef,0x98d70,0x67203,0x1c1ca,0x2b677,
        0xb09a6,0xcb4bc,0xb9eb0,0xeed42,0x226ad,0xdba21,0x7548c,0xeb544,
        0x890d1,0xcdf08,0xe1abf,0x46b40,0x3698e,0x50996,0x13852,0x82e9c,
        0xff0b0,0x71e1b,0x1099a,0xe4cd5,0x7a189,0xb91cc,0x9bcc9,0x2360c,
        0xec4be,0xdc137,0xbd4d7,0x9f6e9,0x1d151,0x35652,0x503d0,0xcf832,
        0xf6d78,0xb4bf5,0xdeea2,0x10318,0xce430,0x4c319,0x494ef,0xc3132,
        0xfa7d7,0x470f1,0xab3bd,0x00002 },
      { 0xc9fbb,0x80922,0x753b6,0xc6d15,0x80f16,0x9e7dc,0xefc86,0xbac16,
        0x45135,0x9b834,0x46d1d,0xa3b48,0x14326,0xd62c2,0xee3b2,0xb517f,
        0x92ad5,0xa20b2,0x905af,0xac136,0xa2cad,0x57131,0xa8d2a,0xebdbc,
        0x04d8f,0xb2cd9,0xf365f,0xa86f3,0xcdfed,0x7eaa1,0x208dc,0x7097b,
        0xe77c0,0x84a45,0x9a35a,0x118e8,0xccf5d,0x7a062,0x9e841,0x1f6e9,
        0xc04a8,0x7d3c0,0xa7a08,0x04b0b,0x2c447,0xa22ad,0x7d13e,0x6f8a2,
        0x7d229,0x164c2,0x3a4b4,0x00009 } },
    /* 17 */
    { { 0xefb7a,0xc11f1,0x4271b,0xcc0dd,0x633fc,0x4e68e,0x0a8ae,0xb11f5,
        0xbc8f1,0x899d9,0xf0760,0x398fa,0x35430,0x3d0e0,0x2fb44,0x45e24,
        0x3d4c1,0x19f6e,0x3ec25,0xad097,0x0ba9b,0x70f79,0x10fab,0xf9add,
        0x12ad5,0xb4de6,0x4e942,0xe54e1,0xab837,0xb8b68,0x6d3dd,0x175a5,
        0x2a408,0x3c1ac,0x85b23,0x0f94e,0x0f0c8,0xff6c3,0x4f9f8,0x898db,
        0xf3fb7,0xdd4b7,0x5a7dc,0x044f4,0x5a2c6,0x3d389,0x2f6fe,0xf3abb,
        0xe7763,0xd732e,0x42ce0,0x00003 },
      { 0x91b1f,0x94cf4,0xb2613,0xe395e,0x71909,0xaaeed,0xbeadc,0x9fe4d,
        0x4055a,0x4ddcc,0x93d60,0x611d4,0xf17a6,0xe5ebe,0xa3a1c,0xba445,
        0x89cb5,0x58e39,0x82e28,0x8406e,0x283f5,0x6f428,0xf55b9,0xa156c,
        0x77b99,0x0e998,0xe166a,0x6a664,0x3af90,0x976d1,0x353b2,0xcea1d,
        0x61a01,0x2736c,0xfc16f,0x5d86e,0x3b0f5,0x04c43,0xc01db,0x8eb34,
        0x4b269,0x803cb,0xae602,0x7f782,0x538d0,0xbe3ec,0xbcb43,0x43ac3,
        0x6fd20,0xf3e15,0x55f4a,0x00004 } },
    /* 18 */
    { { 0xec21c,0x62754,0x057f2,0xba38c,0x9e3a1,0xacd4c,0xfe93e,0x116c1,
        0x210d1,0xb63a0,0xacc8a,0x4e94e,0xae4ea,0x6f32c,0xc9aea,0x31c00,
        0x975ce,0x9d86b,0xcb623,0xa1e95,0xca14e,0x4d5d8,0xc8b65,0x5067f,
        0xd31f4,0xcb230,0x355fe,0x90cb6,0xe48bb,0x172e8,0xecedc,0x78f81,
        0x06737,0xa8cb0,0x88380,0xd0122,0x1e162,0xb02e0,0x45c19,0xc5af1,
        0x87a06,0x540e0,0x72dc3,0xc8b7b,0x6f04d,0xe3c06,0x2148d,0xf70ef,
        0x09fb7,0x43130,0xf1482,0x00004 },
      { 0x055e2,0xce6e2,0xe004f,0x20675,0xa86c3,0xe247e,0xaa289,0x5f9da,
        0xcbd95,0x3b4eb,0xeb7f6,0x212fc,0x0d15f,0x3784a,0xc1f86,0x5ecc5,
        0x60251,0x0b757,0x3b380,0x29545,0x38a6a,0x9301c,0xd19eb,0xa13cd,
        0x6ba18,0x240f1,0x87c2d,0xd2518,0x68313,0x9413f,0x5859a,0xf9923,
        0xfd7c5,0xe6fe3,0x23405,0xee054,0x416e0,0x8aeb3,0xab067,0x3fada,
        0xbe7bb,0x711f3,0x28844,0xfa2c8,0x67901,0x662ff,0xb304d,0xc950d,
        0x1170b,0xd43c0,0x4d5d2,0x00007 } },
    /* 19 */
    { { 0xbfe11,0xc02b5,0x3002d,0x21e7a,0xd52d3,0x33410,0xa8907,0x9679b,
        0x20f65,0x6e159,0x85b23,0x8c146,0x00e24,0x6f604,0x59434,0x8cfab,
        0x717f0,0xb740c,0xf57af,0x45769,0xc6604,0xbab28,0x2470d,0x9cdc3,
        0x09968,0x050fa,0x230ed,0x2ae2c,0x441e0,0x5bef7,0x554e4,0x0d961,
        0xd7b6f,0x82ce4,0x688a9,0xd22e9,0x75e62,0xdefac,0xa28fa,0xbd2cb,
        0x512a6,0x9faf1,0xe7c74,0x8e62b,0xb7886,0x9f5a6,0xd81ae,0x88048,
        0x57a29,0x42c58,0xb1a54,0x00006 },
      { 0x42066,0xad432,0xf5ab9,0xa2ae9,0x52ccc,0xfef1b,0xc4e0a,0x988ed,
        0x43ec7,0xd5b1b,0x341b0,0x00f10,0x70d0c,0x0aab3,0x8f7b5,0x4d68b,
        0x64a99,0x6ff3a,0xa8e4e,0x684e9,0xb7f1a,0x8338f,0xf5c19,0x351a0,
        0x0e748,0x158bc,0xac445,0xf2cdd,0xb2cac,0x9ff76,0x9995e,0xc14d3,
        0x93055,0x3f163,0x4a01b,0x83765,0x5888d,0xc3eea,0x7b16a,0x72327,
        0xd9a9a,0xbfb84,0x11dbb,0x2691e,0x89913,0xb6717,0x7aeab,0x59771,
        0x14ac8,0x268bb,0xc2135,0x00004 } },
    /* 20 */
    { { 0x32833,0xa6955,0xe6fe0,0xd0672,0xed626,0xca228,0x3bdab,0x649e7,
        0xef3d9,0x0c22a,0x03c4c,0xa87af,0x52083,0x169b4,0x75d35,0xe954e,
        0x06a89,0xee745,0x77509,0xcf905,0xe2aea,0xcb276,0xf9149,0xfa409,
        0x75d77,0xb9082,0x0bbd6,0x6f3df,0x461eb,0x13270,0x2cbe4,0x94820,
        0x498b1,0x21b1c,0x5f3fc,0xee593,0x8361f,0xc68ba,0x1f376,0x50e05,
        0xcbbd9,0x42a18,0x18e70,0xa8793,0xb2384,0xdd1e8,0xead80,0x292ab,
        0x7c334,0x295c3,0x5713c,0x00006 },
      { 0x77b9a,0xe9ceb,0xccca8,0x9469d,0x723b6,0x97e72,0xb282f,0xa01d6,
        0xabee6,0xfec76,0xabecd,0x203d5,0x03925,0x290d7,0x08229,0x89448,
        0x14438,0x24b03,0x99314,0x47c3f,0x17cd4,0x209df,0x82704,0xc855c,
        0xf2059,0x697c6,0x6c0e0,0x78625,0x4d97d,0x2d94c,0x6fe41,0x5a9db,
        0xc41dd,0x91994,0x9a645,0x21a31,0x1c89e,0x348aa,0xf0e12,0xc6a03,
        0x04b50,0xacd69,0x616fe,0x5156a,0xb55c1,0xc7693,0x1b57c,0x4e36d,
        0xe3c38,0x6c3ba,0xb0e99,0x00006 } },
    /* 21 */
    { { 0xced00,0xabcce,0x2789f,0xaa663,0xae5b7,0x37e71,0xcdf32,0x2ddeb,
        0x2e269,0x8f87b,0x61dad,0x5120b,0xcb724,0x5f803,0xe48d3,0xe11e5,
        0x50f0d,0xd798e,0xb4df5,0xab92f,0x4bcd2,0xee68b,0x63d60,0x1ce33,
        0xb2f5c,0x4798a,0xcd426,0x39da7,0xf15ba,0xf4fb3,0x2eb83,0x1a657,
        0xf08db,0x88e56,0xf77de,0x62c20,0xe1725,0x43761,0x0f417,0x8a58f,
        0x49ff8,0xe2be3,0x4d1d6,0xa71b8,0x4e04d,0x9ff3b,0x3429e,0x368f0,
        0x223f8,0x05678,0x022a2,0x00004 },
      { 0x47375,0x05838,0x27bbd,0x1af05,0x23f45,0xe56b6,0xf183a,0x4b2c7,
        0x8f24d,0x8d619,0x525b9,0x3f5b4,0x5ee32,0x0884b,0x39a0e,0xa9d8d,
        0x2c776,0xf6fb1,0x005d7,0xc154d,0xe708b,0x1c483,0x1bcd7,0x74254,
        0x6fd28,0xdb8ca,0x8397d,0xdccdf,0x30af3,0xccf24,0x1253e,0xb80d3,
        0x81b8d,0x0858d,0x743a1,0x1f68c,0x17139,0x48eb2,0x57f3f,0x33bb6,
        0xaff88,0x31493,0x7e47e,0xed660,0x61d15,0x8279f,0xb11e0,0x10159,
        0x6a956,0xcb24a,0x12179,0x00003 } },
    /* 22 */
    { { 0x15ac2,0xca076,0x94cc3,0xd581a,0x4121a,0x865e6,0xb7985,0xa7986,
        0x7616f,0x1dae4,0xd5e0f,0x40eb9,0xa395a,0x9457e,0x2643d,0xa9143,
        0x865d9,0xa3fa2,0xde6d6,0xae8c8,0x61014,0x71db9,0x7cb07,0x976a8,
        0x7cce6,0x6077a,0x43a0f,0x42e11,0x4a7de,0x93d93,0xc09d9,0xe203c,
        0xc4c3d,0x9398e,0x20186,0xdf4b9,0x83a25,0x7546d,0xd6bd7,0x62b02,
        0x9eb47,0x890ad,0x05a71,0xf208d,0xbfaaa,0x1221b,0x81f43,0x52381,
        0x511ea,0x78733,0x17d6c,0x00004 },
      { 0x1e9a8,0xb70e9,0xcbd81,0xd6b33,0x8c370,0x34041,0x37373,0x8eaa2,
        0xdb10a,0x56825,0xc7d67,0x09e46,0xd8f2b,0xc33de,0xe9b94,0xe288e,
        0x5e3fb,0xbb169,0xd8426,0xe888c,0x6dce9,0x176c8,0x362a6,0x6165e,
        0xc8922,0x093f4,0x063fb,0x411f6,0xc514e,0xf9e04,0xc20c8,0x6907a,
        0x2ad61,0x9cdfd,0xef746,0x199ac,0x48452,0x30bae,0x462ba,0x12ac3,
        0x81293,0x2d306,0x92d48,0xe873c,0x5011b,0x33099,0xf89e8,0xff4cb,
        0x70a0a,0x52d14,0x2189d,0x00000 } },
    /* 23 */
    { { 0x99c69,0xdd925,0x3e419,0x32ca7,0xb7fec,0x94221,0xbfd5b,0x09bbf,
        0xf9bd2,0x5bb2b,0x3ed89,0x97a46,0x961ea,0x486f7,0x46b3f,0x66091,
        0x41a39,0x05fd1,0xd1c7a,0x4135b,0xf83d6,0x9ec8c,0x07bc7,0x98835,
        0xfd42f,0x277f8,0x7b3d0,0x53b71,0x1afcb,0xca5a2,0xdcd67,0x86658,
        0x49786,0xaccd1,0x6a6c0,0x5067a,0xe34b9,0xf3d70,0x58c16,0xdf449,
        0x208e3,0x12371,0xc2802,0x64e6e,0x1d2dd,0x782c7,0x4ab30,0x33b2c,
        0x176fa,0xbd521,0xbbf8a,0x00007 },
      { 0xb981a,0xafa78,0xe9e4a,0xc828b,0x6304e,0x8b4e3,0xea378,0x3959d,
        0x5cf39,0xc70c4,0x40b39,0xbdd32,0xd70a9,0x383b7,0x7dd28,0x499cd,
        0xa1026,0x2e307,0x0690b,0xf1b33,0x8ee92,0x62d59,0xa4822,0xb4725,
        0xd77de,0x0ec62,0xbc3aa,0x25bc7,0xaa16f,0x5ef7f,0xb65d1,0x62dd8,
        0x6d68f,0x1d0b9,0x97922,0x1906d,0x3a00f,0x2885c,0x740b9,0xeb74c,
        0x76b9b,0x22fa4,0x75762,0xdbb5c,0xf217d,0x88504,0xc3057,0xc2782,
        0x2716b,0x6cf81,0x60d09,0x00008 } },
    /* 24 */
    { { 0x9bbf9,0x7d4d7,0xebc33,0x4f80f,0x869f7,0x53eab,0xd535d,0x33104,
        0x6a095,0x97ff3,0x96f8b,0x20da1,0x92ab8,0xce690,0xd1f75,0x961d3,
        0x83754,0x04046,0x197ec,0xcb9bb,0xf93a6,0x8ce1b,0x1a3a6,0xc5f02,
        0x456ff,0xdb503,0x940ff,0x2db18,0x9b50a,0x00420,0xf8fef,0x77c50,
        0x65875,0x77049,0x635d1,0x770ad,0x98bb8,0x5766d,0x53e72,0xa078e,
        0x9b028,0x788e1,0x9fc83,0x4ccaf,0x0364d,0xdd39a,0x411f0,0x1a3df,
        0xdf920,0x4203a,0xe80e4,0x00007 },
      { 0xa1ddf,0x57539,0xb5f8a,0x65624,0xeee48,0x48e7a,0x1e1d2,0x81602,
        0xb491d,0xc41c7,0xd36d2,0x871bf,0x92e7b,0xec00d,0x5040a,0xda38b,
        0x3f1b3,0x12619,0x28276,0x78d6f,0x6fb1f,0xc3fe8,0xc3369,0xe827a,
        0x8b786,0xf756c,0x487c8,0xf6c73,0xc1687,0xdee5b,0x21719,0xab8f2,
        0x99418,0x3fff3,0x4e847,0x7c800,0x4a902,0x84c01,0xe28f3,0xaa1d2,
        0x7be9a,0xf1996,0x065ee,0x86d3e,0xc8696,0xbd837,0xb08c7,0x737c6,
        0xbd863,0xd19e8,0xdcab5,0x00005 } },
    /* 25 */
    { { 0xd772b,0x3a9a7,0x78428,0x959b0,0x5e540,0x49e52,0xab56b,0x86414,
        0xbb008,0xa9546,0xd74b2,0x81629,0xbd444,0x3b0b1,0x0ad20,0x26789,
        0x3f86b,0xbcc8d,0xe7a82,0x83c71,0x5d85a,0x52bfb,0xccf13,0xfad07,
        0xf16e3,0x3ff29,0x1e0c4,0x63b84,0xfc02a,0x379fe,0x2c56b,0x904f2,
        0x44f26,0x53b12,0x9d8a6,0xbdea1,0xf3a28,0x35b6d,0x5ce66,0xf6d45,
        0x68851,0x3518b,0xcff37,0x28189,0xb74ac,0x2cbda,0x9df8b,0xad40f,
        0x9d498,0x9eadc,0x8cc2d,0x00000 },
      { 0x0c84b,0x66c17,0xe6a68,0xa4842,0xb5a49,0x989e8,0x992bb,0xd04c8,
        0xe00e0,0x237b0,0x1b3a4,0x34786,0x955ad,0xd0189,0x450b0,0x3c952,
        0x00cb3,0x55e31,0x39221,0x76d0e,0xef032,0x265b6,0xb5319,0x76d42,
        0x8595a,0xb60fe,0xc6353,0xdee0f,0xe0a96,0x6f893,0xdc824,0x761e0,
        0x74cba,0xbef0a,0xec902,0xad9b4,0x43fdf,0x00868,0x97561,0x4fdb6,
        0xa60e4,0x0a5d6,0xef759,0xaac87,0x73f53,0x870a3,0xbe012,0xd29e6,
        0xa55b0,0xc155a,0x91fad,0x00009 } },
    /* 26 */
    { { 0x44ffe,0x0fb48,0x2bc4b,0xb8718,0x460f8,0x92271,0x1f373,0x4ce3f,
        0x000e2,0xec8ac,0x63519,0x48b41,0xff0d5,0x288b5,0x42b88,0x7aaf8,
        0xc9a70,0x4c2bd,0xe8b0c,0xfd679,0x24ba5,0x6d515,0xec3a0,0xf93cd,
        0x1afa0,0xf0d0b,0xf89f8,0x55bad,0x22809,0xa32c9,0x92dee,0x86cbe,
        0x05be4,0x993fe,0xcae3f,0x19aa0,0x5fa69,0x60709,0xb8bf2,0x6e0f1,
        0x4741e,0x880f5,0x0ecf9,0x1f743,0x72aed,0x4991d,0x76b73,0x9296f,
        0xf0fe9,0x28259,0x6cf8d,0x00006 },
      { 0xf5868,0x5b226,0xb0190,0x9e9e9,0xc1690,0x02e88,0xb54c1,0x4a37e,
        0x08916,0x232bd,0x98163,0x53e8c,0xcf722,0xbac53,0xe9d86,0x37f84,
        0xaaaf7,0x54afe,0xe3524,0x046e2,0x72ca0,0xc86f7,0x72e67,0x66633,
        0xce50e,0x0486b,0x6950a,0xa960b,0x3f6a3,0x1aba9,0x4d7fc,0x61f99,
        0x26e6e,0x2bc13,0x957c1,0xb0051,0x42e56,0x658fe,0x40c9b,0x85927,
        0x297fc,0xa59cd,0x77f26,0xce9b1,0xb7654,0x9d2eb,0x9dba7,0xaaa69,
        0xb6448,0x5a0ec,0xfca0c,0x00005 } },
    /* 27 */
    { { 0xa6663,0xf3569,0x26e25,0x4ca7e,0x7e6aa,0x597ee,0x80c09,0x8d18b,
        0x4cda6,0x3025a,0x29267,0x02b52,0x94506,0x38720,0x65007,0x9af5f,
        0x33a53,0x34267,0xeeedb,0x2951f,0x88657,0x5ce76,0xe9a0f,0x8398a,
        0xa360b,0xc3872,0xb30f6,0x7a802,0x86034,0x16215,0xb231a,0xd2113,
        0xc6dec,0x92ee6,0xfd9cf,0xf9e66,0x85cbc,0xf0a5a,0xe8485,0x2ba3f,
        0x5a6e4,0x27d7a,0x1ecd7,0x67205,0x0aafe,0x081a1,0xbb2a2,0xe09c6,
        0x3b0b4,0xf0b97,0x57acb,0x00006 },
      { 0x4c8d4,0x6fc27,0x13046,0x94d13,0x630a9,0x76517,0x35f42,0x70794,
        0x258ca,0x06217,0xb897a,0x0406e,0x04485,0x1ee13,0xeee56,0xf38df,
        0x778bb,0xcfaa1,0x1f4fa,0xb9e91,0x7b9ab,0x5c661,0x93276,0xd8f10,
        0x5499b,0x59b13,0x73b91,0x6337a,0xac0eb,0x7e8b6,0xcf16f,0xf2c1c,
        0xdef53,0x3a187,0xb32c0,0x9c625,0x9830b,0xad1d4,0x53889,0x2f10e,
        0x5eae3,0xbc173,0xd5f55,0xd9c29,0xdb1cb,0x39db0,0xc47e5,0x42428,
        0x2b3bb,0x12c85,0xd2da4,0x00003 } },
    /* 28 */
    { { 0xf2865,0x6e871,0x7702b,0x20d69,0xf1429,0xcb639,0x61156,0x45b58,
        0x522a0,0x12328,0x3b138,0x3ad1f,0x8f394,0x2206e,0x00a71,0xe6c22,
        0xd59ea,0x5aa34,0x2890e,0xf759c,0x0f6b7,0x52fd4,0x567ab,0x180bf,
        0x2c8de,0x96f52,0xccee3,0x97b2a,0xb181e,0xea5cb,0x819c4,0xe0375,
        0x1d3ef,0xe8ab5,0xd9985,0x0fd80,0xabcb5,0x6c96c,0x80de2,0x97e1c,
        0xd6b13,0x7dfb9,0x79635,0x1814f,0xb582b,0xf4c7f,0x22107,0x89a78,
        0x57e61,0x2dc03,0x2aeef,0x00000 },
      { 0xec9be,0x6f2c7,0xba792,0xb2012,0xe7258,0x2f307,0xb4a29,0xc6fa6,
        0x62a10,0xab74e,0x2bcc5,0x8549e,0x380c0,0xb8c07,0xdb87b,0xb4160,
        0xf194d,0x29329,0x5ef05,0x4a9cd,0x46dda,0xb8da1,0x3d10e,0x15ea2,
        0xd43d2,0xae0b5,0xc34bf,0xef02f,0x76ceb,0x8757a,0x4d084,0xacd36,
        0x4cca3,0x682d3,0x14013,0x95e2c,0x21d2d,0xca674,0xa2809,0x786ea,
        0xd1d6e,0xecc3f,0x2965f,0x136da,0x39eb1,0x77920,0xbaac0,0x48871,
        0x5aeb0,0x014b1,0xb446c,0x00006 } },
    /* 29 */
    { { 0x8fe80,0x2e25e,0x819eb,0x8a17c,0x69823,0x5f790,0x8492b,0x81e41,
        0x1e996,0x45d6f,0x8ea6d,0x8ad69,0x058ad,0xd02e4,0xad4bf,0x5bae5,
        0x2416d,0x27a81,0x16dc3,0x7ca10,0x5a334,0x31a98,0x3918b,0x82a65,
        0xda610,0xfb0b4,0x48c35,0x1b2db,0x41cb9,0xaaf8c,0x17cd2,0x9e968,
        0xdcdc0,0x83cdf,0xa6304,0x92541,0x112b6,0x55936,0x09770,0xf8a2a,
        0xcd712,0x815fd,0x5cc52,0x623a3,0x559ab,0x2b609,0xbe093,0x30c8e,
        0xe052f,0x4bb08,0x61342,0x00008 },
      { 0x31d8a,0x63b22,0x89020,0x16672,0x9d9a6,0xf6232,0xf27b0,0x071a9,
        0xa0fe7,0x7eaaf,0x03f04,0x89606,0x36bcd,0x92a1c,0xa76fd,0x118cc,
        0x483b6,0x2b71d,0x414e6,0x52623,0xdba70,0x23ccd,0xc5aa1,0xfd9b5,
        0x76437,0xa31a5,0xc8d0f,0x1bc24,0xda530,0x2427c,0xd4410,0x96f0a,
        0xa6c02,0xe0d3a,0xe6fb5,0x39960,0x0072a,0x8c488,0xfadcd,0x840d3,
        0xfca12,0x414da,0xe91d5,0xca3dd,0xd29f4,0x41734,0x59884,0x0037c,
        0xfe57c,0x999cc,0x6333a,0x00008 } },
    /* 30 */
    { { 0x53b40,0x51ecf,0x213a7,0xa542d,0x22f78,0xf2c6f,0x56dcf,0xf13ae,
        0x9f0e2,0x8e0f5,0xe6174,0xccbf0,0x591f8,0x2c414,0xcb9d7,0x0aade,
        0xcdcb7,0x524c9,0xb2ed8,0xfc706,0xc1eaf,0x00b72,0x1028e,0xaa728,
        0x24285,0xfa89b,0x679ca,0xa7e0b,0xfaa7e,0x0a6f6,0xc264f,0x5d2b8,
        0x04397,0x730e8,0xed7b1,0x30497,0x5c857,0x93eb4,0x93e5a,0x0986e,
        0xbf5d4,0xafc92,0xa20c0,0x5a9c6,0xf526b,0x9dc3a,0x7c9b9,0x0adf4,
        0x02cc9,0xe2ba2,0x2b25f,0x00001 },
      { 0xea395,0x8a33e,0x9b8d7,0xfc5c0,0x8f633,0xa9361,0xeefc7,0x270ec,
        0x21629,0x0c7e8,0x628ed,0x79b8c,0x95247,0xd6893,0xca1a1,0x91db5,
        0xedc90,0x8e586,0x626e1,0xf3bf8,0xbfeb3,0x023e8,0x71cfe,0x02501,
        0x9fde1,0xde627,0x5e172,0xc7dc5,0x5e52e,0xd4ca4,0x695c6,0x445e8,
        0xc10f1,0x78bdb,0x2de38,0x835e4,0x86fc3,0x114de,0x6522b,0x7e10b,
        0xba456,0xfe9fa,0x90e78,0xd82a3,0xa4111,0xdf0ac,0x1c2ae,0x576b6,
        0xccb74,0xa974a,0x16279,0x00002 } },
    /* 31 */
    { { 0x7f747,0xbf404,0x14cda,0x5a1ec,0xdc131,0xca233,0x0a703,0x40e5d,
        0x7cbd3,0x6959e,0xb4138,0xc4e9b,0x81fd0,0x01fbd,0x8b10f,0x189d0,
        0xb823d,0x42a76,0x0449c,0x00a15,0x1398b,0xc224a,0x9e481,0x8e817,
        0x84e4f,0xe9080,0x98e41,0xf9946,0xefd8a,0x10bf2,0x37c56,0x1e30e,
        0x2790f,0x3fa7d,0xe6a04,0x53884,0xcb319,0x96e60,0xdfd9d,0x03799,
        0xf986d,0x2fe75,0x8ff90,0x8f11f,0xe3b4a,0x88416,0x37875,0xfa945,
        0x7535e,0x3f982,0x0683e,0x00002 },
      { 0x78878,0x26d03,0xb582e,0x5787c,0x3a794,0x214c2,0x8b39e,0x8f668,
        0x000bf,0x7013d,0x05152,0xd4f54,0xd7548,0x111f5,0x15d40,0x7113c,
        0xff902,0x26a8b,0xbf5a5,0x45cc3,0x09b49,0xa6b01,0xa05bd,0xbc2f3,
        0xcc74e,0xa183d,0x3efdf,0x62844,0x42aef,0x5c5bf,0xee956,0xd2e60,
        0xf243a,0x0d592,0xf0fa1,0xbf514,0x21bc3,0xe58b3,0xa746a,0x60576,
        0xb0868,0x1a813,0xd7308,0x23f84,0x90bc0,0xdcee5,0xaa032,0x9fd03,
        0x6c795,0xf527d,0xe416b,0x00005 } },
    /* 32 */
    { { 0xcc23c,0x60026,0x43137,0x90582,0xeb5b2,0x19aae,0xe17f8,0xc5d2e,
        0x272f8,0x02a92,0xe5cc4,0xe7cbe,0xd8048,0xdef07,0x6ee77,0xdbc7d,
        0xf821e,0x44f6a,0x1d692,0xbb896,0xd996c,0x7966e,0x5a45f,0x96a15,
        0xb17ea,0x56f81,0x3f3ed,0xef700,0x2b2d9,0x82a5b,0x906e8,0x5e6e5,
        0x47180,0x72ae9,0x6fa10,0x76f48,0x1658c,0xd9fc5,0xaa034,0xcb035,
        0x03dc0,0x819f6,0x5be64,0x9feb7,0xfb7b3,0x04a9e,0x54acf,0xca875,
        0x4fde3,0xec87b,0xff682,0x00004 },
      { 0x10ad5,0x7fd0a,0x12562,0x6f453,0x2968e,0xd45c7,0x1637f,0x806a1,
        0x1bd6b,0xe3298,0xe5033,0xe1cdd,0x8b92d,0x4f898,0x45ebf,0x3b44b,
        0x7e1dc,0x96dae,0xa1b98,0xd878c,0xa0778,0x166e5,0x84752,0xa5116,
        0x472be,0x4582d,0x28954,0x382af,0x9fbdd,0x6ec4c,0x6025d,0x22ed1,
        0x52b02,0x1cb65,0x614eb,0x210f3,0x3a1e6,0xc5df7,0x4a763,0x021a7,
        0x60285,0x4de91,0x65cbd,0xa400c,0x9a44c,0x15e29,0x87e0f,0x48cb1,
        0x2507c,0x8e340,0x1eb81,0x00005 } },
    /* 33 */
    { { 0x100ab,0x78b92,0xfc1d1,0xb8391,0x09605,0x2e3d6,0x9d0df,0xb71e5,
        0x7c255,0x0412a,0x4fcbe,0x66751,0xf3f8b,0xfd06a,0x93559,0x0e8a3,
        0x20d07,0x02120,0x63265,0x7be55,0x1528e,0x96fcd,0x65466,0x0c7b7,
        0x8514b,0xb5658,0x912a5,0x0f8c5,0xf0cd8,0x24cb7,0xf04f3,0x8bafe,
        0xa3d75,0xcfc6d,0xb53ee,0xdf2f6,0x831d1,0xef48d,0xb6ded,0x73812,
        0x6b965,0x31f33,0xe6260,0xae4ae,0xbc82e,0x44f09,0xd32d2,0x300ab,
        0x9647f,0x5531d,0xb0af9,0x00008 },
      { 0x03544,0x0a2e6,0x77018,0xcd9eb,0x3221a,0x573ac,0x0322b,0x62407,
        0x7f665,0x3d3a1,0x89abc,0x74adb,0xaad3e,0x93225,0xe3ad7,0x8a3d2,
        0x2564b,0x04ef0,0x57bba,0xd2b54,0xffc2d,0x75652,0x3e888,0xe6714,
        0x05d15,0x70d29,0x2e48d,0x4b420,0x76d88,0x636a5,0x219c7,0x06f99,
        0x378df,0x2135e,0x8dc34,0x4a02a,0xd10c6,0xc1d73,0xa6695,0xcc157,
        0xa4ece,0x54cd6,0xe24a3,0xc1c88,0xdbadc,0x39329,0x1b298,0x8024f,
        0x48ad0,0x494da,0x363e5,0x00005 } },
    /* 34 */
    { { 0xfc641,0xb7e23,0xf5523,0x70631,0xf8666,0x54e72,0xd2ffe,0x8e009,
        0xa15f5,0xe1294,0xc57f5,0x997f8,0xcf203,0x6d64d,0x24cb1,0xa2297,
        0xa2ffb,0xfd4ba,0x97be4,0x8ed66,0x60a6e,0x507e4,0x5363f,0x78508,
        0xe3a5d,0x080af,0x54082,0x6cdd9,0xceeef,0xc4237,0x889f2,0x701fd,
        0x85253,0x3a5c3,0x96d88,0x12f14,0xd72a2,0x5c67e,0xfcde2,0x1ff78,
        0x16783,0x464b4,0x16f41,0x7004c,0x7e996,0x5b069,0x3a1c4,0xfa45c,
        0xd30c3,0x183fb,0x33340,0x00006 },
      { 0xbbbce,0xcca2f,0x9c9a0,0xb7443,0xcaa0c,0x6f6e5,0xce387,0x3438e,
        0x6010e,0x829ce,0x3802d,0x148e1,0xb0aad,0xd45a1,0xc609c,0x9c3e5,
        0xfc1e0,0x597bc,0x75cb8,0x4dd08,0x0d858,0x9ff79,0xa2bb1,0xd81c2,
        0x8b81e,0xe3259,0x2be07,0xdf2f0,0x9118b,0x765ce,0x8eeb9,0x074fc,
        0xf95ae,0x88b24,0x25e9d,0xf09d1,0xc0c98,0xb12cd,0xb273b,0xa0b74,
        0xaee07,0xce4a6,0x08077,0xd2f9c,0xf4723,0xa8026,0x7d6be,0x95944,
        0x80b73,0x5c162,0x3a707,0x00009 } },
    /* 35 */
    { { 0xb27f9,0xe2715,0x6bbef,0x09232,0x22a28,0x35a5e,0x26aa9,0xfd58a,
        0xf23af,0x945dd,0xc1386,0x3e167,0x354c8,0x2a215,0xbc989,0x44799,
        0xd09f5,0x109b8,0xe6e47,0xea684,0x6d588,0x3af61,0x1b6c6,0x883ab,
        0x96706,0x365e8,0xd2093,0x93a03,0xa3c13,0xc23dd,0x92192,0xd02f2,
        0x6ea43,0x7adcf,0xb70cb,0x59e1a,0x87915,0x434ea,0xf0b12,0x6d70f,
        0x680db,0x45040,0x832ba,0xfe522,0xf1a10,0xf0cb8,0xc08e5,0xd69f9,
        0x141fd,0xac44b,0xa7422,0x00001 },
      { 0x0b675,0x2e9f4,0x3a9dd,0x1f39c,0x3fcc7,0x7c660,0x3422a,0x1948e,
        0x39a61,0x84189,0xd0ab4,0x6158e,0xb8f3b,0x31ca6,0xd97ee,0xa3aa7,
        0x8db63,0x5ef7a,0xc1e86,0x62e4b,0x92c7c,0x5f8c0,0xd0f31,0x9f5c6,
        0x0788f,0xc5a26,0xb6f3e,0x31294,0x9b183,0xb4d84,0xcd636,0x73adb,
        0x99a9b,0x90bc6,0x6e148,0x75e76,0x82a11,0x3790d,0xa4fbf,0xfc53c,
        0x3605a,0x917f4,0x7ff60,0x6c478,0x6577f,0x0c82b,0x55260,0x827c7,
        0x5599c,0x309d2,0x944d6,0x00000 } },
    /* 36 */
    { { 0xb9620,0x3ee6a,0xfdeb6,0xd808c,0xd786c,0xf4fa6,0x0b3df,0x45632,
        0xedd82,0x15145,0x49439,0xf862c,0x72ae5,0x3b3f8,0x813b7,0x9508e,
        0xf97a9,0xf3e52,0xbd805,0x9b623,0x8c982,0x1b5c2,0xefcf7,0x86e0c,
        0x4c70e,0x6eb39,0x3bdb3,0xb1a92,0xa534f,0xe27e5,0x862db,0xd64f5,
        0xb6169,0xf383a,0xae23d,0x28cbb,0x127c8,0x6df1b,0xa8add,0x3a307,
        0x1899f,0x66190,0x11ddf,0x86598,0x736cc,0x943b7,0x77479,0xa3cb7,
        0x86576,0x836fd,0xd89f3,0x00007 },
      { 0x92b2b,0x42c9f,0x85642,0x32bdf,0x5c46e,0x0c6a7,0x5c570,0x7f99a,
        0x768b7,0x6893e,0x31495,0xe8580,0x9b6ef,0xce670,0xa19c2,0xbbfe8,
        0xec493,0x1bee6,0x21a3b,0xc28d7,0x9c371,0xeeeea,0xe1d26,0x15177,
        0x8115e,0xa5d79,0x068a5,0x3bceb,0x2d7bf,0xd2b4b,0x22046,0xdf8da,
        0xe9dfc,0x5b59b,0xdf099,0x0b793,0xc7764,0x6897b,0x3c5c9,0x5a2bd,
        0xcf4c2,0x44ce0,0x9afe7,0x5d6e8,0xb16f4,0x8509b,0xacb3a,0xb53f3,
        0x2a6e6,0x1f63f,0x49af8,0x00004 } },
    /* 37 */
    { { 0xd9377,0x32a16,0x2fcf1,0x2f9ec,0x37e1a,0xb377b,0xae59a,0x86d19,
        0x1a12e,0xb172e,0x013bb,0x2e66d,0xad2b1,0x5f66b,0x055cb,0x0972e,
        0xeab50,0xc0399,0x11de1,0x5ec2d,0xdc65f,0xf314f,0x593c1,0x8a9ff,
        0x11841,0xe6fc3,0x05246,0xc1ece,0xddf73,0x25056,0x36316,0xc28d1,
        0x25e19,0xd76fb,0x0a9db,0xd2d73,0x4845c,0x9ed24,0x52d04,0xd36e8,
        0x9b83f,0x83c77,0x68c8a,0x5fc7f,0x385a3,0x5e803,0x1e1c9,0x299bf,
        0x91af5,0xc3208,0xe8617,0x00000 },
      { 0x81b5c,0x0267c,0x37206,0x873c5,0xde737,0xa89dc,0xfd02f,0xa8144,
        0x430b0,0x832a7,0x6208c,0xc5a72,0x53006,0xea40f,0x660d8,0x4e066,
        0x413a4,0xf9896,0xdd025,0x149f9,0xc46b9,0xf380c,0xcc2bd,0x0a125,
        0x56619,0x37801,0x2793c,0xa3b75,0x204d6,0x7a62f,0x3746b,0xb6001,
        0xd5978,0x68585,0x9cfe2,0xfe66a,0x88395,0xad0cb,0x1f6dc,0x46b26,
        0x468fc,0x18bab,0xd9d92,0xf5ef9,0x2ca0e,0x45240,0x4a85e,0xc507d,
        0xcf687,0xf1326,0xf4404,0x00006 } },
    /* 38 */
    { { 0xbd3ff,0x0b4fe,0x3e192,0x2bbaa,0x8fdfd,0x6234d,0x829ca,0xe19a9,
        0x1af2a,0x20b7d,0x6f5bc,0x1610c,0x923de,0xa39ca,0xbf3da,0xe204d,
        0xc70ab,0xb86d8,0xa2de9,0x370b2,0x77c9d,0x2e0c3,0x10e27,0xe5655,
        0x14c06,0xb0809,0x7cbb6,0xe7a85,0xeb611,0x266a6,0x6efd8,0x076fc,
        0x5801c,0xee309,0xfac34,0x4063d,0x2b9e2,0xff40a,0x5c569,0x787aa,
        0xa31a9,0xd2a7b,0x3c70c,0x1fdf3,0x40e4d,0x95f07,0x13268,0x903e3,
        0x671e2,0xf87fb,0x05771,0x00009 },
      { 0x62bee,0x0da40,0x199ba,0xd9f95,0xc94d7,0xe7238,0x2c018,0x1e092,
        0xf29bc,0x5ff53,0x12d85,0x2a81b,0x9de9b,0x68ca2,0xeed6d,0x649f3,
        0xc097f,0x34c50,0x4adfc,0x98a06,0x99db3,0x964ab,0x22481,0x7a587,
        0x59c47,0x3a00d,0x4c590,0xa3967,0x009fe,0x043dd,0x8ee15,0x6aafd,
        0xecc20,0x6e5f1,0x5721a,0xb7b4c,0x30db9,0xd6a48,0x52ab6,0x66c8d,
        0xfc617,0x2706f,0xcc82a,0x41d6a,0x83de2,0xf2f7a,0x05227,0x0605f,
        0x4decc,0x3b640,0xa2295,0x00006 } },
    /* 39 */
    { { 0xce389,0x8f74f,0x2452d,0x55649,0x02afa,0x9634c,0x82505,0xf0ed7,
        0x7ccbb,0x0d937,0x7718e,0x045b3,0xd89f4,0xa69a4,0xe7d9f,0x11074,
        0x5b0ba,0x07729,0xd70bb,0xede65,0xdf107,0x2d54a,0xc7bb2,0xa1a29,
        0x9a3d8,0xab5c3,0x795e3,0x6c02d,0x13723,0x58995,0xd002b,0xf7282,
        0x0bee2,0xbe579,0xe2265,0x5ea25,0x1a8e6,0xe0ea1,0xebd91,0x6001c,
        0x1a708,0x020e7,0xc1c54,0x0f5a2,0x11690,0x7f698,0x5c035,0xc3b2d,
        0xe3427,0xa0619,0x28c9e,0x00005 },
      { 0x6c577,0xb45f2,0xedc86,0xbd451,0x89438,0x07470,0x2a7f8,0x79258,
        0xe1013,0x9f2df,0xe1e56,0xaca0d,0x6e08e,0x55a35,0xefa9a,0x5f952,
        0x76216,0x53e49,0x4d80b,0x71f2a,0x5cd5d,0xb6585,0x3f0d2,0x66cea,
        0x704bf,0xca246,0x92323,0x641f4,0x5193f,0xdb132,0x55c9a,0xa6818,
        0x9d652,0xce2d1,0x6d522,0xed7b8,0x05b82,0x609f1,0xd2953,0x8e150,
        0xf0094,0x913b0,0xb13e8,0x8bfb0,0x923ad,0x94b44,0x56cf7,0xcbb15,
        0xbcf57,0x93738,0x00f90,0x00002 } },
    /* 40 */
    { { 0x8387f,0xc5838,0x9b22f,0x83c5f,0x028e8,0x26f17,0x73ccf,0xd1b79,
        0xcab90,0x71447,0x6ec91,0x4ea2f,0x08d5d,0x0cdbc,0x498c3,0x2e16f,
        0x23c2b,0x0c486,0xc9291,0xc545d,0x030db,0x1491b,0x1b0eb,0x14de2,
        0xdeb2e,0xf4631,0xfe830,0x10662,0xf04a2,0x9c1f3,0x79c37,0xa4c69,
        0x6a795,0x68fb0,0xa732b,0xdfa98,0xa1619,0x44327,0xc9b3a,0x8dbe2,
        0x307d3,0xea91a,0x3989f,0xc8d20,0xf939b,0x4a331,0xaf20f,0x3daab,
        0xf55dc,0x98dd0,0xc307e,0x00005 },
      { 0x233da,0xc435b,0xbc4e0,0xf985b,0x522f6,0xd2908,0x468e3,0xa8b02,
        0xd2d21,0xe799d,0x96916,0x40e9a,0xd978f,0x4bcce,0x86c61,0x0327d,
        0x0762c,0x02b29,0x5e955,0xf2ed9,0x7a879,0xfd219,0xd330f,0x50e0b,
        0x65137,0xc4c43,0x827c4,0x148a0,0x226c3,0xcfc0b,0x2a83f,0xc7981,
        0x28589,0x7e319,0x3d8d1,0xf42dc,0xe8830,0x572cf,0x83f8b,0x4b07f,
        0x9ff92,0x8f7cd,0xa5114,0xa9500,0xc331c,0x59f9a,0x9684c,0xd0c53,
        0x34785,0xfac14,0xdf16d,0x00001 } },
    /* 41 */
    { { 0xcacc3,0xac68b,0xc7bb4,0x58cfc,0xf430f,0xded34,0x55a06,0xd4618,
        0xf9f4f,0xbcc59,0x5c9f0,0x19944,0x2f549,0x75c89,0xec643,0xdc5f7,
        0x5983a,0xf13c8,0xb8708,0xd0871,0x482fc,0x2a5cc,0xc0fb3,0x2d6b4,
        0xcdc35,0x2defd,0xac6fb,0x4f048,0x14bb2,0x90647,0x4f533,0x5982d,
        0xa3ac4,0x2fb83,0x62eb5,0xa2231,0x82337,0x30df2,0xbd371,0xcbc3d,
        0x7b802,0x0edce,0x467ac,0x59592,0xe8b39,0x56717,0x2e81b,0x21d3d,
        0x12617,0x50465,0x29a7f,0x00007 },
      { 0x0f90a,0xaa842,0x74ed1,0xc8558,0xe0fe4,0x68e19,0x4af63,0xb0be7,
        0xd4aaa,0xa9b62,0xca60c,0xc4808,0x776fc,0x45a86,0x5a576,0xf310b,
        0x1b24c,0x9bddb,0x31bac,0x5b441,0xd2dea,0x77d71,0x64eef,0x72fcc,
        0x6d210,0xf0470,0x73d77,0x26916,0x329b9,0x9e066,0xbf3e8,0x22e00,
        0x77d40,0xd3740,0x72d0c,0x32e24,0xd8292,0x21040,0x5333e,0x38dc8,
        0x16dfb,0x672f9,0x4b8f6,0xb59b1,0xd48bb,0x4be19,0xf4ad4,0x19de9,
        0xd9d5c,0x49232,0xf6d36,0x00007 } },
    /* 42 */
    { { 0x94819,0xde6e7,0xbd064,0xbda13,0xef82e,0x6b694,0x8045a,0xb91e2,
        0x17fe0,0xd21f0,0x7a43c,0x31f30,0x9190d,0x0433e,0x22663,0x6c26f,
        0xfdcb4,0xa70ab,0xa488a,0x11c0b,0x5a464,0x8d908,0x88041,0xbffb5,
        0x34fe6,0x491b9,0x200f8,0xe237e,0xb75d1,0x5413d,0x63fa5,0xdf04d,
        0xb3f77,0x75e23,0x216ed,0xbd30e,0xb0f91,0x5866c,0x509a0,0x7729c,
        0x395d9,0xd784c,0x52ab2,0xe1884,0x6ec97,0x93d68,0x1f900,0x8cb7c,
        0xf086c,0x95628,0xd0323,0x00002 },
      { 0x4b4c5,0x074a4,0x81c94,0x2c98a,0x9cc70,0x84687,0xc97b9,0xceb0d,
        0x02287,0x21cb5,0xe3aa3,0x11266,0x23030,0xc256c,0x763e4,0xc0ac8,
        0xb4845,0x20e55,0x5034d,0xf35b6,0x0f240,0x96a04,0xedcaa,0x7cf7e,
        0xd26d3,0x56046,0xb8106,0xa8e13,0xb62a5,0xd70c2,0xb9783,0x86044,
        0x4da8f,0x8859e,0xfbaff,0xf5d12,0xa5457,0x9d901,0x75792,0xb531b,
        0xe1eb2,0x39d29,0xe4e97,0xabdc9,0x9214d,0xaa9bd,0x4fc4e,0x5bd72,
        0x9bb9b,0xb31ef,0x34c12,0x00007 } },
    /* 43 */
    { { 0x9b086,0x2e92f,0x8fe3c,0x45449,0xeb3fd,0x41b93,0x65c46,0x5c02c,
        0xe208b,0x4247c,0x4f032,0xdca1c,0x68a52,0x9d29f,0x7d967,0xb5ec1,
        0x6f5f4,0xd0940,0x1d2fe,0xa8111,0xc0d9b,0x0f63d,0xa3f26,0x15472,
        0xb056f,0xe6de2,0x07290,0x0d9f0,0x91b17,0xb5c8f,0xe8db6,0xa2e23,
        0x4c3ee,0x39cf3,0x45a28,0x3ee23,0x11b97,0xdc546,0x1c59b,0xbb24d,
        0xda6c2,0xa165b,0xc6141,0x2ba33,0x197d5,0x2eb20,0x6129d,0x47bb1,
        0xbe49f,0x8721f,0xc558a,0x00007 },
      { 0x50fec,0x523f3,0x9485a,0xd4c0b,0x56a38,0x6678c,0x64d01,0x0d5aa,
        0x346a2,0xe48ef,0x96da2,0xaa02d,0xcb85d,0x647b3,0x4ea4f,0x845ec,
        0xe946c,0xca0d5,0x0d1a6,0xf4abc,0x14fa9,0xd8d1c,0x30341,0x9c8b1,
        0x72cc5,0xfb439,0x34ffb,0xf48d4,0x867e1,0x9d231,0x93a81,0x350ce,
        0xef23f,0x906dd,0x9f530,0xf12c4,0x9200c,0x2e6cf,0x2fc3c,0x64043,
        0x91cc1,0x52426,0x2496b,0x74b47,0xebfff,0x0a97b,0xc9f02,0x44527,
        0xc4348,0xca7b3,0x4cd7d,0x00003 } },
    /* 44 */
    { { 0x7fe87,0x1a59e,0x03176,0xcd72f,0xa0047,0xeae31,0xf62b1,0xfae30,
        0x02e68,0x43279,0x71db1,0xf48db,0x4a666,0x0038f,0x6780e,0x75ee6,
        0xdd76d,0x6702b,0xb45ac,0xcd5c3,0x8a0d6,0x2fb82,0xb110d,0x9d8c5,
        0xe7f1d,0x9627c,0x20b5e,0xe0e41,0x7141f,0x267c3,0x984b9,0x95a1b,
        0x312cd,0x89d60,0x206e5,0x93565,0xeda54,0x67342,0x4ac18,0x070c7,
        0x520b9,0xb3374,0x557b0,0xcbb59,0x42703,0xed8c1,0x59ca6,0xf621f,
        0x7b887,0xc2abf,0xceb1c,0x00007 },
      { 0xfd65b,0xbbdb7,0x647a5,0x457c0,0x036c9,0xd45cc,0x18ad8,0x9e127,
        0xa99db,0xb1c6d,0x93a7f,0xbbf4e,0x1ed1d,0x1566a,0x95cbd,0x4512c,
        0x0c919,0x00dbc,0x861ba,0x52694,0x89e7f,0x6cc29,0xaae3c,0x0941a,
        0x96150,0xe3671,0x8c538,0x5d0fc,0xfbfcf,0x5a551,0x929a2,0xad6e9,
        0xa0f26,0x8517c,0x07109,0xef7e9,0xafa89,0x3b78e,0x54974,0x71ab4,
        0x5ea31,0x6d39d,0x6d1c3,0xf3f3e,0xd7442,0x9d568,0x3e005,0x25a68,
        0xced5c,0x99227,0xf629a,0x00001 } },
    /* 45 */
    { { 0xa1c3e,0xace45,0x925dd,0x545f8,0x541f7,0xd2936,0x82872,0x37e7f,
        0x22fcb,0xd2456,0xe4c79,0x45133,0x68823,0x2645d,0xf849c,0x5dffa,
        0x802b9,0xdd994,0x078f4,0x9fa03,0x09d33,0x6927f,0xdcc56,0x9fd91,
        0x00a1e,0xd79a5,0xab0ab,0x81800,0xfce00,0x94e5d,0x5a381,0xd9713,
        0xdf088,0x0798a,0xe8763,0xa2a79,0x89a45,0xaf01b,0x3993b,0x788b4,
        0xd6154,0x7d6fe,0x77a99,0x5722e,0xd980e,0x378ee,0xffa2a,0xaac90,
        0x805a2,0xa28bd,0xa75fd,0x00004 },
      { 0x74cbc,0xbb55e,0x09a8f,0x8f25d,0xefab1,0x7738c,0xc3a73,0x9764e,
        0x23ad6,0x310fc,0x7e0ad,0xd35be,0xbc5a7,0x81cc9,0x68ee4,0xe75e0,
        0xaec34,0x993d4,0x0c2ea,0x63c4f,0x80d4a,0x324fe,0x92cf1,0x99b05,
        0xb7c16,0x6b5db,0x7e0f4,0x674da,0xa442d,0x00fae,0x6c7a3,0x5a5d6,
        0x3ac83,0x21333,0x83dc8,0x8496e,0xe8c40,0xef812,0xfc170,0x99ef5,
        0x1dcb6,0x6296e,0x734e8,0x771b1,0x86e2b,0x3507d,0xcdc58,0x04629,
        0x8179a,0xae23d,0x819f9,0x00005 } },
    /* 46 */
    { { 0x78811,0x216aa,0x99691,0xe7c3d,0x42103,0x4ee8f,0x698f6,0x22b9e,
        0x01070,0xdeddf,0xf582c,0x1f9e4,0xae600,0xcfac1,0x8af2e,0x24a60,
        0x93009,0x84063,0xef4c7,0x29116,0x6ebf7,0x62eae,0x5a052,0x8c4ee,
        0xd0af5,0xc7ddb,0xcd87b,0xff90e,0x4875a,0x24f11,0x34c6f,0x2fddb,
        0x5f172,0x81e86,0x81042,0x1b9a4,0x6886c,0x69242,0x31f95,0x9ef42,
        0xf3208,0x2e6f5,0x0a7e8,0x7acfd,0x8af58,0xc395c,0x9179a,0xd6571,
        0x4a750,0x3c136,0x45960,0x00007 },
      { 0xae519,0xbff41,0xc2475,0xf2511,0x14af8,0x401fb,0xc3d34,0xaefb2,
        0xdfcd2,0x0870d,0x1cdaf,0x385b5,0x99b2d,0x08bb1,0x25682,0x8531c,
        0x3f3f6,0xf64c3,0x6c89d,0x17691,0x92457,0x3cfa9,0x0bac2,0x86d01,
        0x9b51e,0x13233,0x26383,0x0e8d2,0x708db,0xfedeb,0x17900,0xf769e,
        0x87ef1,0xcba36,0xfd96d,0x64753,0x39147,0x046b2,0x8ddcd,0x0c45c,
        0xf2064,0x78f3f,0x8343d,0x67bdb,0x0efd1,0x77ee9,0xb6d4b,0x493cc,
        0xf7b45,0x13b3c,0x30255,0x00003 } },
    /* 47 */
    { { 0xaaca1,0x6935e,0x6f004,0x91023,0x58911,0x384b7,0x54c0c,0xe6d29,
        0x75665,0xd7cb3,0x1e9d6,0x99b9b,0x7cb91,0x9c275,0x349c2,0x75852,
        0x738d0,0xbab8e,0x9cbd1,0xa4278,0x05923,0x8dbe9,0x8899b,0x18fe1,
        0x7793e,0x83a23,0x742e0,0x1757a,0x3a427,0xebd61,0x9d24e,0x8c497,
        0x2cf77,0x54d4f,0x03250,0x05de4,0x19587,0xb8a09,0x9baa3,0x33d99,
        0x91bd9,0x1e1b1,0xb0fee,0xfba43,0x4bafe,0xacdf1,0x1843f,0xb3bad,
        0x7561c,0xb0438,0x328ad,0x00009 },
      { 0x6b872,0x80f90,0xbe84e,0x2665a,0x07826,0x5523a,0xcf770,0x3398c,
        0xc6a7e,0x23d89,0x55b53,0x551df,0x82fab,0x54dea,0xeca05,0xa0578,
        0x589cd,0x3d375,0xf2652,0xd750e,0x2864a,0xfd624,0x1fed8,0x178fe,
        0x27fc5,0x2293f,0xdf874,0x6f309,0x47b3e,0x50d05,0x49e37,0x2862e,
        0x038a1,0xb25dc,0xd90c6,0x682b7,0x284db,0xa1ae2,0x30ac1,0x98819,
        0x3dab7,0xa447f,0xaf3e0,0xbd52b,0x530e6,0x2d25c,0x25bf6,0x06800,
        0x0d5e7,0xcfadd,0xaa1f3,0x00000 } },
    /* 48 */
    { { 0x10453,0x9022a,0x98221,0xa10ba,0xc2a03,0x1eb91,0xf3bdd,0x96646,
        0xb5d95,0xc6afb,0x38b6f,0xe344f,0xda58d,0xcfca1,0x3e5b8,0xce47c,
        0x0da04,0x6d0f7,0xcd8e1,0x2ed6f,0xbda26,0x44349,0xf8eac,0xc56e2,
        0x0d87b,0x58932,0x9138e,0xea081,0x09ce3,0xb236c,0xdffa2,0xa5862,
        0xefb0d,0x5c8e7,0xb0f9a,0x78eb6,0xb16ac,0x53432,0x1af4b,0x709b5,
        0x43105,0x286ff,0xf5196,0x36f88,0xd08e2,0xd403a,0x176ee,0x1f93f,
        0x6545e,0xe0963,0x59337,0x00005 },
      { 0xd807a,0x38d8f,0x0ddf7,0x12223,0xdab13,0xe0ec9,0xbc3f4,0x625af,
        0x2f4db,0x9514a,0xf12f8,0x06049,0xdd5b7,0x3044f,0xc23ac,0xb46f3,
        0x0148f,0x1ff54,0xb232d,0xe5541,0x539b4,0xb458f,0xb7561,0x0dd70,
        0x4b24a,0xd9f69,0x89581,0x42992,0xd0fc6,0x5fe22,0x9beee,0xc05d4,
        0x8bf63,0x7f6a1,0xaf344,0x29d67,0x27f19,0x6a1dc,0xe8ce9,0xc1551,
        0xe6028,0xa26af,0xb5d4f,0xcaf32,0x427da,0x5c2cb,0x1bc54,0x4a163,
        0x914d3,0xf9b0c,0x30070,0x00009 } },
    /* 49 */
    { { 0x9bc05,0x5e69a,0x2f32c,0x4b73d,0x6589c,0x5c19c,0xf9c0a,0x94665,
        0xc9e5e,0x39095,0xcfb4c,0xf293b,0x18ab0,0xdb7c3,0x8771d,0xb9070,
        0x38048,0x5866b,0x94e96,0xd9bd8,0xf606b,0x9a90c,0xd69f1,0xb6fd2,
        0xd58df,0x69cc1,0x61d8a,0xcc4e4,0x1886d,0xce483,0x277f9,0xc455c,
        0xf8a82,0x96765,0x49a59,0xdc8d7,0xcc3ba,0xfc668,0xdab2f,0x9112c,
        0x18396,0xcb380,0x243c7,0x95c3b,0x4a987,0x0a222,0x31001,0x8775f,
        0xb5e14,0x41587,0x43a21,0x00000 },
      { 0x73752,0xbc3a8,0xbbe9d,0x2fee7,0x42f44,0x1493f,0x181ee,0xc18c2,
        0xca2c8,0xe7981,0x29769,0x3090e,0xf00ce,0x768c5,0xac8de,0xb4626,
        0x7677e,0x4634d,0x3e9ce,0x94e63,0xde0fa,0x9c2ca,0x5bff8,0x41f5b,
        0x5cc11,0x2c04f,0x228c1,0xf7362,0x52565,0x05cce,0x06a0c,0xf1bf7,
        0x87c4f,0xffbe4,0xd07ff,0xf1a45,0x9a499,0xc43c0,0x8003e,0x98d94,
        0xe79bb,0xf84f4,0x73f12,0x5a160,0xd8a33,0x970d6,0xaf70f,0x4bb5e,
        0xd0ae8,0x7bf24,0x8d074,0x00001 } },
    /* 50 */
    { { 0x01faf,0x7c846,0x8d3c7,0x1f725,0x2af1c,0x465be,0x806c9,0xd116d,
        0x26798,0x3cff6,0x5b0d9,0xc0c6d,0xa3996,0xc6723,0xd755e,0x2fa1a,
        0xa5349,0x4403b,0x66a81,0x4d8a9,0x22ac3,0x4c942,0x865dc,0xed675,
        0x471de,0x8fddf,0x53d52,0xa5979,0xdd8ac,0xebf67,0x3b524,0xb2e46,
        0x5b4d3,0x717e2,0x58248,0x9daa2,0xa4315,0xc5adb,0x54023,0x83357,
        0x8f9c6,0xa6545,0x938b1,0x5da7f,0x1cf68,0xfed23,0xfdace,0x981a4,
        0xb5e59,0xed08b,0x11093,0x00007 },
      { 0xf161a,0xc6401,0x2aa3f,0x5e871,0x0974c,0x35856,0xf82f7,0x17b5d,
        0x252fb,0x994aa,0x48e62,0x2b07a,0xdb0b8,0xdd847,0x15729,0x00234,
        0x9c5a6,0x00452,0x1e54d,0xf538f,0xe6d98,0x1c539,0xbcbcc,0x28d3a,
        0x62b53,0xcd361,0xa84f0,0x79382,0x475a3,0xee748,0x81b4d,0xf717a,
        0x3bf1b,0xfb4c2,0x6cf35,0x8b3e1,0xf787e,0xd1c29,0xab07f,0x59b79,
        0xa7e68,0x0bb7d,0x5f6c6,0x00a08,0x50721,0xed48b,0x159e7,0x31840,
        0xc97d4,0xda4d9,0x7898b,0x00001 } },
    /* 51 */
    { { 0xb8cf8,0xd8ae1,0xd8483,0x8856c,0x2e9a2,0x3d4b4,0xbc232,0x204a4,
        0x3584f,0xfa763,0xa7a69,0x2228c,0x24e0b,0x57bab,0xa8bf7,0x8afbd,
        0x5f9ca,0x886cc,0x5b240,0x95c38,0x3d41a,0xfb481,0xe6b47,0xc2aab,
        0xbc53c,0x9d3f1,0xad159,0xda3f1,0x1f22c,0x1ea9b,0x081c3,0x1b2ec,
        0x14ac1,0x4b016,0x48f30,0xa7ab0,0x9c6af,0x31cee,0xc3dce,0x4140d,
        0xf7633,0xba55a,0xce8ab,0xab37d,0xe84b7,0xcf3ef,0x648c7,0x50de7,
        0x56ab2,0xcf153,0x3a88d,0x00007 },
      { 0x83b39,0x8806e,0xf8682,0x037d3,0x39f44,0x7a441,0x84147,0x17dbc,
        0x58b0f,0x49f90,0x4d175,0x4f4f5,0xe2db6,0x307ff,0xa6af2,0xa23ce,
        0x26261,0x554f1,0x93efd,0x7f263,0xa10f3,0x4e658,0xe352f,0xf4ee1,
        0x37ce3,0x8ba44,0x93cde,0x42a7a,0x164ef,0x9aa90,0x9f493,0x1debc,
        0xb5cd4,0x6a3d7,0x4223d,0x3acc4,0x1f88a,0x9a6a1,0xa2d78,0x2c608,
        0xb9df8,0x0656f,0xbf56c,0xb8e3b,0x0e79d,0x8fa30,0xaf266,0x73c56,
        0x96a1e,0x17ae3,0x2f32b,0x00005 } },
    /* 52 */
    { { 0x4f71a,0xc1e71,0x6f524,0x85195,0x29add,0xbe126,0xbe3c1,0x65cad,
        0x189d8,0x49ad9,0xa0fb6,0xf5c85,0x9d88b,0xd192d,0xa9221,0x9efa6,
        0x24b6f,0x896f7,0x3fe83,0x119ce,0x4b250,0x3fae2,0x3c0ec,0x2ae0d,
        0xaf9f6,0x4d4b6,0x61962,0xba0bd,0xa8fce,0xdb6e3,0x92b2f,0x7dc30,
        0x3cd29,0x76326,0x91da3,0x43bdc,0xef95c,0xc0761,0x4d930,0xcdeb4,
        0x36400,0x1d891,0x3c0d3,0xce844,0xffd7d,0x71899,0x3b198,0x78fec,
        0xf58c1,0x28efd,0x9e14d,0x00007 },
      { 0x40c55,0x359bb,0x38222,0x7a42e,0xd0ed0,0x27202,0x1f40a,0x4838c,
        0x6c1a9,0x8e48e,0x864a7,0x24a7d,0x92b5f,0x6c55c,0x40a0c,0x7e7f1,
        0x2d508,0x4ace1,0x62c10,0x1e10e,0xec11b,0x0a1a7,0xdd59b,0xafbb3,
        0xa275f,0x30fd8,0xa3b6b,0x54fe9,0x1dff3,0x602a0,0xd9e46,0x5a105,
        0xb65f7,0x4d93b,0xd371b,0xfdeb3,0xb0f82,0x5cbf0,0x545da,0xde468,
        0x1229b,0x7e460,0x73d51,0x10b9c,0x2505e,0x2ff49,0x54167,0x77cfa,
        0x66ce2,0x8a995,0xd8ec2,0x00000 } },
    /* 53 */
    { { 0xee995,0x3ecbe,0x14cf7,0xe80c0,0xcd491,0xeb88b,0x5d4b2,0xd9aba,
        0xa6cad,0x4d615,0x304c8,0x46339,0xa2f7d,0xb03c9,0x1d28a,0xba050,
        0xabb94,0xde91b,0x8f723,0x5772c,0x75040,0x85f97,0x094c8,0xc7fcb,
        0x1d2b3,0x1ab5e,0xf96c7,0x7995d,0xe61ee,0x64499,0xaab34,0xb8c8d,
        0x07932,0xdd5f6,0xb425d,0x3587d,0x1b124,0x251ca,0x34070,0x9fc74,
        0x7d3be,0x8926d,0x902ac,0x9310c,0xf8c17,0x59a74,0xc1545,0x72522,
        0x34afc,0x27c37,0x6001e,0x00008 },
      { 0x93947,0xa5e76,0x3b00b,0x062b1,0xe012c,0x78641,0x0a864,0xe8549,
        0x438e0,0x5ee1a,0x9574d,0xdbbfd,0x15173,0xd3ba6,0xb8c9b,0x9532e,
        0xea075,0xb85f3,0xf41bc,0x92b91,0x78cbb,0x1cc24,0x1b4ac,0x1ef90,
        0x4648e,0xee0f3,0x2b3b2,0x9d1ed,0xcdd92,0xd75bf,0xeabc3,0x470f1,
        0xcf4d2,0xf7139,0xcdbc6,0x49535,0xdf042,0x86454,0x383cd,0x47fcb,
        0x79812,0x0c1e0,0x7df93,0x09b41,0x0b9f2,0x4ebc0,0xc3111,0x4225f,
        0x946c1,0xcb347,0x20591,0x00000 } },
    /* 54 */
    { { 0xe0af4,0x21275,0x30037,0x4a4be,0xfe78a,0x1141e,0x48572,0xd1757,
        0xcfcf6,0x9e666,0x68e65,0xd7371,0xe5fa1,0x2842e,0xe540e,0x263e3,
        0xbd5f6,0xd4948,0xdecc3,0x104aa,0xd246b,0x9de03,0x81801,0xf343d,
        0x9e903,0x31f8a,0xb0c0d,0xba4a5,0xfcb57,0xe2765,0x50651,0x8246c,
        0x9bf67,0x1f651,0x0c575,0x9a018,0x0f211,0x05c20,0x4f45f,0x7821d,
        0x487b8,0x067e6,0x61c3a,0x94aa2,0x2262f,0x14605,0x48972,0x56cfe,
        0xf05ef,0x5fa1d,0x11998,0x00005 },
      { 0x586c0,0x7db18,0x81949,0xaa625,0x6c6ee,0x4415d,0x28b00,0x97cda,
        0xa46b6,0x947c6,0xc1945,0x9b287,0x69a14,0xd3a50,0x9fa4e,0xb5636,
        0x94cb4,0x6643c,0x092aa,0xeee27,0xaa9e9,0xbce73,0x50955,0x77893,
        0xb2870,0x2634b,0x6eb53,0x5fb00,0x58af9,0x38f48,0x32396,0x87cd0,
        0x75bf8,0x685ba,0x93762,0xd5812,0xd9d42,0x2d6f3,0x64df3,0x65c6d,
        0xad574,0x41a4c,0x2cded,0x50fbb,0x7985f,0x06a06,0xe0e90,0xcf34c,
        0x57f9a,0x6558a,0x9eaf2,0x00005 } },
    /* 55 */
    { { 0x3876f,0xfb6ec,0xb407e,0x86487,0x3f0f4,0x0c612,0x03978,0xbf893,
        0xb56ff,0xb02ab,0x5a91a,0xeaa04,0x29592,0x811b8,0x4d778,0xce5b8,
        0xf3fc9,0x341f9,0x6a71a,0xe13b8,0x6f0e7,0x7fdd8,0x880c1,0x655a0,
        0xd8297,0x6688e,0x1d5e6,0xdc748,0x775d6,0x17179,0xdf61d,0xeffc9,
        0x79e1f,0x8de3f,0x6ad4c,0x192e3,0xd2046,0x15317,0xa62db,0x274fd,
        0x9fa7a,0x1478c,0x2dd99,0x924f8,0xc04ec,0x64971,0xe383a,0x059d1,
        0x0bbfb,0xea262,0xb4450,0x00003 },
      { 0x6dcdb,0x55c77,0xdb7a9,0xba473,0xc81c8,0xc4a57,0x0fb35,0x50576,
        0x85003,0x53ae2,0x3aec3,0x0691b,0x5e3e8,0x117be,0x5be47,0x38033,
        0xccf61,0x3a056,0x1c47e,0x7916e,0xb3397,0x3cfde,0xee125,0xf5cb7,
        0xcdfba,0x043de,0xcf4b7,0x794f7,0x2f3c9,0xf8146,0x80c9f,0x24016,
        0xdaa9f,0x11be3,0xe440e,0x1d8a4,0x769f9,0xd0437,0xc5dc5,0xcb5e9,
        0x6c7a8,0x4d410,0x3b7d2,0x09a13,0x21919,0x64b4a,0x83837,0xe893c,
        0x9b614,0x0cc42,0xa7fe3,0x00004 } },
    /* 56 */
    { { 0x5c7c5,0x70245,0x78f3a,0x7754e,0x87015,0x7636e,0x62c5b,0x76232,
        0xc4524,0xc7f32,0xbc780,0xb11e1,0x72c98,0x5ed87,0xeac91,0xd48ea,
        0x265f4,0xc0199,0xb04d3,0x200fb,0xbcfa5,0x52b19,0xfe86b,0x93ea3,
        0xa0981,0x59c46,0xa7580,0x733db,0xcd82c,0x96aac,0xbd618,0xd324b,
        0xecd51,0xfcce8,0xc09a2,0x44b3a,0xd02fc,0x9918f,0x84b52,0xaaa17,
        0x45e4a,0x5cf0c,0xe2208,0x6340f,0x13562,0x0c7d6,0x676c5,0x53cbb,
        0x26b23,0xa3651,0x3fa1e,0x00008 },
      { 0xcc646,0xda10c,0x0ac86,0x51e96,0xf7b04,0xe0637,0x6102c,0x8a088,
        0xcf630,0x82bbb,0x03499,0x90192,0x023c1,0x0bcda,0x39cfc,0x707fc,
        0x4fd7d,0x151bd,0xf4d1f,0x3bbb7,0x44471,0xa64e7,0xe60d6,0xc5ac9,
        0xdc676,0x6957b,0x7b611,0x53033,0xd456c,0xf40a1,0x396dc,0xd3451,
        0x7d2c7,0x25499,0x3edec,0xa739f,0x4c2c4,0x4ae9a,0x2e253,0x6a6ad,
        0x1397e,0x81140,0x3e95f,0x9d4d2,0xf2076,0x98fab,0x7c6de,0xcee00,
        0xc51e0,0x79931,0x14097,0x00006 } },
    /* 57 */
    { { 0x56623,0xdb151,0xddb32,0x67c23,0xcab7a,0x137fb,0x3c268,0x6f19e,
        0x11f50,0x61260,0x9924c,0x8b028,0xc3421,0x804c1,0xb0fc6,0x492a0,
        0xae6a7,0x06afa,0x65be7,0xbe61d,0xe0d01,0x13d23,0xc693b,0xf87f4,
        0x45b47,0xa3445,0x4dc1a,0x36e20,0xcd422,0x5161e,0x61d3c,0x61352,
        0x8bc07,0x63bd8,0xeb46a,0xd7201,0x61599,0xc6d83,0x0f378,0x69baf,
        0x55fe1,0x20f69,0x70728,0xebd61,0xa467e,0x3a340,0xa2a3e,0x2f1b8,
        0xb5f88,0x762d0,0x36dac,0x00006 },
      { 0x80af3,0xb9b4c,0x4280d,0x92ab9,0x14e38,0x189cd,0xddc9a,0xd1477,
        0x702e0,0x4f26e,0x8f9f1,0xee386,0x2e91a,0xbaa0b,0x63a80,0x2864f,
        0x14a29,0x738b7,0xcd81f,0x7cb6a,0x0c5fe,0xe1b87,0x7fd30,0xb1083,
        0xea1c3,0x9f883,0xb2048,0x79536,0xf2da2,0xa2da5,0xa6858,0x3aeb2,
        0x8fa14,0xf203a,0x2330b,0xb1c4e,0x5dc70,0xc488b,0x8f4b5,0x29967,
        0x8c4d9,0x5c0a7,0x5df67,0xd0982,0x8233b,0x67d36,0x0767b,0x37b5c,
        0xbef3f,0xfe4d0,0xf6dbd,0x00002 } },
    /* 58 */
    { { 0xda7c7,0xfd2e4,0xf8472,0x79322,0x1ae67,0x8cfc9,0x8e270,0x3dc26,
        0xaf08a,0x24364,0x99a24,0xdfe07,0xf0f10,0xd58bf,0xd5871,0xef912,
        0x962e6,0xfc988,0xbf35d,0xea0a6,0x95f47,0xb96fa,0x8c128,0xaad30,
        0xa79ea,0xba734,0xf437b,0x03379,0x59573,0xf54f7,0xd8e6c,0x002cb,
        0x32eec,0xcfe76,0x7606d,0x31044,0xb5319,0x4b5ec,0x29d40,0x0acf7,
        0x0897c,0xde0ae,0xbddf1,0x8b863,0x88962,0x7d744,0x54ef8,0xeced1,
        0xd5d4e,0x97458,0xcb6e1,0x00005 },
      { 0xc75ed,0x97008,0x8cef1,0xaaf89,0xef6ee,0xf49d3,0x96d7c,0x1875e,
        0xf9e02,0x8a1d6,0xd9b0d,0x2cfed,0xafcec,0x576da,0xcfeb9,0x38a61,
        0x7dbb8,0x3936a,0x0003f,0x14f41,0x823b8,0x7c386,0x153b3,0xb80e3,
        0x66dcb,0xa89fb,0x59847,0x2eba0,0x09e7e,0xa7277,0x3fd35,0xa4ec6,
        0xe0ed0,0x91fc9,0x11f3d,0xbaa43,0x4d515,0x1dc09,0x4e33c,0xa08cd,
        0x06ebc,0xaa75a,0xed5ee,0x72382,0xfab61,0xf52c1,0xbb0e1,0x2e82b,
        0x5d6e5,0x30517,0x149d6,0x00002 } },
    /* 59 */
    { { 0x311f6,0x6f5f9,0xe1a8e,0x1f85e,0xfbabc,0x7e3c9,0x09ac9,0xb4942,
        0x7c52e,0xe14fa,0x9774f,0xf51c1,0xf04c2,0x55844,0x12285,0x5cefd,
        0x73ab3,0xa3b58,0x53862,0x19fcb,0x6cbed,0x8efdd,0x69a76,0xee584,
        0x12479,0x9ccdc,0xd80c0,0x7e313,0xc1123,0x44c28,0x290c0,0xdd74a,
        0x7e287,0x7abd4,0xee651,0xfeef9,0x8ad0f,0x42122,0x81fc2,0x818d2,
        0x3088f,0xe1427,0x3ec0d,0x44bc4,0x3ebc7,0x15bd7,0xccfb4,0x5b26e,
        0x7c26c,0x50cb0,0x4e2f3,0x00001 },
      { 0x6946b,0x10421,0x48d2a,0xd92d5,0x77a4b,0x801f0,0x1606e,0x43695,
        0x6d0a3,0xc9599,0x3a197,0x5c2f6,0x90f1b,0x1f77c,0xc4f06,0x79da3,
        0xf7b22,0x3493f,0xc1cd6,0x123f1,0x0a234,0x61b65,0x33c5e,0xf2840,
        0xb34c5,0x14826,0x2f342,0x90e8c,0x5718b,0x806ec,0x620ae,0xa5f35,
        0x4a9b4,0x45e32,0x2fae3,0xcb51a,0xe8b53,0x0bb95,0x7788c,0xf9965,
        0xf6ac2,0x32c94,0xb9def,0x607d6,0x707ec,0xed8f2,0xdbad0,0x63bf1,
        0x61e4f,0x02dcb,0x8537e,0x00005 } },
    /* 60 */
    { { 0x80ba2,0x6464f,0xf64b0,0xa45b1,0x70559,0xe055e,0x634e8,0xf1f4b,
        0x62b34,0x82c32,0xe8c84,0x7d5fd,0xaef4f,0x0c780,0xea0c3,0x9d55d,
        0x1e693,0xb9cfa,0x740af,0xc34b1,0x67460,0xfe6a6,0x1ee2c,0x1187c,
        0x95941,0x94f66,0xf974d,0xf2775,0xb1382,0x4549e,0xce400,0x1ca0a,
        0xded02,0x3fbab,0x8244b,0x53eaf,0x64e36,0x6f4d0,0xf83c3,0xc55c5,
        0x9f0dc,0x90eab,0xcebce,0x9cefa,0x5d93b,0x06142,0xe7219,0x16658,
        0x7970d,0x5f82d,0x85783,0x00004 },
      { 0x76210,0xbcd25,0xcd525,0x5443d,0x7d51b,0x378aa,0x9949f,0x1bd83,
        0x7bf17,0x21fe9,0x38ac6,0x0f63f,0xc930d,0x8408c,0xc1781,0xaf8f2,
        0xf53f6,0x7e260,0x692c8,0x75e42,0x7db0a,0xe4540,0xb370e,0xffdb1,
        0x47ae5,0x4b0ec,0xaa6a4,0x29dc7,0xd7691,0x40b75,0x2b22e,0xb6f93,
        0xf3b77,0xd095e,0x06764,0x63e8e,0x568bc,0xfd47f,0x4c028,0x9c001,
        0x10494,0x8ed18,0x7995d,0xd3fdd,0xf90e2,0x2a85a,0x05d6c,0xeb39a,
        0xf3128,0xbda21,0xc0277,0x00006 } },
    /* 61 */
    { { 0x9e7ef,0x86b50,0x41b70,0x9f91e,0xb3d7f,0x42ec7,0x88b88,0x5526b,
        0x85f94,0xabcd2,0x51dd0,0xe0640,0xb6e44,0x4f1ce,0xc1077,0x90198,
        0xe661b,0x98123,0xecabe,0x47d96,0x632f6,0x81113,0xaee44,0x26c52,
        0x82b45,0xd51dd,0x39dc9,0x907f9,0xfd650,0xd455b,0xef2fc,0xbd5ee,
        0xe5d7c,0xdd8d2,0x815a4,0x9f2a7,0x288bc,0xd4ec9,0x3225a,0x57a3b,
        0x10d0b,0xdbc6f,0x0b9cb,0xc1e72,0x8e8d0,0x774ee,0x71a9b,0x5a0b0,
        0xfcf8f,0x9af22,0x067bc,0x00003 },
      { 0xa9326,0xf2b7c,0x0e589,0x4f63e,0xdb122,0xa106f,0x7bd17,0x747a5,
        0x54521,0x2eb23,0x2b088,0x982d6,0xf2614,0x91ffc,0x54443,0x7f3af,
        0xe440d,0x7ba84,0xaaa33,0xb0711,0x0941b,0xea37b,0xf5428,0x2e4a7,
        0x7dcb4,0xfba95,0xa6ad5,0x662c1,0x0e7ab,0xc36a2,0x381f7,0xd135e,
        0xa0b6b,0x0c9ba,0x2e798,0x671f4,0xc94e4,0x37030,0x2e342,0x8b092,
        0xc63ff,0x9f24c,0x45a58,0x52794,0xcd10d,0x70ff6,0x316a8,0xbb99d,
        0x6c195,0xcaa99,0x90c83,0x00003 } },
    /* 62 */
    { { 0x4a73f,0x82ffc,0x0d3fa,0x33035,0x53bd5,0x65d63,0x77d26,0x264bb,
        0x06f8a,0x8480a,0x2d73d,0x4a6e2,0xa81c0,0x23b8a,0xff503,0x2409c,
        0xc4d5a,0x178c4,0x1dce2,0x9c193,0xe0c0f,0x4aa80,0xbb837,0x00186,
        0x5a387,0x7f0b2,0xaf148,0x7a10a,0x1d0b7,0x498de,0xad5ab,0x15f39,
        0x0c116,0xa61aa,0x2e32d,0x5ce89,0xd96e2,0x8e3db,0x6d122,0x5e864,
        0xc88dc,0x68b57,0x67b1c,0x11642,0x5672b,0x0bdec,0x07f60,0x5d0d8,
        0xe573a,0x7d223,0xea400,0x00003 },
      { 0x5d0a3,0xd0a59,0x76deb,0xb3b4d,0xbaff0,0xbd76c,0xb97a6,0x9b1bd,
        0xc154f,0x71bf2,0xc714c,0x9ab44,0x362b1,0x1af66,0x3b922,0xc9bf3,
        0x41ef6,0x498c9,0x3d87c,0x0f6d2,0x3d79f,0x5804c,0xbc125,0x2a7ac,
        0xa1005,0xaf6f1,0x50528,0x79d95,0x35dab,0xd1621,0x6f0c8,0xfd77a,
        0xe1029,0x6dde5,0x0508b,0xa12b4,0x2f95d,0x5ac0f,0xba1d9,0x758a8,
        0x0af71,0xfb886,0x160c8,0x4c837,0x40b19,0x004d3,0xc80ce,0xa40e6,
        0x4aaa0,0x176b1,0x9f82a,0x00000 } },
    /* 63 */
    { { 0x366dc,0x88c21,0x0abe5,0xdaf96,0xfaf75,0x9c0a4,0xed472,0xacb93,
        0x01fd9,0x70705,0x7a16d,0x744e8,0xbb97e,0xe7361,0xa7a98,0xa42e0,
        0x54cf3,0xf228b,0xacdaf,0x90781,0xbb7bd,0x87ccb,0x0e7f0,0x66325,
        0xf3983,0x09da6,0xaf07c,0x93eeb,0x766d6,0xbaf15,0x4c38c,0x79baf,
        0xa99d0,0x07dfc,0xa984e,0x8dab5,0x7f26d,0x4d324,0x6f9ab,0x7eba3,
        0xbe701,0x164d0,0xe8dd2,0x9e650,0x337bb,0x1c4f0,0xe2453,0x72aa4,
        0x3d85a,0x84b75,0x7d1e9,0x00007 },
      { 0x62367,0x39d8e,0x93732,0x0cf1d,0xbb982,0x61848,0x7c433,0x5a9c9,
        0x7e344,0xfc00c,0x4f960,0xc9ae1,0x59a0e,0x0474b,0x0cf74,0xcf41f,
        0x065d5,0x8fece,0x5eede,0x8610a,0xe9e80,0xde5a4,0x75db1,0xae0cf,
        0x44ae4,0x0b17c,0xb148d,0x63236,0xc2fa5,0x9ff2d,0x40fd2,0x64fa7,
        0xb212e,0x8a88c,0x605eb,0x3016c,0xd6a86,0xc771a,0xc17f2,0x607b4,
        0x112e7,0x856d6,0x0d497,0xec074,0x5fe90,0x56e0e,0x18be2,0x599be,
        0x4adb0,0xecca5,0xe6eab,0x00004 } },
    /* 64 */
    { { 0x9cfe6,0xd3fb9,0x50323,0x41789,0x6c933,0x09bc2,0xb6f7b,0x7cbdf,
        0x11e41,0x60641,0x9a757,0x17448,0x09114,0x919cb,0xdf910,0x4c633,
        0xbfd2f,0xc7396,0x15fc7,0x62db7,0x28cab,0xa1951,0xaac8c,0x4db81,
        0x72473,0x4a306,0x4c4c5,0x246bb,0x6e67a,0x22964,0x0fabf,0xd77ea,
        0xb5d70,0xf1fa5,0xbed15,0x92f35,0x5c2f1,0x686da,0x0ada5,0x7f669,
        0xac72a,0x7ddec,0xaa50b,0xf2a2c,0xf0c4a,0x49ad2,0x1c160,0xf4463,
        0xcf056,0x9604e,0x25d27,0x00003 },
      { 0x8c144,0x55484,0xe11fb,0xaf32e,0x5b6a7,0x06292,0xf9a4e,0x369e0,
        0xb68e1,0x1e125,0xa53b2,0xdae6c,0xbad9b,0x98ea1,0x05c2e,0xf50d6,
        0xfa395,0x539f2,0xdb9e1,0x32f5b,0xde915,0x70e32,0x0d745,0x46a25,
        0x698ae,0x45810,0xd9d91,0x546ca,0xe7fd9,0xe97a5,0x72111,0xabf67,
        0xf82e9,0xd5249,0xa29f7,0xdf63c,0x99851,0xc539a,0x3e5a9,0x71d0e,
        0x4d54b,0x56fd8,0x41d2b,0x459c0,0xad1e0,0x80096,0xb6efd,0xceb3e,
        0xa79d3,0x46e32,0x9d485,0x00001 } },
    /* 65 */
    { { 0x0f5e5,0x8fb54,0xe19ee,0x8d17f,0xf04e6,0xd2a52,0x87186,0xadbdc,
        0x20db0,0xc8d23,0x03a7f,0xd5a8d,0x6a83a,0xbcb91,0x3c708,0x54bf8,
        0x1e840,0xea2e5,0x92133,0xdddf0,0x4cb52,0xe3842,0x583bc,0x31063,
        0x7be40,0x76d5c,0x58e31,0xb9df4,0xfc1eb,0x4dabb,0x639bc,0xafb19,
        0x725a8,0xe4c05,0x6350f,0xcd243,0x484e1,0x4a063,0x8deac,0xc145b,
        0x73154,0x37adf,0x34832,0xdd9eb,0x00aa6,0xff272,0xc3dcb,0xa3345,
        0x453b0,0x6cb4e,0xb3ace,0x00001 },
      { 0x8bdc5,0xe990a,0x343e5,0xa0890,0xd6306,0x03bf9,0x20ea2,0x8e485,
        0x89a35,0x06984,0xe7d1d,0xdebed,0xfbd17,0x795d3,0x6d75f,0x8fafa,
        0xb0a3f,0x30387,0x4ceb6,0xeafaa,0x2ffdd,0x166b3,0xe02e0,0x7e764,
        0xe2054,0x04a2f,0x871f3,0x9824e,0xe55ab,0x2ec45,0x6bb95,0xa2bd3,
        0xd20ca,0x84a90,0xb4c14,0xfb537,0x775bc,0x19f38,0x4e553,0x6982c,
        0x38a4a,0x1d342,0x10292,0x61c7a,0xea2bb,0x3ab17,0xb64db,0x1e061,
        0xf0a14,0x3e192,0x38ec3,0x00005 } },
    /* 66 */
    { { 0xb56cf,0xfea19,0x93496,0x9acd1,0x47bb9,0x3d77f,0x88166,0x57d0a,
        0x4afa8,0xfd8f0,0x82835,0x3da20,0x7cced,0x82cec,0xaed5d,0x7e21f,
        0x09c85,0x99f80,0xe175b,0xa3076,0xb2d05,0xc6e31,0xd82d9,0x81487,
        0x48d4a,0x55969,0x46f66,0xd3f2d,0x986eb,0x3ccc4,0xaa877,0x86851,
        0x640a6,0x228b1,0xe220f,0x0b753,0x841a2,0x06e3a,0xa6f9f,0x90ac0,
        0xffe5e,0xfb2cf,0xebeb3,0xb1da8,0x9f5a9,0x08e2c,0x9976e,0x2587d,
        0x9f401,0x9803e,0xfd602,0x00006 },
      { 0x7516a,0x8d8eb,0x4709f,0x98ab5,0x4bdc5,0x058a7,0x1ce83,0x87e80,
        0x4dd98,0x96d23,0x17b8a,0x9d90d,0xbfd0f,0x90f6a,0x49f6e,0xaa1e5,
        0xed55b,0x805a7,0x496ff,0x4c192,0xa6c25,0x9f657,0x5750d,0xb8962,
        0xea49c,0xde3cd,0xdff27,0xa3f02,0xbb685,0x8bc04,0x7fddb,0x3c50e,
        0x236b0,0xff987,0x04ff0,0x50559,0xdbb0d,0x4298f,0x8d049,0xe14be,
        0x3386d,0xd634b,0xc3d30,0x4e9c7,0x97ad3,0x59fdd,0x2bde1,0x1f2b3,
        0x1e5c0,0x3cc76,0x4cfa2,0x00008 } },
    /* 67 */
    { { 0x9b964,0xeb8b9,0x3bc11,0xfc471,0xa58e2,0x280c0,0x54b8e,0xd4c9a,
        0xfbc49,0xfa870,0xf6e20,0x34a2b,0xa37a3,0xc88cf,0xd0dd7,0xee583,
        0xaf1da,0xa8ef4,0x5e029,0xf8a60,0x40c2e,0x55e23,0xb626d,0x209e9,
        0x6fdfe,0x0f61b,0xb8e08,0xad26b,0xa3b1d,0x92fc1,0x16293,0x5adbc,
        0xe3f4e,0xe60aa,0x2ac0f,0x4d5b0,0xac2bf,0x99801,0xed28d,0xc282f,
        0x3f93f,0x3f233,0x52db3,0xb10cb,0x716dc,0x5752e,0xf84c5,0x09f90,
        0xa0d8e,0x51c84,0x87d4c,0x00002 },
      { 0x867da,0x010e9,0xfa582,0x4cda5,0x31a87,0x4589b,0x22e61,0xfbdee,
        0xe27c5,0xa8005,0x612bd,0xfef5e,0x9e357,0x3635f,0xedf2d,0x4e0db,
        0x25a86,0xe46f1,0x2be70,0xa2e56,0x40d94,0x9b988,0x5d1a0,0x28b5e,
        0x99a15,0xb57eb,0x51028,0x416e7,0x421b9,0x6d2cc,0xfd7e0,0x1b137,
        0x09845,0x17fea,0xfa1f5,0xcbd76,0x6ffce,0xa1e96,0x53e3b,0x832f4,
        0x89a4a,0xa1d4c,0xca68f,0xe2afe,0x307b1,0xd395a,0x4534b,0xd0fb4,
        0xf9e13,0xdcd8e,0x132a3,0x00000 } },
    /* 68 */
    { { 0x374c2,0x85576,0x53c77,0x7040e,0x18472,0x0526d,0x044e6,0x228ca,
        0x66dc8,0x138a0,0x1ce13,0xc1b2f,0xd1fe1,0xeb0c5,0x832cd,0x2aeec,
        0xf826f,0x999cb,0x75966,0xa589a,0x1de77,0x188e8,0x254cd,0x118d1,
        0xe0fe0,0x6ae5c,0x790b8,0xa9840,0xea142,0xac28c,0x43f39,0xe28f0,
        0xe5804,0x9087d,0xeef82,0xa8c54,0x2f639,0xc31b3,0x94f83,0x58877,
        0x454a7,0x91d70,0x8b1b3,0x5d501,0x5ca63,0xd9c79,0x07631,0xcefea,
        0x8aa25,0x76b6f,0x3cbee,0x00001 },
      { 0xf34f3,0x0f8d3,0x9cabe,0x7fe37,0xca361,0xa9c31,0x6a1bd,0xdd942,
        0xdee23,0x04b26,0x29c91,0x9627f,0xbe9dd,0xc6cd3,0x169e2,0x033eb,
        0xa2196,0x92fcb,0xa73f4,0xc83c8,0xbb858,0xe37e0,0xbb792,0x23b3f,
        0x2aca6,0xa2e4f,0x4be00,0xfb1e6,0x88101,0x8f644,0x26a94,0x91a78,
        0x260e7,0xb4907,0x14067,0xb8354,0x0e30b,0x74aa5,0x06ef7,0xc999c,
        0x2ca80,0x11f92,0xba085,0x35b90,0x06b86,0xfa04f,0xb5c25,0xbf936,
        0xe8967,0xdae02,0xe0a1a,0x00004 } },
    /* 69 */
    { { 0x29c4d,0x708ba,0x0ca66,0x80940,0xe2298,0x8240c,0x752c0,0x16dda,
        0x5ca67,0x3421c,0xbbbfa,0x0e45a,0x2689c,0xd28b7,0x5fd3e,0x1d754,
        0x56ab4,0x98d7c,0xf2211,0x9d655,0x43875,0x3d8f7,0xb894b,0x8fe50,
        0x90dfb,0x16934,0x80eba,0xf5d7e,0x7b641,0xacb53,0x5eb79,0x7b0da,
        0xd5e5e,0x970c1,0xb6b14,0x429aa,0xda5da,0x38e68,0xf2523,0x2f6d2,
        0x0c437,0xa7e01,0x530f3,0x16d26,0xc226f,0xef08b,0x7b6cb,0xefb0f,
        0x9c999,0xd99f9,0x33e30,0x00007 },
      { 0xa38f9,0x82a42,0xcfe15,0xb500e,0xe4730,0xc2d58,0xb2cae,0xde976,
        0x2f2a7,0xbb2ee,0x969c1,0x9db5a,0xaf053,0xecdb4,0x168fc,0x31954,
        0x8e902,0x8ae7a,0x2f734,0x541ff,0xc3121,0x58d7c,0xe521d,0x2202a,
        0x5b75c,0xa75d2,0x40835,0x965af,0x6dea9,0x9b4e4,0xa4152,0x3feb6,
        0x7ad9b,0x6fbd2,0xc97fb,0x900b5,0x0261f,0x7554c,0x19ed8,0x04d5b,
        0x031d9,0x9cb43,0xb219b,0xe9b8c,0xf33d5,0xe00bc,0x4923e,0x7a43d,
        0xa5c0c,0x39b79,0x6facb,0x00005 } },
    /* 70 */
    { { 0x18bfa,0xa2a30,0x19165,0xd9840,0x49ffa,0x0c6b2,0xa9b10,0x55341,
        0x1b1f6,0xc9bbf,0x5dc4c,0x1d972,0x0e6bd,0xfffe6,0xed52b,0x52850,
        0x509ab,0xcc7e5,0x4e992,0x59f12,0xe4ceb,0x6c502,0x148ff,0x1aa7d,
        0xb3573,0x462f0,0x7e3aa,0x1ddde,0x0e90c,0x14288,0xf45d1,0xbaec9,
        0xe5dd5,0x2665b,0x75cfd,0xce134,0xe1feb,0xabb14,0xd3083,0x80942,
        0xa4829,0xc86ab,0x97e82,0x235d2,0xd1e1b,0xd8218,0xdbe50,0xb771c,
        0xd6cbb,0x66d94,0x85992,0x00008 },
      { 0xccaf2,0x90155,0x88472,0x773e0,0x77c5b,0x79ebc,0x8ed86,0xb2dd0,
        0xb2dd1,0xdba88,0x7d475,0x180e8,0xa960a,0x94d02,0x6b766,0x80fdb,
        0xf9e96,0xc93f3,0xe8758,0x36c43,0xa4ad8,0xa3f6f,0x87dbd,0x32fb3,
        0x0c581,0x0f940,0x55020,0x85422,0x825a7,0x6ecf1,0x35177,0x2a97c,
        0xdb59a,0x6e566,0x3ebf4,0x5eda0,0x02654,0x43a28,0xb4447,0xcf74a,
        0x69d84,0x69ed1,0x8cb3f,0x931d8,0x6baab,0x25719,0x32cd8,0x70ae9,
        0x09719,0xa6a0c,0x97224,0x00007 } },
    /* 71 */
    { { 0xf3567,0xf8441,0x32923,0xbf1d6,0x82e24,0x1c316,0xfffc1,0xb7671,
        0x7726b,0x224b9,0xa5e1a,0x46a77,0x76017,0xddb41,0xea03a,0x53ddd,
        0x9b846,0x3c7f5,0x7867a,0x7ff75,0x756cd,0x12a98,0x9a8b0,0xf19ba,
        0x5fec9,0x481bd,0x83067,0x79a2f,0x17503,0x8c05d,0x45dab,0x77634,
        0x3f42a,0x1b790,0xd7f44,0xe46d5,0xda903,0x11674,0x6c1c0,0xadd12,
        0xd3c4d,0x401b1,0x1455b,0x2aac6,0xea275,0x5c356,0xa6855,0x4da42,
        0x0852c,0x15d82,0xff09c,0x00003 },
      { 0xb7784,0xcef9c,0xc0a1b,0xf3054,0xc2422,0xc539b,0xaa7ae,0x0c414,
        0x0f9fd,0xc45f4,0xfd42b,0x316cf,0x5d3aa,0x358e1,0x4c32f,0x42f5a,
        0x27682,0x9ed6e,0x0bdcd,0xecee0,0xff8a5,0x9f789,0xf5d06,0x05e14,
        0x8018e,0x41807,0xb40c7,0xe4938,0xd2bb3,0x17f72,0xc1d79,0x5dbc8,
        0x7150c,0x64cc5,0x0eea6,0x8920e,0xac3fa,0x5ecc5,0x164a2,0x1c797,
        0x1b0f5,0x6b3c2,0x34ad1,0xa2f26,0xa8f09,0x391d9,0xfc558,0x8e730,
        0xfae4c,0x054fd,0x7ef18,0x00004 } },
    /* 72 */
    { { 0x285e4,0xd13da,0x965f3,0xe3f49,0xa3a01,0x7d4db,0xad0ba,0x61214,
        0x8413a,0x49473,0x23975,0xd5352,0x2d3b7,0x730b9,0xdcf5a,0xa53db,
        0xd165d,0x2b332,0x130d9,0x7ef43,0x182f9,0xa2854,0x1b644,0x44dce,
        0x2221c,0xc9bf6,0xe2a0e,0x38587,0x8bba1,0xfad99,0xc8dcb,0x33f32,
        0xed44b,0x3fb5f,0x09e5f,0x17bb4,0x5c662,0x328c6,0x1a95c,0xfcdf7,
        0xdb69f,0x88b00,0x89207,0x2a21b,0xba23c,0xe6464,0x8e63a,0xf8ab2,
        0xe0861,0x9cb8d,0xa6b6e,0x00001 },
      { 0xf77aa,0xb606a,0xf6ec2,0xf065a,0xda887,0x60f5c,0xc562e,0x9f498,
        0x21400,0x4b87d,0xcbaaf,0x5b59f,0x5db59,0x1ab85,0x2a127,0x0fb59,
        0x49b0c,0xe5d43,0x0ce10,0x8c9ca,0x8887d,0x6187d,0x6db9d,0x154bd,
        0xe95f9,0x9903e,0xd06c9,0x32135,0x08fe5,0x6a64d,0xc30fb,0xf4a7b,
        0x4cb60,0x0d66a,0xd22af,0x367c3,0xf5d37,0x952ce,0xe5516,0x997d8,
        0xea734,0xd06f0,0x31732,0xc70f7,0x2b447,0xcb394,0x034a9,0x00ab3,
        0x10fd0,0x80285,0x9dd01,0x00007 } },
    /* 73 */
    { { 0x7424e,0x3a3ac,0x4e003,0xa4d00,0x860fd,0x06b68,0x2fbdb,0xbcb77,
        0xa9766,0xa4236,0x297cd,0x8e2bf,0xe294a,0x013c6,0xb85db,0x4b0aa,
        0x3a3ad,0x98872,0xd2aec,0x4a6b3,0xd13c8,0xae32c,0x69e0c,0x70ec1,
        0x88f5e,0x62218,0x2a882,0x33bd4,0x87396,0x60d9b,0x92e7b,0x68ac7,
        0x69fe1,0x22107,0x9f2b7,0xed348,0x6d24b,0x3fcfe,0x4aa8f,0xa3eb2,
        0xefb88,0x6bd35,0x84c70,0xfa3f4,0xdddec,0x9ece0,0x9a992,0x7cc11,
        0x05436,0x458d4,0x7e5ad,0x00008 },
      { 0x000a7,0x9d7d1,0xa99aa,0x3833b,0xcae82,0x94aff,0xdc58b,0xdfb83,
        0x29628,0x8dc82,0x45a41,0xfe118,0x42f59,0x41705,0x0f85d,0xa8b97,
        0x71581,0x6572b,0x918c2,0xdd178,0xdc0d1,0xef477,0x7c0e4,0x3afad,
        0xb4cf3,0x5bb50,0x1870a,0xea790,0x821ba,0x3a286,0x7f9bb,0xc7708,
        0xa59cd,0x1e124,0x85753,0x32397,0xf57f4,0x74c26,0x94aed,0x0164c,
        0x5ae25,0x74d5f,0x094bf,0xb7e2f,0x26608,0xceea3,0x5bafd,0xf4cdb,
        0xcc045,0x19990,0xb7125,0x00000 } },
    /* 74 */
    { { 0x5c64d,0xa188d,0xa290c,0x25345,0x9a749,0x96d74,0x92505,0x2a00e,
        0xb0d3d,0x6ba04,0xaf7b6,0xd02cc,0x3082c,0xdded8,0x0c2ec,0x912b5,
        0x1646e,0xdeff3,0x13ce9,0xff958,0x7c75f,0xae70c,0x61562,0x7e2a4,
        0x852e0,0xd16f6,0x3804f,0xd7d00,0x9320f,0x18e8d,0x4dd82,0xb1a2a,
        0x645d7,0xfbafc,0x918a6,0xfdbe4,0x1e8d9,0x080fa,0x6eefb,0x4470b,
        0x4d08a,0xf733d,0xd974e,0x20776,0x2d2ba,0xdae5d,0x5a769,0x8ecb9,
        0x9596d,0x3a7d6,0xa3f42,0x00007 },
      { 0x29387,0xa69a9,0x62d2c,0x1fff3,0x1cb1c,0xdb758,0x6cbab,0x7e51b,
        0x2ec9f,0x1fd89,0xa4e13,0x86323,0x1ee8d,0xd8756,0x3f15b,0x4680e,
        0x7e732,0xe1d4e,0x3a597,0xfefee,0xc5581,0xc72b7,0xe0b3c,0xca8ca,
        0x77f8a,0xaff3e,0xe2fd4,0xd7dc5,0x9fcc7,0x355b7,0x55221,0xdd3a4,
        0x07177,0xf2a2c,0x46b24,0x621f5,0xd0689,0x5b532,0x63e41,0x3f781,
        0x9af51,0x212be,0x3d7ed,0x3b9b3,0x327d6,0x80294,0xef296,0xab019,
        0x3faf4,0x55162,0xda5fc,0x00002 } },
    /* 75 */
    { { 0x5c600,0xf3c8a,0x2429c,0x3e7c6,0x23fe3,0xa80c2,0xdcba7,0x0a57d,
        0xda740,0x749ff,0x25b0c,0x156d9,0x0d1ae,0x100eb,0x3f96b,0x097a4,
        0x43c81,0x5cef9,0x69e94,0xcf241,0x51128,0xf734e,0x133a1,0x419f0,
        0x87c4a,0x24043,0x10440,0x868b0,0x2c007,0x359cf,0xabf90,0xe5416,
        0xd54e3,0xee478,0x9c76f,0x173ef,0x642a2,0x219da,0x14166,0x9fe30,
        0x03156,0x7e61e,0x3ef24,0x5ce39,0x2a0ff,0x2b659,0x2ba07,0x81179,
        0x854d3,0x1970c,0x55f02,0x00008 },
      { 0x314c4,0x6c847,0x1fbfb,0xb96a6,0x5eb45,0x90615,0xfac97,0x6ba2a,
        0x2e146,0x81710,0xb9497,0xf975a,0xeed51,0x10c4f,0xb17c1,0x9d2f5,
        0x57667,0x70aff,0xac8ce,0x44e77,0x16eb2,0x366a2,0x5c7e7,0x551c6,
        0xbbcec,0xdedd1,0x1a859,0x060ae,0x7b525,0xa7d2e,0x1748b,0x7a048,
        0xea8c4,0x41ab8,0x1a2c5,0xf078e,0x36fdf,0x7824c,0xb046e,0x14874,
        0x49fc7,0x3379b,0x6b1f7,0x337f0,0xf22ae,0x8fe6c,0x1926f,0x1c352,
        0xd0797,0xcf525,0x92236,0x00002 } },
    /* 76 */
    { { 0xb29dc,0x0a7d8,0xdb8d8,0x648ac,0x408ea,0x7a202,0xe91d1,0xae92b,
        0x12c5e,0xbc7db,0xda72f,0x7d18f,0xf1f34,0x760c6,0xb409e,0x11374,
        0x38d91,0xf1d8e,0x361e8,0xc1f47,0xd739a,0x14be9,0xc4e77,0xb4df5,
        0x9701c,0xe1c1f,0xf72ca,0x8ed86,0x4d913,0xd180c,0x1f76a,0x1c7fe,
        0xdbf9c,0xbe9e2,0x8c185,0xc44df,0x97c70,0x5db26,0xb5f83,0xb0d15,
        0x7cfea,0x5ef99,0x1e654,0x445a6,0xe5101,0x184e5,0x88425,0x16b06,
        0x1e7aa,0x59752,0xcfac3,0x00007 },
      { 0xbc53a,0x673c0,0x11821,0x13678,0x37e75,0xb5ede,0xa1884,0xa3657,
        0x255fd,0x983ca,0xa1fdd,0xbbf4b,0x8096a,0xda77d,0x69fc5,0x9ce83,
        0x342c5,0xe7aab,0x27b9a,0x59f1f,0x69720,0xc91bd,0xfe906,0x914ec,
        0xdab30,0x12ee0,0x3f53f,0x7fbb9,0xebb64,0xa57e0,0xa7aff,0x30c38,
        0xad607,0xef9f2,0x17d06,0xdcc95,0x7bb99,0x728d8,0x0a149,0x44608,
        0x34af1,0x7db00,0x2b9c1,0x0c3f1,0x0cc81,0x2a22a,0x14f77,0x7225f,
        0xf82bd,0x7f1dd,0xce3dc,0x00006 } },
    /* 77 */
    { { 0x97830,0x35a43,0x07cd8,0x3306c,0xcf473,0xd9290,0xe8c4d,0x29989,
        0x5d3a8,0x52dd3,0x63d81,0x25595,0xb7990,0x7de61,0x911e8,0xf278d,
        0x4e35c,0xc7102,0xc7340,0x0e599,0x14a0d,0x44446,0x6a12d,0xf3262,
        0x7608f,0xa963e,0x4c9ba,0x37e9c,0x5627a,0xfffd2,0xc5176,0x0c56d,
        0x2a1cd,0xc8cef,0xb6def,0x59d9c,0x6efc5,0xcc0d5,0x692cb,0x041cb,
        0xf3fc5,0x09e45,0x5161e,0xc239e,0xccd05,0x3b559,0xee95c,0x2a731,
        0x0a16d,0x22a3d,0x51511,0x00008 },
      { 0xf19e2,0x3586f,0x82d03,0x86037,0xa1da2,0xc60da,0xeedc2,0x557c7,
        0x78cfe,0xb0b2e,0xbc4e8,0xf9841,0x7a8f6,0xf35c6,0xb4b3d,0xcc1f9,
        0x4462a,0x03476,0x6e136,0xe0b09,0x77c7a,0x910b9,0x956bf,0x51435,
        0x7f305,0xe527c,0x631ea,0xb15cf,0xcc14d,0x69b34,0x1427e,0xa51d6,
        0x12ff2,0x515fc,0xec828,0x7162d,0x3fb88,0xceae1,0x8bdfc,0xde148,
        0x32ac1,0x4cda3,0xee3e7,0x74e22,0xca203,0xae069,0x1a1f0,0x597ea,
        0xdec04,0xf277b,0xb1159,0x00008 } },
    /* 78 */
    { { 0x61d30,0x442f9,0xaf71a,0x248f4,0x87ac7,0xf968a,0x6cdbd,0xb1a90,
        0xdf87c,0x25d32,0x4abf9,0x0e260,0xc00c1,0xf04d4,0x759b9,0xb8711,
        0x705da,0x60939,0x0d54e,0x08490,0x3c9f8,0x58743,0x375f7,0x6a7a2,
        0xabade,0xac2e9,0x4ac17,0xd4789,0xc5676,0x02d99,0x25bc2,0x4ca05,
        0xae73d,0xadabf,0x5b8bc,0x991b9,0x83405,0x71ed3,0x9c323,0x458a9,
        0x9e47a,0x662b6,0xb78c8,0x0b182,0xc7cac,0x232c7,0x79be0,0x6ceaa,
        0xf7459,0x33588,0xbd864,0x00000 },
      { 0x34189,0xb47e7,0xea1a8,0xfa17d,0x8cfe5,0xc5ac8,0x66452,0x11437,
        0xa4d4e,0x50444,0xf9e97,0x2308a,0xbc252,0x0c6b3,0x0c3d3,0x78b1d,
        0xdf477,0xf04c6,0xedae5,0x8dd72,0xa2ee8,0x131d9,0xe3453,0xacc93,
        0x380ee,0x8ec4e,0x8db0e,0xb1aca,0x7d499,0x5d49d,0xc167f,0x77348,
        0x6ccd7,0x57155,0x96632,0xd13dc,0xc2611,0xce0e8,0xdcc65,0xb5a2f,
        0x5fe66,0xa12c9,0x658fa,0x88328,0x82669,0xc32c9,0x1f431,0xda87d,
        0x91907,0x98fcd,0x66505,0x00004 } },
    /* 79 */
    { { 0xa5efa,0xcc6b4,0xc6c13,0xb2654,0xb1d07,0x81989,0x9c0c4,0x8bdc6,
        0x966ce,0xd410b,0xc2531,0xfaa22,0x0f54c,0xd0a10,0x808ca,0xcb5f1,
        0xda449,0x38ee5,0xeb525,0x83ccb,0x5bedd,0x24008,0xc78a6,0xd6255,
        0x2dacf,0x8fe79,0x06205,0x19062,0x18837,0x1658c,0xe83ed,0x96615,
        0x8d542,0x277d2,0xb549b,0x5df34,0xb83b7,0xf127d,0x942ea,0x17fbb,
        0x0df6d,0x304f6,0x6f7c9,0x31dbf,0xfd086,0x18789,0xf9860,0x17c38,
        0x9280c,0x4ab9a,0xc4357,0x00000 },
      { 0x0cad0,0x4c1d2,0x6eb32,0x108a7,0x98c61,0xdecb0,0x36d90,0x6f06d,
        0x9d39c,0x97a6e,0xc0da1,0x78bab,0xe6cd9,0x7ac5c,0x1c050,0x5948b,
        0x97eb5,0x64c54,0xbd471,0x14e32,0xf4d59,0x9c4c0,0x03c2a,0xa759f,
        0xc5046,0x7e772,0x9ac84,0x328a6,0x0e7d7,0x48b33,0xd0c30,0xa8d57,
        0x7bace,0xe040f,0x60034,0x1790e,0x3a85f,0x3d919,0x73682,0x5c859,
        0x9b66c,0x22a6e,0x79e10,0x2c7a6,0x422ca,0x023fa,0x19c09,0x00e7a,
        0x6d5b9,0xf1272,0x24999,0x00003 } },
    /* 80 */
    { { 0x34915,0xd67c8,0x67eae,0xb64d6,0xabc5e,0x77aa6,0x0119f,0x25d62,
        0xebcb6,0xc2729,0x99fd9,0x24f26,0xc0aee,0x8d4f6,0x8742b,0xe1eb5,
        0x976d6,0x0c14c,0xf1271,0xea657,0x5f6d9,0x39033,0x06491,0x06b50,
        0xb7049,0x4f668,0x876ee,0x9a0e0,0x06596,0x9d936,0xf3f2f,0xf901b,
        0x9e3ce,0x51b49,0xb1a86,0xcaaaf,0xbf2db,0xb953f,0x6b680,0x973b0,
        0xcc566,0x64312,0xaf36c,0xd9c33,0x53534,0xffd81,0xa5210,0xe4463,
        0xc2b91,0x4bf18,0x7ea2b,0x00005 },
      { 0x0f2f2,0x628aa,0x0f5e1,0xbcaa0,0x50e46,0x7e75c,0x42d8c,0xa4a2c,
        0xb479a,0x0297a,0x4baa2,0x08ea1,0xeb4f3,0x43cc2,0xd1469,0xa901b,
        0x58804,0xeeeed,0xb125f,0x0f7cb,0x99d18,0x02c8f,0x61c65,0x1580c,
        0x53919,0xe3e53,0x7101e,0x80692,0x77e27,0xa7271,0x0a1fa,0x7a0a4,
        0x5b153,0x024c7,0x2edce,0x1c223,0xb538f,0x23660,0xd2eda,0xbe307,
        0x11e98,0xb44d5,0xbaee0,0x6e409,0x72427,0xf1f30,0x9277f,0xa78c3,
        0x935c9,0x46ea7,0x0480b,0x00006 } },
    /* 81 */
    { { 0x2ece3,0x66387,0x1087d,0x70f83,0xd955b,0x29be7,0xbb85f,0x9cf95,
        0xb4fc7,0x21b50,0xbffa6,0xb58dd,0xdbae3,0x22ba5,0x280e0,0x0e61d,
        0x1449c,0x17418,0x8ae51,0x54857,0x0cf55,0x13284,0xb0e0b,0xb8ce0,
        0xed1b6,0x3d800,0x8d5de,0xfdd57,0x735df,0xa56b4,0x37469,0xf7e42,
        0x10ae7,0x698d9,0x5e323,0xc7c7d,0x06313,0xff52a,0x9e5b6,0xa92de,
        0xfe20d,0xbb5a2,0x12110,0x47d3d,0x341b3,0xc16f2,0xedb40,0xc5905,
        0xf88cc,0xd39a8,0x774a0,0x00000 },
      { 0x6c106,0xabe3b,0xae181,0x50b73,0xf8de1,0xbe163,0x8364e,0x6f354,
        0x5b82f,0x16cf7,0xac7ac,0x20633,0xfaa0d,0x1722a,0x66829,0x5c680,
        0x45553,0x61115,0x3941e,0xe3f77,0x8bf5d,0x127e3,0x1da17,0x1afb4,
        0xfdf03,0x6332c,0x7bc86,0x3c918,0x9c689,0x2c9c9,0x744a6,0x75046,
        0xc1947,0x2d962,0x6866e,0xdf4c9,0xf378c,0x9ec8d,0xa3248,0x3407f,
        0x0709b,0xd13a6,0x51290,0x21595,0x3d37d,0xb9227,0x303ba,0x9623d,
        0x2014b,0x54243,0x81519,0x00000 } },
    /* 82 */
    { { 0xb2108,0x89fb7,0x9236d,0xf9aaf,0xcad75,0xcc83c,0xa113e,0xb4e1d,
        0x72b15,0x62f7c,0x315c3,0xeaef0,0xf552a,0x72fe3,0x0edf2,0x11e14,
        0x43ee8,0xf6878,0x9d79b,0xb25b9,0xd1d9b,0x6b54f,0xd74ce,0x5b1ba,
        0xb0e21,0x0db20,0xb84c9,0x214f5,0x954a0,0xa6cec,0xf52fc,0x459bb,
        0xdf76f,0x8d9e4,0x363c4,0xf17ee,0xed64c,0x45f84,0xa4830,0xf62ad,
        0x2a167,0x01840,0xa74ca,0x1bf36,0xd2c9e,0x91c42,0xd41f6,0xe8cf9,
        0x4b874,0x78c2c,0xabf21,0x00005 },
      { 0x3bccd,0x6bf3b,0x77796,0x0caa4,0x0be3e,0x47e0f,0x04300,0x8c7d5,
        0x383b3,0xfccb8,0x46fd5,0x3baf9,0x7e77e,0xec0e8,0x785e9,0x79baa,
        0x18d25,0x7cc8a,0x83c55,0xfcfed,0xf25be,0x96e5a,0xb619b,0x98c71,
        0x5d15e,0xa14f0,0x7e62d,0x991a7,0x1081f,0xaa382,0x781cb,0x1c6ec,
        0xd9bfb,0x5de54,0x522f6,0x14307,0x344ed,0xd0557,0xddaf5,0x95caf,
        0x5b31f,0xbf303,0x378f5,0x7f436,0x947e6,0x70b9d,0xcad52,0x029f7,
        0x16a48,0x874d9,0x5ad15,0x00001 } },
    /* 83 */
    { { 0x88ae4,0xceaa5,0x0de2e,0xa2320,0x8a371,0x2ebc5,0x44455,0x71230,
        0xea934,0x2dd00,0x4b183,0xa67de,0x3afbf,0x89e84,0x341b6,0x29216,
        0x4e2e8,0xbd61f,0xf96bb,0x9dc51,0x404c2,0x42068,0xfd195,0x42317,
        0xe3827,0x62c7f,0x34831,0xaec66,0xfe0a0,0x00184,0x4d107,0xfc2b9,
        0xfbd85,0x73fe1,0x72199,0x43520,0x1fb07,0x8b6ab,0x39264,0xc46e5,
        0xbdaad,0xff23b,0x0fa56,0xdd1f0,0x60db8,0x6725f,0x5eb86,0x10481,
        0x81963,0xca52e,0xf9c4c,0x00003 },
      { 0xe637e,0x9732c,0xf36b2,0x5cddf,0xdf5d2,0xa15f2,0xd9781,0x8b02a,
        0xd052d,0xe91a1,0xfbab3,0x3bbcc,0x52e5f,0x4eeb7,0xbd761,0x60d2c,
        0xa793a,0x43cd5,0x44918,0x2144d,0x5cdba,0x42cf7,0x76622,0x88b99,
        0x705e7,0x32a20,0xc77e1,0x2cc0e,0x564e1,0x1a9b0,0xdf6b6,0xb1c14,
        0x25b5a,0x04748,0xfd97f,0x12238,0x13da3,0x60482,0x70d95,0x4d30c,
        0x86727,0x69de4,0xc12ee,0x8f151,0xdbcab,0x8d893,0x8b466,0x5dc63,
        0xf574b,0xd6223,0x479da,0x00006 } },
    /* 84 */
    { { 0xf2b26,0xf3b05,0x69044,0xf76c5,0xa80b9,0x5a294,0x6aeb3,0x4290f,
        0x9fe28,0x77883,0x26a58,0xfb230,0x3761c,0x5ff9c,0x6b62e,0x76892,
        0x1c576,0x200b1,0xae6cd,0x3efeb,0x672a0,0x85775,0x63adc,0xe1bad,
        0xe074a,0x9c0ca,0x709d9,0x91a1d,0x13fe4,0x01d9c,0xed665,0x76c5d,
        0xaeff7,0xa1c32,0xda6ec,0x83e81,0x5c576,0x849d5,0x84750,0xdf98d,
        0x92e9c,0x649e3,0x4d9a5,0x982f6,0x2fad7,0x7b98b,0xdb7a3,0xf7c3b,
        0x60497,0x94f08,0xfe09f,0x00001 },
      { 0x8cc63,0xae764,0x9a7ea,0xa7144,0x167cf,0xea251,0x55913,0x653f4,
        0xb923c,0x86fc8,0x1a16e,0x619b8,0x4d957,0x86467,0x04b3c,0x0c7e8,
        0x6599a,0x4a161,0xc8813,0x2328f,0x90a65,0x6ea96,0x29e36,0x4bc90,
        0x32960,0x2b415,0xe2aad,0x1994a,0x5ef9e,0x10bef,0xc527f,0x9e2a8,
        0xbf860,0x86c67,0x3dcb5,0xc25d7,0xa844c,0x1a43f,0x653f6,0x74eb3,
        0xe7eea,0x02d74,0xd240f,0x6706d,0x4f335,0x83bcb,0x94cfd,0xeec76,
        0x2526a,0x86db6,0xde957,0x00004 } },
    /* 85 */
    { { 0xac2f7,0x153de,0x867d3,0x9a8e4,0xab61d,0x84778,0x2d5a0,0x0ab7b,
        0x76f96,0x79f3b,0xfdf4f,0x0056c,0xb00b3,0xab8f4,0xe1531,0xd0701,
        0x79d01,0xd59c7,0x7f948,0x53710,0xc8267,0x994eb,0x4c07c,0x48bad,
        0x4d4ee,0x58110,0xfc9d0,0xe0b5b,0xb798c,0x9fa80,0x98d30,0xc7ca8,
        0x33eaf,0x25acb,0x244f2,0x31750,0xc5b2f,0x1e8df,0xe34d5,0xa4d7b,
        0x9ba6b,0x433e4,0xda02b,0xf4c7b,0xa1760,0x35275,0xa7e44,0x37e36,
        0x6980c,0x8be63,0xc9441,0x00001 },
      { 0xc1414,0x1309d,0x3a213,0x35374,0xc43c9,0x0765f,0x9ce06,0xdf5f7,
        0x3207a,0xca6ff,0x5d4cf,0xb1fa8,0xb6f18,0xe995a,0x72e63,0xf5c42,
        0xb3002,0xe4a82,0x21a09,0x7f161,0xb9714,0xb65d1,0xe2682,0x20a7f,
        0x3c20c,0x26499,0x67167,0xcb98e,0x099c9,0xb440a,0x673fe,0x5a02d,
        0xb4bc5,0xe1251,0xf3fa9,0x38ea3,0x4a053,0xdbc47,0x6cb75,0x7b09f,
        0x4044b,0x093cb,0x04346,0xda188,0x26767,0x8ceac,0x42209,0x97851,
        0x235ba,0xb2b55,0x11bfb,0x00006 } },
    /* 86 */
    { { 0xad2a1,0x5ef00,0xdbaa5,0x90d7b,0xe14a2,0xefa85,0x69429,0xe92b1,
        0xa4768,0x303b4,0x1ec81,0x1bcd1,0x26711,0xbd27b,0x70288,0x0e425,
        0x03c06,0xa3d9a,0x28cf2,0x884af,0xdf318,0x7c8d2,0xb20bb,0xe3aae,
        0xa1462,0x77e2e,0x3b85d,0x58044,0xd3353,0x4ee9b,0x48255,0x81ee4,
        0xa198f,0x9ee6a,0xb2eee,0x5944e,0x4c26c,0x5aa80,0x67c7a,0x82ab1,
        0xf2da5,0xa5a0e,0x2fe21,0xb4760,0xe5a2a,0x70298,0x3b833,0x169cb,
        0x3aa8d,0x440eb,0x6e6c5,0x00008 },
      { 0x93d9b,0x210b7,0xde033,0x5ecee,0x11ddb,0x9fade,0xb64f7,0x68930,
        0xfda92,0xb2f73,0xe4fd1,0xd97df,0x806aa,0xa4dc8,0xb1d92,0x073a5,
        0x76d75,0xd8bc9,0xaf8cb,0x26c08,0x163ce,0xb4abb,0xb0660,0xdcb1f,
        0x300a9,0xd39c8,0xa95b3,0x594cd,0x7335a,0x7eac8,0x7d4b3,0x1f97d,
        0xefaab,0xa220e,0x3d2eb,0x28c8a,0x6f3e8,0x58c90,0x78132,0x85ab7,
        0x2616f,0x17c83,0xc28b6,0x71928,0xd7259,0x33b82,0x6bc32,0xcd719,
        0xa126d,0xb919f,0x3867e,0x00008 } },
    /* 87 */
    { { 0x74edb,0x3e224,0x74fe7,0xe1ae7,0x41a84,0x76639,0x6e32a,0x9c6dd,
        0x329ad,0x5d270,0x4f8bf,0xa4151,0x000c4,0x267b9,0xa37d2,0x3ce2e,
        0x24fae,0x1511d,0x27530,0x1b781,0x4263a,0x14d85,0x2067c,0x1ae0b,
        0x8401b,0xfc20c,0x81f49,0x011b0,0x8f32a,0x9c6df,0x3fb95,0x1e812,
        0xe1d06,0x7c800,0x328dc,0x9a9aa,0x82425,0x76a37,0xc3758,0xb7ef6,
        0xda8b5,0x9f23a,0x93d4c,0x6b6ea,0xf023f,0xb6389,0x14dff,0x89f54,
        0x8b39e,0xa2e62,0xb26bb,0x00004 },
      { 0x18454,0xb45d3,0x30b1c,0x6cb6d,0xfd743,0x3b749,0x46112,0x568a7,
        0x0c726,0x1e311,0xc84fd,0xe1231,0x5c85d,0x403d5,0x6e608,0xa5f8d,
        0xfabf8,0x139b1,0x95b6e,0xdce03,0x33cfe,0x6d68c,0x110fe,0x94b91,
        0x0381f,0xb71d9,0xdcc6e,0xea812,0xbf0a8,0x90ca2,0x4137e,0x59e80,
        0x25c5a,0x07c8a,0xeb5fc,0x663cb,0xa5d84,0x9c253,0xa7c00,0x910b6,
        0x15073,0xd500b,0x108f8,0xda4c4,0x58607,0x901e6,0x9c3cb,0x02c3d,
        0x615c6,0xc52c9,0xd697b,0x00004 } },
    /* 88 */
    { { 0x8fb40,0xf0efa,0x0db1e,0x989ce,0xb5ba3,0x021c5,0x9df29,0x809d1,
        0x6fb15,0xe1a8d,0xc1219,0x7b734,0x26b78,0xef05e,0x16814,0x6417e,
        0x796e2,0xdb8f9,0x49342,0x421b4,0xebf84,0x878a5,0x5362f,0xe94a4,
        0x916d7,0x93e71,0xe1196,0xbba3a,0xe9818,0x68804,0xbe957,0xec674,
        0x24f8a,0x4cf84,0xa2607,0xe6ab0,0xd466c,0xc93b9,0x78bdb,0xc9200,
        0x15a98,0xa3b3f,0x870f1,0xfd0d3,0x79d10,0xe785a,0x1d9e4,0xa6124,
        0x8cd80,0xa1e6c,0x6ca87,0x00007 },
      { 0xe48b7,0x56e02,0x357fb,0xe9c64,0x3cc09,0xd14b1,0xcf0fb,0x24069,
        0xf2435,0xa9db5,0xc3b01,0x165c2,0xdf878,0x956da,0x7c4e6,0xe549e,
        0x60b68,0x38bbd,0x2fe95,0xc653f,0xb059d,0x2f856,0xe9b95,0xb377f,
        0x60225,0xc4d3f,0xfe908,0x7328b,0xd6a0c,0x8f5f2,0x2d3bc,0xce6aa,
        0x25050,0x43244,0x72134,0x3ce5f,0xa3d3b,0xe1266,0x51217,0xc1677,
        0x5e43f,0x4a75b,0x7fb89,0x70623,0x51592,0xe3e37,0x7532b,0x15260,
        0x3b7be,0xc66da,0x7e7f2,0x00002 } },
    /* 89 */
    { { 0x15883,0xade6a,0x38f65,0xdb336,0xc66af,0xa7e68,0xde5d4,0xd3f12,
        0x7b6ab,0x10620,0x7b878,0xf9503,0x31c6f,0xacf6d,0xcb264,0xc0d44,
        0xe78c2,0x01f2b,0x63ac6,0x980e1,0xa1636,0x63cc5,0x49b1c,0x95c93,
        0x2cfe8,0x203e9,0x1ec72,0xe0d84,0x17738,0x5fa96,0x7642d,0x6169d,
        0x028e9,0xc1c3e,0xaa776,0x54092,0x6b16d,0xdc564,0x4d993,0x706df,
        0x27fb5,0x97a0b,0xe9c6b,0x1170c,0x09e99,0xc85f4,0x2be53,0xea8e4,
        0x46528,0x37832,0x2e964,0x00000 },
      { 0x8ea1f,0xddae7,0x1540a,0x0e969,0xd7b67,0xa1b74,0x82651,0xf7006,
        0x36441,0xc7f99,0xd7520,0xd6ea7,0x18f97,0xce12e,0xa0269,0x0faa6,
        0x08342,0xa8792,0x590ac,0x44362,0x37561,0x48386,0x08f7a,0xf3814,
        0x6149e,0x0607c,0x78534,0xf584d,0x7733b,0xbbb6f,0x0109a,0x8761b,
        0x8a09a,0x9ff52,0x4eb24,0xae3ce,0x82e00,0x781ed,0xffa08,0x2178e,
        0xc1b25,0x7e864,0xd513a,0x62a29,0xfcc1e,0x19062,0x94e19,0xedb8b,
        0x6527d,0xda4f1,0x39f53,0x00007 } },
    /* 90 */
    { { 0xadc5f,0x88924,0xa5f4a,0xf56d7,0x6a818,0x646c1,0x95495,0x7795f,
        0x49129,0x000ec,0x19c54,0x753dd,0x42b48,0x5912b,0x36b20,0x16fa2,
        0xa4946,0xf3e87,0xb3d65,0xd0666,0x1045f,0x174a0,0x140a7,0x12a5e,
        0x50313,0x23b63,0x96b86,0x4b44a,0x5a79c,0xb003d,0xd659a,0x7a339,
        0x6f31a,0xc6382,0x72f30,0x90cdc,0xc6f70,0xe7390,0xe24b4,0x906eb,
        0xc6c36,0x5a59a,0xba450,0xf06db,0xa39a7,0x8c413,0x1e1c5,0x83999,
        0xe0e84,0xffa20,0x20c23,0x00000 },
      { 0x74661,0xdaafc,0x20e4a,0xc0651,0x3277f,0xbbcf6,0x79937,0xb6dce,
        0x49cf6,0xa1410,0xb161b,0x6b537,0x25b8d,0x610fb,0x431a9,0x22218,
        0xde769,0xd1dfd,0xe9ec9,0x0630d,0xd42d8,0x2bfa4,0xf4bd3,0x6244d,
        0x5702a,0xfb388,0x5592d,0xd1ed4,0x8cded,0x4e01b,0x45bfb,0x0e1df,
        0x215b0,0xd286e,0xf4bde,0x7e6a8,0x76a93,0x93548,0x72380,0x8130f,
        0x278ba,0xf8415,0x8a821,0x46923,0xac6dc,0x8b4f8,0x119fd,0x2207b,
        0x69cef,0x53f92,0x6e7bf,0x00007 } },
    /* 91 */
    { { 0xbd187,0x2827e,0xf1284,0xadbb5,0xbb65a,0x3320a,0x6958d,0x72258,
        0x2765a,0xabb04,0xf0986,0x33f98,0x3da3f,0xbff50,0x7a7ae,0x41180,
        0xf71a5,0xca825,0x5c776,0xf24b2,0xdff7d,0xde7be,0xfb4c0,0x165f1,
        0xb0f42,0xe3da8,0x31f3a,0xf7377,0x25f3f,0x3e0a5,0x7e719,0x4cd1d,
        0x3ba46,0xa3b6b,0xdf84a,0x37828,0x7aa1f,0x84b89,0xac7ba,0xe7733,
        0x960cc,0x216e7,0x0981a,0xd6ab5,0xd4d46,0xbb80e,0xc257c,0x1ec12,
        0x6ef09,0x272b9,0x9e7ad,0x00007 },
      { 0x0caae,0xdc8f3,0xcd970,0xbef43,0x10a6e,0xcabcf,0x16d85,0xc7146,
        0x1863e,0x9863c,0x19e3a,0xdb0b5,0x61c50,0xcb13d,0x96364,0xf39b8,
        0x47b69,0x1f225,0xf67d8,0xb0ccd,0x9d67d,0x57abb,0x1b771,0x88949,
        0xa25ba,0xdcccc,0xa27e0,0x207c7,0x1f689,0xd4328,0xfbe0f,0x34ae8,
        0x0ec09,0x73572,0x5d91f,0x7beda,0x9cdfd,0xf6190,0xe32b2,0x4a039,
        0x10232,0xdc1ec,0xb0d8f,0xd65ed,0xdd3c3,0xe5005,0x6c84f,0x32c91,
        0xbea94,0xac4c0,0xf8c37,0x00007 } },
    /* 92 */
    { { 0xc05e5,0x5443a,0x3ec1e,0x38253,0x4cd8d,0x4a4da,0xe2bda,0x88bf9,
        0x88c0b,0xdc86d,0x53811,0x1dd0b,0x434d7,0xc3aba,0x0d2a3,0x65504,
        0x611be,0x49b61,0xbc409,0x4fa02,0xe279a,0x2d426,0xac31c,0x3b065,
        0xa5aa2,0x90535,0x52ea8,0xa32fc,0x2daa8,0xddad2,0xca79f,0x5a5de,
        0x3b26f,0xfd2ab,0x11f05,0xd81e9,0xbf37c,0xace7d,0xb8c5d,0x90d16,
        0xe44e7,0x4e0e0,0x4f589,0x8aede,0xf15e6,0x92a74,0x999fc,0xafe04,
        0xe7c2f,0xaa970,0xd7703,0x00001 },
      { 0x062a9,0x1d3f0,0x8a4c8,0x20baa,0x8d96a,0x1eb2b,0x101e3,0x864bd,
        0xd98df,0x1466d,0x413b6,0xf5924,0x8ba05,0xa555f,0xa0de9,0x51a67,
        0xb52d1,0x972e4,0xcc2f0,0xab23a,0xc7184,0x5daae,0x91bab,0x7c7f6,
        0x8b43e,0xf4ce0,0x6c427,0x530b7,0xc520e,0x23ebd,0x069e4,0x7d352,
        0xf14ce,0xe834d,0xb5e39,0x05ac6,0x54463,0xcbf29,0xdc13d,0xfe34c,
        0xcb2e1,0xfb682,0x11f5a,0x45d11,0x9d4ac,0xf296f,0x3cd47,0xc5ef6,
        0x20871,0xec93c,0xa2c40,0x00000 } },
    /* 93 */
    { { 0x747db,0x4faf5,0x9bc38,0xb86b0,0x6c06a,0xad608,0x5473b,0x9e7c1,
        0x6882e,0xbfa40,0x5977a,0x26d15,0x02d53,0x81deb,0xa05da,0x063a9,
        0xb6111,0xa7524,0xa86e4,0xeb909,0xa4ab2,0x02f87,0x0ba14,0xd5c60,
        0x721d4,0xbf7d0,0x289fd,0xd9a9f,0x71a2f,0xde6f0,0x66dec,0xf5dce,
        0x9fa73,0x77dab,0x21712,0x4bab6,0xf6c47,0x2dc49,0x0336d,0x76eed,
        0x17e1f,0xd3dc0,0xda825,0x75c04,0x3b971,0xb05e4,0xe3d54,0x6c297,
        0x9c87e,0x4656c,0xefb45,0x00002 },
      { 0x1c064,0x008b2,0x4712b,0x629ea,0x24a70,0x86fe4,0x0afd1,0x9b74f,
        0x5b340,0x29643,0xec9e6,0xaa437,0x86965,0xc60d0,0x673c4,0xdda14,
        0x057aa,0x70bf3,0xb6566,0x6f600,0x03ce8,0x05e84,0xa167f,0x04401,
        0x073a9,0x7ec05,0x94e60,0xe6382,0x616b1,0xcf704,0x25269,0x20783,
        0xe7d3a,0x1be8c,0x94114,0x053d2,0x37577,0x8ad8d,0x30dd3,0xcaa66,
        0x68fb3,0x50dba,0x95043,0xaff1e,0xbecbe,0x2d760,0x6d51d,0x9f516,
        0x891e4,0xce462,0x37532,0x00003 } },
    /* 94 */
    { { 0x0bb9b,0x533a0,0xf1118,0x66853,0xe45f6,0x2ffba,0x24d2d,0xd4aee,
        0x11a85,0x6e9ae,0x34185,0x1e1b0,0xf18ba,0x31349,0x17827,0xa9ac8,
        0x715b5,0x4a545,0x13dfd,0xd2eac,0xc5daa,0xf7423,0x6a7a5,0x535b7,
        0x483b9,0x9b30a,0xf873e,0xada4f,0x592e9,0x3a105,0xd8472,0x15662,
        0xac4e0,0x7b8ed,0x93549,0xfa70b,0xa39d8,0xb6441,0x89f61,0x40d15,
        0x1d756,0x0a154,0x0a05f,0x4237f,0x86299,0xb2890,0x0346b,0xfd8b0,
        0xd32bf,0x5dd4c,0x92a2b,0x00001 },
      { 0xced07,0x28365,0x35766,0x1d1f6,0xb05de,0x9f32f,0x7aa02,0xbf40a,
        0x7b9bc,0x476d1,0xbb50a,0x2a089,0x81b1b,0x5a627,0xbbb79,0x9389a,
        0xfc19b,0x0fb34,0x2cff6,0x87395,0x2387d,0xab949,0xcd6f3,0x6920c,
        0x053e6,0xf0a8f,0x3a9b4,0xdd4b6,0x93ef2,0xe8212,0xde151,0x9ab0e,
        0x8bfa1,0x0b083,0xfba0c,0x11bea,0xc9ffc,0xd5a7a,0x8782b,0x95cc0,
        0xbfd95,0xc6058,0x8c2f0,0x48a3f,0xa686d,0x9b31b,0xaaf1d,0xc33ab,
        0x0c268,0x893bc,0x32e22,0x00006 } },
    /* 95 */
    { { 0x1ccca,0x2015a,0xc851d,0x2bc31,0xc7e52,0xfe290,0x0534e,0x18eab,
        0x41d55,0x170b7,0xc85e2,0x6197b,0x9ae65,0xcf8b2,0x41e01,0xae131,
        0x48478,0x93669,0xe2cb5,0xd8ae2,0xfc31b,0x57bb0,0x788eb,0xc264e,
        0xef5d6,0x86dec,0xcb96d,0x56cc9,0xa6fa8,0x9183d,0x81327,0x2db16,
        0xd796a,0x20383,0x03f38,0x6fedf,0xf1d0c,0xa456f,0xd9b58,0x8a6ab,
        0x89805,0x19255,0x3f96f,0x52c58,0x7339f,0x7e9ea,0xd8fda,0xcf6de,
        0xccd45,0xc15d1,0x8c3d9,0x00006 },
      { 0x392b7,0x65e6b,0x7e262,0x95096,0xf775d,0xc1d9b,0x4f7ce,0xd7651,
        0xabcd4,0x1ce16,0xde72e,0x59b20,0x3d86f,0xdfb03,0x3cd1a,0xa66e4,
        0x457cc,0x4005e,0xb3443,0xdaa2d,0x65681,0x7a791,0x731b6,0xf0114,
        0xe7bab,0x61c32,0x3b1e9,0xe16ed,0x6066f,0x3d26e,0x98ef6,0x924e2,
        0xadd6d,0xd8541,0xbea0d,0xf9719,0xf9982,0x9500d,0x6acef,0xc5f07,
        0x76e63,0x6b5c8,0x23d39,0x2ae5b,0xa55e1,0xc6747,0xb362e,0x09efb,
        0x286a5,0xee233,0xf2055,0x00008 } },
    /* 96 */
    { { 0xc1af0,0xe3b82,0xa4ab9,0xe2644,0x7f2ca,0x65e9e,0xd46fc,0x60187,
        0xaac0a,0x634fe,0x393b3,0xf335e,0xe27d3,0x9bacc,0xc0081,0x9c9f7,
        0xa6611,0xb5b8a,0xf7418,0xae953,0x7372a,0xa9455,0x589ff,0x8db38,
        0xd7804,0x1c937,0xf1fbc,0x86df6,0xed10c,0xf0a0c,0xd89a2,0x48aeb,
        0x439eb,0xa2367,0xe5d5f,0xd2d8a,0xb3f17,0x3a6a0,0x89410,0x411d9,
        0x3f68a,0xa2f23,0x18b67,0xe8b32,0x67fec,0x19bf0,0x40f23,0x04225,
        0xd322e,0xc9340,0x292c8,0x00001 },
      { 0x6463d,0x87038,0x5eb55,0xd97ff,0x20371,0xbbc2b,0xc5ad4,0x0b819,
        0x64571,0x411b3,0xf04ad,0x42d6c,0x10cbb,0x939ec,0xc7666,0x5d819,
        0x847e7,0x13a01,0x745ac,0x32e48,0x21c72,0x704b0,0x7804f,0xacb05,
        0xe58a0,0x952c9,0x561e2,0xb8b3b,0x59523,0xf9ba3,0xf0079,0x3384d,
        0xa9628,0xc21ea,0x8231f,0x2b907,0xf8aea,0xeac54,0x263a2,0x30d1c,
        0x5ed77,0x00807,0xb3390,0x4ed5f,0xaacb4,0x11293,0xac2f0,0x92546,
        0x21764,0x2beb8,0xc7876,0x00007 } },
    /* 97 */
    { { 0x902b6,0xfb067,0x8f7d6,0x5980b,0x3d173,0x823a4,0xdddb2,0x59741,
        0xcfb12,0x5c062,0x033f9,0x1b074,0xc6e39,0x589b8,0x0a368,0x3831d,
        0x290f2,0x49522,0x3474d,0x1f3ae,0x6222e,0xab14d,0xd394d,0x53f08,
        0x0fcde,0xf58f0,0x07f28,0x17ae7,0xc5599,0x8e607,0x0ba06,0x166aa,
        0x1f824,0xe7d7e,0x02713,0x328f6,0x04d6a,0x25554,0xd2a7c,0x9890c,
        0xe3264,0x0a0d2,0xca0b2,0x7944e,0xcf220,0xf4e09,0xc0752,0x5c98d,
        0xde81d,0x04d84,0x94035,0x00006 },
      { 0x07206,0x66e54,0x8b7b3,0xfa8cf,0xf0d88,0xcf54c,0xe6f1e,0xf7272,
        0xfe548,0x686fe,0x1ab44,0x13728,0x8d653,0x47440,0xf0e4e,0x52cb5,
        0x0737f,0x3a649,0xe426b,0xd0719,0xb4980,0x76c19,0xcaf25,0x0f272,
        0x34628,0xc991f,0x68f31,0x0a4f4,0x978e6,0x844d8,0x32990,0x8776a,
        0x1582b,0x0cb95,0xa5570,0xadbf8,0x514b1,0x1af36,0x3efab,0xfbd34,
        0xbff92,0x3422e,0x7d81f,0xfb01b,0x132f9,0x6b30e,0xe06ba,0xad850,
        0xf9546,0x27bc5,0xda9e0,0x00006 } },
    /* 98 */
    { { 0x490ce,0xc25c9,0x1eee4,0x83812,0x30df6,0x6ec4a,0x68ea9,0xa4a93,
        0x607e0,0xf3e6c,0xbc262,0x492a4,0xfd8b0,0x0c34f,0x21046,0x0846a,
        0xf33cd,0x6428d,0x7ff7a,0x7612f,0x42182,0xc5504,0xd0110,0x149bc,
        0x5fce9,0xdc9d2,0xfc613,0x11cdc,0x57256,0xf51ce,0xe8897,0x159f7,
        0xc08b5,0x314e8,0xfa3bf,0x538f3,0x575e7,0x15611,0x020ea,0x91c84,
        0x0a951,0x0ad1e,0xf02ad,0x68bac,0xf0d22,0x8b8e5,0xac405,0xa04c6,
        0x15912,0xb9b35,0x73b40,0x00007 },
      { 0x1cfd2,0xdc363,0x0ff2c,0x37bc0,0x38077,0xc4c2d,0x27014,0x338a5,
        0x0616a,0xded60,0x32cab,0x306db,0xad0e3,0x0b17c,0x8eaa7,0x33673,
        0x353ee,0x8d79f,0x2f4aa,0x3ad3f,0x9576f,0x2f6ad,0xce071,0x89b2b,
        0x79852,0x30e42,0xa92ca,0xf94dd,0x905d8,0x492dd,0x475d8,0x9891d,
        0x5e4bd,0xca4d1,0xe06a5,0xabbd3,0xb254e,0x25d4e,0x13c47,0xc0ed5,
        0x94ace,0x6c313,0xbfaae,0x9859b,0x77e0f,0x3fd13,0x54683,0xdc125,
        0xc4f75,0x85c56,0x2b463,0x00001 } },
    /* 99 */
    { { 0x951de,0xbd932,0x10dbe,0x9c948,0x25aa6,0x959d4,0x08d96,0xecb2f,
        0x49c04,0x2c5fc,0x250b8,0xf0cc2,0xdac74,0xec4e1,0x9a53a,0x96a43,
        0x99acd,0x9a904,0x33cab,0xb3afc,0x654d9,0xccde6,0xe8b2f,0x3863a,
        0xf285c,0x88f4a,0x6febf,0x373e4,0xd2373,0x9ab7e,0x72c3c,0x751d6,
        0x2020c,0x30fe1,0x1c511,0xe56ec,0xf52f3,0x82402,0xa81ad,0xa4a64,
        0x9ab7a,0xf2348,0x9f163,0xb661d,0x70a1f,0x55331,0xbe10e,0x17c69,
        0x8d417,0x5e7d8,0x1c193,0x00006 },
      { 0x2ae43,0x9b349,0xe722d,0xf05a2,0x50538,0xf89d9,0xb631e,0x200aa,
        0x7e588,0x17ae7,0xba4b1,0xc120e,0x82872,0x461cb,0x2c83a,0x5c243,
        0x38f26,0x34cb9,0x15b34,0x7dc03,0x58c4c,0xbf2ac,0x78d05,0x596b3,
        0x501dd,0x30d2e,0xb890c,0x6c9fc,0xca850,0x361f0,0x4617c,0x3d0af,
        0x5cbae,0x185a3,0x1f7b7,0x01382,0x1f3fc,0x1035f,0xedfbd,0x8b248,
        0x28af5,0xe0746,0x8c9ca,0x21d04,0x38d64,0xa1877,0xa392c,0x75e3d,
        0x3db94,0xf271d,0x7ad0d,0x00002 } },
    /* 100 */
    { { 0xb5aed,0x79305,0xe3bda,0xd6a79,0x45998,0x67d4a,0x7002c,0x0f7eb,
        0x5e1d3,0x44c85,0x47d1c,0x7e9e1,0xdc18a,0x9540e,0x618c8,0x3ea99,
        0xbfd20,0x0a7e6,0x53be2,0x4437a,0x4ecc1,0x487e6,0x5c6c9,0x34ef8,
        0x79207,0xd5729,0x5e1eb,0x4e71d,0x6fa0d,0x48d6b,0x1e64d,0xfda2b,
        0x200d4,0x0566e,0x82a1e,0x66a17,0xa5a53,0x3c70d,0x7382a,0x1a473,
        0xfbd2b,0xe8fe3,0xfe020,0x8c067,0x5d7ef,0xcfb66,0xfdeea,0xec686,
        0x1542f,0x276dd,0xd9b5e,0x00005 },
      { 0xe472e,0xa5cb3,0x637c5,0x405e3,0x730a1,0x53d92,0x55821,0xb4498,
        0x992e5,0x51009,0x39a08,0x0ccdf,0x018f0,0xc6c56,0xc11b5,0x26237,
        0x3540e,0x08134,0x18ed4,0x31844,0x07e7f,0xf7cbf,0x76bfe,0xbf485,
        0x92366,0x1aecd,0xc94c9,0xbe1ab,0x61b75,0x16227,0x8de4a,0x8e177,
        0x6bcb8,0xd3c5c,0x52e57,0x1858c,0x75ab7,0xc382c,0x9f95c,0x3f6e3,
        0xc2c28,0xfce12,0x62735,0x0ef2d,0x64c7e,0x5a599,0xeb183,0xe071d,
        0x8c766,0xcdcbb,0x4f891,0x00002 } },
    /* 101 */
    { { 0x8c1e2,0xbf677,0x4ef60,0xbe5c2,0xd00d5,0x49c03,0x09fff,0x2f01a,
        0x1986e,0x58ec1,0xe096e,0x28a4a,0xc59a7,0x77984,0xedb70,0xaabbc,
        0xca5a5,0xd2870,0xb473b,0x0e3df,0x14de3,0x928c6,0xbca8c,0x4f67a,
        0xe7f9a,0xcf3fa,0xc21a9,0xb2ebe,0xe83c2,0xd9b5d,0xd629c,0xafa70,
        0xb18df,0x59c60,0xdeaea,0xb54ca,0xe4049,0xfef7b,0x0e3d5,0x6dd31,
        0xebc76,0xccfce,0xf6321,0xefe38,0x57748,0xee8af,0x2b118,0xfe9c3,
        0xdf612,0xcfd42,0x63ac3,0x00008 },
      { 0xa2fe2,0xa7b85,0xa36fc,0x9dc60,0x8ee42,0xe70d0,0x944f3,0x141c3,
        0xba209,0x0a8c9,0x7272a,0x81066,0x6306a,0x68bd0,0x555f9,0xe69a1,
        0xc603d,0x47153,0x86f7e,0xe4fab,0xaef56,0x06614,0xb4c97,0x98780,
        0xc36b8,0x63c0d,0xa1d32,0x7fe23,0x94365,0x5522c,0xa8643,0x01f97,
        0xef679,0xf6edf,0x91897,0x17a0d,0x46daa,0xbe31d,0xfbdeb,0x85acc,
        0x79100,0xde6f1,0xf9fc1,0x6e328,0xce0da,0xe7142,0x3dbe1,0x1c9d5,
        0x6725a,0x1e8b8,0xe3f1b,0x00003 } },
    /* 102 */
    { { 0xfbf05,0xc07b7,0x7ea15,0x3882b,0x61f1a,0x2f11b,0x1bc99,0xd1dcd,
        0xdd95a,0x8bc9d,0xd0f7e,0xb7faa,0x931f5,0xa7ab7,0x5ebfc,0x2936e,
        0x55be6,0xdc19a,0x0f417,0xe5543,0x343cd,0x6f4e4,0x4bf1f,0x82f04,
        0xf5e65,0x08971,0x288c4,0xb8e44,0x573c3,0x07f57,0x59fb8,0x61aac,
        0xb58f0,0xdd818,0x64ee2,0xb0d3a,0x097a3,0x7a0a6,0x0586f,0x0394b,
        0x5ecc8,0x7d8b8,0xfb351,0x9474b,0x69a05,0x9c3f0,0x977a7,0x89ad5,
        0xa8025,0xd8700,0x1208e,0x00008 },
      { 0x4ce37,0x9914c,0x09350,0x48a61,0x3a1aa,0x4bb84,0x8e8f3,0x580d5,
        0x07024,0xba860,0x375b8,0x2c49b,0x36db4,0x3bde8,0x524ed,0xac365,
        0x233b6,0xb4649,0x521e1,0x946f5,0x564dd,0x7cc5d,0x6aebc,0xbfb5b,
        0x4b035,0xa39c1,0x146c1,0xba180,0x57f22,0x2214f,0xbbc87,0x0b62f,
        0x21764,0xf7b49,0xacfd7,0x6df13,0x1cb4d,0xf10da,0xa915f,0x62600,
        0xe2620,0x7f660,0x1d916,0xda9d8,0x97ac7,0xe7a19,0x60cb6,0x6e8e2,
        0xeb3c2,0xb880d,0x4383f,0x00004 } },
    /* 103 */
    { { 0xf9af6,0x1de44,0x107f0,0xfa1ce,0xd8cb1,0x381a4,0x49336,0xfb7dd,
        0xbe3ec,0x9fe65,0x6a883,0x435a2,0x8d0b8,0xc789d,0x9153e,0xee60f,
        0xc5e1f,0x502bc,0x25fea,0xa81ce,0x57e44,0x77c0c,0x5b804,0x230ba,
        0xe9f83,0xd9349,0xe180d,0xf32fd,0xcdd42,0xa3d11,0xeaf64,0x8b039,
        0x7083a,0x4ebeb,0x0ef88,0x42cb8,0x4f127,0x8e60c,0x26228,0x720a0,
        0x56cc5,0x7f441,0x253b7,0x7de67,0x9cd54,0x013a5,0x6eca6,0x9829a,
        0x48445,0x8f0d5,0xaee70,0x00008 },
      { 0x54409,0x9c32c,0x8f22d,0xaac41,0x675eb,0xebfa4,0x981a9,0x86284,
        0x2e928,0x0c90e,0xb3a8e,0x1f6f6,0xed020,0x77641,0x16cbd,0xc9730,
        0x70575,0xf0701,0x926f2,0xce01f,0xffec0,0x84048,0x30449,0xf319d,
        0x96211,0xc4bf6,0x91a88,0xc844c,0x274b5,0x030a8,0xbcee0,0x4c40f,
        0x6d521,0x25e4f,0xed675,0x7d1eb,0xc29d6,0x7e47c,0x536af,0xc21d3,
        0x07db8,0x05fa3,0xbb294,0xc46ab,0xf56b6,0x3e805,0x7e303,0xf059a,
        0x6a5a0,0xfe609,0x70f61,0x00009 } },
    /* 104 */
    { { 0xc8e4a,0x231be,0xbc53d,0x034c1,0x435a6,0x09ac1,0x64d88,0x509e4,
        0x081da,0x354ee,0xa4882,0xe1fd8,0x6496a,0x5864b,0x86332,0xa1ae9,
        0xd069f,0xe974c,0xaca13,0xa6b4b,0x8b1d8,0x38cc5,0xda437,0xe76b9,
        0x71f58,0xfb5fa,0x7eb16,0xbe88c,0xdc919,0x4e429,0x13fad,0xf5c8f,
        0x9f9ed,0x71249,0x583b6,0x8bd74,0x5a10d,0xe2011,0xb7ebc,0x5790b,
        0xd7605,0xddf66,0x82b78,0xaede4,0xa9316,0xf855f,0xb2d75,0xe0d8f,
        0xdcca7,0x945a7,0x04b5b,0x00004 },
      { 0xa15c7,0x2a517,0x9ee68,0x0202f,0xcef88,0xe4cfb,0x354aa,0x5106a,
        0x2c139,0xe7cee,0x70feb,0x01921,0xb5de6,0xd0c54,0x9fd73,0x589e3,
        0x092b7,0x358c9,0x95c71,0xfe5f1,0xf0a7b,0x7ed53,0x979cb,0xf61cc,
        0x9242a,0xd92bd,0x395f7,0xf16c5,0x98d2e,0xb32f0,0x1ca70,0x0d4ac,
        0x185c1,0x6d52d,0x58752,0x6195a,0xa942d,0x32b04,0x0ac29,0xa500b,
        0x5a979,0x30fe2,0x62fd2,0xf4ae5,0xc5fa1,0xda253,0xaf220,0x60f55,
        0x46002,0xb5831,0xfaa11,0x00007 } },
    /* 105 */
    { { 0x02149,0x0c6e4,0x0ba4f,0xc119b,0xd963c,0x84cc1,0x47635,0xa6527,
        0x0dc1a,0xf2774,0x95715,0xff75c,0xe3f77,0x89fb0,0x4ad3f,0xb2f23,
        0xbe3ff,0x32ef9,0x51590,0x7e825,0xd0423,0x9fb21,0xd93fc,0xa153e,
        0xeff38,0x13eb2,0x0041d,0x3ae01,0x889d5,0x1bd82,0x45b7f,0xcf2e5,
        0x53ea5,0xce439,0xd4a27,0x75c8d,0x4d85e,0xd2e5d,0x1c300,0x241be,
        0x3ed62,0x2deb9,0x24203,0xf25f0,0x11e53,0xa4e70,0x636c3,0xb9957,
        0x8febf,0x52ed9,0x4b63a,0x00001 },
      { 0x43336,0x5371c,0x610b5,0x824b7,0x623a4,0xdfd4a,0x51b19,0x02860,
        0x7a2e0,0xdb7b9,0xf5f1e,0xbb9c8,0xd86ab,0x67daa,0xd779b,0x67a57,
        0xffafb,0x6dcd5,0xace50,0x3c638,0x589ac,0xda9f9,0x15085,0x75a3d,
        0xcbaa8,0xd2081,0x9346e,0x3d8fe,0xd0335,0xf9a02,0x1f1a1,0xb2ab6,
        0x59c71,0x373a6,0x0cb09,0xf8a1b,0xb4f5d,0xe0e30,0xa1db7,0xeb7d5,
        0x4c741,0xf077c,0x28e5c,0x6c9c7,0xc8f04,0xc171a,0xbc7f7,0x32dd0,
        0xd2655,0x73836,0x24858,0x00000 } },
    /* 106 */
    { { 0x4cd8d,0x2375a,0xd40dd,0xba78c,0x397bc,0x2ca43,0x1f513,0x258d6,
        0x5cd84,0x6830c,0xa1e8e,0xc059d,0xa0a7e,0x65d40,0x1711d,0x07a8f,
        0x50d76,0x5ef43,0x69e65,0xae428,0x05983,0x8ce6f,0xbd0b9,0x9d8be,
        0x1391d,0x497b6,0x1ba5d,0x9e25b,0x63a52,0x6b2cf,0x2e91f,0x46f73,
        0x3b629,0x6a3fa,0xd66ec,0x0ed2b,0xcc3ef,0x7950e,0x47639,0x5f08b,
        0x008cb,0x2eee9,0x65a0e,0xe4259,0x7fd6b,0x77bc8,0x13c11,0x78ed5,
        0x12dae,0xdffe5,0x798ce,0x00006 },
      { 0x7c5c6,0xfd1b9,0x9e3f8,0xb33f4,0xe78c3,0xfbab3,0x5ba39,0x40f59,
        0x74412,0x76442,0xd7d43,0x25b95,0x71742,0xc4477,0xfcc79,0x880b3,
        0x6b245,0x83329,0xc3aca,0xe184d,0x71734,0x913df,0x47255,0x9c934,
        0xb23d3,0x11a4d,0x1420a,0x3733d,0xccebb,0x608bd,0xcf9f3,0xb9d20,
        0xfe13f,0xf630c,0x618ac,0x874ca,0x15f30,0xf06b3,0x5a575,0x9f000,
        0xefe7f,0xdb506,0x1bfc9,0xa78c0,0x18aae,0x8e7c4,0x255f7,0xf9179,
        0x96395,0xd252e,0xea7ae,0x00003 } },
    /* 107 */
    { { 0x6ae25,0x045b0,0x8617e,0x50ef9,0xdcb57,0xac148,0xba2bc,0x604c2,
        0xa2f0e,0x7591e,0x6b789,0x9f6b7,0x100c1,0x1da18,0x6d065,0x79b9b,
        0x5705b,0xebc94,0x3225b,0x5bf1f,0x35c00,0xb435f,0x86d30,0xbc24d,
        0xb4482,0x77440,0x63737,0x0996d,0xc2b8f,0x44b4d,0xc561c,0x65fd6,
        0x06999,0xe6309,0x9405e,0x1ec1e,0x408aa,0xff092,0x89519,0x3d2f2,
        0x3246a,0x97eef,0xc7467,0x3765b,0xe016c,0x705f7,0x69fd0,0x62d25,
        0x50044,0x9c052,0xa8ad3,0x00006 },
      { 0xe7282,0x0d46b,0x45f02,0x0f12e,0xd2138,0x05afe,0xad094,0xd5da6,
        0xca5bd,0x1e4cd,0xf8be6,0xf1847,0x8c2d6,0x6b817,0x95359,0x20132,
        0xdf954,0x7b7a8,0xd3b1e,0x2b4d8,0xb3957,0x7c61b,0xb5675,0x80cc3,
        0x9b57b,0xecd74,0x7b3ff,0xff933,0xd9590,0x5dc94,0x65314,0x39bbb,
        0x5e573,0x06233,0x0c1c6,0xfeba7,0x7f763,0x2e72d,0x7329c,0xcc61b,
        0x8e424,0xca476,0xa73f2,0x2fa6a,0xd777d,0xcb58c,0xbaac5,0xdee4d,
        0xae1aa,0x799cf,0xa1811,0x00001 } },
    /* 108 */
    { { 0x75ed0,0x2f775,0xf6ff6,0xa99b6,0x97d1d,0xf14fa,0x7f618,0x69efd,
        0x2aefb,0x332e7,0xdc286,0xb4cbd,0x4c45a,0x6c583,0xd4858,0xb0e20,
        0x75dd8,0x1a397,0x39701,0x4498d,0x8f413,0x30c80,0xed801,0xf5115,
        0x08eba,0xd92d4,0x260de,0xa05c0,0x1c506,0xcab91,0x36219,0x9e5b7,
        0x93a86,0xc6e86,0xcf508,0x36174,0xfcc77,0x71245,0xca34e,0x95d89,
        0x1aa1f,0x982f7,0x07bbc,0x7c6a6,0x24bba,0x2b7fd,0x5e721,0xf3a51,
        0x0f5a8,0x75923,0xd2ddc,0x00007 },
      { 0x2cae8,0x6d4ed,0xd0581,0x03773,0xdb9c0,0xf6bc7,0x8d44c,0x646b0,
        0xe98e6,0x80c23,0xb9c01,0x6c614,0x1f9ee,0x9179c,0xa13ef,0xe11c9,
        0x9688a,0x7e8ed,0x5b614,0x70a7a,0x8d066,0xfeb64,0x2757a,0x17685,
        0x0333c,0xf2d67,0x5f9e8,0xd9697,0xea89d,0xa68ad,0x28d37,0xbb572,
        0xcb186,0x5e454,0x1a05d,0xd5502,0xf063d,0x10158,0xaf348,0x4cb6c,
        0xd4f08,0xe792d,0x854ab,0xd8527,0x670c4,0x729d7,0x9dc6e,0x84596,
        0xf40ba,0x7ab1b,0xa52f8,0x00005 } },
    /* 109 */
    { { 0xcacbd,0x9109e,0xd019e,0xbdeae,0xd7b89,0x44023,0x71e65,0x57073,
        0x51f0b,0x177cc,0x6c8e2,0x2b041,0x51483,0x259ab,0x68281,0xb1aa6,
        0x361d4,0x9223e,0xe100f,0x5c2a6,0x9e3a9,0x93eee,0xe26e5,0x16c10,
        0xb6bbd,0x3f699,0x473a1,0x78739,0xcad48,0x74987,0xdc5b2,0xf1c14,
        0x9e2e9,0x75255,0x7dc00,0x7ad25,0xdc3d4,0x49849,0x79384,0xdd527,
        0xf278a,0x9983d,0xefd5b,0x3ec8e,0x0770e,0xbd02a,0x44676,0x2ae58,
        0x05ffe,0x643e7,0x7f027,0x00001 },
      { 0xbea1f,0x0d29a,0xda401,0xac4cd,0x52407,0x6b969,0x18b63,0x04332,
        0x60129,0x4a96a,0x63d53,0xfc3b1,0x5f221,0xc2056,0x5becc,0x05ba1,
        0x85577,0x4d962,0x238e5,0x04d31,0x78788,0x14425,0xfe41b,0xa89a9,
        0xbf304,0xb196f,0xbe642,0xf06c4,0xec8a7,0x2b085,0x0e86e,0xdd1a2,
        0xa591d,0xc2ff4,0xf7f27,0x43b88,0x3a4a3,0x7b075,0xd4dc1,0xbb173,
        0xb1e88,0xbe684,0xdc07b,0xea443,0x73acc,0x441d7,0x88d4c,0xdb15c,
        0x5957e,0x9a53e,0xef030,0x00000 } },
    /* 110 */
    { { 0xe5b60,0x21fa8,0xfc257,0x0bb24,0xd691c,0x6938a,0x24864,0x0b0a2,
        0xd4b76,0x77e46,0xde168,0x9ac27,0x0863f,0x21c63,0x6ef27,0x503bb,
        0x7fb02,0xdf0b6,0x8c199,0xbd39f,0x2e07a,0xc1ed7,0xdda78,0xb32f0,
        0xdeb7b,0xf3cf9,0xc3c89,0x26f06,0xaaff7,0x72225,0xb2d19,0xb7008,
        0x45f5c,0x174f1,0xf5a61,0x4f378,0xc457c,0x0e6f8,0xc644e,0x1c453,
        0xdaa44,0x808bb,0x6e92c,0x326da,0x157be,0x77356,0xfd95d,0xa9bc3,
        0x7b72a,0xc6bb3,0xd3b6c,0x00003 },
      { 0x2c880,0xcc972,0xe6f12,0x68896,0x7286b,0x1b6ae,0xfec3a,0xad2fa,
        0xcc09b,0xefba1,0x3bb8b,0xad7a4,0x3ad64,0xc3f4c,0xa0097,0xa5af6,
        0x3a91b,0xd9c35,0xafcb0,0xbf6b2,0xb69cc,0x13fca,0x190ca,0xf2abc,
        0xa1391,0xe5699,0x3a247,0x55422,0xa2dbd,0x488d9,0x80f95,0xe2061,
        0x4cc3c,0xff124,0xa9e7b,0xa365b,0xe87d3,0x297ab,0x5e229,0xfa4ca,
        0x4fa38,0x6c405,0x7be1b,0x623d6,0x4b390,0xf41a4,0xc5778,0x1fa67,
        0x544e7,0x43c7b,0xe946e,0x00002 } },
    /* 111 */
    { { 0x934ae,0xdfc60,0x980fd,0x06d12,0xf1642,0x3e7ef,0x75a2c,0x416ed,
        0xe7f96,0xdcf75,0xcd0b2,0x0cf35,0xbfac6,0xaad87,0xece1f,0xddc4b,
        0x9e5dd,0x7c984,0x53fa8,0xf1ae7,0x32c1b,0xd516a,0xb4bc5,0x14732,
        0xdbea8,0x6b565,0xe4869,0xbe3ac,0x4007e,0xb9769,0x4d6cd,0x40ca7,
        0x4e7be,0x7065e,0xf5cd2,0x4ebc3,0x13aac,0x847c0,0x3a174,0x43d6c,
        0x2e034,0x6a676,0x67a07,0x8c954,0xd690d,0xda677,0x8d61e,0x768d7,
        0x1d8c2,0x55018,0x997ce,0x00000 },
      { 0xa0b81,0x6c965,0x29774,0x2dfa9,0x6e5e1,0xb58be,0x37f48,0x715f4,
        0x3b3c4,0x59557,0x565c4,0xe907b,0xce425,0x82797,0x51215,0x4f43f,
        0x5474f,0x6f8ea,0x5dafa,0x04ace,0xe13de,0xeb8fb,0xc832a,0xe8a07,
        0xf95f0,0xfeed7,0x62c09,0x2a6e6,0x73e01,0x42cf1,0x9b8c7,0xbf96e,
        0xa1c45,0x9ae28,0xea575,0xe2f38,0x45cf4,0x5941b,0x01947,0xf901a,
        0x3c02d,0x2e7dd,0x0916b,0xdeea7,0x8e7a4,0xa9b98,0x2b52f,0x50b27,
        0x17fe6,0x9fd09,0x6f9f0,0x00009 } },
    /* 112 */
    { { 0x10a96,0xc42c3,0x8e8aa,0xa7347,0x3f7a2,0xa9830,0x20732,0x23962,
        0xca83d,0x80c46,0x95412,0x1e6ed,0x1ad13,0xabe91,0xc5e2c,0x5791f,
        0xb6c68,0xeb841,0x0cb77,0x88785,0xa3d3c,0xf93de,0xbceaf,0xf1007,
        0x41f1d,0xfd065,0x5cdf1,0x29c25,0x24ee7,0x3e397,0x31732,0xe0f71,
        0xd08c1,0x41ad4,0x2de7a,0x22bfa,0xfa35e,0x912ab,0x325a9,0x89b03,
        0x0122b,0x4ea05,0x6514d,0x51f40,0xb8b9e,0xd3e0a,0xaad79,0x423c7,
        0x8fea5,0x2640b,0x1998e,0x00007 },
      { 0x6ed78,0xcdceb,0x0140f,0x45164,0x71853,0x3cf37,0xdcc65,0xe8d60,
        0x0b65a,0xf8045,0xdac55,0x1a769,0xcce6c,0x05686,0x92dae,0x8a96a,
        0x12562,0x62127,0xfe447,0x94252,0x0a4f3,0x7bcb5,0xfc274,0xfc531,
        0xc6ff2,0xf0f0e,0x0fe9f,0x34471,0xfc97c,0x792cf,0x7839c,0xfb488,
        0xfb019,0x48026,0x52c52,0xc2905,0xcd804,0x01a29,0xa7340,0x35c8c,
        0xb5ad8,0xa0742,0xee5df,0x1f176,0x1c378,0xfa4ab,0x5f03d,0xca6b8,
        0xd32ac,0x1a0b0,0x38994,0x00008 } },
    /* 113 */
    { { 0x67dff,0xa2de0,0x0f062,0x0162c,0x0bcb8,0xf3269,0x2bdd4,0x0707a,
        0xd990d,0x9198c,0xae4a3,0x63b8f,0x45afc,0x2ad81,0xb7bb3,0x684f1,
        0x9dfb1,0xe2f19,0x0a2dc,0x5848b,0xf48f2,0x60e17,0x86222,0xc2d5e,
        0x3db00,0x71739,0x38cf1,0xf8543,0x29e88,0xacf52,0x42902,0x00679,
        0x5af3d,0xb8683,0x9157c,0x614c1,0x2b8a2,0xaa6f9,0x46c2f,0x134ec,
        0xf95f5,0x3504f,0xb7a81,0x626ef,0x4cf00,0x7a470,0xd05b3,0x454b3,
        0x4ec25,0x31269,0xfbfda,0x00001 },
      { 0x69c77,0x57c8f,0xdebb6,0x88faf,0xba3df,0xa8278,0x8b492,0xc1fb7,
        0xb5571,0x33463,0x1c71a,0x6a1a1,0x0d206,0x9958b,0x14308,0x10c88,
        0xd67a6,0xe0cf9,0x975c7,0x7b8fb,0x87303,0xa5d20,0x861da,0x40bf5,
        0x5005d,0xa95ee,0xdba69,0x6ce77,0x4300e,0x62cc7,0xcb3c9,0x893c3,
        0x84055,0x294cf,0xac986,0x9d700,0xa225c,0x7ef63,0x7e80a,0xb91e4,
        0x84869,0xbefe1,0xc2f84,0x7deb8,0xf1b9d,0xe278b,0x915c0,0x67788,
        0x6f19e,0xcac42,0xf9488,0x00004 } },
    /* 114 */
    { { 0x1b8ce,0xd4dd5,0x10dfc,0x0e806,0x83623,0x57927,0x56208,0x36599,
        0x7ff1c,0x77edc,0x2cae8,0xad4be,0x8905e,0x96760,0x5d9e7,0xa1c32,
        0x8926c,0xddbd3,0xe39ed,0x0a4e3,0x85f6f,0x92c86,0xfa4da,0xf47a0,
        0xf800a,0xabe16,0x5f60a,0xdb5be,0x350b4,0x3853d,0x12f98,0x36654,
        0x9789c,0x509b7,0x4b622,0x72b26,0x84e0e,0x56005,0x2bbea,0xe555c,
        0xd4901,0x11abb,0x7292e,0x19a71,0xf3784,0x74218,0xaaae1,0x6e0b5,
        0x96b92,0x848f7,0x88e06,0x00006 },
      { 0xb8f64,0x41313,0xdfef6,0x7462c,0xb942c,0xf11b7,0xabdae,0x5c0d8,
        0xcfb77,0xa9067,0xf4041,0xa5f0a,0xf608e,0x35210,0xd8269,0x23d5b,
        0x17a08,0xfc279,0xab904,0x2d215,0xe45d2,0xdbb1f,0x59f85,0x4d361,
        0x5e509,0xf2c3d,0xd39b8,0x528e1,0x0aebb,0x4acef,0x828f4,0xdd5ca,
        0x57a54,0xdf20c,0x4209a,0x5f442,0x378f9,0x42b43,0xd3757,0xa9337,
        0xfa7d9,0xb7d11,0x64cfd,0x0c09c,0xcd66a,0xb817e,0xb8f9b,0x56e55,
        0x41265,0xe3e4c,0x723c7,0x00001 } },
    /* 115 */
    { { 0xb43f3,0xd8dc8,0xa6486,0x9e689,0x12640,0x3e0e6,0x003fc,0xd9b46,
        0x9c437,0x7b188,0x284ec,0x03356,0xa3a85,0x9dbae,0x5c46a,0x5a366,
        0x8933c,0x1de97,0xbf694,0x14907,0x06934,0xd5a51,0x02d1e,0x8cb80,
        0xa7b7a,0x59664,0x0ed0a,0x76e46,0x7603f,0x4ebf2,0xba31f,0xc3e06,
        0x38a7f,0x41f2c,0x96ced,0xb08a2,0x9cf1d,0xc18f7,0x3b62a,0xcde7a,
        0x9e882,0x06c91,0xbf68b,0x7d29d,0x515e7,0x947cb,0xbaa4e,0x21978,
        0x0993a,0x2b763,0x4bf54,0x00008 },
      { 0x4f21e,0xa9e36,0x1decd,0x557ec,0x5012e,0x6cf34,0x0e10d,0x588f9,
        0x46848,0xb8ba2,0x3b104,0xda4be,0xa9f6d,0xaef57,0x346e3,0x6bf7a,
        0x27ea9,0xfee83,0x10299,0xe6c72,0x7da95,0x99f48,0x645aa,0xd2cdf,
        0xf813e,0xb824f,0xbd414,0xb2d28,0x1d1db,0xfa1a6,0x1afca,0x06510,
        0xebda4,0x9a9cd,0xd9f4b,0x39e47,0x5e410,0x41b39,0xf42af,0xc50ad,
        0x9e6ba,0x49e3e,0x41e9e,0x33ae3,0x34f21,0x157f2,0x0f3cb,0x4968c,
        0x68153,0x7bda0,0x83f82,0x00003 } },
    /* 116 */
    { { 0x3ff4c,0x21658,0xec46a,0x09e72,0x94ad7,0x645a2,0x12a4e,0xc04ca,
        0x6e9cf,0xe5dc6,0x160a7,0x28f49,0xe82f1,0x9c762,0x7b156,0xbfb22,
        0xdb8e7,0x63c2e,0x80c79,0xf688f,0x649a0,0xdafe0,0x8cca7,0x2d14b,
        0x41754,0xbeb7e,0x6de40,0x5c538,0x13a0c,0xb7933,0x2861d,0xf0d05,
        0xe071b,0x69fbf,0x902ce,0x9903b,0x6210e,0xe4695,0xbb861,0xf703e,
        0xf874e,0xb6fae,0xd5f78,0x947ed,0xaf668,0xf5ea3,0x5475a,0x6fe86,
        0x94625,0x1543f,0xb121f,0x00003 },
      { 0x275e9,0x47659,0xb26e8,0xce505,0xd6d0f,0x581cf,0x1ef47,0x8aa3f,
        0x5cbfd,0x0e55f,0x484e6,0xe315e,0x41e7b,0x9698e,0x20ffe,0xd8f1a,
        0x04784,0xa97ab,0x5d46d,0xdb3e2,0x5834c,0x26db7,0x009a5,0x8d08a,
        0x408d9,0x161fd,0xb5ca8,0x4b205,0x8fc00,0xe4bbe,0xbb365,0x5b3e3,
        0xbb6ef,0x25759,0x50cc1,0xc737f,0x7c2fa,0x5fa81,0x51af0,0xd2739,
        0x102d2,0x679ee,0xecb33,0x540bf,0xf2a8e,0x6a515,0x6fb2a,0x67344,
        0x90c83,0xd1372,0x505e1,0x00005 } },
    /* 117 */
    { { 0xe68a6,0xa1d15,0xc3014,0x35e50,0x664dd,0x9f0b2,0x7f96f,0x03ad6,
        0x3742d,0x8418c,0x2c144,0x8c0ed,0xb7481,0x41a3c,0x1690d,0xc5181,
        0xf3e9e,0x3fc49,0x5c8c8,0x93866,0x12c27,0x260c6,0xe9c9b,0xced04,
        0x86fae,0x58f60,0xd7c47,0xccebf,0x8a7b2,0x297fd,0x13390,0x4b3c3,
        0x01ac8,0xe8097,0xa8264,0x3762c,0x7508b,0x976a8,0xdfe9f,0x983a8,
        0x82714,0xe95d5,0x9d598,0x2669d,0x8350d,0x6fd34,0x9cb0f,0x85cb8,
        0x4317c,0xd4a57,0x17d80,0x00006 },
      { 0x22b67,0x7e700,0xcef26,0xb94a4,0x53768,0x536bb,0x46280,0xd2784,
        0x3a566,0x19315,0x82439,0x4d443,0xa4905,0xf78c4,0x1725d,0x8d11e,
        0x1e35a,0x71d5a,0xb252a,0xe31d9,0x08171,0x866c8,0x00e07,0x1b38a,
        0x501db,0x360a8,0xe7702,0x32b8c,0x02ed9,0xdaf7d,0x6098e,0xa2d77,
        0x006e9,0xabb93,0xaee5d,0xb0363,0x4bbfe,0xffc8c,0x38bfa,0x4e21b,
        0xb9678,0x69077,0xca8e0,0xc59fd,0x1491f,0x93847,0xf550e,0x3f624,
        0x1780b,0x087cd,0x156f5,0x00005 } },
    /* 118 */
    { { 0x6e8d0,0x22020,0x8234e,0xaf325,0x47f15,0xf6f5d,0x50ff5,0xd6389,
        0xb7289,0xf4afa,0xd4495,0x4d097,0x966ec,0xda80a,0xc5d68,0xad890,
        0x8a36b,0x2064f,0x4aa09,0x5c5fe,0xe0f4d,0x9e257,0xe3179,0x24495,
        0x677ae,0x5244c,0x5b8e3,0x87b3a,0x97203,0xa287b,0x0f475,0x70379,
        0x1f2f7,0xc5c3c,0x4895c,0xfa415,0xb41a7,0x680f9,0x08bb8,0xb00b0,
        0x47458,0xcbfcd,0xa6473,0xc838b,0xa149c,0x9be19,0xf7aac,0x78ed5,
        0x765ba,0x9cb33,0x25459,0x00005 },
      { 0xb54c4,0x79a21,0x87396,0x7d9d0,0xab649,0x9ece2,0x64002,0xc8488,
        0xf1a92,0xd9f14,0x9fa79,0xdcffe,0xbae48,0xc208d,0x1c246,0x14b91,
        0x3f69e,0xf2dae,0xab0fb,0xb8385,0xed1ed,0x0ac87,0x6bb18,0x18858,
        0xfd718,0xd0146,0x467cb,0xb6545,0xe210e,0x67cfe,0x40816,0xaa239,
        0xd1a60,0x1ab73,0xb125c,0x1cbed,0x0881c,0x68530,0x232de,0x37c30,
        0x4c713,0x18fe3,0xf3c8d,0x070e6,0x3c6c6,0xaf4e8,0x5bab4,0x07e36,
        0x82b45,0xeddcf,0x2f0a7,0x00002 } },
    /* 119 */
    { { 0xf1b7f,0x1fea7,0x26279,0x09d4e,0xddcff,0x3d8c5,0xc589c,0x39c7d,
        0x2a9c3,0xc086c,0x276e8,0x40174,0x64dad,0xfe1d5,0xf59e9,0x0a918,
        0x810c9,0x702aa,0x8d796,0xcdc4b,0x64aa5,0x7a883,0x72eeb,0xe7afa,
        0xc23bb,0x08fc4,0xac869,0x5c9e4,0xf4dbb,0x0c7e6,0x0136a,0x37e39,
        0x218d2,0x0149c,0x55d70,0x24a28,0x794b3,0x75bc6,0x071e4,0x6287a,
        0xa8dc6,0x3cc98,0xfb432,0x299b5,0x9395a,0x0389e,0x3ee0c,0xe186c,
        0x34c46,0x6f167,0x9f81e,0x00007 },
      { 0xf3c4e,0xf3364,0x3f2c1,0xe14b8,0x51367,0x6b2ac,0x43d53,0x5933e,
        0x6dcfc,0xfe44a,0x0d961,0x94751,0xe34e5,0x3f2aa,0xece7e,0x08234,
        0xa7f25,0x0abde,0xb92e0,0xa124c,0x0a791,0xfba4f,0x53a1e,0x1192d,
        0x86fd2,0xf6c20,0x51c8a,0xd0fcb,0xffec0,0x0f1b5,0x2cadc,0x48d1b,
        0xdbe19,0x8f812,0x07a38,0xdd45b,0xadedb,0x873a6,0x89a40,0xd7025,
        0xa1268,0x64bc2,0x7e27b,0xe3a81,0x5bbf6,0x386e8,0x6636d,0x73ee5,
        0x7c000,0x379de,0x42ecd,0x00004 } },
    /* 120 */
    { { 0xf90a6,0xe68a2,0x4cd1a,0xd0ccb,0xd6f5a,0x77d41,0xb8ef2,0x401d4,
        0x828c4,0x316a3,0x83766,0xa134d,0xbe817,0xe1124,0x58df5,0x142b7,
        0xb95e4,0x9dfd6,0x5fbc6,0x9e3e2,0xfd74a,0x0c9f5,0x3cea3,0xd8966,
        0x0f163,0x6d5ac,0xce638,0xeef70,0x432a9,0xed554,0xea5d8,0x7a690,
        0x9427a,0xf0988,0xde23f,0xed585,0x5eaac,0xad36a,0x46575,0xd3e18,
        0x4a6c1,0x10351,0xf0939,0x62c37,0x83d91,0x3d56e,0xdd9e3,0x5c10a,
        0xa691e,0x7306a,0x5176b,0x00008 },
      { 0x21e38,0xfa28a,0x32110,0xd538a,0xd5773,0xb6379,0xdc497,0x2d020,
        0x97bbf,0xcdd36,0x61833,0x75939,0x65917,0xfa851,0x5fae5,0x6d704,
        0xab5d2,0x9a786,0x390f2,0x5b703,0x0dc4f,0x0bda3,0x5c6ac,0xdcc61,
        0x0240a,0x91cca,0x5146d,0x1702c,0x78e1f,0x2cef8,0x2d0a7,0xceb47,
        0x69ba1,0x080b6,0x48407,0xaa0a8,0xd7e61,0xb08f9,0x60b79,0x46695,
        0x160be,0x1e388,0x48eb7,0x5c2d9,0xc2393,0x31590,0x3c094,0xd7fd8,
        0x768b3,0xbb6e5,0xab154,0x00008 } },
    /* 121 */
    { { 0xc4a96,0x03353,0x86860,0xd8352,0x8905c,0x5c60e,0x8cc4e,0x8f66f,
        0x91364,0x9ebd5,0xfaccf,0x0b989,0x5b6b8,0x2639e,0xfaee3,0xbc1c1,
        0xaadeb,0xd2278,0xf6396,0x202d2,0x01898,0xa796d,0x83500,0x3a474,
        0xb548f,0x3e18a,0x31b0e,0x56c3b,0xdacd0,0x64512,0x8dd01,0x15ba6,
        0x3f3bc,0xd94b0,0x03836,0x06c52,0xbd8f2,0x4eca6,0x9b6d6,0x9f177,
        0xa361e,0xa8931,0x2ab34,0x90fc5,0x2d826,0x922e2,0x8e092,0x342bb,
        0xb02a9,0x84e00,0xbfcdd,0x00001 },
      { 0x365d9,0x4375a,0x10b9a,0xfb033,0xe08d8,0xade15,0xf83d4,0xd742d,
        0x753d7,0x429c9,0xe3187,0x09d4d,0x0cf73,0x60ace,0x21233,0x1228e,
        0x69643,0x38f76,0x043d2,0x5a531,0xdf90f,0x2adbe,0x397fc,0x7b5f9,
        0x64cb7,0x1041d,0x446d0,0xb30ac,0xe5200,0x1720f,0x42d23,0xc3c86,
        0xa2075,0x2db9a,0xcc012,0xae47f,0x2041e,0x6e3b1,0x6a485,0x68c87,
        0x64455,0xb1458,0x33606,0x78422,0xf1a1c,0x7757b,0xd1f22,0x9b766,
        0x9d4f1,0x3bf7b,0x5b78a,0x00002 } },
    /* 122 */
    { { 0x707ce,0x18156,0x08357,0xf90a9,0x84314,0xdc239,0xdbd9b,0x8be57,
        0xc885a,0xb8017,0xd63a4,0xa225a,0xdd4bb,0xaacff,0xb8615,0x5ce71,
        0x54722,0x75729,0xf2664,0xd3dd5,0x74f0a,0x80f1f,0xed70a,0xfc352,
        0x538a3,0xca010,0x203c6,0x40454,0x4f8a6,0x0c73b,0xa8833,0x2b2c7,
        0xcac1b,0xe602d,0x3433e,0x17c7b,0xfed2b,0x0499c,0x9c72e,0xbd632,
        0x681a4,0x379f8,0x6fadc,0x99463,0xb3897,0xb7895,0x0c892,0xdc565,
        0x51cf0,0x7065a,0x0ab95,0x00007 },
      { 0x85d93,0xc47b5,0x6778e,0xfe4e4,0x0a633,0x6d361,0x11aca,0x4ea03,
        0xa154e,0x2f21d,0xd6400,0x190bb,0x9af22,0x1cb7a,0xac7d9,0x9e633,
        0x837d7,0x1fee6,0xd13c3,0xee8ae,0x71616,0x4a07d,0x616da,0x3afcd,
        0xa2732,0x94d78,0xa14d6,0x96e5b,0x0c066,0xf5842,0x4d74d,0x73375,
        0x8e3c9,0x4e277,0x85e50,0xa5c2e,0xc55b5,0x55aa0,0xb5c30,0x8a3ac,
        0xdf538,0xda313,0xa088e,0xacb52,0xe5896,0xc85dd,0x2a084,0xfc884,
        0xde6be,0x7951d,0xfec9f,0x00005 } },
    /* 123 */
    { { 0x19f99,0x7cfe5,0xebc2c,0x03535,0x0e541,0x96bd8,0x8f3e3,0x8a398,
        0xd9402,0xa1ade,0x601bd,0xb735d,0xc1c03,0xce64a,0x03614,0xfd302,
        0x40290,0xe9012,0x837eb,0x097d5,0x3a554,0xaea1a,0x139ca,0xb0b88,
        0x73d25,0xb9dce,0xcb090,0x412be,0xc35ed,0x3dab3,0xff7d6,0x99029,
        0xdb071,0xd9062,0x55437,0xc11d5,0x642a4,0x7d2f5,0x10927,0x24fc9,
        0xfa645,0x4d477,0x79925,0xe9b72,0xc7b12,0x4c618,0xe22d8,0x7ad2a,
        0xed195,0x63ce8,0xa8d56,0x00000 },
      { 0x1fde1,0x630a2,0x3ac51,0xd8494,0x66903,0xcf5dd,0x281cf,0x5fdd6,
        0x499ee,0x346d2,0x7a49a,0xc6f07,0xf4ded,0x75c06,0x2c028,0x46bda,
        0xb8046,0xf6347,0x0e0e0,0x836fd,0xb5e67,0x58169,0x04210,0xde8a8,
        0x1912a,0x32c96,0x93b3d,0xea0aa,0x5df3f,0x576bc,0xedb0c,0x9f138,
        0x37e47,0x6ed8d,0x971ad,0xe7cb7,0x9cce5,0xb8573,0xb40ea,0x1d202,
        0x4b434,0x2688a,0x3a1fd,0x2557e,0x15d84,0xa86f9,0xbd5b3,0x872fa,
        0x4629f,0x936aa,0x5b934,0x00009 } },
    /* 124 */
    { { 0x951de,0x0199f,0x998a7,0xdb459,0x6f058,0xade59,0xdd38f,0xf3d03,
        0x79c1e,0xd34d4,0x3b141,0x8d5d3,0x06e92,0xfe8a4,0x800ac,0x9a465,
        0xefa3d,0x2fc1c,0x108ad,0x726ed,0x1e013,0xb9692,0xb9f64,0x8e83b,
        0x6a6b6,0x44b9b,0x242e5,0xe6dc1,0xb29f1,0x65966,0x6762f,0xd3f8f,
        0x05b41,0x965e1,0x34dd0,0x1e1ca,0xa1601,0xe9139,0x41bd4,0x25155,
        0x4dc68,0x6deea,0x82216,0x30acc,0x46f80,0xd1612,0xe1d31,0xbdc7a,
        0xafa7d,0x51621,0xe25ef,0x00002 },
      { 0xe7357,0x8fdd8,0x533cf,0xddb82,0x8eace,0x3ba21,0x2ac33,0x0784d,
        0x3e31d,0xe268e,0x2804a,0x7f36f,0xe1c92,0xe7ad7,0xd2277,0x01433,
        0xf78a0,0xf0587,0xb401c,0x27ae0,0x6aa00,0xfcf03,0x6b59d,0x1d9a4,
        0x46c8b,0x32c9e,0xf288d,0xe4861,0xdaa6d,0x8a043,0xa2f1b,0xdd56d,
        0x0bb56,0xe5f2d,0x46230,0xfb563,0x419de,0xf0b6e,0x87419,0x21d2c,
        0xc37cd,0xb355e,0x70e45,0x0397b,0x23dbf,0x7ce85,0xa8dac,0xf0862,
        0x1f3d6,0xa7e14,0x7979e,0x00008 } },
    /* 125 */
    { { 0xc747f,0x3f7f1,0xb7e7b,0x33699,0xdc6e6,0x1a4c1,0xba015,0xb372d,
        0x3ff70,0xfe427,0x3ee54,0x2234d,0xfca6d,0x3cae0,0xe0cd3,0x12fc8,
        0x6f10c,0x385dd,0x73285,0x9cf92,0xdf01a,0x6f3fb,0xe91c8,0xe36ca,
        0x2677f,0x44532,0xfefea,0x00332,0x739a7,0x8af21,0x328ce,0x2c9ca,
        0x731f4,0x76f6a,0x02567,0x6813c,0xf66a9,0x87b3d,0xda8c6,0x8db2e,
        0xaab12,0xbd194,0xec4fe,0xdc5ae,0x2de30,0x9241b,0x36a97,0xc0522,
        0xd4c16,0x02c23,0xec988,0x00003 },
      { 0x2f74d,0x0c407,0xf9e76,0x40590,0xeab59,0x8eb0d,0x9c2e7,0xc9b00,
        0xdea40,0xe5db3,0x8b59a,0x75f03,0x647e8,0x4daa0,0x4362b,0xf40eb,
        0xf3788,0x92090,0xa6a4f,0xaf8b9,0xfedbf,0xebe9a,0x256ef,0x9867e,
        0xf96a5,0xebf87,0x5ab6a,0xed237,0xb1e6f,0xdb13c,0x82a3f,0x17f27,
        0xa2621,0x1e70f,0x102c7,0x0dbe5,0xcfd4c,0x2b06e,0x2975d,0x30347,
        0xcc268,0x80537,0xb67e7,0x5e2b2,0x28dbf,0x25da3,0xf3aba,0x2f633,
        0xec914,0xe8efa,0xe9315,0x00003 } },
    /* 126 */
    { { 0xa9ea9,0xa5239,0x255cf,0x3a629,0x00be3,0xf3c69,0x2bd20,0x9cb64,
        0xeeb4b,0x18759,0x0bae7,0xc5460,0x43316,0x410f8,0x6d5f3,0x874a7,
        0x129b6,0x2e90f,0x23b50,0x1f1c1,0x81285,0xc8f9a,0x08cad,0x1b624,
        0xb764a,0x7bf57,0xa8077,0xc01f1,0xc116e,0x0ddc5,0xef21f,0x746ec,
        0x6a5a7,0x7ce5a,0xc49d4,0x55ba3,0x706e9,0x15dbe,0x9b01e,0xb45d7,
        0xc0c79,0x87629,0x78d10,0x83087,0x71127,0x6a22d,0xdc78c,0x22585,
        0x82791,0x0d0a6,0xed02a,0x00002 },
      { 0xa2682,0x164da,0x30434,0x96255,0xb0135,0x26d32,0x0970e,0xbd867,
        0xc834a,0x2e449,0xe77ae,0x9d2be,0x911a1,0xf6c16,0x29a3a,0x39bd5,
        0x61054,0xc05cd,0x6cca5,0x0fe13,0xbdc6c,0x70a59,0x13563,0xb93d5,
        0x20d27,0x1aca4,0x54c45,0x0d455,0x2d873,0xcdebf,0x8c996,0xebd25,
        0xf9a05,0x90a50,0xcb1b9,0x01510,0xa7b0f,0xa8c97,0x7e169,0x11d21,
        0x36d34,0xe82cc,0x52f75,0x688a7,0x1f117,0x9b2a6,0x394a0,0x1db01,
        0xfd7dd,0x44a9e,0x46278,0x00001 } },
    /* 127 */
    { { 0x803cf,0xed232,0xbca3a,0xff346,0xb9a96,0xe4398,0x88bc1,0x74ab7,
        0x6757f,0x4dcaf,0xe68c0,0x3e007,0x0c3a5,0xb7cd2,0xc195c,0x5f969,
        0x68bca,0xa6dc0,0x28b65,0x3032f,0x31d86,0xca01d,0xe14e3,0x87808,
        0x33b81,0xbe9b7,0xfe618,0x04d9e,0xdb5d7,0x1b946,0x542b0,0x276f3,
        0xdddbf,0x9efbe,0x057e1,0x75cee,0xb9032,0x182f2,0xbc67d,0x880f7,
        0xc5f77,0x143cd,0x8476c,0x3d3f7,0x2d6f0,0xba507,0x557a9,0x035f5,
        0x29628,0xb6b40,0xacb57,0x00007 },
      { 0x6b07c,0x6944e,0x24135,0x345dd,0x9e1c7,0x1c4cc,0x9fb45,0xe273b,
        0x444d8,0xfc407,0x88e34,0x6079b,0xdfe49,0x52776,0x4cff1,0x77d18,
        0x2299c,0xb9c74,0xd1033,0x28976,0x477bf,0xa0a68,0x42029,0xee8f0,
        0xfdf10,0xd659f,0x4bb56,0x146c4,0x54e17,0x9ae85,0x6c2fb,0x831d0,
        0xe7cd5,0xdbd93,0x2cb82,0xb607b,0x63c96,0x381c4,0x2a883,0x7549e,
        0xed251,0xd406a,0x74a21,0x891c7,0xdef97,0x75fbd,0x7c786,0xae980,
        0x3516c,0xb9636,0xa5a05,0x00006 } },
    /* 128 */
    { { 0xf4f33,0xa66a8,0x2e71e,0x8f4a9,0x64dea,0xfc6fc,0x461f2,0xfee88,
        0x6252c,0x08d35,0x8954d,0xa83e0,0x659b0,0x8ab76,0xc2346,0x5bd68,
        0xf8d04,0x57900,0x02813,0x67ae4,0x052b8,0x1c19c,0xc4118,0x18764,
        0xa5169,0x24986,0x3575d,0xdfae1,0x7cb01,0x3677b,0xae559,0x17269,
        0xc9b19,0x2546d,0x6d170,0x97c8f,0x9c400,0xe6849,0x07b8d,0x259c4,
        0xf0032,0x8b76d,0x7d29d,0xaad91,0x64091,0x7ab5f,0xd214a,0xa7f46,
        0xce48c,0xb470e,0x88054,0x00006 },
      { 0x5b86c,0xaa51a,0x0d168,0x7247f,0x89577,0x37e4d,0x32924,0xf1720,
        0x44076,0x4eae8,0x647a5,0xc87d9,0xc0a7a,0x05622,0xa4b04,0x1e597,
        0x79f2f,0xc6f0a,0xdefe5,0x156de,0x24d55,0x3ef0c,0xcf6af,0xef047,
        0xfb04e,0x37917,0x4b621,0x799f5,0x83792,0x4be0b,0x32f31,0x875ea,
        0x66b0c,0x5b0c4,0x157c6,0x8978e,0xe7e21,0x8c90c,0x7afd2,0xcde58,
        0xfc3ba,0xedb90,0xb877b,0xd71c8,0xddd32,0x8e10c,0x200ca,0x3b432,
        0xf6e53,0x19d94,0x021f4,0x00000 } },
    /* 129 */
    { { 0x19d26,0x2c435,0x19112,0x18452,0xd40a5,0xafac1,0x89fbd,0x548bb,
        0xf71e9,0xf9cc6,0x6844b,0x375c1,0x59ef3,0x8e8d5,0xf7917,0xe7789,
        0xbe1c5,0xb61f8,0x4f599,0xde400,0xa2cbb,0x88c99,0x6c980,0x89320,
        0x9a260,0x51893,0xcd308,0x4bfff,0xea1ae,0x8feaf,0x3fee0,0x664cb,
        0x4aabc,0x99ff1,0x1f380,0x1ef96,0xc2a84,0x8394c,0xdb60d,0x17f01,
        0xad8ad,0x7375f,0xdebb7,0x45766,0x26fc3,0x25251,0xb05a4,0x1e716,
        0x1ed9f,0x8029e,0x98558,0x00007 },
      { 0x06473,0xaa951,0x2cb3a,0xda04a,0x15a61,0xfafa4,0x3c095,0x53956,
        0xc9362,0x87fd3,0x5312b,0x80919,0x6baa4,0x885c7,0x582bf,0x6c7e7,
        0xc78d5,0xb6230,0x0f6da,0x440d7,0xc7747,0xe3051,0x1868c,0xffdb6,
        0xebd14,0x966db,0x90e40,0x41fa1,0xab0e0,0xe62e2,0x4666e,0xba10c,
        0x333d6,0x2a74f,0x3d57e,0x9b669,0x4fe7b,0x6aadc,0x37d00,0x06d28,
        0x72f6c,0xeafaf,0x10741,0xc5e69,0x7318c,0x69247,0x60965,0x9c502,
        0xfb08d,0xc31d0,0x5d823,0x00009 } },
    /* 130 */
    { { 0x528a5,0x86140,0xaeebd,0x9bc86,0xa5397,0x68c2b,0x4abf2,0x4ec14,
        0xc9b8a,0xedb1b,0x2a7d7,0xbb0d8,0x81efa,0x0118d,0x0d14e,0xf12c7,
        0x1558e,0x68a1c,0x16071,0xe73e3,0x7e4b7,0xe428b,0x9dd33,0x83aec,
        0x76637,0x5c631,0x12ac3,0xffbee,0x45172,0x17b2a,0xbfbbc,0x37df0,
        0xf812a,0x70741,0x212f8,0x8f9c4,0xbe288,0xcecbd,0x55d3d,0x756ca,
        0xc15aa,0x41a9d,0x9028e,0x18ecb,0x3f319,0xeadb0,0x2856a,0x7ede0,
        0x54f54,0xd5786,0xe2708,0x00000 },
      { 0x20f88,0x53cde,0x270cc,0x10392,0xc5f5b,0x38272,0xdbf93,0x5dcb1,
        0x2e19e,0xc1504,0x72d74,0xe219b,0x54b3d,0xaaaa5,0xa8b2a,0x16c49,
        0x86ba6,0xe5bba,0x08443,0x16950,0x220cf,0x6bcd7,0xd11ee,0xa89ab,
        0xfac6b,0x9d59f,0x11563,0x217bf,0x22831,0x4cba5,0xaf2f3,0xe4d28,
        0x7a906,0xe7072,0x27f03,0x7766f,0xf6901,0x42c79,0x23e68,0x7a811,
        0x469bd,0xb8cb3,0x42973,0xf346a,0xd48c0,0x990db,0x4a623,0xfc578,
        0x99678,0x3bfb2,0xd3dab,0x00000 } },
    /* 131 */
    { { 0x9c3cc,0xe6ce2,0xf8376,0xcbc68,0xcf016,0x0507e,0xce1cb,0x5e394,
        0xff996,0x41deb,0x3c50d,0x526f7,0xd24fc,0x16ce3,0xa542d,0x4edd5,
        0x13141,0xd991c,0xb37bd,0x8606b,0x2e33a,0x442ef,0xda8e3,0xc0629,
        0x90337,0x312ae,0x92ab3,0xec645,0xb57fa,0x2b857,0x997d8,0x1a938,
        0x73176,0xb9a33,0xd6c8c,0x751fa,0x29086,0x595de,0x19682,0x18c17,
        0xe97fb,0x57a81,0xf6973,0x8a13b,0x9e4f4,0xb89f6,0xc2e5c,0xa1387,
        0x4b426,0xeb587,0x30b4e,0x00005 },
      { 0x7b5ae,0xa1bab,0x9f275,0x7bf4e,0xd03a5,0x69dc4,0x05bbb,0xa45c5,
        0x4dc4a,0x02c97,0x16ac4,0x69f34,0xc7263,0xd985d,0xe78ae,0x735e4,
        0x446a1,0x79cdd,0x548d8,0xb02a0,0x99e16,0xceb06,0x1a684,0x789b1,
        0xf6fa4,0x84f73,0x2a4e7,0xc41fb,0x76aa0,0xa9b69,0x90293,0xb1f76,
        0xa8ab2,0x00f03,0x14cce,0x66c18,0xb844d,0xcb255,0x20164,0x30952,
        0x4e7d6,0x71b79,0xda322,0xd4e43,0x9e052,0xb6a4d,0x2e708,0x5278b,
        0x6577f,0x5280c,0x09425,0x00009 } },
    /* 132 */
    { { 0xb4c2f,0x4d0d5,0x269a1,0x649cd,0xb5c8a,0x8fc59,0xd4a2b,0xb0e37,
        0xecb3a,0x7e95b,0x11103,0xa7689,0x2fda1,0xe3532,0x05a94,0x5810e,
        0x8fafc,0x12a17,0x24dcc,0xce62a,0x28e3d,0x2c63b,0x4445c,0x9452c,
        0xc3f17,0x61995,0x2d451,0x0ec34,0x93533,0xef812,0x60ab4,0xa025a,
        0xe9c13,0x528ba,0x54932,0xcaf88,0x6e2e3,0xd1a60,0xf4725,0x3649b,
        0x091ab,0xf1d44,0x04ec5,0xafbf7,0x3c7d0,0x8b333,0xd62bd,0x27bd1,
        0x616f5,0x11cfe,0x05701,0x00005 },
      { 0x4356b,0xcef53,0x0084a,0x0fbcd,0x54b4b,0xf1de0,0xdc19d,0xcee04,
        0xafe05,0xe1021,0x61b78,0xe6883,0xb64bd,0x78d38,0xcc7ef,0xa324f,
        0xa5e4e,0xceeb0,0xeb372,0x1996f,0x36581,0x04fcb,0xb4eef,0x5eb0a,
        0xe5d50,0x6e7dc,0x38c58,0xb5882,0x71e29,0xd8003,0x197bc,0xde5e3,
        0x6b9cf,0x51480,0xbf5e4,0x67ab8,0xbd18e,0x30968,0xfad43,0xf9f63,
        0x7d04e,0xb426a,0x5c18b,0xf123b,0xca1c7,0xdce22,0x48225,0x485b8,
        0x0e79f,0x6fd54,0xff0b3,0x00008 } },
    /* 133 */
    { { 0x42cff,0xf43ff,0x9f2e2,0x317c9,0xd1c35,0xc19f9,0x545a3,0xaba1b,
        0x49392,0x32db7,0xafa9a,0x2b054,0x68423,0xdcd43,0xd46d7,0x0b855,
        0xf9915,0x2045c,0xac35e,0xa2188,0x7f001,0xcf22c,0x305d7,0xed408,
        0xd35ae,0xcd057,0x53ccf,0xa5195,0x925a4,0xe2b93,0x79393,0x5e565,
        0x2ec27,0xb0342,0x20332,0x3958a,0xe3ac5,0x09005,0x1639b,0x79e9b,
        0x051a3,0xd6628,0xc6618,0xdc09f,0xfb4a0,0x48e7a,0x57f67,0x9e0e8,
        0x7d63e,0xeec57,0x1b28e,0x00007 },
      { 0x26bf8,0xcd997,0x942b0,0x8f3c4,0x91c20,0x90a3b,0xeaa12,0xb0598,
        0x290e7,0x28fd7,0x25a91,0x791fa,0xac6a7,0x37d7d,0xb24c0,0x2d33d,
        0x2837b,0xb070e,0x21efe,0xe2a0c,0xee3da,0x70d96,0x027bf,0x85076,
        0xd8191,0xe343e,0xd4ad7,0x0aa84,0xc4aeb,0xc5b74,0x01fe8,0xbc751,
        0x6ebdd,0x6ead2,0xbfb2a,0xaa4ed,0x86b78,0x81206,0x848ba,0xe1159,
        0xaa8f2,0x4ec94,0xeba5c,0xd9db3,0xa0d10,0x18295,0xc4763,0xce7fe,
        0xd925a,0x1a330,0x29471,0x00007 } },
    /* 134 */
    { { 0xbd495,0x0432b,0xce459,0x973ff,0x1be54,0x0f4dd,0xf4e33,0x5d9c3,
        0xbee1d,0x04006,0x9ba72,0x60785,0x840ee,0xc2c76,0xd3f42,0xc194f,
        0xe88be,0x12e9f,0x0e76b,0x0210a,0xbec2b,0xcdddd,0xec717,0x00811,
        0xd436b,0xe4689,0x84be9,0xba372,0x4a6a6,0x7d411,0x5b200,0xabc39,
        0x1e744,0xf30f1,0x8cdf9,0x6402f,0x8e939,0xfebec,0x285c5,0xeeb46,
        0x51743,0x378a7,0x6e0d1,0x8782c,0x399bf,0xb292e,0x170be,0x3965e,
        0x1fd5f,0xd8580,0x01c39,0x00000 },
      { 0xa0912,0xb9da4,0x4805c,0xbca4f,0xa4410,0x7cb76,0x65bd2,0xec71d,
        0xdcb8e,0x9aef3,0x81684,0xbb2b4,0x5780f,0xb2463,0x026a8,0xef6a7,
        0x44e68,0x8812c,0x5625c,0x74a81,0xc4d7a,0x4c232,0x1e462,0x4b163,
        0x77037,0x2e81a,0xb917c,0xf7f1d,0x504e4,0x61ed9,0x5fd1f,0x1d046,
        0xe6e3d,0x49cbd,0x10480,0x1fcfb,0x1d713,0x7ce0c,0x71563,0x8ada4,
        0x4dbc2,0x2622e,0xce997,0x0c5ca,0x0f753,0x28745,0xdccee,0xa0160,
        0x1af13,0x70bb9,0x132e6,0x00009 } },
    /* 135 */
    { { 0x6099d,0xe2799,0x057ef,0x608c8,0xba06e,0x2344d,0x588b7,0xd0958,
        0xa8740,0xe9eb4,0x9e5ae,0xaf067,0xde53d,0x8a2fa,0xa9a90,0xc9560,
        0xe706a,0x31107,0xf4be1,0x246a7,0xb2830,0x5f3d9,0x3e66d,0x27cca,
        0x8e8da,0x92a5f,0xc28f2,0xdca64,0x8eb51,0x1dfd7,0x10ef3,0x4cfa3,
        0x073e5,0xc22ca,0x2e0c7,0xa6839,0x4a40d,0x2f169,0x8fc10,0x750d3,
        0xb07cc,0x3516b,0xadae0,0x83e2b,0xd703e,0xd3c9d,0x066b4,0xea93c,
        0x40ed1,0xe5799,0xd0b03,0x00007 },
      { 0x94c63,0x304dd,0xfe7ea,0x0b3a5,0x5738b,0xef01c,0xb4b57,0xa14e6,
        0x4a78c,0x76953,0x53532,0x2cdea,0x60762,0x22d00,0xa077c,0xaf696,
        0x6b209,0x867d4,0x33c18,0x2b4a7,0xb626c,0x54ccb,0xc4c96,0xa84f3,
        0x8d3a1,0x74a09,0xd734b,0xf9ed2,0x03596,0x551c9,0x21a5d,0xdfd30,
        0x5123f,0x2f1ec,0x2ba7d,0xaa39e,0x5b2c1,0x72692,0x927f9,0xf8eb2,
        0x75d0e,0x6fd2e,0x9192a,0x712e1,0xefaba,0x83e50,0x43a9b,0xa606b,
        0x5de60,0x2fdab,0x1b178,0x00003 } },
    /* 136 */
    { { 0x4db92,0x45403,0x78dba,0xdc4d8,0x18f34,0x97790,0xc33a3,0xdf754,
        0x04f2e,0x888d0,0xd563a,0x954ac,0x1eaa5,0x5ffad,0xc89bb,0xa29d6,
        0x8bdb8,0x55b0d,0x8adf6,0xdb47a,0xd8cdb,0xfb842,0x05bf7,0x80d32,
        0xe3a03,0xa9b72,0xcac7c,0xb0b27,0xdc335,0xa5475,0xbcbd8,0xffc60,
        0x4d25f,0x19eba,0x36f77,0xfca67,0x80c50,0x901c3,0x9003d,0x80c01,
        0xacf7b,0x4d1fd,0x681f8,0x658f5,0x175cf,0xefbbc,0x6345c,0x57a7e,
        0x7ed1f,0xe53e0,0xfc0fb,0x00006 },
      { 0xb0e5f,0x6bb81,0x96d11,0x53b84,0x52ac8,0x2dd2a,0x7f0d8,0x32738,
        0xe22d4,0x59357,0xa912c,0x2a84b,0x13e33,0xd5dcc,0x64349,0x8b71c,
        0xd85d3,0xe9438,0xc982e,0xcd4e0,0xcbf7f,0xb9553,0x5e390,0x38fed,
        0x39bbc,0x032cb,0xac429,0x7c9c5,0x5a2c6,0x07da5,0x217bf,0xebf21,
        0x9e4ee,0xada0b,0x5ac05,0xe0c65,0x28ee9,0xbb12c,0xe3f10,0x48bb6,
        0x3aee5,0x915cf,0xb046e,0x269c8,0xf4ae7,0x0e553,0x012aa,0xcb266,
        0xc8fc8,0xa1a94,0x01935,0x00007 } },
    /* 137 */
    { { 0x26dea,0x1da46,0xe58d4,0x039fd,0xa15b9,0xef66c,0x65b25,0x3164e,
        0x810a4,0xcf99a,0x48cfc,0xdaad7,0x99fe6,0x142fa,0x6bd2f,0x7ab9a,
        0x71796,0x685d4,0x4cba1,0xa39ba,0x66bc3,0xd30b3,0x07612,0x8bf45,
        0x6a5dc,0x0e1f4,0x421ac,0xe5291,0x4b868,0xbba1c,0x20659,0x7a686,
        0x98b90,0x2eda6,0xb4b55,0x37072,0x4e545,0x39dcd,0x65f50,0x9e901,
        0x07a9e,0xfc42a,0x7d45d,0xfff3d,0x0a838,0x5ceb3,0xe5a3b,0x41991,
        0xca600,0xc8969,0xc961e,0x00006 },
      { 0x7eb46,0x1bc4e,0x03bdc,0x7b487,0x7596c,0xbac55,0x74dd6,0x66afd,
        0x917cd,0xf34f9,0x56ce6,0x51056,0x55635,0x49717,0x50c32,0x3d1fb,
        0xffb2d,0x3e63e,0xda678,0xa2bdf,0x3eefa,0x79f1f,0xef7bd,0x17af9,
        0xfbe54,0xa4a4e,0xa55b7,0x64625,0x46cef,0x71330,0x2381a,0x116f3,
        0x625a3,0x7fb95,0xb2a2a,0x7e96d,0xa0b02,0x0aa43,0x3bc6a,0x4832b,
        0xfe5d2,0xc0458,0xadfaa,0x18df5,0xa5234,0x9e7f9,0x9cbc4,0xc05a8,
        0x24b53,0xd869e,0x30883,0x00008 } },
    /* 138 */
    { { 0x57389,0x62025,0x59b1c,0xc0bc9,0x7adef,0xe5ce9,0x3835f,0x8330f,
        0xbbe7f,0x1e893,0x6cfb8,0xc6af1,0xd27e0,0x4428f,0x65bd0,0x6f64e,
        0xe6182,0x45b79,0x3de92,0x11ca5,0x1487e,0xa313c,0xe9308,0x445bc,
        0xec3b9,0x9e65c,0x67ed4,0x0314d,0x233bc,0x78235,0xb2430,0x69f36,
        0xd31d2,0xaf93a,0x78e5d,0x890cd,0x0c780,0x682b7,0xfe9f2,0x9e45e,
        0x5c34f,0xea701,0x6cbaf,0x4ba4e,0xc135d,0x3fcc6,0x8a47e,0x43a37,
        0x38f8c,0x7f966,0x376f9,0x00002 },
      { 0x75b99,0xc0ae5,0xa6e1e,0x70dc0,0xf81b9,0x14cb4,0x9477e,0xd3a73,
        0xa3824,0x9df00,0xb235a,0x9c81f,0x40b4b,0xf6294,0x15f5b,0x8d151,
        0x65d7a,0x431e1,0xfd35b,0x3e3bc,0x2b2ee,0x12fea,0xe7b5d,0xf5182,
        0x984a6,0x8e629,0x365d0,0xe2f3c,0x24e43,0xf36e7,0x09130,0x99327,
        0x45401,0x00fd3,0x98b4a,0x6dce6,0xebaf9,0xc4fd0,0x55423,0x23675,
        0xba0ae,0x84a60,0x03257,0xac2db,0x151bd,0x5464a,0x90a21,0x8ab41,
        0x10296,0x616bf,0xc4616,0x00008 } },
    /* 139 */
    { { 0xf36a5,0x582d1,0xffca2,0x5f2de,0x2894c,0xded2b,0x84f0e,0x43ced,
        0x5cdb8,0x9b35a,0xb0e3b,0x8982d,0x2290f,0x19a11,0xaf007,0xcce0e,
        0x362d6,0xe439a,0x0e657,0x7e47d,0xd6269,0x16a55,0x51455,0x8e636,
        0xe1f77,0xbc269,0x50269,0xedcbd,0x55e3d,0x1c57c,0x30044,0xecec2,
        0x5578d,0x1cc70,0xb83f3,0x9eabd,0x31e48,0xdefb7,0xdb41b,0x395fc,
        0x678cf,0x0120b,0xf9db0,0xf91cf,0x8908c,0xf52cc,0x6f455,0xcbebc,
        0x61162,0x22b4c,0x55ea6,0x00001 },
      { 0xfa42e,0x1f876,0x4be2f,0xeee79,0x97fad,0x5e874,0x5afab,0x38c86,
        0xe70f5,0xb0692,0xf8059,0x9b84d,0x916e9,0x5a7ac,0x06e8b,0x0ceb6,
        0x63d2b,0x572d4,0xed233,0x09a0c,0x32a9a,0x0f262,0xbdf2d,0x3861f,
        0x9998c,0x0b252,0x1be31,0x88a7c,0x37118,0x8aade,0x9c50d,0x9b122,
        0x3533d,0x783b1,0xbcf9b,0x9708d,0x8ff02,0xa746f,0xf883c,0xda83e,
        0x013a1,0x44a5a,0xab284,0x4d184,0xa8e90,0xbd4ab,0xb3dbc,0x2fe84,
        0x058c3,0x24259,0xf570f,0x00008 } },
    /* 140 */
    { { 0x9c508,0x8a2ca,0xeb66c,0xb780d,0x269d6,0xc5bec,0x6002d,0x88ead,
        0x61266,0x1416d,0x9d726,0x1b974,0xf6184,0x472e6,0xe6cce,0x41e40,
        0x7a876,0x641fa,0xda242,0x97a0a,0x3cc39,0xb9fd3,0xcf445,0x7c15d,
        0xe8fa9,0x9db25,0x2e962,0xceb21,0x60124,0xb3d95,0x2c67d,0x3a8c7,
        0xa7844,0x2b7c1,0xe2ded,0x27ff8,0x66dd0,0xab09c,0xbc694,0x7e7a2,
        0xa057d,0x63f89,0xf70c7,0xf226c,0x2ad8b,0xa2621,0x8e7c8,0x4cb26,
        0x44c1d,0x87b2c,0xd171e,0x00003 },
      { 0x49820,0x6e8ce,0x82ac1,0x4dc93,0x2c0c4,0xee45e,0x8c424,0x73e85,
        0x67912,0xf90ec,0x6327c,0xb25c4,0xf918c,0x159c1,0x76bc6,0x43e38,
        0x45cb3,0xe0375,0x6b6e0,0x347eb,0xb5d12,0xb839a,0x54164,0xa300d,
        0x09274,0x6972e,0x81c11,0x28e68,0x326ab,0x75a84,0xfffeb,0x4a580,
        0x120df,0xca359,0xa5802,0xf4a30,0x03209,0xee82d,0x3807f,0x8e6a9,
        0x8016b,0xcab51,0x2ee11,0x6c70c,0x7b99c,0x9d4ec,0xaf1ab,0x16105,
        0xd9004,0xf834c,0x34e98,0x00002 } },
    /* 141 */
    { { 0xb9cda,0x0814d,0xf4352,0xec90f,0x796ad,0xcfdc4,0xb6d99,0xaf458,
        0xaaa6f,0x31843,0x43eaa,0x74157,0x13f1f,0x735d8,0x92e61,0x915e1,
        0x595d5,0x2d0ac,0x441a2,0xbc8d3,0x7c044,0x4bbf6,0x23670,0xbe23a,
        0x60471,0x572f9,0x5d1d5,0x63881,0x4cc32,0xb1dd9,0x30b76,0x94102,
        0xc8a67,0x9f0c1,0x2e543,0x910df,0xc833c,0xb141a,0x4df56,0x865b8,
        0xc999f,0x7b467,0x1f02b,0x51fa2,0x01b02,0x21695,0x26096,0xde5b5,
        0xa1e93,0xe3ce3,0xa2130,0x00006 },
      { 0xca1a7,0xa04b3,0x21b67,0xce80d,0x300c0,0x42ed5,0x07aaf,0x932cf,
        0xcd368,0x5a22c,0xc25c3,0x3a815,0x63652,0xd04d0,0x9588d,0xecdd3,
        0x93a3b,0x02b2f,0x3da35,0xb5307,0xcd5e5,0x5e0c3,0x7774c,0x13268,
        0xf5486,0x92ef9,0xe7422,0xfefc1,0xeed87,0x4e5ed,0x29ea2,0x6d9ac,
        0x49f1a,0xf0338,0x8abc9,0x39050,0x240f2,0x9b229,0x353b0,0x7f934,
        0x1072c,0x50679,0x6aeb5,0x6381e,0x0102a,0xfeb87,0x40996,0x3ee07,
        0xd2830,0xaa9c4,0x4f06f,0x00003 } },
    /* 142 */
    { { 0x8f005,0x9f234,0x69dc7,0x20b18,0x1df49,0x5c5d7,0x4a49b,0x6dee6,
        0xb57ca,0xb4fd1,0x82a4f,0xf734e,0x621b7,0x57836,0x834b9,0x637cb,
        0x87d96,0x1b7d2,0x93410,0xecabc,0xc0392,0x90f8a,0x4e315,0x7f75f,
        0xdc373,0x62280,0xa61ac,0xf50f6,0xa8b36,0x5568d,0x304a6,0x74f58,
        0x0870a,0xa9d93,0x0d792,0x95cc8,0x2fc88,0x17b19,0x39f6d,0x49149,
        0x392fa,0x9e498,0x41d5b,0x027dd,0x5af36,0xaa82b,0x9e25c,0x452d7,
        0x15d1a,0xb1f41,0x64d47,0x00007 },
      { 0xe8b9c,0x03a2e,0xdf223,0xcd485,0x385df,0x9f72d,0xa371b,0x10813,
        0x2b983,0xf56b4,0xde741,0x523b3,0xbe28c,0x03bb5,0x25af3,0x08576,
        0xbf9af,0x9aac9,0x26f29,0x5b349,0x80d44,0xbeac0,0xc0e21,0xd6ba2,
        0x23a02,0x646a5,0xfce28,0xa1b17,0xae302,0x00c1e,0x235e3,0x4516a,
        0xa9311,0x6a7b4,0x54373,0x89f74,0x8c0cc,0xc0b9e,0x8ded3,0x40ed8,
        0x1904f,0x70048,0xcb7fc,0x9b563,0x84f26,0x1b973,0x53a32,0x09a1d,
        0xa3810,0xc3230,0xc0dd9,0x00001 } },
    /* 143 */
    { { 0xa7d9a,0x67c46,0xfaa1f,0x91ccf,0x4bedf,0x74333,0xf2e64,0x47a42,
        0x33a74,0xa9458,0x41ffa,0x00512,0xb6798,0x5efe6,0xa8433,0x70979,
        0xb2403,0xf5f08,0xf0613,0x11dc5,0xd64f2,0xb22fc,0xcfc6b,0xa0572,
        0x8b2a3,0x4ae1b,0x950a1,0xeb417,0xc19e0,0xb6cd4,0xb293e,0xe634b,
        0xa25ff,0x25470,0x1a04b,0x5a0a3,0x9a3d1,0x1f7ac,0xde9a4,0xbf2fe,
        0xd85ec,0x00efe,0x1b94a,0x1f5f8,0xc1f58,0xf4a15,0x6b09e,0xaa399,
        0x041bc,0x39b06,0x2d8be,0x00005 },
      { 0x31a2f,0xf6fd6,0xd1536,0xa8dcb,0x0b351,0xfae7f,0x21291,0x9b126,
        0x590c7,0x35d1a,0xbd0f4,0x875f2,0x052d4,0xb0ea7,0x6d392,0x9aedb,
        0xab89e,0xdcb83,0xbd0ab,0x192c0,0x289fe,0x7a106,0xbda82,0x102a0,
        0x6a960,0x14656,0xe0368,0x3037c,0x5da08,0x63940,0x79f58,0x30bed,
        0xa8df9,0xb6dbc,0x72019,0xa3f59,0x6efda,0x20128,0x89289,0x5236b,
        0x7b996,0x73b33,0x8fc2e,0xe38e2,0x311d3,0x0e8da,0xf4188,0x70787,
        0x4a45d,0x67dae,0xcff63,0x00006 } },
    /* 144 */
    { { 0xa8bb4,0x33f89,0xd3d04,0x8f71b,0x393b9,0x144c3,0xa2d42,0x03470,
        0x616c8,0x9e82b,0x5da08,0xc757e,0x698fc,0xf5fda,0x4ef7b,0x54235,
        0xd34cc,0x539eb,0x885c2,0xdd0d1,0x5bec5,0x20b28,0xbca2e,0x782a1,
        0xbbbe1,0xf0e71,0xb854e,0xed309,0xa959d,0x97fa6,0x97989,0x17249,
        0xf3c45,0xa8d81,0x0cf8f,0x11525,0x760c1,0xa3b51,0x5eaa9,0xecf84,
        0x0ef7d,0x1bc9b,0x9fed1,0x9e23b,0x0c933,0x25608,0xc5c28,0xc93e9,
        0xec1e7,0x17613,0xd2c82,0x00001 },
      { 0xcfc93,0x7d987,0x38134,0xf8107,0xbf187,0x7603b,0xa3104,0x1250c,
        0x6bc9d,0xf33fa,0xb055b,0x91e0b,0xc4800,0x3af87,0xf1a3a,0xbdf95,
        0x540ab,0x70140,0x26877,0x045be,0x0d7fe,0x8df73,0xc2d99,0xb723b,
        0x8135f,0x46b39,0x5ebec,0x0f8c1,0x0ac23,0x5561c,0x8305f,0xe08e1,
        0x0a47f,0x4cda6,0xc0fbf,0x4bfc7,0x4e16d,0xe95c2,0xe9206,0x74617,
        0x63495,0x0e741,0xae0c2,0x98694,0x63971,0x31e2b,0x31221,0xfe269,
        0x37722,0x360a5,0x5486e,0x00002 } },
    /* 145 */
    { { 0x72806,0xca535,0x18795,0x68e16,0x96569,0xc8944,0x3aeb2,0x3fb32,
        0xc2c97,0xd6149,0x09bc7,0xde264,0x3fb15,0x9121b,0xa72c7,0xa90cd,
        0xcabbb,0x4e204,0xd2fa1,0x41256,0x79160,0xcda6f,0x947cb,0xb435f,
        0x86261,0x10250,0x282eb,0x6c38c,0xbdb68,0xa791c,0xd62f1,0x51016,
        0x2266c,0xd161a,0xb1c7e,0x74a66,0x6271d,0x78066,0x7a426,0x82428,
        0xfeda1,0xf3b5f,0xbe4f0,0x03ffb,0x4cbe5,0x482a7,0x0beb9,0xd7f7f,
        0x493f1,0x58088,0x51b23,0x00007 },
      { 0x9be68,0xd6e9c,0x597b9,0x0c6cd,0x467d1,0x94b5c,0x2f417,0x7762b,
        0xcdc3d,0x11a88,0x1b44e,0xa63aa,0x86d94,0xa8eca,0xbb9aa,0xfb0bb,
        0x3d87f,0xd0c96,0x4b0f2,0x075df,0xc5dc7,0x53062,0x989b7,0x49933,
        0x726ac,0xdefed,0x7f9cc,0x06385,0x65da6,0xf8c76,0x92a75,0x221c3,
        0x672ca,0x955dc,0xd264d,0xcc8dc,0x2b66e,0x04ff2,0x8ba70,0x18a45,
        0xaa9ae,0x53fb1,0xbabd6,0x44df8,0xcea96,0xa0de7,0xe802b,0xa9378,
        0xc6c75,0x2dca2,0x44cc1,0x00001 } },
    /* 146 */
    { { 0x9aa3a,0x1d298,0x93a0a,0xe64d5,0x359e6,0x3f228,0x32ed8,0xd32e7,
        0x8b0cb,0x49e93,0xc3cb2,0x64c53,0xcf4c4,0x9ea6a,0x5f8f8,0x9750a,
        0xcfc32,0xbf346,0x67e5b,0xb8094,0xd37b2,0xbfab9,0xc6dc9,0x3b339,
        0xb7453,0xeef8e,0xb766d,0x1fbe3,0x73fe0,0x6aea2,0x254ef,0xb3154,
        0x61b10,0xf27be,0x55c3d,0x84885,0x1dd81,0xfb6d8,0x4f970,0xbbe71,
        0xaf3a4,0x93da1,0xd18f6,0x20179,0x9575f,0x65b83,0xc6b24,0xdc08f,
        0x4a951,0x336b8,0x74ecf,0x00008 },
      { 0x3f6be,0x3ebbb,0x24af8,0x423d6,0x908bb,0x78fbb,0x527f5,0xd7873,
        0x3b0ba,0x42562,0x62e04,0x9bd8a,0x9c365,0x236f7,0x167fe,0x2903b,
        0xf26a6,0xc6e53,0x5a430,0x12cf5,0xe3ad7,0x2547a,0x72b22,0x76eb2,
        0x890d7,0xf9b73,0xd628d,0xf70b3,0xc95b4,0xeae4a,0x3b053,0x9f0e1,
        0x2174e,0x38e7f,0xb4f51,0xae175,0x998db,0x482cf,0x48075,0x44518,
        0x9bbde,0x5c2b6,0xafef1,0x9652c,0x94f27,0xbcaf1,0xf2bb6,0xa0a3e,
        0xc634f,0x81ce4,0x1fb85,0x00003 } },
    /* 147 */
    { { 0xcd607,0xd1615,0x98306,0xc3a63,0xaaa32,0x0c9fa,0x31d68,0x77791,
        0xa705b,0x00e87,0x6708b,0x013a3,0xf1031,0x45297,0x0e194,0x814fa,
        0x79b56,0x3aa6a,0x0c558,0xbed47,0xf4b16,0x039cb,0x8d303,0xaaaaf,
        0x7ca8d,0xa518a,0xcdb68,0x59e75,0xaf331,0x3814f,0x738d2,0xdea0e,
        0xf4f9f,0x188d0,0xb3527,0xf032e,0x9dcdf,0xb7660,0x38bb0,0x3d483,
        0xa8ea9,0x7a65b,0x5dd50,0x4d825,0x41804,0x4a50b,0x23e4a,0x844a2,
        0x19e54,0x0018e,0x83230,0x00009 },
      { 0x3d5a6,0x2757f,0x8a210,0xadcd2,0x86e8c,0xce564,0xf3bff,0x02551,
        0x0381b,0xf1959,0x35ebd,0xc64f9,0xeb26c,0x83aa6,0x291c0,0x60611,
        0x4cf41,0x6688e,0xd988a,0xb1b5c,0x3dd53,0x1c3f7,0x21d58,0x77fc6,
        0x804a9,0xfa78c,0xadca2,0x4330f,0x23187,0x3ccf0,0xda4c8,0xf7008,
        0xa4707,0x1da79,0x4122a,0x5eb5c,0xf4a91,0x8e0d3,0x6609a,0xd0123,
        0xe157d,0xa0a2d,0x5ead2,0x43b26,0x545ef,0x8db28,0xade18,0xd0a22,
        0xe0caa,0x9e922,0xabbe3,0x00008 } },
    /* 148 */
    { { 0xd2f01,0x053a2,0x44469,0x685cb,0x35dc6,0x7c319,0x027d2,0x1d74a,
        0x08bbf,0x1d6a9,0xb50ec,0x350f5,0x601da,0x3c2e2,0x45e3f,0x1d3dd,
        0x6ee92,0xd0b83,0x66e11,0x979cf,0xf474b,0x03908,0x8347e,0x98b87,
        0x7c5b9,0xe919e,0xd3d1d,0xd3feb,0xba741,0xf6059,0xe8d1e,0x63c68,
        0x4e247,0x39367,0xb9ff9,0x67f69,0x73e7e,0x7d53e,0x2481d,0xaee9e,
        0xdc326,0x4c698,0x3bd98,0x3edab,0x752f2,0x8fe8a,0x1b06f,0xf95e3,
        0x0ba95,0xd0c3d,0xf15b4,0x00000 },
      { 0xa8d85,0x35790,0xf2f66,0x5af18,0xee259,0xbffba,0x28751,0x24b51,
        0xb7ec6,0x5dd15,0x23471,0xb6ab3,0xd7639,0xc5441,0x2992b,0x0cdd5,
        0x05833,0xa4f6d,0x4800e,0xe3605,0x2f6d6,0xefd75,0x61321,0x19290,
        0x7ffe5,0xcdc0b,0xea898,0x5825e,0x6b68a,0x98226,0xa9222,0xecedb,
        0x06bb2,0xb0bbd,0x78a91,0xb0cb6,0x04bb6,0x436dc,0xa98b2,0xcaf8e,
        0xa99e7,0xbbcf7,0x1aa05,0x0e6e7,0x1b92d,0x993eb,0x471f5,0xbf8d0,
        0x85ddb,0x78203,0x15db3,0x00005 } },
    /* 149 */
    { { 0xbef22,0xaa6f5,0xe43ea,0x8712e,0x82034,0x2d269,0x6c695,0x7a3af,
        0xc484e,0x031e4,0xa8c94,0x34c69,0xa18d4,0x01899,0x74150,0x63e5d,
        0xea40c,0xbcfe8,0x238db,0x87215,0x29679,0x6cc8d,0xde8ca,0x04acb,
        0xb6aee,0xce73d,0x7f993,0x328db,0x4bf69,0x45e33,0xbbfad,0xa3f79,
        0xf1630,0x937c1,0xc51ec,0xa6de8,0xf9b00,0x07325,0xbc349,0x12d82,
        0x6acb4,0xc949e,0xec59f,0xb36d0,0xb5901,0xf34e3,0x7109c,0xcb09b,
        0xf4c02,0x7e1ab,0xde048,0x00002 },
      { 0x9d484,0xf38dd,0x8b722,0xbacc1,0x37c77,0x34939,0xb8a83,0x93d92,
        0xbb8f1,0x2558d,0xe3fac,0x8d508,0xd80d7,0x5f4a7,0x98174,0xf0500,
        0xcc29d,0xed877,0x072bf,0x89f8d,0x2c30a,0xabf8f,0x0d767,0x9a082,
        0x567ea,0x3892c,0xa3a57,0xb12e8,0xb425a,0x55521,0xaebf0,0xc162f,
        0xea5e9,0x26b94,0xe1c4f,0xe546e,0x43d71,0x41499,0xe1d1e,0x43e8b,
        0x183b8,0x0b258,0xf9eae,0x7c82e,0x04491,0x874a3,0x45773,0x6813a,
        0x2f86e,0x71cc4,0xf6ac0,0x00006 } },
    /* 150 */
    { { 0x6e3b1,0xad4dd,0x38822,0x0869d,0xcad62,0x78e1c,0xe80fc,0x2cacd,
        0x43845,0xe3e78,0x8469f,0xc14aa,0x2121c,0x7e8ef,0xda7e6,0x8e8f3,
        0x47448,0x6e4d3,0xb83d1,0x31f4d,0x87986,0xa1dd9,0xc173b,0x0a4c4,
        0xb5977,0x1fdfa,0xedc70,0x13063,0x81f0a,0xd8ff2,0x6016c,0x4649d,
        0x55bc9,0x0bbcc,0x26723,0x412a2,0x05760,0xa19c6,0xef602,0x328fa,
        0x9d5f1,0xd9c71,0x67eaa,0x969ef,0x527cb,0x9bafb,0x30e71,0xf3425,
        0xa82cb,0xccff5,0xe2c24,0x00006 },
      { 0xf8793,0x4bada,0x31302,0x948e6,0x1035c,0x4bccf,0x0bf94,0x95350,
        0x066b7,0x65e9a,0xd1167,0xa9461,0x87991,0xd93c7,0xb2e9f,0x95add,
        0xe5495,0x37e92,0x5d2c0,0xe5cf0,0x89f03,0x145b1,0xf72cb,0x95aa1,
        0xe48ca,0x4f81a,0x35a6e,0x27021,0x5203f,0xb2a7d,0x5a249,0x2bcef,
        0x7f2a3,0x0002d,0x687a9,0x45b00,0x86c67,0x7d322,0x3052f,0x86507,
        0x8a875,0x8f3da,0xe8dc5,0xb8842,0x5be38,0xf1118,0xf34db,0x6b48b,
        0x08f91,0x0d97c,0xaf7fd,0x00005 } },
    /* 151 */
    { { 0x224a5,0x50f4a,0x5f9b9,0x273a5,0x4cc50,0x90457,0xfd541,0x643f1,
        0x81330,0x8334f,0xe50f7,0x01bb0,0x29968,0x58171,0x40389,0x866d7,
        0x91d36,0x5da40,0xb9a40,0x6fe7d,0xf16a4,0xe379d,0x168f1,0x83bf9,
        0x4a93f,0xca8d0,0x2b20b,0x83353,0x0ae4c,0x2a1c1,0x4b1f7,0x99d33,
        0x95db4,0x77d81,0xfbc99,0x4b5d8,0xffba1,0xeb3df,0x476ca,0x76daf,
        0xef022,0xf460f,0xb5b72,0x8dfed,0x24b94,0xdfb06,0x925b6,0x5185c,
        0x9d4ae,0x81960,0x7a9c3,0x00002 },
      { 0xa93af,0x46f12,0x3c373,0x634d7,0xc5536,0x8b707,0x3d102,0x49819,
        0xa58d5,0x9d8ef,0xf21b6,0xa5cce,0x24f83,0x88a0e,0x0a3a7,0x05cbb,
        0x13c98,0x8165b,0x10317,0x784c0,0x82b73,0xa20e5,0x1f2fe,0xe5036,
        0x713a0,0xd9df9,0x0cc22,0x9a0fd,0xb3144,0x5e2e1,0x2e77c,0x18375,
        0x044cf,0xbdb67,0xe44d6,0x177a6,0x5733e,0x2dde9,0xc2301,0x08ee2,
        0x49669,0x4968b,0xf5f19,0x05411,0xfd9bb,0xcd886,0xc716a,0x95182,
        0xe9244,0x94fbd,0xc6906,0x00001 } },
    /* 152 */
    { { 0x80026,0x173a8,0xdb67d,0x95f25,0x0125d,0xc4f0a,0x7a489,0x3f6cb,
        0x50551,0xa5290,0xcbbdc,0x31d15,0x33eb2,0x2bcbd,0xc9997,0xf8cff,
        0x5a03a,0xd4ad5,0xb4ef4,0x7c2fc,0xa2286,0x4d47c,0xaa594,0x0ead1,
        0x88548,0x4596d,0xbc8b0,0x7cf8c,0x076a5,0x5e55a,0x44b00,0xdfe58,
        0x8a097,0x191d1,0xe9e7e,0x3c745,0x85292,0x7a26e,0x33995,0x7f5db,
        0x67b79,0xc8d08,0x3bed0,0x408e6,0xc2553,0x9ad23,0x5d568,0x1596e,
        0x4c339,0xd6a50,0xb8c13,0x00007 },
      { 0xb6901,0xad52f,0xfc43a,0x253b2,0x916ca,0x0313f,0xdc61c,0x515aa,
        0x5830a,0xc2147,0xf577d,0x19267,0xdc93d,0x23c0d,0xe8ef7,0x26e52,
        0x9f6da,0xb83eb,0xf1e0e,0x376d2,0x2f180,0x79de8,0x93999,0xb0834,
        0x28ecb,0xe743e,0x39c38,0x51dca,0x59a2d,0xe3f6b,0x3a9a8,0x6e606,
        0xb3270,0x3a4b9,0xcf1da,0x915d4,0x2d2f8,0x5348a,0x9126e,0x50507,
        0x5e3e0,0xfa5e7,0x0d383,0xce572,0x9aeff,0xd2fb2,0x3cc8f,0x1d6d5,
        0xf4cd0,0xf6696,0xe3c3e,0x00000 } },
    /* 153 */
    { { 0xe1d83,0xc121e,0xbc337,0x77883,0xd787b,0xe08f6,0x4ce97,0x138fa,
        0x09fcc,0x58bf7,0x0348e,0x7647a,0xdbaf7,0x5e672,0xabca5,0x04f8b,
        0xec5dd,0x9d7d5,0xed291,0x92180,0xf33e9,0xe64bf,0x9af8c,0x24b05,
        0x9fc57,0xbaac0,0xc5e32,0x31f9d,0x95068,0x5af6a,0x67746,0x26a22,
        0xf1ff8,0x66c97,0xc5efe,0x87fd3,0x6bc60,0x15e0d,0xc6b15,0xaa8ed,
        0x39c5e,0x29b1a,0xe79ed,0x16bb0,0x83dd8,0x3788b,0x769bc,0x6cc13,
        0x2a51c,0xe3c09,0x63098,0x00004 },
      { 0xd0fa7,0xc7c8b,0xa6408,0xde493,0x1ce6b,0x76431,0x7bed1,0x283ef,
        0x5e108,0x38e31,0x9b5d9,0xcc779,0xb8213,0xa49a6,0x58145,0xaf7f1,
        0x9e4d1,0x0fe52,0x00fdb,0xc9d6d,0x7ce66,0xd38f7,0x95255,0x1bd4b,
        0x7ccc0,0x86b4f,0xf71f9,0x5b49a,0xa8d97,0x64d00,0xfcbcd,0x12b59,
        0x3bad7,0x04a5a,0x860e5,0x89f11,0x42b5c,0x97604,0x31f6d,0x7a3e2,
        0x0c659,0x92fed,0x78cba,0x4c331,0xe5811,0x98e11,0xc0666,0xe2e74,
        0x8b85a,0x93a34,0xf8fd0,0x00007 } },
    /* 154 */
    { { 0x428af,0xcac19,0x24592,0x8665f,0x13a30,0x2a1c8,0xd7f19,0xe30bb,
        0x89812,0xb9425,0x36c6b,0x07238,0x710db,0x8e498,0x1e959,0x9c7a4,
        0xd6f4b,0x9e6ea,0xaff17,0x2c448,0x97586,0xf8f9b,0x83e70,0x6f219,
        0xb0237,0x526b3,0x8e651,0x3e9b9,0xa25d8,0x51218,0x6a8d7,0x3b2d2,
        0xf1da6,0x1a9d6,0x50828,0x1f749,0x5a5a8,0xf78d0,0x4718d,0xe4687,
        0xee559,0xccd79,0x787d8,0xca576,0x52060,0x476c9,0x4ffa8,0x427a8,
        0x35131,0x51e64,0x7b64c,0x00008 },
      { 0x0d3c4,0x654b3,0x7f46f,0xef148,0xc23b4,0xec4c5,0xd68cd,0x63ca4,
        0x74766,0x6db3b,0xf3fb5,0x4269c,0xa1df3,0xd7d46,0x9c40f,0xd4f13,
        0x9a8bd,0xc76a6,0x3b7c7,0xd7d2a,0x9cbad,0x56b4c,0x334ee,0xac942,
        0xff342,0xa3b28,0x86f1d,0xfdfa7,0xe0046,0x00c82,0x49cb7,0xce5d1,
        0x66597,0x81509,0xa30ef,0x4bddc,0x9fcff,0xa2060,0x26844,0x44925,
        0xf65e7,0x380f2,0x4021f,0x552cd,0x0e5b6,0x2dbbd,0xc2a04,0x77ea9,
        0x062f5,0x7cd9c,0xc9526,0x00008 } },
    /* 155 */
    { { 0x1abb1,0x2e5fc,0x65503,0x47436,0x412fe,0x15af5,0xef522,0x29f05,
        0x57560,0xe9fd6,0xc191b,0x3325d,0x0b0e7,0x8639b,0x65ec0,0x7ab3c,
        0xe6673,0x511c3,0x7507f,0x55556,0x3c861,0x8befc,0x4ad63,0x42f0c,
        0x188cf,0x6d5d0,0x89618,0x301cd,0xe843a,0xc6741,0x3f7b2,0x04560,
        0xcd1d0,0x0cfa3,0x7545c,0x672ef,0xd4a40,0x12aff,0x8ddf6,0x45b9e,
        0x97c9f,0x74561,0x7922d,0x237d8,0xfb453,0x2d59b,0xe3a4b,0xbf132,
        0xa6a16,0x73b84,0xafa1b,0x00008 },
      { 0x3ac70,0xeae79,0xb3596,0xdd106,0xeeef6,0x94ef8,0xe404c,0x70422,
        0xb4fa2,0x63926,0x9e5d7,0x1dcee,0xfc8c7,0x12aad,0xb70f5,0x352fc,
        0x3975f,0x38a88,0xb7ba1,0x3b131,0x0058c,0x99139,0xfd157,0x97740,
        0x2092a,0x97969,0x60b06,0x945b1,0x219ad,0x837ab,0x38810,0xbc634,
        0x4bb71,0xc4f17,0x6ee11,0x80eb7,0x1ab1b,0x11bfc,0x58a61,0x70ec4,
        0x2bac8,0x25bc8,0x12d33,0x01273,0x8eee6,0x40adc,0xb1ab2,0xb4118,
        0xa093c,0x912b5,0x72111,0x00006 } },
    /* 156 */
    { { 0xcf9bf,0x06f55,0x1e993,0x96d99,0x8a46b,0x04530,0x5df9b,0x9e7a6,
        0xc1e1d,0xbbae3,0x731bc,0xb151c,0x1453c,0xd58a6,0x227a4,0x14be5,
        0x74cc2,0x2297c,0x9dac9,0x00d63,0x5822e,0x0f7a4,0x3df4d,0xc62b0,
        0xb1d51,0x2dafe,0xaa18b,0xc3a4b,0x0bb1d,0x2b74f,0x178df,0x7f3c7,
        0xb6a33,0xa6896,0xcd328,0x055ff,0x41dce,0x5ed45,0xb87e9,0x6a4e2,
        0xbc76b,0xe997f,0xa59dc,0x67f1f,0x1e5ec,0x0367c,0x8accc,0x05236,
        0x4a3fe,0x1654e,0xc8639,0x00007 },
      { 0x388cf,0x5eca7,0x5e94b,0x5d385,0x0c033,0xcc0a6,0x5ba17,0x616f8,
        0x9b78b,0x809b6,0x01229,0x02ef1,0x9705d,0xfd0a7,0xe801c,0x565a6,
        0xee352,0x6d7d1,0xb74a9,0x9dade,0xd427b,0x8832e,0x30f5c,0xe6d53,
        0xa8528,0xe896e,0x8d24e,0x862b1,0x730d8,0xf939f,0xed59f,0x9cd38,
        0x60252,0xa2010,0x90fc9,0xb3ff6,0x82303,0x2d88b,0x469c6,0xdd52b,
        0x2d7a4,0x93fc4,0xcad2d,0xdfa28,0x806f8,0x92043,0x09060,0x50236,
        0x855ad,0x58fce,0x25827,0x00003 } },
    /* 157 */
    { { 0xe8c60,0x5f359,0xb20e4,0xa186e,0x5364c,0x1bb8a,0x110c7,0xdff8e,
        0x15071,0x7802b,0xc93e5,0x91d34,0x8074e,0x29d0d,0xe00b8,0xc0326,
        0xa83fa,0x58626,0xc1922,0xa09e3,0x5fb29,0x7a64d,0xc8238,0xe5ac5,
        0xa3d34,0x29caa,0xda2da,0x85e5a,0xe8ed6,0x29650,0x267eb,0x92720,
        0x802f3,0x19763,0x7184b,0x1aeaf,0xedf6b,0xf5dd0,0x25d23,0x25e61,
        0xfa347,0x1abe1,0xc872a,0x7f9d0,0xfd628,0x57c3a,0x3d2ac,0x49aa9,
        0xa7656,0x715bd,0xa4e6a,0x00001 },
      { 0xd1267,0xde554,0xa126e,0x2b481,0x31cd0,0xf9453,0xb1d37,0xce31f,
        0xaf04c,0x12d70,0x97dc0,0x0b0b0,0x5cf41,0xc7b6c,0xd1736,0x930e1,
        0x91085,0x41c68,0x02fee,0x638f9,0x779fb,0x9ba4a,0x8df34,0xacd6f,
        0xc5821,0xcea16,0xe076a,0x83c12,0xdfb3b,0x01d14,0x33be5,0x6b8d0,
        0x2d2da,0x5220f,0x593d4,0x18800,0xd99df,0x52526,0x3a637,0x9feb3,
        0x2351c,0x56ca3,0xf6ef4,0x43bc1,0xad913,0xb9dc8,0x7db35,0xc7485,
        0x4e832,0x9385b,0x56a7c,0x00008 } },
    /* 158 */
    { { 0xa5583,0x020d0,0x007d0,0x658aa,0xdeda4,0x1301d,0x9be2f,0x34d93,
        0x07964,0x3691c,0x70c08,0x6780a,0x0a0cb,0x81e54,0xf95be,0xc0b4d,
        0xac8b8,0x345d4,0xcbbcd,0x62396,0x05475,0xc52ed,0xeb657,0x1805c,
        0x2dca4,0x55cac,0x93442,0xe6ab7,0x6915e,0xc9a2a,0xf3124,0x366de,
        0x2c674,0x2f8c1,0xd3b96,0x7c3bb,0xb7dbb,0xb64f1,0x95baa,0xe22bb,
        0xe4553,0x743c0,0x4c63b,0xfebac,0x12408,0x4da63,0x3122a,0x3ca77,
        0x6da40,0x84c63,0x28890,0x00006 },
      { 0x8d208,0x538cb,0x457fd,0x06d4a,0x9543f,0x8f800,0x2ab7a,0xf2eff,
        0xde154,0xe7b66,0x72517,0x28ebf,0xcfddb,0x389d2,0xe66f9,0x0149f,
        0xb88ce,0x3fd85,0x9e877,0x43f77,0xb0ba5,0x2e090,0xfc045,0xb0b03,
        0x9b5cf,0x7bdeb,0xc5ed7,0x448a6,0x23113,0xfc037,0x3cf8f,0x3609f,
        0xb4c4a,0x6d5c1,0xbc9c4,0x9be92,0x38fa5,0x6f3bf,0x691e6,0xcdb02,
        0x6bf5f,0xf9139,0x09f88,0x59d40,0x3f1ec,0xd9dfe,0x4562a,0xc2903,
        0xa4d58,0x2c5ad,0x9d812,0x00007 } },
    /* 159 */
    { { 0x29507,0xceaa5,0x4d4e4,0x5d001,0x47465,0x6a081,0x47405,0x4f0fc,
        0x30a38,0x8ec0d,0x443cb,0x03ea3,0xd8a82,0xf1728,0xfb097,0x33c62,
        0x0ef52,0xfdb52,0xa38dc,0x9d3e8,0xd7cac,0xf90d5,0xa50a0,0x873ce,
        0x7b0bf,0xcb28a,0xc6c41,0xae3a6,0x1d115,0x3812c,0x1daa1,0xa3517,
        0xd507e,0xa5624,0x5d4bb,0xf42f2,0x97e98,0xdad28,0x37191,0x96a41,
        0x6b1e9,0x77ffd,0x69e5b,0x2125b,0x7d46c,0xc4f70,0x42420,0xc7d2b,
        0x2557a,0x95814,0xab3af,0x00002 },
      { 0x372a6,0x4c6a5,0x6ca07,0x2ba78,0xe5629,0x8fb83,0xcf572,0x77741,
        0x596dc,0x9d745,0x20ef4,0xcea15,0x270b4,0xe4647,0xe3461,0x1472f,
        0x8ac5d,0x663fb,0x4d6bd,0xc071f,0x9c10b,0xe52cc,0x46146,0x371a3,
        0x94efe,0x77287,0x76fe8,0x07182,0x4a485,0xef5ab,0x7739b,0xedad5,
        0x5c815,0xff3f1,0x4c2d9,0x95c32,0x58f83,0x8950e,0x85518,0x80b6a,
        0x40996,0xe1bae,0xa8803,0xe22c8,0xe4f53,0x9d25e,0xf6103,0xaf233,
        0x409ca,0x35250,0x7db2c,0x00000 } },
    /* 160 */
    { { 0xd4703,0xdb037,0x7f3b8,0x88b9c,0xfc5f4,0x3708d,0x402e8,0x8471d,
        0xa830f,0xe91fb,0xa2faa,0xe8d25,0xea55e,0x04fc1,0xf1054,0xc2e5b,
        0xd5651,0x27aa2,0x47d50,0xf5f96,0xc7eba,0xa53c0,0xabf37,0x95b30,
        0xf0bb2,0xba7ad,0x64c93,0xe1fed,0x85a62,0xef4a7,0x8c0e2,0x7ffc1,
        0xcd04f,0xd94d2,0x39dd9,0xaf021,0x75ea0,0x3fbab,0xacf25,0x0fef9,
        0x100ea,0xa77c8,0x8615a,0x384dc,0x974c5,0xe5206,0x82d9f,0xcb286,
        0xdd759,0x8fcf7,0x8b6ca,0x00000 },
      { 0xc3b5a,0xea036,0x04e5b,0x2b4be,0x27f9f,0x72610,0xc0f38,0x29797,
        0xca570,0xa3a9f,0x2879e,0x180b8,0xf1656,0x7f0dd,0x9bb60,0x15338,
        0x0e087,0x3c67b,0x9a122,0x7fc79,0xc9d89,0x1808e,0xf190d,0x916ed,
        0x0711a,0x18947,0x72171,0x2f2b0,0x6f8f5,0x8888b,0x9ffd1,0x5d8b2,
        0x6f900,0xc54cc,0xf1e22,0x877fe,0x5eb24,0x03616,0x525c4,0x35479,
        0x95233,0x8afda,0x86146,0xa4216,0x8d622,0xfaba0,0xb0774,0x5d043,
        0x1a7d2,0x020d3,0xc337b,0x00002 } },
    /* 161 */
    { { 0x2fa65,0xbcea2,0xb2305,0xf63a7,0x4d159,0x183ef,0x23fbe,0x3f359,
        0x3d87d,0x53347,0x11d77,0xb306c,0xfb27f,0x054cf,0xe6b2a,0x702e7,
        0x85619,0x7caf1,0xce9f9,0x51c53,0x34e7d,0x55024,0xc5b83,0xf356a,
        0xe3d82,0x31a63,0x76451,0x7caad,0xd867b,0x71fc9,0x6afa6,0xee85e,
        0x7cd77,0xde2b0,0xb985e,0x51933,0x0ffda,0xd598b,0xc3607,0xa942d,
        0xeca39,0xa9b10,0x06218,0xdcee5,0xa17f3,0xb7d5c,0x8d106,0x3d94e,
        0x831c9,0x34ed8,0x09b26,0x00005 },
      { 0xaed54,0x4e48c,0x1b941,0x1e97b,0xccbf5,0xa78c6,0x25877,0x4de9b,
        0x88c8d,0x78a46,0x1ee3d,0x137c9,0xc0024,0x0ee64,0x234e3,0xa68f9,
        0x90d78,0xbc881,0x73255,0x690b5,0xfba80,0xe8e05,0xf4c41,0xec354,
        0x38d84,0x16500,0xfa528,0x02d6d,0xab18f,0xb63fd,0x007cc,0xc47f9,
        0xae455,0xfbe98,0x9d480,0x319d2,0x25d0e,0xc45d2,0x7194a,0x026db,
        0xf3575,0xb9d06,0xc3587,0x9e202,0x7733b,0x31772,0x9922c,0x22483,
        0xb8752,0xa754b,0x592d5,0x00001 } },
    /* 162 */
    { { 0x453f0,0xa2cf7,0x778d9,0xc1f05,0xaed83,0xfb899,0xba7af,0xe0a82,
        0x506d3,0x81ae6,0xa3d50,0x4e1ae,0xb32c8,0x0aa38,0x8c081,0x9ad52,
        0x7d041,0x20bd3,0x1fdb0,0xe41fb,0x1d06c,0xd6cbe,0x7f678,0x2e74b,
        0x7f0f0,0x22d28,0x43bb0,0x2575c,0x3f5cd,0x1a71b,0x2f3f8,0x6d28f,
        0x3e7f4,0xf5c63,0x65bb1,0x580ee,0xcc4fc,0xe5fc1,0x7a532,0xbb7b0,
        0x5539f,0x3acd5,0x3caaf,0x4471c,0xdb5a9,0xc22d2,0xdf44c,0xb958b,
        0x2777c,0xbd77a,0x614bd,0x00001 },
      { 0xab04d,0x30ed0,0xc1f02,0x82ea4,0x06e20,0x347b0,0xb5fae,0xc42c5,
        0x0bc63,0x359f1,0xe0199,0x9e6fd,0x5b053,0xdd082,0x4e765,0xd89bd,
        0xeda16,0xefbbc,0x2260f,0xca329,0xce62a,0xaa755,0xc5f8a,0x5ec82,
        0x62fa9,0x68ed7,0x86507,0x4c011,0xc99e6,0x2e348,0x245c9,0x57dd6,
        0xa6d68,0x7731e,0xdb88a,0x47360,0xb07b4,0x0012a,0x0feef,0x171d7,
        0x56b94,0xb0b93,0x3f891,0x06280,0x2e68b,0x9c20a,0x53ab7,0x3a54a,
        0xb0728,0xc7b00,0x89656,0x00004 } },
    /* 163 */
    { { 0x53c25,0xba713,0x43649,0x7e24e,0x113f6,0x7f27a,0x9e351,0x1c1eb,
        0xd333a,0xf910b,0x8e29b,0xc05c7,0xd94e1,0x43f15,0xd9747,0x84fe7,
        0xa2df0,0x0890d,0xc8749,0x3be19,0x75367,0x403fa,0x1b182,0x1baea,
        0xf5db4,0xad7eb,0x4180e,0xae352,0xfcfe0,0xf50c3,0x73fc2,0x1d158,
        0x61cd9,0xd6706,0x6851a,0x8c2c1,0x9a51e,0x2968d,0x09980,0xe0161,
        0x1a9cd,0x56e7d,0x8a7ea,0x3c89a,0x82b15,0xe3c49,0x78906,0x6d41b,
        0x69dcb,0xe9d67,0x82bb2,0x00000 },
      { 0x6615f,0x46c4d,0x180ef,0x829c6,0x101b9,0x629dc,0x4cafc,0x0fb26,
        0x22ec0,0xc4de2,0x0ecc2,0x7e061,0xdc545,0xea2c4,0x99f1e,0x95ce5,
        0xc5b2c,0x728f9,0x433fa,0x10f90,0x2cd63,0x03546,0x253ee,0xce2e2,
        0x57c3b,0x4484c,0x6d87e,0xc31a9,0x76c8e,0x52c5a,0x393a4,0x30bfe,
        0x7b235,0x40a04,0x592b1,0x545ec,0x8c018,0xd8be1,0xc467b,0x5c178,
        0xe0107,0x5b794,0xe2300,0x19462,0x34847,0x2a54f,0x23762,0x2665e,
        0xc9042,0x46901,0x6451a,0x00003 } },
    /* 164 */
    { { 0x93e71,0x18198,0x7802d,0x20821,0xb539a,0x765d8,0xcfca1,0x2302e,
        0xaea01,0x9dfc6,0x65bf5,0xf51b3,0x08d4c,0x232a8,0xd720d,0x87741,
        0x80427,0xb318e,0xc343e,0x39eca,0xfe747,0x3ecb2,0x7ca55,0x1a8b0,
        0xa79a8,0x3aaec,0x6f4ab,0xf3225,0x7089f,0xa1d1f,0x7293f,0x5e95d,
        0xa9a16,0xaef62,0x60569,0xddc22,0x2aa08,0x77623,0x54a5e,0x1b7bb,
        0xabec3,0xe793f,0x43d56,0x09567,0xf48a2,0x0ebef,0xb12eb,0x749cd,
        0x8fcf1,0xa469b,0x05307,0x00007 },
      { 0x8310b,0x04e48,0xa8e4c,0xcd7b7,0x25325,0x726e3,0xfac12,0x4983e,
        0xfd8b0,0x135d0,0x2ddb9,0x552c0,0xc796e,0xb9685,0x3f777,0x0eeca,
        0xf24a3,0x89b15,0xb766e,0xc9799,0x648ef,0x2736d,0xc6c7c,0xa8021,
        0x19685,0xea3d6,0x0b2f1,0xe278a,0x0fe33,0x76d6b,0x879b6,0x95c69,
        0x4e0be,0x191af,0x07473,0xee55a,0x136c4,0xfab5f,0x3b9a2,0x59e5f,
        0x8b8ff,0x6e693,0x9cafe,0x4da43,0x01e11,0x6ad12,0xec36a,0xc9595,
        0x62aec,0xd057e,0x0f79b,0x00008 } },
    /* 165 */
    { { 0xf09b3,0xa760a,0xcef42,0xfe143,0xd933d,0x016eb,0xaa83c,0xed85e,
        0xcf1e0,0xc9720,0xeaa3b,0xe99fc,0x7d4f5,0x106f9,0x9d2b7,0x7216b,
        0x68ad2,0x36c96,0x5f34c,0x651f6,0xc5b0c,0xfb82b,0x4dea8,0xf2fda,
        0x42f1c,0x9e20f,0x21f65,0xab2cd,0x8eb31,0x3d161,0x6c7a1,0xb7a77,
        0x62be5,0x22386,0xc4410,0x8e0be,0x0cad0,0x25da7,0x180c8,0x022c0,
        0x99079,0xfd992,0xaef9f,0xbda02,0x07623,0xc58b5,0x4f3f5,0xde84f,
        0x4ff19,0xa4d82,0xf5a5d,0x00005 },
      { 0x311dc,0x7e7e8,0x73725,0xf1365,0x1466c,0xf94f5,0x21ade,0xb05ca,
        0xe1645,0x37a73,0x2e4ab,0x9b3c0,0xb38ea,0x79165,0xac985,0x7760e,
        0xb01a4,0x47c24,0xffdd0,0x5584d,0x13fb9,0x8d4fd,0xbda18,0x25548,
        0xc38b8,0xacfaa,0x9e9dc,0xa6f05,0xf1a79,0xa2700,0x20f09,0x983f7,
        0xa7e48,0x54fb8,0xcbba5,0xfad58,0x847a1,0xa1996,0xb5e38,0x5abd6,
        0x56547,0xc2118,0x3716e,0x3d31f,0xb7511,0x12907,0x78142,0x1391e,
        0x15889,0x010dc,0x319c8,0x00005 } },
    /* 166 */
    { { 0x1c3af,0x6e6b6,0x32013,0xbb682,0xe07b4,0x40f2d,0x7f01d,0x380c9,
        0xdee7f,0x3a651,0xa8c31,0xba706,0x0a978,0x11ca1,0x7d620,0x22c58,
        0xf445b,0x18ab1,0x8bba2,0x44e64,0x7e504,0x5eaf0,0xcf98c,0x442fc,
        0x9f02a,0x3d554,0xd8049,0x746f3,0x12564,0xc0459,0xf6179,0x42d24,
        0xc8887,0x18abd,0x600fa,0x8f8f1,0xaded3,0xb8600,0xb465c,0x923ae,
        0xf9b90,0x8aa4b,0xe1c57,0xee351,0x4d63f,0xb9ea1,0x5aceb,0xf3c9c,
        0xa4ff0,0x4df11,0xd1331,0x00003 },
      { 0x13d1e,0x2db45,0x5cc66,0x52bde,0x5d559,0x78a8c,0xd0ade,0xe7f86,
        0x37a3f,0xc5e8a,0xa04f0,0x12a47,0xcca2d,0x25d06,0x6e42e,0x4c669,
        0x36071,0x98b21,0x26146,0xe1cb5,0xb89f6,0xd2701,0x95ef4,0x80efd,
        0xd6177,0x07aaf,0x5bb69,0x3ac4c,0xae6d7,0x0db35,0x4ac42,0x49e87,
        0x51fa0,0xe4f27,0x1631d,0x2edd1,0x6a1fa,0x9f733,0x94db2,0xb7fd7,
        0x06864,0xa64c4,0x22f92,0x21d3e,0x673cb,0x43cc7,0x4e620,0xeae90,
        0x2c6ad,0x9fb32,0x7f28a,0x00006 } },
    /* 167 */
    { { 0x48ab5,0x58ca1,0xc17b2,0x00517,0xfb3c6,0xa1976,0xdf9b9,0xc8f28,
        0x60698,0x17ea2,0x8d450,0xcc74e,0x287b2,0x78a42,0x32905,0x37257,
        0xec732,0x2517b,0x1d5ee,0xbbc48,0xf1d48,0x411fc,0xcfed7,0x487f5,
        0x17e6b,0x1b462,0x1eb8e,0x7ac54,0x8cb00,0x5a00c,0x7a6e0,0xc41c5,
        0x9fa99,0x2bd2f,0xf954d,0x1cad1,0xb4094,0x0bd5d,0x09d37,0x38295,
        0x7879c,0xeee48,0xceca5,0x75525,0xe4c13,0x3efb9,0xfa4fd,0xe8ef7,
        0x1bdb2,0x741bd,0xff091,0x00005 },
      { 0xc6632,0xa4579,0x91912,0x08157,0xfb8a2,0x19a44,0x9d3bb,0x53563,
        0x97b84,0xcef4f,0xc3c9b,0x2bcbb,0x0e57e,0x9e641,0xf2bf1,0x122b3,
        0x7d9ad,0xda135,0xf0189,0xff661,0xb79e5,0x5573b,0xc4c67,0xef2f3,
        0xe5c98,0x31444,0x4d107,0x1e200,0x5d6f6,0x75d63,0x66fac,0x0dfa3,
        0x54f23,0x862c8,0xfc47c,0x850b9,0xe0ad0,0x4ae43,0xc32c0,0x2f720,
        0x94f64,0x9d5ce,0x753bc,0xae65a,0x367ef,0x373a6,0x0d3b0,0xc27d3,
        0x21646,0x3a297,0x68101,0x00006 } },
    /* 168 */
    { { 0x509df,0x13e84,0x385d9,0x93761,0xdcf33,0x78bed,0x148e9,0x3423a,
        0x425d3,0x792df,0xe8cb5,0x0ae3e,0xc43fa,0xc4553,0x69d31,0xf0153,
        0xf1d48,0xbbdfb,0x5cf08,0x244a0,0x69444,0xff4be,0xa33ad,0xa35dd,
        0x35f81,0x7c016,0x76fab,0x8949e,0x3085c,0x73778,0xcde16,0x4bd7f,
        0x4f8d2,0x2ca25,0xd8cb5,0xc985f,0x6413e,0x168a6,0x6cc62,0x7a902,
        0xb9741,0xb7f2d,0x0e1e1,0xee565,0xe3962,0xbeffd,0x346d3,0xbee0a,
        0xfab1f,0x2f0bd,0xb35b7,0x00003 },
      { 0xc3749,0x9f535,0xff8de,0x9c48b,0xf8add,0xc1f20,0x66323,0xc8f8f,
        0x5b37b,0x49a97,0x8f3ae,0xe475e,0x82529,0x5e262,0x0d51d,0xc32f1,
        0x62f1d,0x97678,0xac0d2,0xbe365,0x8854c,0xc7933,0x46213,0x4b67e,
        0x004ef,0xe148f,0x5d10e,0xa150e,0x0fa37,0x8288a,0x78dd2,0x49747,
        0x73f4d,0x66cfb,0x6830a,0x49529,0x30780,0x44401,0x6949f,0x9760b,
        0x3c709,0x99823,0x5b75c,0xcca52,0xc8340,0x71f99,0x40bc7,0x3f62e,
        0x5c685,0xebcd9,0x7d0a1,0x00004 } },
    /* 169 */
    { { 0x811f1,0xff652,0x66f4f,0x30022,0x362ef,0xacaa9,0x0caea,0x50cba,
        0x87a55,0x676c3,0x07f54,0x142a0,0x3a350,0x2f267,0x02a20,0xc7fd1,
        0xc6e65,0x7033d,0xdaee5,0x63d95,0x3064a,0x682ec,0x51e60,0x462b2,
        0xf0bb0,0xe746c,0xda936,0x0ca55,0x50e03,0x4265b,0x0f243,0xc87a6,
        0x4e8f5,0xbb69b,0x637b2,0x770a9,0xc7ad7,0x1fb58,0x5a660,0xed3a1,
        0x147f6,0x611f2,0x995e9,0x7d5e2,0x605b4,0x213a1,0x9b383,0xcb0ca,
        0x5a85c,0x4a499,0xf4b61,0x00008 },
      { 0xeb3c1,0x194b4,0xaa8ec,0x3a705,0x42032,0x549ac,0x6aa8c,0x4f6cc,
        0x49322,0xa300d,0x5f9a5,0xb9bb4,0xb0e53,0x97abb,0x11008,0xe46ef,
        0xcd7d0,0x57d7a,0xe873e,0xb588f,0x50f7c,0xfccfe,0x7d17c,0xc8555,
        0x53d65,0xe20ea,0x288f2,0xeb447,0x8fdd9,0xeb68a,0xdfac0,0xab2de,
        0x03a0c,0x70086,0x82214,0xb06c5,0x900fe,0x46468,0xaac69,0x25e5c,
        0xcf5bf,0xe9804,0xfc91a,0x98589,0xed855,0xc45ea,0x8b173,0xed937,
        0xc9801,0x02524,0xf942d,0x00008 } },
    /* 170 */
    { { 0x45808,0x028e8,0xf1ec3,0xbfc51,0xab77a,0x02bff,0xdc7c3,0xf8d97,
        0xfd4b9,0x4b26a,0xaac59,0x83c43,0xc3d3a,0x4d94d,0xbd167,0xe3b74,
        0x5911c,0x37caa,0x464b7,0x2cd24,0x3871c,0x92577,0x0fe62,0x3b444,
        0xf2485,0x7d419,0x052ad,0xa0f3e,0x0dda6,0x6c86c,0x0d684,0x64528,
        0x24f42,0xfaf83,0x25689,0x117aa,0x807cf,0x4ad1e,0xdb7c7,0x8ddc9,
        0x6dea0,0x5d562,0x66fc8,0x03739,0x35262,0xb1eb5,0x7c3f3,0xe0ad5,
        0xc1acb,0x52949,0x83002,0x00003 },
      { 0x44723,0x405e7,0x0ef5a,0x8481a,0x51ae0,0x5bcf7,0x76fdb,0xfec1f,
        0xad8cc,0xc6abf,0xab37f,0xd831f,0x8fba5,0xfedb7,0x248c8,0xbe39e,
        0x3f310,0x5fad9,0x5cfad,0x5c24a,0xe913d,0x7fdb1,0x7f574,0x4518b,
        0xa47c9,0x27052,0xcfb43,0x8d6c7,0xe9e20,0xe538b,0xb9c70,0xb135c,
        0x17916,0x595bb,0x63527,0x06c73,0x05b31,0xc0788,0xb06a2,0xc209b,
        0x42a06,0xadd2d,0x3c504,0xb471d,0x4b525,0x2ce03,0x36882,0xc9f4b,
        0x185a5,0x96eb4,0x5f187,0x00001 } },
    /* 171 */
    { { 0xe4684,0x060ae,0x94dea,0xdbc80,0x67cdb,0xb21f0,0x31942,0xb1931,
        0x9e149,0xa6a43,0x1a7db,0xdd418,0xfea4b,0x2ae80,0x7063c,0xc6213,
        0x23dc2,0x67128,0x58b09,0x11b1b,0x58326,0x43d51,0x38474,0x13c20,
        0x6f831,0xd22e1,0xbd992,0x04d62,0xb0ce2,0x19388,0xcd6f4,0x499db,
        0x778c7,0x1d1d3,0x92ded,0xae734,0xfc5dd,0x5bd74,0x2599d,0x994b6,
        0x13d52,0x68d48,0xe86ca,0x9cf60,0xc191d,0xe9c2a,0x9eaf3,0x56217,
        0xe1238,0xf39fe,0x146f1,0x00006 },
      { 0xe2aa6,0x3e078,0xd06d3,0x9265b,0x79dee,0x3af7f,0xe8469,0xdaa40,
        0xe0f81,0x7ed56,0xb9a40,0xbb889,0x905fb,0xe9951,0xadced,0xdcf44,
        0xdba39,0xd3092,0xf71f8,0x774b7,0x54231,0x5b5da,0x5eb67,0xa5f60,
        0x6a251,0x9e745,0x7a39a,0xd4af8,0xd9031,0xb474b,0x00605,0xdb430,
        0x5aa91,0xf2b66,0xda5db,0xeeb4b,0x56631,0x1a3df,0xc585d,0x62377,
        0x149ef,0xff028,0x85d0b,0xf4e96,0xe2e1a,0xa465d,0x87582,0xe0ea0,
        0xd0050,0x9e06b,0x5543f,0x00009 } },
    /* 172 */
    { { 0x7c6ef,0xf485d,0x7cbc6,0xbc24f,0xd63b1,0xd8084,0xa62ca,0xbf8cb,
        0x0ce88,0x92df9,0x455c1,0xb686b,0xd98e4,0x4fc6e,0x8d577,0x6146b,
        0x20077,0x9e7ae,0x0e238,0x25297,0x961c2,0x41c47,0x5f552,0x3884e,
        0x21510,0x737d2,0x7e282,0x0ce21,0x8d6d2,0x2674f,0xf514f,0xe3119,
        0x011db,0x5570c,0x54590,0x760e8,0x9fcfb,0xab75d,0xa19df,0x9e8c2,
        0x6362a,0x27954,0xa7d4b,0x3f8a4,0xc4b6d,0x5d698,0x104ee,0xa5c87,
        0x296ff,0x782ba,0xdb434,0x00006 },
      { 0xf0d95,0x935c3,0x64864,0x88950,0x24e74,0x17db8,0xe4489,0x6b2f3,
        0xfdf62,0x4bf73,0xb7f57,0xdc542,0x3c60e,0x73272,0x9a2af,0xbe1c0,
        0xd114c,0x9d7ca,0xd3466,0xaff97,0xa321a,0x46600,0x61c96,0xed0cd,
        0xe2bba,0x0eb94,0xec475,0x1a41d,0x8866e,0xa89f5,0x90db1,0xa1be9,
        0x59693,0x6cf27,0x39e4d,0xdddfc,0x0c0e0,0xcfb78,0xa4111,0xd99c8,
        0xfcd7f,0x50f0a,0xe1c30,0xfadb6,0x4cebf,0xd2c6e,0x1b096,0x4f398,
        0x27a94,0xe72ae,0x7a791,0x00000 } },
    /* 173 */
    { { 0xf0300,0x471e9,0x70e90,0xf904e,0x9bccd,0x253ad,0x078e0,0xff053,
        0x0289d,0x6251c,0xe8934,0x092ea,0x5f1ef,0x84684,0x91aa4,0x2c90a,
        0xad4b4,0xa0f1d,0x946ed,0x67b21,0x333df,0x7650f,0x014f0,0x0b15a,
        0x988db,0xf9c6e,0x542f0,0xc66eb,0xf72e0,0xc0378,0x311e0,0x5d4b6,
        0x6950d,0xaaae8,0x48bad,0x1c8f5,0xdb35f,0x01638,0xad468,0x944d1,
        0xe3216,0x32129,0x0471d,0xbac84,0xe9951,0xe94dd,0x9f385,0x03cc2,
        0x3ecac,0x2e454,0xd6acc,0x00006 },
      { 0x2d299,0x9557b,0xb999e,0x21cde,0xbe3d7,0x2bcd9,0x4443a,0xbb4cb,
        0x0384f,0xaa2e6,0xc060f,0x7709d,0xeae17,0x987cd,0x6d38c,0x74f0e,
        0x6fbed,0xf8107,0xa237c,0xfbff9,0x37983,0xaf151,0x58469,0x323f9,
        0xf7a1d,0x986c3,0xdb643,0xcacf6,0x23e21,0x703d9,0x34f96,0x7cd81,
        0x93f76,0x8fb83,0x75589,0x52220,0xc2e82,0x5b28b,0xa7c1b,0x7924a,
        0x799c1,0x8ab78,0x1427a,0x78f28,0x21db3,0x28949,0x1b1ff,0xd5a45,
        0xc46ee,0x123d3,0x9d182,0x00007 } },
    /* 174 */
    { { 0xd5589,0xf9109,0xa3edf,0x44991,0x4029b,0xd52eb,0xadfde,0xb4b54,
        0xb9d30,0x6713e,0x27bff,0x14c1a,0x04f92,0xf0f46,0xee767,0x4c817,
        0x50e28,0x83c3a,0xadf8d,0x6237b,0x99402,0xdc03c,0x7c1c5,0x96664,
        0x9581b,0xf35f2,0xa0687,0xa0898,0x710b6,0x63451,0xcec31,0xae787,
        0x75188,0xa562e,0x001db,0xc3fb2,0x745e2,0xd4e1a,0x39555,0xb67d3,
        0xacdeb,0xeebfc,0xc6842,0xaf9cb,0xba1a0,0x88580,0xa2b3e,0x50590,
        0x4cdc8,0x91a78,0x31044,0x00007 },
      { 0x8d676,0xdf264,0x4ca2c,0x12b14,0x54f1b,0x85eca,0x1eb9a,0x2980e,
        0xdac94,0x891b9,0xac8aa,0x37091,0x5f30d,0x19e19,0xab7c7,0x73072,
        0x03797,0x822f7,0xa518c,0x67f6b,0x4ac00,0x090e1,0x927ac,0x8dcd2,
        0xcfc70,0x630e6,0x1e7da,0x89e22,0x64f58,0x71c7c,0x40b83,0xb4aaa,
        0x878c9,0xe28f7,0xf9dab,0xaf3f1,0xbd84c,0x8aed6,0xd92f7,0x9e0e1,
        0x9dd07,0xdc3c3,0x22424,0xe5fb1,0x9680b,0xdc009,0x14d0b,0xf41b2,
        0x0c54f,0xc9518,0xa8f8f,0x00006 } },
    /* 175 */
    { { 0x35132,0x63532,0x2a1ed,0xa88b6,0x159db,0xb233f,0xdd81d,0x291ef,
        0x25452,0xae856,0x25111,0x5297b,0x8c750,0x701bd,0xaf91d,0xb5921,
        0x4f45d,0x72977,0x4d05d,0x73ffb,0xef18e,0x3d4c5,0x0386e,0x899b3,
        0xd985f,0x58897,0x89b15,0x30fbc,0xc8a9c,0x13181,0x1a34d,0x3c92d,
        0x3320e,0xba222,0x92e86,0xed022,0x201ce,0x2454c,0x09fcf,0x583f3,
        0x45f74,0xa327a,0xd0fd1,0x102ca,0x875a6,0x9c753,0x5d2cb,0xdb4f4,
        0x83fd7,0xc1db2,0x752d8,0x00004 },
      { 0xff4d5,0xead5d,0x14d6c,0x27f45,0xb45a8,0xcd5fd,0x35e74,0x4fc71,
        0x0a60c,0x8e107,0xbe577,0xbb781,0x8dec0,0xdc6b0,0x2cd58,0x271e1,
        0xc2496,0x9b54b,0x76508,0x98acb,0x36190,0xdf2c6,0x8326d,0x67528,
        0xebac6,0xf1fd6,0x2508a,0xd025c,0x0eaa2,0xcfc1f,0xda84d,0x13c2c,
        0x10be0,0xa8455,0xc7836,0x68011,0xd1a88,0x04688,0x54539,0xafaf2,
        0x132aa,0x8d643,0x830a8,0x55772,0x04968,0x44b47,0x1ca87,0x56949,
        0xb8552,0xf375f,0xa6518,0x00003 } },
    /* 176 */
    { { 0x042a0,0x50224,0xaa8ed,0xf1e6a,0x02452,0xb4e3b,0x1d86c,0x76821,
        0xa5f4c,0x3fedc,0xf4d5d,0xe3f9e,0x54e0f,0x2d46e,0x2a452,0x33a8e,
        0x46775,0x1ff14,0x998e2,0xd01b5,0xef592,0x96c50,0x73914,0x83a67,
        0x04c2f,0x00691,0x72bbf,0x0bcb4,0xd2867,0x3177b,0x3b250,0x8ea88,
        0x712a2,0x057d2,0x5d8bc,0xc994c,0x7b439,0xef931,0xaff41,0xdcda1,
        0x1d3a8,0xfb980,0x038f6,0xeeb57,0x0d686,0xfbf82,0xcd0fb,0xe80c5,
        0x25817,0x63edc,0x40ac3,0x00005 },
      { 0xf43df,0xa9fe7,0x71969,0x9e4ca,0x82c1b,0x65380,0x917e6,0x859c2,
        0x677d8,0x04ad9,0x6aa44,0x95459,0xabaca,0x1297d,0x55fff,0x0e9d8,
        0xea7de,0x7b22a,0xf6189,0x3f8e1,0xd36f1,0xedccf,0x0df96,0x16e20,
        0xd3070,0xa4627,0x98988,0x0736c,0x2729f,0xf231d,0xe6097,0x95e25,
        0x48752,0x1bf60,0xf7f22,0xb299a,0x94019,0x68260,0x1d9d6,0x26b4b,
        0x9de09,0xa31d9,0xacdd7,0xcf661,0x9ec47,0xbe15e,0x2b36e,0x4de9f,
        0x6974f,0xecfa1,0x7db32,0x00001 } },
    /* 177 */
    { { 0x40599,0x196cf,0x5ef69,0x20ea7,0xb00c0,0xa10df,0x6797e,0xfcaaf,
        0x5ae7b,0x783da,0x8ddd6,0x3ca38,0xd0d66,0x5bcfc,0x8fe25,0x5a21f,
        0x4bc7e,0x38e34,0x9c3f5,0x0632e,0xd548e,0xf62b1,0x64d35,0x43c6e,
        0xf2425,0x27654,0x69936,0xa7a62,0x4c755,0xf4132,0x5f7b0,0xa3b7c,
        0x180f3,0x793a2,0x5697f,0x675b0,0x11e81,0xf85fb,0x8f56c,0xe5342,
        0xcdb35,0x026d3,0x2d28b,0x15915,0x8e3aa,0xa3fb7,0x255f7,0xa8470,
        0x4445d,0x1ba19,0x60bd0,0x00004 },
      { 0xd8077,0x23c24,0xc34dc,0x0d2cb,0x04c72,0xf4b58,0xffe82,0x6f5d1,
        0xda911,0xe2a29,0x2783c,0xf5209,0x3578a,0x904af,0x1abb5,0xe29f5,
        0xa1190,0xd7f7a,0x6c570,0xddf04,0xa571b,0x522fb,0xb514a,0xae89b,
        0xe2a06,0x4dbf4,0x9f344,0x35cc5,0x7799b,0xcc255,0x36726,0xc3028,
        0xec177,0x85afc,0x4a4e9,0xcbd09,0xb7c36,0xaf7dc,0x077ad,0x75d39,
        0x1b787,0xbced3,0xd3e24,0x904f2,0xb52d6,0x95421,0x6691f,0xc5ca2,
        0x4878d,0x3c173,0xd342c,0x00007 } },
    /* 178 */
    { { 0xd127f,0x0a11f,0x5cf2c,0x4c5ee,0x8119e,0xd36bb,0xac366,0x6ef56,
        0xab252,0x75621,0x54306,0xeaeee,0x930cf,0x3e961,0x7d2ac,0x2ede2,
        0xce671,0x3af8f,0x41351,0x4c3d6,0xb075f,0x59c61,0xd9861,0x59069,
        0x7efe9,0xa9d44,0xa76ae,0x6f68e,0x4af8d,0x5bd16,0x61b0f,0xac5dc,
        0x8bb98,0x6e1e8,0xbab44,0x2320d,0x61ba9,0x8b8b1,0x86561,0x78989,
        0xafb3c,0x82a0e,0x08b7e,0xbcc2c,0xb0c7a,0xd160b,0xb6e20,0x10f09,
        0xc63a7,0xa68e4,0xbe0af,0x00005 },
      { 0xbf49c,0x381bb,0x2ab6d,0x03fe8,0x98c07,0x09ce4,0x2633e,0xe10f4,
        0x58b5d,0x32eca,0xa5a45,0x6581d,0x7d9cc,0x18f7b,0x876f6,0x07e18,
        0xf7fe7,0xe3250,0x419a5,0x86be0,0x0de6b,0x1a9e9,0x169bb,0x37359,
        0xa7deb,0x2c584,0x149db,0x34895,0x838eb,0xebabb,0xa33b0,0x14546,
        0x88a92,0xb0c2f,0x067f0,0xb0190,0x70a2d,0xe0dfe,0xf3ebd,0xc63e6,
        0x1b06c,0xadba5,0x9206f,0x27b9e,0xaa191,0x80dc0,0xe87fe,0xe4eb5,
        0xe30ae,0xf5d4d,0xe6fcc,0x00001 } },
    /* 179 */
    { { 0xac924,0x66aa8,0x57dff,0xb3e8b,0x1c298,0xe9ad3,0x80c06,0x65fb0,
        0x0e329,0x3fd14,0xd95c9,0x211d1,0xa7dab,0x180ca,0x8428a,0x6d68d,
        0xded69,0x08a20,0xa9294,0x461f1,0x338df,0x15175,0x932a8,0x60eae,
        0x604ae,0x0bff5,0xdae4c,0x9e497,0x9901b,0x262e8,0x97fde,0x4573a,
        0x84983,0xa4f10,0xd69d9,0x4f1de,0xf6472,0xfa022,0x15f8f,0xea85a,
        0x1c2e4,0x94d5f,0x14537,0x6ce90,0xd4c62,0x0907d,0xcd6bf,0x80440,
        0xaa837,0x615dd,0x522d4,0x00004 },
      { 0xbe7c5,0x79ebf,0x895f0,0x34468,0xd84ef,0xea1de,0xb9630,0xd4a1a,
        0xa9eb6,0x68716,0x0a30c,0x5d225,0xa1a4a,0x43bba,0x31c00,0x5a166,
        0x0e5f5,0x02501,0xd1075,0x0556b,0xd3d8c,0xfe3e9,0x419bf,0x07772,
        0x30b18,0x9731b,0x4b822,0x7ef08,0x390ff,0x1a18c,0xd75f2,0x00c37,
        0xbb8f8,0x35565,0x8d0a6,0xbceb1,0xa45e3,0xc1da2,0x08dba,0x23f0b,
        0x8e90c,0xc51c3,0xfbc5a,0x1aa25,0x6f1ba,0xa71fc,0x56bdd,0x09d52,
        0xe40ba,0xa96d7,0x46501,0x00003 } },
    /* 180 */
    { { 0xb0f1d,0x8ccc2,0x6be44,0x37038,0x9ac4c,0xeb45c,0xbbfe3,0x9fc96,
        0x7f65d,0xda538,0xae27f,0xc4e95,0x9cef3,0xc1808,0x7761b,0xa008f,
        0xa18a1,0x8422c,0x374a0,0x3371f,0x253b7,0x88284,0x354ee,0x7cc09,
        0xfc6d8,0x6bcb6,0x1496d,0xec1b6,0x48489,0xe325c,0x9b949,0xa92c2,
        0xec166,0x527bd,0x5c6ca,0x28131,0xedcea,0x444ee,0x54f95,0x3a211,
        0x83eb3,0xcf346,0x39061,0x6f98d,0xb8fb2,0xc940b,0xaa806,0xc3b08,
        0x4c96d,0xcfe55,0xc1d42,0x00007 },
      { 0x10aa7,0x3fdc1,0x66e70,0xe3787,0x7f362,0x7b79d,0xa3cab,0x5aadc,
        0x9c75d,0x73d25,0x0be33,0xca796,0xf2a6e,0xc4e8f,0xa4b06,0xf4744,
        0x705bf,0xcef3b,0x2842c,0x4b53b,0xaae30,0x3af5a,0x1b81a,0x1b2d3,
        0xfa201,0xd97bb,0xbee88,0x6eba4,0x9c4ba,0x5cb83,0x5ce56,0x2d356,
        0x7ece8,0x96daf,0x48086,0x97452,0x7e695,0x7ccce,0x8372c,0xe94f9,
        0x6eb3c,0x26efd,0x811a3,0xb4cf3,0x60a33,0xfa93a,0xf43ff,0x14203,
        0x31d90,0x2873c,0x31e98,0x00000 } },
    /* 181 */
    { { 0xa17ff,0xfc765,0xfefec,0x0a654,0x8d129,0x9f388,0x038a0,0x938da,
        0x65c46,0x46bf2,0x169ad,0x145da,0x84bb6,0xa62fe,0x21423,0x33cf8,
        0x860a5,0x71abc,0x62df5,0x38c45,0xa815c,0x2a90f,0x875bf,0x17eda,
        0xa1d6e,0xe145b,0x46fa5,0x881a9,0xb799d,0x0f5a3,0x784b9,0x6c1be,
        0xff52a,0x7cb10,0x910a3,0xfd360,0x4a4f4,0x8c1fe,0xba0c3,0x8e2d3,
        0x80fc5,0x87c31,0x17a61,0xf050b,0x23e2f,0x3a35c,0x59b94,0x3a000,
        0xcc51c,0x45a28,0x94d36,0x00004 },
      { 0x021f8,0xb64ba,0x98426,0xeb6c3,0x3796d,0x4c908,0x762d1,0x7e36c,
        0xe5395,0x166d2,0x51cf2,0x6eca7,0x98f55,0xb24a1,0xe0019,0xdaca1,
        0x0c2ae,0xa44b2,0x7887d,0xa7334,0xdff41,0xed4cc,0xcd793,0x5c7c0,
        0x17c44,0x098d7,0x1bf70,0x634a9,0xfcc48,0x59bba,0x6f93b,0xa1f14,
        0x24f15,0x39e56,0xd38bb,0x8443d,0xd303f,0xd41aa,0x4fc96,0x4bf10,
        0x70f03,0x826b6,0x97065,0xf9ed2,0x50503,0x4200f,0xf47b3,0x768e1,
        0x4c6f3,0x5ebbd,0xcfdcc,0x00003 } },
    /* 182 */
    { { 0x3e13d,0x86b52,0x36c2a,0xd0a05,0x82920,0x14a45,0x29610,0xe7571,
        0x2b478,0xea3d5,0xeb51b,0x60667,0x90574,0xb0e91,0x86187,0x709f7,
        0x888e8,0x88686,0x28aed,0xfcd40,0x7d94a,0xa809d,0xaf379,0xe2129,
        0x6032f,0x8250c,0x83c40,0xbe729,0xe75e4,0xb3be8,0xbbb7a,0x98331,
        0x8c728,0x2cb61,0x31a03,0xc4a4d,0x13f59,0xdd85a,0x1e236,0xed4f6,
        0xce345,0x15dbe,0xe5717,0xaccd1,0x7ba7a,0xa1ebd,0x8da64,0x138c5,
        0xaeea1,0x0f3d1,0x9296d,0x00008 },
      { 0x82c97,0x8fcca,0x16528,0xe8dcb,0xd1427,0xc6c12,0xda926,0x4c3ed,
        0x94f07,0xbe66a,0xaa01e,0x0e1ee,0xd9460,0xf5e86,0xe7c30,0x14abc,
        0x56a31,0x20cb4,0x41d70,0x42c27,0x3279f,0x05aa1,0x468ab,0xd4238,
        0x60faf,0xe670b,0x18d39,0xfec13,0x8a18e,0x20b31,0x1ac89,0xeb07f,
        0x99e03,0xa8d83,0x1e3cb,0xa3010,0xe3c81,0xf8932,0x7d865,0xccc66,
        0xbca7d,0x7cae8,0x26860,0xae79a,0xccee1,0xc0a12,0x64cca,0x3182e,
        0xa4c54,0xf72b1,0x233a2,0x00009 } },
    /* 183 */
    { { 0xbee17,0xf60ac,0x17e8d,0xfcdc7,0x25c24,0x0959c,0xcb00f,0xe54ff,
        0x09887,0x6b46f,0x28511,0xdecad,0x1b993,0xa1fa5,0x4f8bb,0x0bfaa,
        0x2183e,0xefd0f,0xc9249,0x77799,0x89684,0x3cb35,0x421f9,0x2322d,
        0xbfb7f,0x09284,0x42af0,0x709ad,0x540cc,0xb1d61,0x2749b,0xc69f2,
        0xc3c6a,0x3a717,0x6f50b,0x5eeb7,0x5bb9c,0x21e98,0xb5f8b,0xa4783,
        0xb19ae,0xe758f,0x2e1c3,0x6b9b5,0x804c8,0x971ac,0x092f2,0xaca59,
        0xd8291,0x6921e,0xbb26a,0x00002 },
      { 0x81416,0x3515f,0x8a344,0x5bb49,0x7aaff,0x6e72e,0x61c08,0x03172,
        0xf64de,0xfe3d1,0xc0a1c,0x786c5,0x131c0,0x68340,0x4d8b3,0x542ea,
        0x9b4cd,0x3a1a3,0xf7727,0x27f12,0x1cbef,0xfe7ee,0x7dc14,0x16bb2,
        0xfc09e,0xc7ee7,0x10e5d,0xcc174,0xdc0dc,0x43b3d,0x74219,0xa3466,
        0x1c1b7,0x603f3,0x2934b,0x10709,0x9c22c,0x86ded,0x66b01,0x799f9,
        0xee8ba,0x93a37,0x49b08,0xfcb42,0xe0f3b,0x92d4d,0x4472e,0xbae61,
        0x6eb08,0xf8e19,0x37cb3,0x00009 } },
    /* 184 */
    { { 0xbfdce,0x7c16f,0x7c0e7,0x4cc05,0x9c98d,0x034cc,0xd20ea,0x42572,
        0x06d72,0x3ce76,0x019a8,0xb55c0,0x29861,0x59716,0x803f1,0x80ba2,
        0x0fd7b,0xdd05a,0xf4141,0xaaa20,0xb4b0d,0x65913,0x8ec88,0xaa384,
        0x85746,0xd2e66,0xe0485,0x5a5a3,0xd16d1,0x6905d,0x7743b,0x81c0c,
        0xaf2ba,0x7d818,0xec31b,0x4b78c,0x4d2b7,0xd8f19,0xf2880,0x543e2,
        0x59db2,0x1cca6,0xfb07c,0x3a7d9,0x031b8,0x1048c,0xfdc1f,0x86537,
        0x86a11,0x07785,0xd57bb,0x00004 },
      { 0x396b6,0x8a53b,0xc4b76,0x1dacb,0x493b5,0x8b24c,0x1b3bc,0xa30ae,
        0x511eb,0xc533e,0x45147,0xbd959,0xe893b,0x9fe3c,0x03117,0x6cc86,
        0x20bd4,0x673f9,0x4b0a1,0x61603,0xb6b25,0x2912e,0xd83b3,0x9d168,
        0x9a2a4,0x28bc6,0xf0dd1,0x9e7ae,0x1b494,0x2699e,0x19a87,0x26134,
        0x1376b,0x77bf2,0x6c584,0x71470,0x9a4f9,0x5b190,0x45fe5,0x7b9b7,
        0x6eb75,0x8563d,0x8df3c,0x5b290,0x3b536,0xfcfae,0xe4355,0x0e257,
        0xf2aa8,0x18979,0x067c1,0x00001 } },
    /* 185 */
    { { 0xf8883,0x8432b,0x84550,0x6667c,0xa6fd0,0x55286,0x35d47,0x77c23,
        0xb0f8f,0x94d70,0xf4a2c,0x60da2,0x5678e,0x18acf,0x8acd1,0xa468d,
        0xb90d9,0x0bbf5,0xe9383,0x9104c,0x4ed4e,0x4b1c7,0xea4ea,0x27776,
        0x7316d,0x12ac6,0x61bab,0xd75c3,0x1b98a,0x12245,0x48299,0xc323d,
        0xa43ae,0x20530,0x64402,0xd5a52,0xe3292,0x44532,0x1bc3a,0x5fecf,
        0x8694b,0xb8db4,0x667b8,0x516ec,0xee4e0,0x306ad,0x95fa4,0xb3aa5,
        0xe9725,0x91f34,0xe4f70,0x00007 },
      { 0x70919,0xe9b7f,0xf3816,0x03f53,0xd16b0,0x5216e,0x9e576,0x778c9,
        0x6cff4,0x1046c,0x0a518,0xabe83,0xbe6a5,0xe728d,0x9e645,0xef6f4,
        0xcefd6,0xeacac,0xfdd73,0xf3f76,0xf8c37,0x394e6,0xfc3ec,0xb6407,
        0x20802,0xbd733,0x6625c,0x8f7a9,0x0988e,0xabfb0,0x3637c,0x83292,
        0xf359a,0xdf407,0x58ba9,0xae502,0x5ccbf,0x01aee,0x813ff,0xfe251,
        0xaeace,0xa1fbe,0x3f1cb,0xf1618,0x59c69,0xadcdb,0x8ad9e,0x512c5,
        0xce8bd,0xd46cc,0xae49c,0x00002 } },
    /* 186 */
    { { 0x849f2,0xe3c40,0x239b0,0x098c1,0xda441,0x36a4c,0x64951,0xe547f,
        0x35a99,0xc6615,0xa9bba,0xbdc47,0x692e4,0x547af,0x64653,0x195a1,
        0x7a74a,0x198b4,0x5ecb3,0xa2b28,0xc9de6,0x8553f,0x52d27,0x0e2ba,
        0xc038a,0x93471,0x5bcba,0x1b883,0x212ba,0x31eca,0x0da6f,0xd4bf5,
        0xb32c6,0xf6802,0x146e3,0xc8c4d,0x13c64,0x9c013,0x2970c,0xeed21,
        0x0f12d,0x0fad3,0xc6853,0xbffb9,0x19b75,0x18de5,0xd3e89,0x23c0a,
        0x771b7,0x52a73,0x80e9d,0x00001 },
      { 0xb77b0,0x2f29a,0x31654,0xe628c,0xcf7ae,0x411d9,0xf40dd,0x353c2,
        0xc0685,0xcf044,0xb0ae4,0xc7e44,0xf638d,0xfc266,0x18595,0xa0924,
        0xfeb7d,0x71fd2,0x39da6,0x97986,0x55ea3,0x858ed,0x32a56,0x58f38,
        0x94f31,0x317a6,0x316d8,0x33c6d,0xba942,0xa35a7,0xb2630,0x2fcac,
        0xf713b,0xddf1f,0xef8f7,0xe2f3f,0x559ee,0x9b452,0x64a8b,0x156d0,
        0x4f91b,0xfcd1b,0xf5cfc,0x66c22,0x11778,0x77eb4,0x56637,0x12bc2,
        0xb85b4,0x3cd8a,0x1ca6f,0x00002 } },
    /* 187 */
    { { 0x66635,0x13a3e,0xe162b,0x76af0,0xb2a9f,0xf20a2,0x3561e,0x46db3,
        0x73a30,0x8dab4,0x802bb,0xbd777,0xc0840,0x99b44,0xf5ea6,0x5b6ba,
        0x207f1,0x001b2,0x6e119,0x0105c,0x9790b,0xde16a,0x004e5,0xdb67f,
        0x12f15,0x2522b,0xa025d,0xad458,0x2185f,0x0a114,0x953df,0xbccf6,
        0x034c0,0x9bf45,0xc4212,0x7bff4,0x01c27,0x74040,0xe180f,0x280a9,
        0x40b4c,0xb46e4,0x42aa2,0xe8f58,0xf767d,0xe8d94,0xab805,0x3de20,
        0x27635,0x59202,0xaff58,0x00005 },
      { 0x58e40,0x20a84,0x05acd,0x32bd8,0x81497,0x5557d,0x72d5a,0x5f1ca,
        0x74131,0x23c70,0x52b53,0x269c9,0xf7f2e,0x94fad,0x55664,0x5c592,
        0xd2666,0xcd1a7,0x53b7a,0x28651,0xd86fe,0xdf063,0xb6ba6,0x57d53,
        0x1db13,0x011e9,0x93ead,0xbb89e,0x69195,0x63bfe,0x1af29,0x3d71e,
        0x78886,0xc2882,0xab2b9,0x9b6ff,0x23b85,0x83669,0xdd177,0xf7029,
        0x95174,0x616e6,0xb9845,0x78767,0x9c798,0x07d84,0xf1d59,0x64fb4,
        0x8a977,0x1c88d,0xeab7e,0x00003 } },
    /* 188 */
    { { 0x5718b,0xb652e,0x73a94,0xe1e9c,0x4f4ce,0xaefa5,0xdeae3,0x553ee,
        0xe9e63,0x1a654,0xf3aca,0x1e1b5,0x6f254,0x08331,0x4890d,0xd7129,
        0xf950e,0x63fb7,0x965af,0x3e4a7,0xdc74e,0xfc9e0,0xebcd8,0xeaf79,
        0xe48d2,0xe6b4e,0xb7787,0xa86a8,0x0a458,0xcceaf,0x21ff7,0xd8c76,
        0x7980d,0xffdf6,0x228ee,0x67278,0x2f910,0x0d474,0x62921,0xb07e3,
        0x63501,0x9d91f,0x971e2,0x61c67,0x54417,0xa3b8a,0x65f03,0xc0ccc,
        0x09544,0x4f38e,0x491da,0x00003 },
      { 0x62eae,0x46cb0,0x706d0,0x776d6,0x55d08,0x7db73,0x5d2ee,0x29231,
        0xe8052,0xdb80d,0x402bb,0x5662c,0x74078,0xed333,0x25c26,0x5f935,
        0x68ed3,0xd67d5,0xcea14,0x8b1e6,0x96688,0x6a118,0x67591,0x5dc71,
        0xd5205,0xf20fb,0x4575d,0x1077e,0x5833d,0x09233,0x00aec,0x4e931,
        0x85389,0x016cd,0xf9e1d,0x63682,0x54322,0xbd372,0xfd7ee,0x1ba4c,
        0xd172b,0x38401,0x74c58,0xab9d5,0xe377d,0xd517d,0x95880,0xaeaa6,
        0x15a18,0xfd6ad,0xc843d,0x00000 } },
    /* 189 */
    { { 0x73300,0xffc93,0x55811,0xc3004,0xa99fd,0x39332,0x6551c,0x353cb,
        0xbb81c,0x27e19,0x6a83d,0x924a9,0xa774b,0xee3f1,0xfcbb2,0xcbfc8,
        0xd56c7,0xc4010,0xf278e,0xaf79a,0xfe0ab,0xde682,0xebf6f,0x7339a,
        0x6d072,0xb6756,0x1205d,0xad5d7,0x0bd35,0x51c9d,0x69470,0xb5bbe,
        0x3067c,0x80d3a,0x77db4,0x75305,0x4572d,0x70ff5,0x53d2c,0xe06d8,
        0x15aec,0x5de86,0x5abfb,0x9ccb0,0x77199,0x0a8ed,0x96bea,0xeeefc,
        0x6df69,0x9d35f,0xdcc46,0x00002 },
      { 0xf0e77,0x06c65,0xca6cd,0xb14ac,0x0bd71,0xcc798,0xc00dd,0x3c93c,
        0x21f8b,0x57b62,0xe8cbf,0xd5b3a,0xfddfc,0xf8e63,0x73f76,0xbc929,
        0x132b7,0x3406e,0x9848a,0xc9e2e,0x3d51e,0xc59a0,0x81a4c,0x3a330,
        0xd32bb,0x6b9c9,0x0e846,0x10528,0x50012,0xbe729,0x32a1b,0xc2b00,
        0x38448,0x72249,0xbfc65,0xa0ffd,0xeb6bb,0x72a0c,0x802e9,0xc0a94,
        0xc0a4f,0xc7f60,0x99d8b,0x41cc5,0x8f62c,0x2da0b,0x6ee31,0x820c9,
        0xdf9fc,0xdbcdb,0xa1a65,0x00005 } },
    /* 190 */
    { { 0x85684,0x1a424,0xfba69,0x70c9b,0x929c4,0x3116b,0x51961,0xe62a0,
        0x01971,0xdab4b,0xff499,0x5aa65,0xff324,0x238ef,0x7f4a5,0xc2ef8,
        0xd5515,0xbacc9,0x16dc6,0xacacc,0xe2dbd,0x7f227,0xecb5a,0xa9bba,
        0xdaac4,0x858de,0xe7c98,0x8a6d2,0x3ff30,0x89559,0xfc2e6,0x4c6f2,
        0xe0611,0x85177,0x655f2,0x1bee3,0x6300b,0x3e8d0,0xb54a6,0x13c17,
        0x0ce79,0x62bed,0x49742,0xbe35c,0x7ca4a,0x4e403,0xa17bc,0xf4b44,
        0x5fbd9,0x99efe,0xae950,0x00005 },
      { 0xf7455,0xe7804,0x22e5e,0x66821,0x72206,0x1a499,0x33334,0x7795e,
        0x24c31,0xed97d,0x48efc,0x123ce,0xc12f4,0xfbc21,0xd9219,0xe8738,
        0x3a3ae,0x61066,0xb3bdc,0xa6dbb,0x28593,0x03d8c,0xc7536,0xe3c1a,
        0x227f2,0x19926,0xeaae5,0x2ac05,0xcfea9,0x6812a,0xf0bfd,0x5b596,
        0xa82dc,0x44fc2,0xce7e8,0x2b273,0xa6352,0x40481,0x89538,0x52867,
        0x088b1,0x88836,0x65886,0xb7cc2,0xc21ff,0x4a7ca,0x1612f,0x0ca33,
        0xdd298,0x7ea3e,0x11066,0x00004 } },
    /* 191 */
    { { 0x04b63,0x57c2d,0x18303,0x9a188,0xdf492,0xc5a34,0x5df3f,0x22d19,
        0xbf6da,0x73c73,0xb4324,0x2f89c,0x814df,0x97f13,0xe5ce9,0x345af,
        0x604f4,0xf98b9,0x8e3f5,0x0ae5d,0x950c1,0x7942e,0xff3ad,0xeed25,
        0xd5447,0xcccef,0xe73c0,0xe51e0,0xcbf68,0x54fa4,0x591ab,0x5b1ad,
        0x61c8c,0x0512b,0xbbc11,0xf7608,0x3b5ab,0x93291,0x649bb,0x01e79,
        0x231be,0xe7db1,0x40ccb,0x3e910,0x9d0a8,0xa96db,0x26f90,0x3dde4,
        0xf11ea,0x4534d,0xcceb6,0x00001 },
      { 0xd0f55,0x4f0c6,0xd210c,0x3c9d2,0xb9c67,0xadf61,0xfbb6c,0xa9ce3,
        0xf9919,0xe4dd7,0x3b063,0x494c9,0xe135f,0x5a93b,0xb3c14,0x580bd,
        0x2ef7c,0x320f5,0xd8723,0xbb6a4,0x88814,0xd876e,0xdee74,0xc7a97,
        0xf723a,0x334f6,0xe3cd8,0xb8f03,0x07de2,0x72027,0x082ae,0x6162f,
        0xa486e,0xd4ddf,0x88ec2,0x17c6e,0x98d3a,0x65c85,0x71ad9,0x39801,
        0x59e54,0x2262e,0xbef6b,0x285db,0x30ab6,0x48b20,0x1954d,0x3cf45,
        0x25ea3,0x334ea,0xf1752,0x00001 } },
    /* 192 */
    { { 0x7ea91,0x5b346,0x08a76,0x9c458,0xefd2d,0x4632e,0xc6f3f,0x9cf2b,
        0x5dc6d,0xae7b7,0x59813,0xd2403,0xdefc8,0x4cbd8,0x209e4,0x23ecb,
        0x25622,0xe3215,0x9ba10,0xe19a5,0x43f1e,0x14d93,0x8f7fa,0xfb0c4,
        0x7c21b,0x37df9,0xa30d4,0x2890e,0x2c4e6,0x1475c,0x2a465,0xb286e,
        0x672a5,0xe4126,0x91f01,0xb3b82,0xc31aa,0x6fda5,0x2ec9c,0xe17d2,
        0x77a5a,0xadb72,0x14f0b,0xed839,0x1bd88,0x2392e,0xd1b6a,0xd0b05,
        0x93c2b,0x90658,0xcb8af,0x00004 },
      { 0xb1953,0x57bb4,0x2b020,0xf6eea,0x4f597,0xe08b4,0x2c84c,0x5e641,
        0xf5d9b,0x19854,0x3cd49,0x262db,0xd1913,0x42bb5,0x2e46e,0x90276,
        0xe7f60,0xe6d78,0x355c8,0xc16c8,0x438b6,0xfaa82,0x6188e,0xe550f,
        0x73790,0x8ed01,0x57d77,0xf462e,0x4118a,0x5b471,0x5e871,0xa16ad,
        0xea4f9,0xc341d,0x00596,0xa6109,0x2280c,0x957c3,0x5a12a,0x374c6,
        0xee800,0x142fa,0x00804,0x51275,0x1db10,0x080fa,0x931ff,0x8c1db,
        0x878fc,0x25d79,0x86a5c,0x00004 } },
    /* 193 */
    { { 0xb4f36,0x13941,0x521e2,0xb4f90,0x4f803,0xacfb1,0xba8ba,0x52a54,
        0x1e22e,0x6cfdf,0xfe479,0xbbba8,0x6acfa,0xdbacb,0x8db58,0xae078,
        0xdfa51,0x36c19,0xf98d7,0x16eed,0xa35a7,0x5c286,0x61b15,0x9c864,
        0xd4676,0x5ebe7,0x3a64a,0x380f6,0x250b6,0x60926,0x9149f,0x14b41,
        0xfc5b3,0xd0a2d,0x919a7,0x66ac0,0x5cef4,0x54da5,0xaecc4,0x6986a,
        0xa4a24,0xed93f,0x1a49c,0xb1717,0xd5090,0xfa75a,0xd6cc1,0x602f1,
        0x4c054,0x8978e,0xd269f,0x00005 },
      { 0x20419,0x0c149,0xa7403,0x87393,0x89096,0x45d86,0xfa608,0xeeb70,
        0x994c4,0xcb81b,0x9fc5b,0xa06dd,0xdabca,0x8f8f2,0x427f5,0x06539,
        0xc52aa,0x67b1d,0x5c85f,0x1baa3,0x22c91,0x7d8d7,0x8345a,0xaec2d,
        0x1005c,0x47404,0xa8e53,0x8a447,0x3b586,0xe512c,0x80b8d,0x04ee1,
        0x168eb,0xe5211,0xdaa66,0xcd8a4,0xb2317,0xbd5da,0xdf6c0,0x61164,
        0x4185d,0xc9a1d,0xdbad7,0xca261,0x3aced,0xb0268,0x5ac09,0x0fe4b,
        0x9550f,0x5a26d,0xac999,0x00008 } },
    /* 194 */
    { { 0x0a39d,0x9b264,0x2c8dc,0xc9f9b,0x8ede0,0xff0b3,0xa0a21,0xa1ecb,
        0x469bd,0x1774f,0x80d04,0x2ccd0,0x48a90,0x99460,0xa32f4,0xe956f,
        0x6ab15,0xcf977,0x48f85,0xf4923,0xe0066,0x1fc6e,0x367c2,0xfeeef,
        0x1ebfe,0xed35b,0x613e5,0x581c4,0x17804,0x6ba07,0x8e6ea,0xcbdfe,
        0xd73ed,0x32950,0xdfcaa,0x8889d,0x61da4,0x74793,0xbd1c9,0xdbaff,
        0x67c8c,0xe7ce8,0xcbaea,0x431f1,0x8d267,0x7912c,0x04589,0x68255,
        0xa1e4d,0xdcd7e,0xc7c1d,0x00000 },
      { 0x963a7,0xcc1ce,0x3aa30,0xfade5,0xcc4c5,0x52f64,0xfbf73,0x2828a,
        0xaa2f8,0x072b9,0xa2121,0x3c56c,0xc6427,0xa576d,0x65485,0xaadd7,
        0x5c77c,0x3e90b,0x196ac,0xf39b6,0xfd1aa,0xd43e9,0xbc420,0xcd05c,
        0x92062,0xfdfc3,0xc0ff2,0x38724,0x61416,0xe821e,0x8d82a,0xcf32b,
        0x7a3f0,0x433fa,0xf58f9,0xca925,0xdf644,0xbf1d2,0x75fae,0x1918a,
        0x61563,0x180c0,0xb8761,0xb5ed6,0x17989,0x41244,0x445ad,0xbf342,
        0x633ab,0xae1df,0x4ffc9,0x00002 } },
    /* 195 */
    { { 0x7cb2b,0x0593c,0x9fcdc,0x53fb8,0x55900,0x243b9,0x43cc1,0x61823,
        0xdebcf,0x63601,0x6c18a,0x46ef6,0x73645,0x91328,0x701ec,0xa5290,
        0x88c31,0x26f97,0x35b80,0xf7d7c,0xa92d1,0x2b862,0x72885,0x0aa79,
        0x9cb05,0x05180,0x3cb20,0x467ca,0x6897d,0xf5b94,0x7c09e,0xf20c7,
        0x41984,0x42f22,0x3372c,0xb206c,0xdf35b,0x053e0,0x0b5da,0xa9c14,
        0x6c6d0,0x33bc2,0xb56fb,0xcc0cc,0x861cf,0x9b396,0x9ef29,0x1c3cf,
        0x21ba4,0xd1406,0x9e4d3,0x00008 },
      { 0xa9be3,0xe7a45,0x35e80,0x6fbdd,0x80735,0xdaa57,0xc2fc4,0xb967b,
        0x6d62e,0xe3018,0x7cd16,0x679e4,0xba702,0x30ce9,0xc025f,0xca2f1,
        0x64f50,0x461f8,0x1205b,0x1d66f,0x78506,0xd6d79,0x09e7f,0x8a088,
        0xdc4f6,0xe247e,0xa4d3a,0x04499,0x85dac,0x1f9da,0x64a6d,0xf8446,
        0x83a71,0x84d7a,0xf30ce,0x33f19,0xceaac,0x382ba,0x2abe9,0x94862,
        0x33831,0xb21f0,0x7681e,0xa4baf,0x7b037,0xa1b5c,0x90899,0xd156a,
        0x1d0fb,0x6fe6f,0x75d3e,0x00006 } },
    /* 196 */
    { { 0x193e5,0xfd707,0x9767f,0x58e5d,0x18103,0x78aa9,0xef7e4,0x328d8,
        0x4f9ff,0xa7563,0xdbbd9,0x0ee86,0x6913a,0x21568,0x9687e,0x379b2,
        0x9da38,0x0a89d,0x03f41,0x34d29,0x91b13,0xf8d7b,0xfb5d9,0xbd82e,
        0x74229,0x789fe,0x803c7,0x8b623,0x4db56,0xd2534,0x350d3,0x93e9a,
        0x497e8,0xb0724,0x59c35,0xe23b5,0x6a169,0x72d43,0xc69c4,0xcc5b4,
        0x64632,0x31098,0x3c7f5,0x759d8,0x89f6d,0x49788,0x1db1e,0xa91cf,
        0xf1a4b,0xfe60a,0xf7f92,0x00005 },
      { 0x5167e,0xc6054,0x18a1c,0x88e0f,0x2affa,0xee2e0,0xbcf55,0x432a7,
        0xdff51,0x6624c,0x75108,0xda42a,0x77382,0x511af,0x11f40,0xe894c,
        0xf1423,0x312aa,0xa4e4e,0xd2aea,0x0f63d,0x3d36f,0x6358c,0xd7660,
        0xc9550,0xabfc5,0x7ea7e,0x37313,0x60125,0xb950f,0x59839,0x2a5cd,
        0x63442,0x0140e,0x5a0f6,0x70459,0xef2ac,0x5e238,0xf7390,0x446b0,
        0xacc0e,0x8a44b,0x44857,0x206ec,0x34cd4,0xbd780,0xaaaa5,0x367b1,
        0xb458d,0xd90a2,0x5bece,0x00002 } },
    /* 197 */
    { { 0x3a8fb,0x820c3,0x79a73,0xdc1d0,0x10f25,0xbf6cd,0x2b6cf,0xc6d48,
        0xc73f8,0x4a4ff,0x7bf84,0xf18c0,0x03e51,0x9162f,0x23659,0xa7651,
        0x13811,0x4e140,0xc59a7,0x18a0a,0x5e550,0x7a686,0x9b195,0xe3ca0,
        0xc51bd,0x3fe1e,0x96025,0x7eb3a,0x4bc0c,0xe03f8,0xd147d,0xe83bf,
        0xbdb09,0xd152f,0x0540e,0x5ec1c,0xdcea1,0xa52ed,0x3076b,0x4b261,
        0x30ed5,0x06f3d,0x83972,0xbae8e,0xa9bd7,0x6373a,0x69209,0xf20d8,
        0x0bf63,0x4bc3b,0xa616a,0x00000 },
      { 0x339c9,0xed6e1,0x075f3,0x00a62,0x2bf8b,0xfaa07,0xb477a,0xbccd9,
        0xfec82,0xc7dfa,0x0ca54,0x158f0,0xe4713,0xbc31a,0x2f138,0x44910,
        0xdfc8a,0x58310,0xf98f1,0x54d4a,0x559e9,0xef207,0x0c4c9,0xc527a,
        0x21af9,0x23e80,0xa1920,0x12777,0x76e80,0xb0237,0x38c7f,0x635f5,
        0x9e951,0x4fe8c,0xdf197,0x90975,0xd15cc,0x87fae,0x15c02,0xf7a51,
        0x728f0,0x3dfa0,0xfac62,0xfbe60,0x990db,0x11ba0,0xfd403,0xa8d40,
        0x6464c,0x4e07c,0x76d15,0x00008 } },
    /* 198 */
    { { 0x3ea8a,0xd2c2d,0x3a4d6,0x600ed,0xba842,0xbe681,0x67236,0xe4070,
        0xf100d,0x7bc53,0xa7d7a,0xb6fe6,0x3e3e5,0x5e1a8,0x4f95d,0x6e699,
        0x97c2a,0x22760,0x7cacd,0x10110,0xaa679,0xd98db,0xe2412,0x102e0,
        0xc4461,0x2addf,0x49327,0xdbc2d,0x64815,0x43669,0x64ba9,0x7e38e,
        0x2bf90,0x1a32b,0x960eb,0xe28b4,0x5d928,0x45752,0xc9eda,0x2a077,
        0x75b39,0x0072f,0xfd61d,0x0cbb7,0x62776,0x4b145,0xd1b0f,0xaf235,
        0xd1700,0x3be76,0x040c2,0x00003 },
      { 0xa9a70,0x5b4ef,0x10dc5,0x6610b,0xf53e8,0xde414,0x27fd4,0x09f8a,
        0x5c113,0x3c3d9,0x6661d,0x09a50,0xe5051,0xeb513,0x94a60,0xcaa29,
        0xd338b,0x371e7,0xee415,0xe71f3,0xc4651,0xd145f,0x3b44f,0xcbc31,
        0xbf838,0x5051b,0xeb921,0xe0781,0x7b039,0xbf5ac,0xb4414,0xe8696,
        0x0d48c,0x888be,0xd6671,0x2b6f2,0x5dd8f,0x93b2f,0xf8abe,0xeb8a7,
        0xfd1e7,0xc5c1d,0x0f751,0x3dd99,0xe862b,0x2a74b,0xd58a3,0x1eb1a,
        0xbc9a2,0x9a1eb,0x486d7,0x00005 } },
    /* 199 */
    { { 0x59e13,0xffa13,0xb2e34,0x6051c,0xf2819,0x2d8db,0xb5e20,0x23564,
        0xe023d,0x12e95,0x2f6ac,0x40b64,0xdfb13,0x53725,0x852b6,0x543ba,
        0x466ad,0xd68d2,0x1aedc,0x728b8,0x4547c,0x78022,0xb65bf,0x9569f,
        0xf8a11,0xc9559,0xfb22e,0x7a62d,0x2505b,0xed5e5,0x5409e,0x07107,
        0xf6f11,0x88299,0xc8992,0xf8c79,0x13db6,0xd6926,0x9a9a7,0xb3ca7,
        0xb7fb3,0xb030e,0xb2160,0x9bb8f,0xacab9,0x8b409,0x568d2,0xd2012,
        0x45f8b,0x0f5ac,0x80f1b,0x00003 },
      { 0x0068f,0x6be6a,0x0b99e,0x3753c,0xac8a7,0x67cf2,0xb7c4b,0xb2fae,
        0x9a548,0xc3a6c,0x40260,0x7f993,0xe7f41,0x0f739,0x855cc,0x8ee56,
        0x949da,0x0f780,0x08b51,0x6efff,0x28d5c,0x770fc,0x7bbb1,0xfd96a,
        0x5abee,0x2ab4f,0x2665a,0x1136f,0x9a07b,0x01dcf,0x0a4b6,0x2fb38,
        0xbecc6,0x14162,0xc8036,0x83b3c,0x6ee6b,0x98fb9,0xeeb34,0xa8c17,
        0xb0fd6,0xc2ea9,0x177ef,0xb5baa,0xe5834,0x110b3,0x4f55b,0x92904,
        0x7285e,0xedebd,0xabedd,0x00004 } },
    /* 200 */
    { { 0xef376,0xb9700,0x355e1,0xabff3,0xa66cd,0x6e5d9,0x646d5,0x47e87,
        0xc2575,0x69b3d,0x0f793,0x4b8a0,0x928f4,0xc52e2,0xb1ea0,0x08c32,
        0x9b392,0x12372,0xa78de,0x239d5,0xab26d,0x84519,0xa6b41,0xe0ce4,
        0x6b4b7,0xf923f,0xcb2a9,0x6f8aa,0x9235f,0x064a5,0x454e2,0xbb8bc,
        0x3062e,0x341bf,0x7efd0,0xf6f93,0xb94df,0xac683,0xa066b,0x8aa7f,
        0x64b1e,0x45c33,0xe0b37,0x772ac,0xf0616,0xe3fb0,0xd08d1,0x46f08,
        0x132d3,0xb318e,0xa20ab,0x00006 },
      { 0x5cbc7,0x166a8,0xa8310,0x9aa7e,0x6934f,0x99094,0x1b3d0,0xe778f,
        0x11088,0x99c22,0x247b7,0xff8f2,0xe7ea4,0x4484c,0xd7145,0xb3171,
        0x8c364,0x494f9,0x94039,0x14582,0x397df,0xa911f,0x1165d,0x09439,
        0x58093,0xbca6b,0x74238,0x509a1,0xd75f9,0x09758,0x82182,0xfeb51,
        0x925d0,0x21a47,0xe0c60,0x315ea,0x4af8a,0x94669,0x4b70e,0x6bad0,
        0xaf8a3,0x7dae7,0x07244,0x5e7ff,0xe44c1,0x456ff,0x68aa5,0x51846,
        0x6b977,0xa7bf3,0x5e353,0x00004 } },
    /* 201 */
    { { 0x92f71,0x64930,0x60567,0x2d717,0x2f5b9,0x66b6c,0x6c5eb,0xe2c8b,
        0x3149b,0x3e9db,0x0c036,0x583a2,0x7f62f,0xcd709,0xd3303,0x688ac,
        0x916ac,0xf8ebb,0x5d0c0,0x9b0e8,0xc84c1,0xf7462,0xad11b,0x7c4a6,
        0xed5f9,0x69c76,0x119f3,0x88bad,0x3ec8b,0xe50b8,0x71beb,0x59b83,
        0x706a6,0x08866,0xcc695,0x3d2c0,0x3f837,0x1c75a,0x2fb53,0x2a5a0,
        0xcd3a3,0xd04e1,0xa39a1,0x4778d,0xee827,0xda333,0xbbb75,0xedfc5,
        0x9bd36,0x24ca7,0x5941f,0x00001 },
      { 0xdd512,0xf8a77,0x2e8c0,0x65f64,0x71dc3,0x1b59a,0x862a9,0x08753,
        0xd14cd,0xcae80,0x272fa,0x230dd,0xa1624,0x27cb5,0xc1640,0xeea3e,
        0xf9f03,0x59c1e,0x1700b,0x148dc,0x70da3,0x11c12,0xaf1d4,0xc4181,
        0xee448,0x0b801,0xe3a90,0x85599,0xdedf2,0x09aff,0x0bd0d,0x5d67b,
        0x70024,0x968b3,0x839df,0x36b8d,0x0e6f8,0x6307e,0x1c93b,0xbd320,
        0x2e588,0xbb538,0xa1d02,0x8a6b7,0x9636d,0x8641e,0xb7696,0x70b7d,
        0xfad03,0x4a118,0xd17c3,0x00006 } },
    /* 202 */
    { { 0x1c99b,0x41c18,0xf6088,0xdcafc,0x1c87b,0x5dc90,0xabeb6,0x3720d,
        0x0b447,0x5bb46,0x37751,0xc3965,0x74c79,0x96c27,0x22e0a,0xd447f,
        0x0f440,0x302ac,0xd9521,0x83ad0,0xbc905,0x30b26,0x4a083,0x92890,
        0xe977a,0x18e25,0x5c50b,0xffd98,0xa1dea,0xad5f6,0xcb7a5,0xcf4db,
        0x37ed5,0x19c8a,0xbcd00,0x50b6c,0x01e98,0x46dd9,0x60578,0xb0b8e,
        0x8194a,0x901ac,0x4132f,0x85713,0xbb972,0x6ee28,0x149f5,0x4ce9f,
        0xe1d4e,0xa43e9,0xab9b5,0x00001 },
      { 0xfa7a3,0x92314,0x06dab,0xf9632,0x0478f,0x4af0f,0xfdbcc,0x904d9,
        0xe1713,0xfe4cc,0x2c045,0xa2eb1,0xdac20,0x8f6d7,0x478fd,0x44fc5,
        0xb6ffa,0xc5ca7,0x86e72,0xf7588,0xb6fd6,0xa4529,0x0d57f,0x92a82,
        0x1d1b1,0x494df,0x789f1,0x2f9f2,0x23d81,0xbb53d,0x083aa,0x9842f,
        0x3ab32,0x9b2a0,0x64853,0x25022,0x0b151,0x1ce09,0xbd563,0x731f6,
        0x94d15,0x34e12,0x436e6,0x361d9,0xfb229,0xa966a,0x1c43c,0x8c428,
        0xab3ed,0x56c21,0x4b349,0x00002 } },
    /* 203 */
    { { 0x824e2,0x86659,0x9bdcb,0xe74c4,0x84e13,0xc4ce4,0xeea6d,0x6bbe1,
        0x01a26,0x57a4c,0xe3ec4,0xb8e71,0xb47b2,0x5a8e4,0x5e02f,0x7e8b1,
        0x3530d,0xe6e33,0x81eb6,0x5202e,0xe17a4,0xba369,0xc9fac,0xd70e4,
        0x41431,0xb8812,0xe12be,0xaf4b3,0xdc190,0xf486f,0x52311,0x53270,
        0xb2bce,0xe129f,0xf6c41,0x6c089,0xbb70f,0x6287e,0x477be,0x3feb4,
        0x9850a,0xbb147,0xbcf18,0xfb119,0x0fcfd,0x80d04,0x92fda,0x925c2,
        0xc5bf9,0xe57e3,0x12d65,0x00002 },
      { 0x5cf08,0x86ca1,0x3adb3,0x72eb2,0x481e1,0xfa4ac,0x0c04d,0x4d42d,
        0xdbf93,0xc79d1,0x4404d,0x60737,0xdd9cf,0x32bfc,0x441e9,0x60508,
        0x82a98,0xca1c6,0xae910,0x1cc09,0x841ac,0x28fc1,0x63095,0xdbbed,
        0x120ae,0x50e6a,0x0ccf2,0xe1ec3,0xf94e0,0x8bbf2,0xa54e5,0xfe84b,
        0xa4415,0x4f9fa,0x66d0b,0x7ce5c,0x7ecee,0x58f1e,0x73a0c,0x6fa68,
        0xd43eb,0x487a1,0x99f13,0xc5a03,0x796c6,0x727ab,0xaaae6,0xe6ef9,
        0xc2447,0x549a5,0x6afa5,0x00006 } },
    /* 204 */
    { { 0x0e91d,0xa8c98,0xa5aab,0x8efad,0x96ac9,0x3cf50,0x662a9,0x8da32,
        0x90e0a,0x3eb09,0x08145,0x15300,0x401d2,0x71de8,0x33e3d,0x2bb0d,
        0x9a012,0x803e1,0x65f6d,0x38e74,0xc78a8,0x02ff4,0x48c59,0x19313,
        0x2afb7,0x7b74e,0xcfb05,0x27579,0xfa493,0xd03f8,0x6423a,0x761ea,
        0xfa40a,0x4558f,0x7d4c2,0x7e30b,0x977a8,0xe9c0d,0xd26b5,0xc9c84,
        0x5edba,0xa0d1c,0xd1963,0x839a3,0xdeca8,0xf6bf0,0xf35eb,0xbc6f2,
        0x8abdf,0x310d5,0x1ef06,0x00000 },
      { 0xdcbb0,0x163ec,0xbf903,0xc9552,0x827c1,0xe2d72,0x93019,0x9575c,
        0x27030,0x309e5,0x69839,0xc5a99,0xf0dc1,0xd082d,0x0ff7c,0xef9f8,
        0x7e051,0x75df9,0xd9150,0x1b55c,0xe9cc6,0x86fff,0xcc4f2,0x80f24,
        0xdb38f,0xe3352,0x6523a,0x99ec3,0x9ed9b,0xb104a,0xca810,0x109a8,
        0x203ad,0xe7305,0x2700f,0x00f5c,0xe7694,0x2ee24,0x52c2a,0xee0c4,
        0x5d399,0x41d59,0x7f02a,0x5d6af,0x70ab7,0xb730b,0x0990d,0x34108,
        0xd1202,0xfd5e8,0xe4f5f,0x00000 } },
    /* 205 */
    { { 0x14c38,0x440ff,0xd1c64,0x11f2b,0xaaece,0x5b59f,0x3309a,0x22af6,
        0x605a7,0xeeaa4,0x2af24,0xf65a8,0x9ddc9,0x9a115,0xbfeeb,0xf4ee4,
        0x84eaf,0x7674e,0x463d0,0xaace2,0x00e0b,0xcbe1e,0xdcb88,0xd5fab,
        0x568ea,0x9d7ca,0x57eb9,0xd524c,0x3bd80,0xbe987,0x72ce9,0x9c465,
        0x0b85e,0xcd730,0x18a1d,0x41769,0x240f5,0x22131,0x23649,0xb5b14,
        0x324ff,0x6af7e,0x434f1,0xa5012,0xc40dd,0x33d97,0x421a1,0x08833,
        0x6f020,0x61087,0x3d411,0x00003 },
      { 0x8e5ec,0x6b987,0x531a3,0x82327,0x14691,0xe3e32,0x4645d,0xd0a30,
        0xf9a33,0x59d15,0xa1736,0x1b87a,0xe734c,0x25d4f,0x4a2f9,0xac209,
        0x2b0f4,0xa1c26,0x3c965,0x5cbc4,0xe447d,0x9c903,0x30075,0x05239,
        0xf215e,0x3492a,0xf593f,0x6d5f1,0xffffb,0xcddb5,0xb4bc3,0x65943,
        0xd5408,0x9cbfd,0xd03a2,0x76c09,0xb198d,0x7cda6,0xb598f,0xc0f27,
        0x90a22,0xcfc07,0xcb58c,0x7a848,0xcba55,0xc54fd,0x52d76,0x59220,
        0x6b466,0xaa47b,0xd3de7,0x00002 } },
    /* 206 */
    { { 0xdd3b7,0x6265a,0xade74,0x4c2aa,0x5abf2,0x888f3,0xd93e5,0xe1a57,
        0x549ca,0xbfd41,0xc76f7,0xe18e2,0x30e22,0x3202b,0x8eabe,0x67f28,
        0xd0f0a,0xba1d1,0x79a66,0xad18b,0x92881,0x0ab74,0x0e90e,0xc7adb,
        0x24086,0x2f7d4,0x84213,0x32c52,0xe870c,0xf9a09,0x7f158,0x85847,
        0x25589,0x72ec0,0x22a93,0x87774,0xca509,0x428c5,0x058be,0x57660,
        0x79564,0xcf45b,0x57f37,0xc6319,0x96c7f,0x31628,0x3ddd6,0x8b702,
        0xc12a6,0xb65b1,0x7003b,0x00004 },
      { 0xc1c96,0xc1c91,0x99401,0x2970d,0x927a1,0x5dcdf,0x107aa,0xc3c29,
        0x92e17,0x103ab,0x3fe47,0xe8f7a,0xe26fc,0xe998e,0xd5e4e,0xb0d09,
        0xa41f8,0x048e3,0xfa622,0xa506a,0x5a26c,0xc012a,0x252b1,0x99b57,
        0xf734c,0xe12c6,0x12f7f,0xd79f5,0x61093,0xee19a,0x06eac,0x2f309,
        0xd1ea6,0x81056,0xbff83,0x5f216,0x6eff3,0xc7585,0x22461,0xc1ad2,
        0x7e978,0xe86e0,0xb20fd,0x6ca16,0xb2cca,0x3fe81,0xd2d63,0xab4d6,
        0xa2ce6,0x04b06,0x3dff5,0x00007 } },
    /* 207 */
    { { 0x20fb8,0x05d8e,0xb6158,0x33f08,0x482b5,0x6873e,0x4ca7c,0x56a85,
        0x5f001,0x11520,0xb3692,0xc6acc,0x787fe,0xf092b,0x0ecc7,0x1fa3c,
        0x5fe4c,0x7ee84,0xb3664,0xf1125,0x5f8b1,0x781e8,0xa6fd4,0x8b0f1,
        0x26839,0x92c65,0xcb8eb,0x8c6cd,0x2ceeb,0x5f6d5,0xead8e,0x133f0,
        0x934dc,0x23c8d,0x1883e,0xc45a3,0xd428a,0x4ed5b,0xa8521,0xdbbfc,
        0xca492,0x13f77,0x7e5ae,0x13fe0,0xbdf41,0xab05f,0x0d272,0x63e4a,
        0x8f535,0xb7714,0x544d0,0x00007 },
      { 0x97ace,0x34807,0xfe8d1,0xd97e4,0x0af86,0x6d6aa,0x8fc21,0xef5a6,
        0x0a688,0x84dbf,0xf9b26,0x6f459,0xc18b2,0x99d2f,0xcfa89,0x52fef,
        0x23955,0x82624,0x5af8d,0x3780d,0x9f63a,0x12346,0xeaf8f,0xdcd4f,
        0x3454f,0x09293,0x73b5d,0x18b7a,0x8ba80,0x552c1,0x276e5,0x9af1f,
        0x6bb1c,0x3dff2,0x5d477,0x4f44c,0x006dd,0xf4941,0xa499e,0x5f39b,
        0xf12f9,0xf2ad8,0x66ca4,0xf6dcf,0xa5767,0x22f59,0x3f179,0xba877,
        0x42d49,0xeac1e,0x20081,0x00002 } },
    /* 208 */
    { { 0x7a0ba,0x73ba3,0x043d5,0x6df63,0xcdd17,0xa431b,0x0f705,0xc4207,
        0x22cfc,0x09033,0x7c2d1,0xd30e6,0xa5cab,0xf8bcf,0x5decb,0x362c9,
        0x7b10b,0x77778,0x767d2,0x5e64d,0xe6ec0,0x2c915,0x30e61,0xce69c,
        0x69631,0x359e6,0x82e26,0xdd8f6,0x827c9,0xffcc3,0xf1295,0x79021,
        0xadca2,0x798a2,0x6a8ee,0x500a0,0x44b5d,0x00e78,0x6c58e,0x8d80d,
        0x46fc7,0xcc877,0x15f10,0x53be9,0x82460,0x9f6fd,0x28b21,0x844e3,
        0xd3733,0xac11b,0x20541,0x00006 },
      { 0xe5a29,0x82509,0xf7fd3,0x531e0,0x0b432,0x48d7d,0x3b987,0xcd388,
        0x49354,0x7a8f7,0xbfbb1,0xac748,0x5c6b8,0xf2d2c,0xa6605,0xa4616,
        0xb1b83,0x251bc,0x3d966,0x265ab,0x42fee,0x75310,0x058cf,0xdb225,
        0xd73fb,0x56c70,0x0c2d5,0xd434f,0x31211,0xb259b,0x1d854,0x86206,
        0xb3f7d,0x6dc42,0xfe460,0x4949f,0x5e86a,0x5c858,0xdac4c,0x160ee,
        0xdcc8b,0x2004d,0x68e24,0xce675,0x61804,0x14165,0x55a42,0x91f38,
        0x2be97,0x98f93,0xf3781,0x00007 } },
    /* 209 */
    { { 0x6639a,0xdadfa,0xa374b,0x73919,0x402ab,0xbd48d,0xe2d0c,0x47031,
        0xef236,0x1f5c5,0x0599d,0xe2bcd,0x3b49e,0xd3844,0xb60e0,0xd285e,
        0x392e8,0x2f269,0xbbea9,0x538fd,0xfb8bc,0x455fb,0x76891,0xe469b,
        0x59ff1,0x82ae2,0x1de56,0xcb1f4,0xec1ce,0x52d1a,0x07199,0xc876f,
        0xf7446,0x81e7b,0xce251,0xd2f11,0x6282a,0x93ad8,0xf67cb,0x6ba4e,
        0x3cd31,0x3e8fa,0x507aa,0x8a04e,0x8fce6,0x1bb60,0x170a6,0xced74,
        0xc10d0,0xb3f6a,0xde716,0x00006 },
      { 0xd6dc5,0x04172,0x4e58d,0xc65cd,0x66397,0xd2cde,0x4e8be,0x0c9eb,
        0x77e18,0xdb7ae,0x5fa2e,0x54687,0x85627,0x1e673,0x24ea9,0x4b303,
        0xc8b2e,0x56235,0x023a8,0x28876,0x2a8f9,0xf6d6c,0x8b59d,0xf6f5e,
        0xc185f,0x8aec2,0xad574,0xe12b3,0xc7892,0x4aefb,0x4f2d5,0x7aebb,
        0x68821,0x48ee8,0x49154,0xbd5b1,0x1b1d9,0x6c5f7,0xdf7a2,0x2ff00,
        0xcd166,0xeee5c,0x95b1d,0x9f17b,0x4ebc9,0xe1f77,0x6163f,0x90983,
        0xd25b0,0x30bb3,0x1f908,0x00005 } },
    /* 210 */
    { { 0x22461,0xa1f29,0x9376f,0xd0d14,0x31650,0xb1b1c,0x08ddb,0x0dd86,
        0x91c33,0x0692b,0x6b899,0x2c4b3,0x23e61,0x56005,0xb0bdf,0xe1977,
        0xa2545,0x70636,0x8afff,0x3d8ef,0x81172,0xa7d27,0x7bacd,0x81bde,
        0xbc4bb,0x8e0b0,0xd2a57,0x80b2e,0x23cb0,0x1b2e0,0xd0d17,0x5bda0,
        0xbb9ae,0xcf941,0x6df38,0x65c5f,0xbc14a,0xdd81d,0x98e85,0xc19dd,
        0x8c82d,0x937f9,0x2206f,0x747f5,0x8c613,0x5bbe7,0x2c25f,0x9e13a,
        0x34be7,0x8e0aa,0xeed21,0x00005 },
      { 0x4dc0b,0x5401d,0x15657,0xbb07e,0x7f566,0xae5f2,0x5d5a1,0xb8222,
        0x5ebeb,0x6be98,0x189ec,0xd21c1,0xd5f3a,0xce4d9,0x18cec,0x17da5,
        0x65b59,0x3ed6b,0x84a2d,0x771cc,0x58ffa,0x98817,0xa7a7f,0x2ac69,
        0x6ae12,0x6d50d,0x6e684,0x30b1c,0x3cb7f,0xd0bb1,0xa605b,0x8c023,
        0xf2407,0xcdd73,0xa10fe,0xa9969,0xce5f0,0x5158c,0x8068c,0xbd8f5,
        0xbf615,0xe1d26,0x15a46,0xea879,0x8af32,0x87d30,0xe8102,0xeaf74,
        0x64254,0x06a62,0xc14ba,0x00008 } },
    /* 211 */
    { { 0xee201,0x95b17,0xc8778,0x7a770,0x188e5,0x5aa47,0x456c0,0x97822,
        0x3e763,0x1d19c,0x9c3ba,0xf8c0c,0xe0be6,0x389eb,0x4ffb4,0xfe85f,
        0x7fbb6,0xce0ce,0x38bcc,0x6c645,0xa6526,0x6eab2,0x84287,0xcf9a3,
        0xac690,0x815c9,0xcc8f9,0xf3b1c,0xe9f5c,0xf687d,0xe6a9c,0xfa17b,
        0x35c15,0xfc838,0xcfc10,0xf2ebf,0xb150e,0x6b0fd,0x2e608,0x884a5,
        0x7ecd9,0xb89f9,0x0cd1e,0x6fa2b,0xa416e,0xcc03b,0x5993e,0xe2bd1,
        0xb165e,0x5deab,0x45c0a,0x00006 },
      { 0xa7e31,0x0550a,0x94c42,0x1da5d,0xc2f85,0xc8df0,0xe6aae,0x3c726,
        0x46909,0x9a996,0x619bf,0xdc362,0x572db,0x53fbd,0x0e0e2,0x1b426,
        0x09e06,0xfb8c7,0x7c259,0xec5b9,0xbcdda,0xbf7cb,0x3e9fa,0xe4b70,
        0x5e8b1,0xddb4d,0x734ef,0xe56e0,0x51b06,0x55f8a,0x4f91f,0x02d4a,
        0x65c8d,0xba3f5,0xf8608,0x1d947,0x2816d,0x2f47d,0x13682,0x5ce7b,
        0x36156,0x420cc,0x1d042,0xe5ef3,0x6e46e,0x3567f,0xf7068,0xb2a65,
        0xa6c91,0x40d2f,0x7e9ff,0x00002 } },
    /* 212 */
    { { 0x952e7,0x93d7e,0x52518,0xbf187,0x3c735,0xb3058,0x49115,0x96fe0,
        0xb5992,0xca732,0x06d2f,0x18588,0x92745,0x885ed,0x6a01b,0x71ab7,
        0xf55ec,0x976d9,0xdce9d,0xba9cb,0x048f2,0xa60b2,0x32b3d,0x592b1,
        0x7c086,0xd7697,0x99051,0xa9cb0,0x5b6dc,0x88ae2,0xb23d1,0xd9c2a,
        0xaaf3d,0x3fe20,0xf469f,0x74d09,0xf5aad,0xd1f7c,0xb3bdb,0x22a9e,
        0xefe5c,0xc43d5,0x37010,0xdfa21,0x08c5e,0x87026,0x17b57,0xada22,
        0xc9776,0x673da,0xfeee5,0x00004 },
      { 0x3d780,0x52b5d,0x0e18d,0x67443,0x30716,0xadb5d,0x1564d,0x5a742,
        0xd386e,0x86320,0xd6bbb,0x290e8,0x15d8c,0x263dd,0x3232d,0x981a4,
        0x84636,0xca989,0x3d0e7,0xacb13,0xda519,0x38784,0x1ff51,0xdddc8,
        0xe3fab,0x3a832,0x199a4,0x85943,0x3fc27,0x74316,0xbcf32,0x5b4ca,
        0x94fa7,0xbd74f,0xfa010,0xa6279,0xd5694,0x8a743,0xa24c2,0xcb657,
        0x2a888,0xeac1d,0x86a25,0x2503e,0xf7eef,0xc561f,0x5d304,0xed11a,
        0xede0e,0xe79c9,0xfe818,0x00004 } },
    /* 213 */
    { { 0x1c7ff,0x9d7fc,0x0252c,0x9ad10,0xd9fa8,0xbd419,0x9cca9,0x4064e,
        0xa124a,0xccc93,0x3942e,0xbcb84,0xb384c,0x49695,0x1fd87,0x004c2,
        0x165bf,0x9f421,0x9c81d,0x11026,0x8dde0,0x32562,0x04de2,0x5a9b0,
        0x37457,0x21ec9,0x6dcfc,0x46bff,0xdfb33,0x372c7,0x64b4d,0xac4da,
        0x494e2,0xd3f20,0xecb7a,0xc150c,0x5e867,0x2c41b,0x3d856,0xc2b72,
        0x395ce,0x31299,0xee532,0xdfc57,0x7c91a,0x0b659,0x161f1,0xe06f1,
        0xd3ffc,0x29b74,0x19155,0x00008 },
      { 0x9d4ee,0x316ed,0xec124,0xff018,0x4689a,0xffa15,0x3f43d,0x2a89a,
        0xa349f,0xb24ab,0x467ef,0xe8e2d,0x22db1,0x9102e,0x35403,0x18dea,
        0xf082b,0x53e52,0x22ab8,0xdd474,0x1ed36,0x30a2c,0x1ee71,0x0295d,
        0x0e86d,0xd3ca6,0xc7f5a,0x68087,0x8e6ac,0x86465,0xecfde,0x0f83c,
        0xd1265,0x21461,0x2e66c,0x50997,0x0bd38,0xef415,0x289fe,0xa6632,
        0x83f3a,0x950f1,0x92dc7,0x54be7,0x22754,0x36770,0x11b11,0x2744c,
        0xa6ef3,0xc7e8e,0xd06bc,0x00007 } },
    /* 214 */
    { { 0x0212f,0x42709,0x92859,0xe8448,0xc5521,0x1b7d4,0xb9269,0xbe2db,
        0x38422,0x804c0,0xd81f8,0x21edb,0x63177,0x89bc3,0xbeeac,0xc136c,
        0xf004d,0x0b7b8,0xf71b6,0x8ab84,0x04e21,0x9132d,0x14d26,0xe6cc8,
        0x2496e,0x15b0e,0x5fadc,0xe3177,0x50b2c,0xd223c,0x08466,0x82e3c,
        0x12f8b,0xa64c6,0x721ca,0x53559,0xba4b6,0xa751e,0x9d159,0xc7d3d,
        0x3aad5,0x46343,0x80d42,0xb9d2e,0xa1e61,0x673ca,0x55ffc,0x149f6,
        0x9cb92,0x99d0f,0x8b52b,0x00004 },
      { 0xc05be,0x99efd,0x39153,0x95e9a,0x813e0,0x70db1,0xfdade,0xcddb3,
        0x862e9,0x51447,0xa0094,0x31621,0x3a2b0,0x920ea,0x80c23,0x4b279,
        0xb8feb,0xf1a23,0xc5394,0x16d4a,0x63e56,0x3f725,0x19a16,0xb7142,
        0xff93f,0x74aa0,0x3d624,0x96d29,0x6d26f,0xcfe27,0xea87d,0xdd212,
        0x38d15,0x2f470,0xb27bf,0x168ea,0x5f418,0x8c832,0x89ae5,0xb32a9,
        0x04222,0x3be37,0xfc9f1,0x4390b,0xda369,0x0684a,0x6060d,0xf16e2,
        0xc76ec,0x879d8,0x7c0de,0x00001 } },
    /* 215 */
    { { 0x01958,0x53dcc,0xca5f4,0x8393b,0x41ce8,0x94595,0xb6d7d,0x561f5,
        0x350a1,0xbc5e6,0xe2d36,0x3c867,0xc291c,0xac3a6,0xd84a5,0xf6c7e,
        0x006cd,0x0bd98,0x913c4,0xec3b7,0x75671,0x8bb08,0x9a9f7,0xb43e8,
        0x28f6e,0xed1c9,0xe1ea1,0x8df3a,0x5fdf2,0x24b2b,0x5b1b9,0x62bba,
        0x16e05,0x051a1,0x91d27,0xd3e34,0x7167e,0xec02b,0x04608,0x5bc0b,
        0x1cf7b,0x59e29,0xc5d7f,0x01698,0x730e5,0xc799b,0x50df5,0x0c7c3,
        0x6e1d7,0xe20ac,0x862b9,0x00006 },
      { 0xa1f64,0xe79ff,0x6c6f4,0x43495,0xaa1e2,0xd6a91,0x232fe,0xcdb75,
        0x0ee0c,0x07e9a,0x322d6,0x0b370,0x7bfc9,0x2fef8,0xad246,0x29480,
        0xfcf34,0x69c2b,0xc2149,0xe38ff,0x0a539,0x5211e,0x49c6e,0x12a51,
        0x9ec26,0x322a5,0x706b5,0xe212d,0x9195f,0x9c842,0x108e9,0xf77fb,
        0x80482,0xa35dc,0x4ceae,0xd2987,0xbbd92,0xa6030,0x5eea5,0xaaea1,
        0x2dca5,0x9cad4,0x98710,0x3bc74,0x9d6ac,0x0af64,0xc4029,0xc64e1,
        0x8de6c,0x2d51f,0x093fa,0x00005 } },
    /* 216 */
    { { 0xd553b,0x804c2,0x4cf32,0x6c29c,0x23b96,0x1abe2,0x14adc,0x22969,
        0xa549c,0xc9556,0x99976,0xf8b59,0x3d8c9,0x6e83f,0x7bd77,0xc22c5,
        0x5ec57,0xab7c8,0xf2942,0x61f54,0x56e2c,0x3407e,0xb48ef,0xf213d,
        0x5e8ca,0xc7f00,0x32698,0x853df,0xb470c,0xc0a54,0x8d7ca,0xe6f48,
        0x7501e,0xed60b,0x6bd6b,0x4bd9b,0x6714a,0x10310,0x894f0,0x6e098,
        0x5bc3b,0x00528,0x5f92a,0x741af,0xaec06,0x7ef24,0x426ef,0x32f16,
        0x7a438,0x4d6c7,0x2f9c4,0x00001 },
      { 0x13a1c,0x64833,0x951e9,0x8b371,0xa33c5,0xedd3d,0x04498,0xc7ac4,
        0xbbf52,0xe84ed,0xdcb5e,0xa6f70,0x8866c,0xd422f,0x8f56d,0xec0ae,
        0x1ec2e,0x54066,0x077bc,0x523c1,0xad422,0x39913,0xb3e6d,0x58e7c,
        0x5e1e8,0x45d10,0x979bb,0x397fc,0x247c9,0x97b59,0x4a909,0x3221d,
        0x52fe7,0xa3e89,0xef628,0x62410,0x74e94,0x8d582,0xf40d0,0x59780,
        0xbed0f,0xec64c,0x8e110,0xc2270,0x313d7,0x79b1a,0x86676,0xd186d,
        0xe1d18,0x4e26a,0x2f75e,0x00000 } },
    /* 217 */
    { { 0x307d7,0xbf47f,0xb637e,0x14771,0xad014,0x644a6,0x80c6b,0x2e05a,
        0x33d65,0x3182a,0xed07b,0xa0f3f,0x7c8f1,0x96e59,0x7f936,0xc09ee,
        0xfc01e,0xc3c7f,0xdaa7e,0x73b9c,0xef8f3,0x9f88f,0x98954,0xc3bb8,
        0xd1961,0xb7c88,0xfcaa7,0x4fe9d,0x0d92a,0xe4ab2,0xee23a,0x12ff9,
        0xcb1a5,0x41f5e,0x5aea6,0xb47df,0xfe32f,0x69237,0x5c0e7,0x25d08,
        0x5c420,0xa296a,0x6c755,0x25582,0x3dc91,0xce972,0x85f9b,0x580b9,
        0x61941,0x66639,0x2b1b5,0x00007 },
      { 0xe5558,0x08790,0xd708a,0xaf809,0x10689,0x53604,0xb5f98,0x42313,
        0xe7b8a,0x1ae85,0x5a49d,0x12925,0xbe6ba,0x371b0,0x4b0ac,0x5e76c,
        0xe6e19,0x39938,0x8504f,0x9a215,0x260ae,0xd4142,0x5ce8d,0x96848,
        0x04e9b,0x43d8b,0x87efe,0x4ba58,0x3f94c,0x1c5e7,0xe67f1,0x11268,
        0xb99c4,0x28cf6,0x2623e,0x96629,0x87a0a,0xd0aaa,0xed3f2,0x4ca02,
        0x6772a,0x51b26,0xd63b5,0x8e4e2,0x568ee,0x78b5b,0x2992e,0xcdebb,
        0x225ad,0x16e17,0xdf192,0x00005 } },
    /* 218 */
    { { 0x2e7e3,0x1e8df,0x0027e,0x07de2,0x8d8da,0x83cc6,0x694b1,0x4b4ae,
        0x5ba69,0x88ce3,0xca62e,0x97df3,0xc896d,0xefed2,0x13b52,0x3de47,
        0xd084f,0x0e26b,0x006c4,0x923bd,0xbfc81,0x9b71b,0x6b01e,0x1aacc,
        0x1c7b6,0x40999,0xf6568,0x93648,0x4650c,0xf4752,0x1d187,0x13856,
        0xd3ca2,0x11bff,0x10f2b,0x14186,0xffa19,0x915fa,0x30996,0x955e5,
        0x236de,0x798f1,0x1872d,0xbeeaa,0xb613c,0xa2a48,0x4ea66,0x7f7b4,
        0x89c32,0xc2e0a,0x52265,0x00004 },
      { 0x30010,0x79254,0xad5ec,0x90c04,0xfebd0,0xc786f,0x3f5ca,0x20a9d,
        0x9f4ff,0x5fa5f,0x3edc6,0x4112a,0x1fcbf,0xf3eb1,0x39c0c,0x88248,
        0x5b700,0x4e8aa,0x8dd6d,0x8ab8b,0xdb756,0x271df,0x60ee2,0xb7445,
        0xec373,0x96e43,0xcf752,0xf9261,0xb78ea,0xa96d9,0xe0e3f,0x1809a,
        0x5dfd5,0x2ddc2,0xb312d,0x77110,0x46bab,0x8f78b,0x1e46b,0xb5ecf,
        0xefc8d,0xaa069,0x09fec,0x2bae6,0x1c195,0x4dbde,0x2ed5f,0x43e30,
        0x78555,0xf91e0,0x4b02b,0x00001 } },
    /* 219 */
    { { 0xe5b57,0x68b87,0xc71c7,0xa5572,0x7f531,0xcc78f,0xdc80b,0xf7597,
        0x93f8b,0x5f4ff,0x39e17,0x026d1,0xcb28e,0x94ca6,0x727cb,0x6b83b,
        0x9f7fc,0xb2007,0xeafe3,0xd1702,0xecf3b,0xca54d,0xc6c2a,0x6af0d,
        0x4133c,0x5e17c,0xcf5e3,0xe665c,0x6bea1,0x5505c,0xa4834,0xa6691,
        0x00b89,0xd0e61,0x633ab,0x03882,0x6c17d,0x6c670,0x90c96,0x1a0cf,
        0xfffbe,0x4c7ae,0x0add6,0x7be7d,0x64d84,0xa2aa4,0xdfbae,0xd49bc,
        0x7d0a5,0x742cc,0x5e07e,0x00008 },
      { 0x25bca,0xa60bc,0x3aae0,0x64ec2,0x1e44f,0x8e55f,0x7736e,0xb607b,
        0x696d8,0x09e1e,0x30059,0xa746d,0x0aa90,0xbc499,0xccd2c,0x072b1,
        0xe2f5d,0xc6c68,0xd0fe6,0x8ec90,0x053e2,0x0ec5f,0xcc192,0xf0040,
        0x21fb4,0xc779b,0xcc4a2,0x5bd3f,0xda737,0xbac7d,0xef9e1,0xf5f5d,
        0x0f8d3,0x7935c,0xc315d,0xd318d,0x02cac,0x17c17,0x71c71,0xe926f,
        0x823c4,0x9a6f2,0xd02f3,0x58bbe,0x338db,0xb6932,0x2317d,0xe5b49,
        0x9f430,0x9f8d4,0x96403,0x00000 } },
    /* 220 */
    { { 0x99eba,0x16569,0x1774f,0x63052,0x7b1de,0x8ee28,0x6693d,0xde0b2,
        0xaf726,0xa1d81,0xf8942,0x69393,0xc3744,0x03e13,0x615ea,0xbcf6b,
        0x273cf,0x3594e,0x30c0c,0x5c56d,0x6c672,0xd33a5,0x7a24f,0xa8be9,
        0x534ad,0x51a57,0xc22a2,0x42a67,0x97992,0x0c5c4,0xdb59d,0x4e51b,
        0x42768,0xccc6a,0x7cd76,0xbf59d,0xcd426,0x4097a,0xeb291,0x66e9b,
        0x04a2c,0xe9594,0xc96e3,0xfe985,0x04738,0xd666d,0xe0eaa,0xbcbb3,
        0xc5e56,0xd263b,0x26b0f,0x00006 },
      { 0x1ec42,0xbae1a,0x7217d,0xcc504,0xbab5a,0x6ae7d,0x1d1aa,0x86533,
        0x1ab1e,0x6fb7e,0xd3012,0x30703,0x1b845,0xe6185,0x9e0de,0x28064,
        0x89544,0xa3ea6,0x806f4,0xf6328,0xdcb56,0xbe43a,0x94f4b,0xbcaff,
        0xb9bda,0xbe036,0xd0637,0x1e65b,0xb0d94,0x6f3ab,0xd4468,0x82179,
        0x6afd6,0x2caad,0x48691,0x15341,0xeff7e,0x3b891,0xd969a,0xeb86f,
        0x426ce,0xc388c,0x17928,0x6a811,0x0b56e,0x399e0,0x13596,0x933e7,
        0xb6ac1,0xd9a17,0x9bbdd,0x00000 } },
    /* 221 */
    { { 0xd3673,0x1de4f,0x5e39c,0x8e077,0x1a65c,0x80d9d,0x7fef8,0x7289c,
        0x5c1dc,0x00472,0x529d2,0x35ee3,0x35b67,0x747af,0x2ed3c,0xc1f8f,
        0xefdf5,0x8f912,0xcf399,0x9c395,0x84985,0x72261,0x95ded,0x0e697,
        0x93a2f,0xa7237,0x6b1d2,0xb8d68,0x48a6a,0xa882e,0x5de22,0x00c81,
        0xb8d7e,0xfcf9d,0xe77d6,0x7547b,0x20226,0x86fb3,0xedc08,0x49c10,
        0x687d4,0x4cb62,0xc83ed,0x3e177,0xa9f1c,0xf366e,0x7f05a,0xe6d5d,
        0xfad24,0xb8d1e,0xeaa01,0x00002 },
      { 0x57c74,0x701f3,0xe47fb,0xb7945,0xaa9e3,0x085c4,0x90593,0x6e85a,
        0x98733,0xc94f0,0xe0244,0x08ffb,0xdf538,0xb5660,0xf93a3,0x91ddd,
        0x95ed6,0x7bf3b,0xb7637,0x20d48,0x7bb39,0xb911b,0xcf391,0x86a13,
        0xf08bf,0x587cc,0xa018e,0x8f97e,0x453ed,0xc5519,0x34378,0xb1ea4,
        0x2d5a6,0xe9e0d,0xe6add,0x259a8,0xf9b96,0x2b248,0xdddfc,0xeef17,
        0xbceae,0x8596e,0x57f9c,0xb4435,0x8f694,0xd5bba,0x50f07,0x48cd1,
        0x1986b,0xe9b4c,0x2d31d,0x00000 } },
    /* 222 */
    { { 0x9499d,0x1ede7,0x6bb9e,0xc2ada,0x8fd0f,0xca8ff,0x356f6,0x1a7d9,
        0x0f8e8,0x27bec,0x8f063,0x1c9fe,0xbbc3d,0x300be,0x2173b,0x805c7,
        0xc181b,0x08413,0x0420a,0x9d010,0xef0ca,0x9a167,0xdd69e,0x1aeed,
        0xc909d,0x72076,0xe3a8a,0x997f8,0xe64a1,0x7b429,0x7a7a7,0x3ce7f,
        0x4d3e9,0xf45c9,0xac0fb,0x8407a,0x7e6d4,0x7694a,0x1e7f3,0xa9192,
        0x679e2,0xd6f56,0xe1dbb,0xe0f3e,0x9f23f,0xf9fa9,0x566cb,0xc7917,
        0x4d765,0xf2e0f,0x65860,0x00009 },
      { 0x5f79c,0x2b7fa,0x73470,0xd26de,0x65af2,0x0bd42,0x0ce93,0x6c73e,
        0xd8b98,0x2d45b,0xee44a,0x7bed4,0xa7dbe,0x6c8a1,0x02495,0xc129e,
        0xdf80e,0xac77c,0xfdc05,0xa59b6,0xb589c,0xa6ba2,0x5af70,0x99982,
        0x84021,0xb6fc4,0xa23f0,0x4b547,0xf1d28,0xa0a8a,0x0a428,0xb1da1,
        0xaf6d8,0x312b2,0x1eb1b,0x5ee3b,0xa3393,0x51443,0x6ecf0,0x8effa,
        0x7eb26,0x4c7a0,0x66265,0x4086d,0xc16ee,0x49ee4,0x50145,0x7a7bc,
        0x98a52,0x321fa,0x50810,0x00006 } },
    /* 223 */
    { { 0xed9b2,0x60b67,0x9f0e4,0x93d24,0x0c36d,0xda0fd,0xe1c0c,0x88c75,
        0x963e9,0xc9bb5,0x14bc0,0xbe936,0x5757b,0x76860,0x8019a,0x9a9b8,
        0xdc544,0xaf48e,0x8b7e2,0x5985a,0xeb51a,0x77ed9,0x24c9e,0xebbf0,
        0x25274,0x36dd0,0x545c6,0x62881,0x0598b,0x00dba,0xed048,0x39bda,
        0x2a23a,0x3981e,0xfc201,0xb4f27,0xc550c,0x66fd5,0x8c7dc,0xb5206,
        0x7032f,0x15ad2,0x169fa,0xbcae8,0x2c9a0,0x7ca8a,0xf213a,0x60606,
        0x2652f,0x46986,0x82950,0x00009 },
      { 0x1c128,0x002e1,0xe3746,0xca7e3,0xd0e6d,0xdfae5,0x26480,0xd9552,
        0x016e2,0x43e44,0x80b71,0x88f28,0xcf65f,0x6b881,0x8d452,0xca3d2,
        0x86afe,0xd1dfb,0x9c59d,0xf958f,0x24c74,0x8860c,0xf4f54,0x9cb69,
        0xea43c,0xecd06,0x334ec,0xc9ae7,0x35343,0x32971,0xcd635,0x5cc2c,
        0xa6c0c,0x035f3,0x95ff4,0x653ba,0xcb372,0x01a1c,0x23d2e,0xa2505,
        0x10fdf,0xb2315,0x6227e,0x38e2a,0x0eee5,0x23cd1,0x8a0ca,0xeadfc,
        0x8f54b,0x1b3e7,0xb7e6e,0x00004 } },
    /* 224 */
    { { 0xf928b,0x6fdb5,0x9c907,0x7cec7,0x6b734,0x250bb,0xc41e6,0xac00e,
        0x67798,0xc754b,0xd9619,0x20ba9,0xf900d,0xe4343,0x0d059,0xed42c,
        0x935d7,0x85451,0xdf39e,0x01ce3,0x264f7,0x39118,0xaac26,0xe1f87,
        0xf2554,0xaace8,0x5f91a,0x67896,0xffddd,0x24539,0x63fa3,0x96cd1,
        0xce995,0x2c4ba,0xc815f,0x9ea55,0xaa94f,0x8c8c2,0x455d7,0xef24e,
        0x2aff4,0x6a7ab,0xcddc2,0x64091,0x2f0ed,0xca282,0x20b00,0x954a4,
        0x97658,0xc5d32,0x611c4,0x00000 },
      { 0x81829,0x1ca9e,0x19200,0x82ccf,0x008a2,0xd3332,0xd9bde,0x8f9de,
        0xd7de1,0x030bf,0x78890,0xac0db,0xd6793,0x77a5d,0x91d35,0xbb00d,
        0xd3c2b,0xa7802,0x17a23,0x9014e,0xcfb54,0x95f88,0xe07ff,0xc71b6,
        0x1bf4b,0x8b7cd,0x3588c,0x24a02,0x62e3b,0x11207,0x5b8a4,0x9b533,
        0x56d30,0x5ec40,0x481c0,0xa1b52,0xce916,0xc7410,0x9f455,0x85017,
        0x03271,0x08bbe,0x3cd12,0xc177b,0x015e6,0xcbfe5,0x4c090,0x509a2,
        0x08566,0x291c1,0x20795,0x00008 } },
    /* 225 */
    { { 0xd353e,0xff1c7,0xd2d3c,0xce3b5,0xd7de0,0xe7ecc,0x635d5,0x6ca87,
        0x1075f,0x3eb4b,0x5f9ad,0x04e02,0xeda84,0x5cb5a,0xe8920,0x6b963,
        0x221a1,0xd809f,0xe5ee0,0xaca49,0x9ea41,0x4c85d,0xa34d6,0x34442,
        0x6c4e9,0xa46a4,0xcf655,0xf97e3,0xcac6f,0x417d7,0xc1ee5,0x76565,
        0xf9c4c,0xa9eeb,0x81009,0x63886,0x988da,0xb61d3,0x2c695,0xf6b47,
        0x2b46a,0x71640,0xb7f11,0x51650,0x31fde,0x0c05e,0x273be,0x94f8f,
        0x344a7,0x36a88,0x487b0,0x00007 },
      { 0xe2370,0x759c3,0x860e5,0x8719a,0x3f804,0xd5819,0x9aa19,0xa6e2f,
        0xdbf3c,0x9b3a0,0x14471,0xe9596,0x1b6c7,0xffec2,0xc74de,0xa9049,
        0x0cebf,0xb23f5,0xba064,0xde158,0x049a1,0x2822c,0x7f2b1,0xb1d52,
        0x4b7d9,0x30b65,0xffd04,0x859d0,0xbc470,0x05446,0xa674f,0x37c74,
        0xdd995,0x1ba3a,0x55325,0x33b5e,0xbe335,0x3ed6c,0x9ce4a,0x27e41,
        0xf44d0,0x792f2,0x5d1b9,0xee82a,0xf2d84,0x6fa69,0x123db,0xcc76b,
        0xa3bdd,0xc521f,0x34f85,0x00008 } },
    /* 226 */
    { { 0x9b31a,0xc12ce,0x29347,0xb3b73,0xafe3f,0x88522,0x0fd1d,0x52ff9,
        0xefb4d,0x1d4bc,0xb1a08,0x73862,0x853b1,0x411f0,0x1ba2a,0x538c1,
        0xb603a,0x3c141,0x895b9,0xd7417,0xab10b,0x93b9a,0x98629,0x09912,
        0xbd046,0xa5ccb,0xea0ab,0xafb0e,0x7669f,0x66189,0x62235,0xd4844,
        0xffa54,0x9c367,0xa63b8,0x78da4,0xd1c34,0xad5d1,0x4f7cb,0xaa603,
        0x39227,0x91c53,0x61b13,0x705fe,0x50e6d,0x4ff51,0x660f7,0xdd14b,
        0x2b54c,0x0a533,0x39d8b,0x00006 },
      { 0x217cd,0x62162,0xa4231,0x28e6f,0xa811c,0x0e4a2,0xdc02e,0x21766,
        0x9ce18,0xef68d,0x46a06,0x37390,0x15126,0xe9210,0x231dd,0x44eea,
        0x298d3,0xf2114,0x607c8,0x57e90,0xa63d9,0xf272b,0xae127,0xa5e8c,
        0xe80cc,0x3fe7c,0x4f7a6,0xebe22,0x45816,0x673e3,0x5a789,0x4dece,
        0xbabd4,0x22536,0x3756a,0x77af1,0xee3bf,0x4d61a,0x8bc64,0x2bcf9,
        0x2bf6e,0x2c60b,0x9fa96,0x59f32,0x33b0b,0xb5002,0xa1aab,0xb0769,
        0x5402c,0x360c7,0x09031,0x00004 } },
    /* 227 */
    { { 0x0433f,0x3a167,0x4d287,0x3dfc8,0x62549,0x394df,0x89ec9,0x80fcf,
        0x5a19a,0x16eb0,0xb2976,0x4310d,0x6e39e,0xe6304,0xdc9d9,0x50742,
        0x9ca9e,0xc81de,0x31ad8,0x1d0df,0x4fb7b,0xaabf9,0x2d186,0x1b3c8,
        0xda27a,0x8436c,0x9702d,0x2ef43,0x9fb1a,0x08129,0xddc46,0x280bf,
        0x96238,0x8dd23,0x4b2b4,0x9353e,0x37b3c,0xb2c2f,0xa692d,0x12fb8,
        0x5b317,0x74d5b,0x81804,0x7a3b0,0x8f9b8,0x95257,0x9861e,0xd8590,
        0xa2bc8,0xedf37,0x0668e,0x00008 },
      { 0xa0249,0x35b39,0x2edcd,0xaeaee,0x4b2f8,0x230cd,0xf05af,0x7223d,
        0xb15e4,0xf4295,0x0e937,0x982ae,0x2bb66,0xbc916,0xb728c,0x019d2,
        0x9dca1,0xe9cf4,0xc512a,0x07b45,0x7630f,0xb491a,0x4e911,0xa0387,
        0x4f34c,0x3348d,0x4cb74,0x0ea64,0x3c1fd,0x5b30c,0xae1f9,0x13f79,
        0xb60ac,0x4ded8,0x0362d,0xd81c4,0xf61ea,0x8314f,0xd289e,0x498c3,
        0x00dd4,0x02ed6,0x25217,0x1c19c,0x35fcb,0x9c1f3,0x9fc3a,0x59232,
        0xe6ce9,0x481bd,0x46775,0x00000 } },
    /* 228 */
    { { 0x33c96,0x6e392,0xe3de5,0x7eafe,0xc8073,0x8c409,0xc6886,0x201ab,
        0xe11bd,0x05aca,0xb4862,0xea9b2,0xc0f2c,0x19056,0x7e16f,0xe3238,
        0xc2a41,0x5aa5d,0xa7536,0xbe86e,0xc12b4,0xc29ac,0x94d76,0x8d632,
        0xfcab7,0x24a01,0xcab9f,0xe88b0,0x481db,0x14c05,0xe5bf4,0x76646,
        0x6b7aa,0x93cb9,0xe1118,0xe097f,0x17664,0x49f5b,0x5a9b6,0x53fcf,
        0x6422e,0x34a19,0xb7ff6,0xc9bd0,0x55978,0x22989,0x38e3c,0xb5feb,
        0x3c456,0xfb083,0x38a49,0x00000 },
      { 0x93257,0x8c13e,0x5e381,0x741b3,0xda612,0xcebc9,0x06b14,0x7caac,
        0xe9249,0x164f6,0xdaa11,0x8e333,0xa8227,0xe2034,0x65e4d,0xe7cc5,
        0xba630,0x5f0a1,0xb7dc9,0x6fbdb,0x36695,0xdd9f2,0xdd681,0xbb132,
        0xe6319,0x37c63,0xc2413,0xb022f,0xc6e22,0x8beb1,0x1937e,0x23848,
        0x938ac,0x4dd8c,0x3b199,0x56448,0xaa6bb,0x4cfac,0x807b5,0x06f91,
        0xcd44e,0xf31a7,0x8f8d9,0x39bba,0x61dd4,0x74a8e,0xa787f,0x660c2,
        0xb5660,0x22121,0xbb76e,0x00004 } },
    /* 229 */
    { { 0x54817,0x8ae63,0xa151e,0xb4387,0xaf038,0xd494e,0x98633,0x85958,
        0x6c688,0x124c8,0xdcbac,0x38271,0x67215,0xedad0,0xf8cc0,0xf487a,
        0x0e5d6,0x1fe50,0xd3305,0x7f55a,0xbd6e4,0x711b1,0xad50a,0x8c746,
        0x709a7,0x5ea68,0x402f3,0x72626,0x027f1,0x30c13,0xefafb,0xc6d08,
        0xc7497,0x41c06,0xef1c0,0xe2da9,0xedcc3,0xc74ec,0x073d0,0x092e1,
        0x5f96e,0x7430c,0xaa12b,0x93cf2,0x20f13,0x07eb0,0x01621,0x24584,
        0x6f98b,0x5f7b7,0x843d2,0x00008 },
      { 0x2a83e,0xdcedb,0xe1501,0xd7244,0x02bb8,0xfe8fb,0xf62bc,0xd925d,
        0x20659,0xc3090,0x2ab6f,0x5dcf4,0xd3c71,0xf09df,0x055a0,0x73c05,
        0x90aea,0xd8e35,0x26745,0x749e1,0x876ff,0x82f4d,0x66353,0xa920c,
        0x9feef,0xcafc6,0xfd711,0x02119,0x5de16,0x75c4d,0x3bd90,0x4219c,
        0xd6bf2,0xd13de,0x800cb,0xa1163,0xb6263,0x7ea0e,0xc378c,0x7d264,
        0xd7958,0x8c35b,0x159c9,0x2e457,0x556e2,0x7373b,0xa2dfa,0x71bf2,
        0x5c949,0x39893,0x503f9,0x00000 } },
    /* 230 */
    { { 0xad4f6,0x6671d,0x5addc,0xea1b6,0x9024b,0x8e488,0x3dd23,0xf605d,
        0x6c8e2,0x89fb7,0x0d96b,0xf5deb,0xb13d5,0x01b2c,0xa3566,0xe0b5b,
        0x3d254,0x1d83e,0x37d49,0x8ea7e,0x3240c,0x86042,0x9bae8,0xe91c9,
        0x182f3,0x19374,0x87ad9,0xcaf9a,0x526c2,0x74f29,0x40af5,0x4b130,
        0x000a3,0xd1944,0xb9bce,0x42e75,0xe06df,0xcc57b,0x89d4c,0x4bd10,
        0x8ec50,0x0022e,0xddbb5,0x177ad,0xb0c53,0xcfead,0x1d29e,0x690d3,
        0x668f9,0xfe176,0x35778,0x00007 },
      { 0xc1137,0x3e843,0xf86ee,0x73cd0,0xa3f0b,0x1c42f,0xe3a3c,0x8ab20,
        0x5679d,0xae0e7,0x6242f,0xf1f41,0x46f95,0xb092e,0x11c39,0x7b88e,
        0x36ac0,0x3e4c2,0x62940,0x02e61,0x12dac,0x105f4,0x63266,0x862e0,
        0xc28a7,0x8d74d,0x3b23c,0xffb2f,0xf2118,0x45ffb,0x17c07,0x11824,
        0x5711e,0x044c0,0x9b55a,0xe4de4,0x4cefb,0x665b7,0x1072c,0x97bf7,
        0x4c01d,0x761cc,0x54f06,0x06dac,0x8b2ca,0x50d0f,0xdaa74,0xfc599,
        0x182a1,0xa61a3,0x2e637,0x00005 } },
    /* 231 */
    { { 0xbc6db,0xf16be,0x81700,0x3d924,0xbf950,0x6b45d,0x9194a,0x5d153,
        0x5cd3c,0xbcc71,0x5ad2a,0x1c05e,0xf942a,0x7b466,0x433ab,0x36a82,
        0x3918b,0xedba1,0xa413b,0xe6ceb,0x490f4,0x8a562,0x3ca69,0xf3f1f,
        0x20da6,0xb3bb7,0x3471a,0xd41d6,0x92116,0x3d360,0x22730,0xe00d2,
        0xba69e,0x00463,0xfd4cc,0x5fd17,0xd6284,0x609e4,0x9c7ac,0x80adc,
        0x03b2c,0xca636,0x5fafb,0xfc9a4,0xbbf16,0xbc94a,0xf7fc4,0x41007,
        0xb1698,0x4fa74,0xc916b,0x00007 },
      { 0xac2d4,0x9178b,0x1026f,0xa875c,0x82601,0x2e809,0x6408a,0x0073d,
        0xf276e,0x88ad2,0xcc1fb,0x10c4f,0xf4436,0x6b291,0x822ca,0x5727b,
        0xc60fc,0x2c88e,0x64553,0xd48b0,0x9ed9a,0xe4889,0x10351,0xf543f,
        0xb48b5,0xeb841,0x591ce,0xb1bed,0xba6cc,0xcf5a8,0xf0f9d,0xfc4ad,
        0x7ddb4,0x20b34,0xa7ca0,0xc5213,0x2cb44,0x1accc,0x0c4aa,0x0527c,
        0xb6828,0x50773,0x023cf,0x4c107,0x6aa37,0x74c92,0x0006b,0x733d1,
        0x8d07c,0x6f77a,0xff391,0x00001 } },
    /* 232 */
    { { 0x7939d,0xe4f99,0xa218f,0x83b3a,0xb7915,0x4dfbb,0x60b3d,0x87f75,
        0x7b5da,0x98b3a,0xda92c,0x28015,0xaa9c0,0x666f4,0xaad46,0xe1eb4,
        0xe9dd7,0x5114c,0xeb17a,0x30762,0x4ef8f,0x6a66a,0x46ef4,0x810e5,
        0xb45c6,0xdd900,0xbaf04,0x22584,0xff7af,0x84d42,0x8725c,0x3cc1c,
        0xc83de,0x258e4,0x093f2,0x88b23,0x1170d,0xfade4,0xe4462,0xac076,
        0x612e4,0x1be19,0x2dd14,0x73463,0xaf48d,0x5e34d,0x75992,0xc1b1f,
        0xb90c9,0x56072,0x9ed1a,0x00001 },
      { 0x35473,0xde6c7,0xcf7fc,0xbc3e9,0x76003,0xb88e6,0xbb8aa,0xfb199,
        0x87cbc,0xbd121,0xacccc,0x04419,0x9bb73,0xf6545,0xf3cb0,0x214af,
        0x26282,0xa36f9,0xaec81,0x20b86,0x29f9d,0x82cb3,0xc90aa,0x5773c,
        0x3f90f,0xe182f,0x62257,0x0e6bf,0xf4af6,0x4762d,0x4bfbd,0xf18b4,
        0x70753,0x29db9,0x948b1,0xc18e3,0x97c22,0xe920e,0x7adc6,0x57be9,
        0xd6208,0xf9393,0x6b637,0x382c4,0x5e8d7,0xfed1d,0xccbf1,0xf6625,
        0x81599,0xf9686,0xf31e0,0x00006 } },
    /* 233 */
    { { 0x8f204,0x5582b,0x45afe,0xb54ac,0x6d358,0x0441b,0x5edac,0xacd5f,
        0x3e7bf,0x93721,0x39bcd,0xc70b1,0x01914,0xdbcbb,0x58196,0x714b4,
        0x35d21,0x351ed,0x9297d,0x1f20e,0x76a3e,0x64083,0x7058f,0x2f3cd,
        0xa8a9d,0x6d150,0xcdd9f,0xe801d,0x2fb36,0xf56d8,0xb655c,0x5a54e,
        0xa5a21,0x0c92a,0x61050,0x9f037,0x23b08,0x0d0ae,0x6e8d1,0xc42b6,
        0xb2079,0x48491,0xeee8d,0xae3d0,0x54af1,0x556f4,0xc2841,0x137e4,
        0x8a7e6,0x0863d,0x75e33,0x00008 },
      { 0xc0acc,0xdcaf6,0xc80fd,0x7c08d,0x6bb1e,0xad1e6,0x5add5,0x82858,
        0x17ae1,0xa6dc7,0x75c7d,0x43402,0x5bdc5,0x6b9e1,0x852d2,0xf4b4c,
        0x5fa50,0xbf6a0,0xf0a1f,0xcb325,0x7817b,0xf81e4,0xe1dc6,0x70ff2,
        0xd4328,0xfc2cb,0x7c7f7,0x90166,0x48a24,0x85a6c,0xcb7b5,0xd045a,
        0x6c057,0xd4466,0xe972a,0xd63d2,0xfe6d7,0x4d87c,0x144c7,0x0e274,
        0x67d87,0xaef70,0xb2584,0x157a8,0xbb2ca,0xf0fde,0xbfb75,0x495c5,
        0x6e009,0x81f38,0xabb05,0x00005 } },
    /* 234 */
    { { 0x97f57,0x2bf0c,0xbe62d,0x28c78,0x1962f,0xe0487,0xabb0f,0x47b50,
        0x8a467,0xedc54,0x4fa09,0x6e034,0xef6b2,0x05a96,0x6e3ab,0xfd44c,
        0x6ae82,0x2c70e,0xdb003,0x899de,0xbd7e4,0xbd402,0x1c228,0x9b7c1,
        0x2e963,0x1643f,0xe9137,0xfc0ec,0xc0ec3,0xfd0f8,0xbc902,0x769b8,
        0xbc3ac,0xaa7ca,0xd9cb3,0x4cc99,0x20692,0x8a889,0x014e8,0x42609,
        0x461aa,0xe0a51,0x62e79,0xaa8b9,0x0c7f4,0x1b3e8,0x10a8b,0x4ef02,
        0xee4bc,0x801bf,0x05446,0x00007 },
      { 0x901c1,0x13121,0xab3d7,0x54aaf,0x7fead,0x0a262,0xa23e9,0xbc08b,
        0x6d285,0x7e64f,0x6ec22,0x30153,0xb8d99,0xc191a,0xab906,0x99a16,
        0x9ce2c,0x5bf64,0x6b1cf,0x3a808,0x966be,0x20675,0xcf059,0xccba2,
        0x36279,0x86188,0xff534,0x7b87e,0x22c15,0x223af,0x8964b,0xbfac9,
        0xe7a57,0xf00aa,0xd0fd4,0x8a80c,0x06321,0xddb94,0x14eda,0xdf88f,
        0x4bb79,0xfd384,0x71ed9,0xe3d4b,0x6c1b3,0x20503,0xa13d6,0x6c634,
        0x80a6b,0xcfb86,0xf56ae,0x00006 } },
    /* 235 */
    { { 0x05c5d,0x03d92,0x01dc8,0x3929b,0xd6712,0x955f7,0x56568,0x9d9b6,
        0xbbffd,0xfe3de,0x3b1ac,0x395ed,0xfb844,0x94eef,0xb2160,0x04328,
        0x91feb,0xa8229,0x631ff,0xd0756,0x6190d,0xde66e,0xc050d,0xe8577,
        0x03c55,0x0775b,0x17224,0xce5f9,0xf6c91,0xbb3a3,0xa408e,0x9a288,
        0xa1396,0x8a058,0xd376f,0x06761,0x79a6e,0xa5945,0x288f3,0x7b71d,
        0x029c5,0xc0103,0x44c30,0xf428b,0xc0843,0x0e0b9,0xff873,0xd8e6a,
        0x644ad,0x114ed,0xb6be8,0x00007 },
      { 0xaa54e,0x4a3d3,0xec38e,0x509a3,0x3d83d,0x23394,0x5e210,0x24395,
        0xaa621,0x44f84,0x51d3d,0x4717f,0x72910,0xca4e3,0x42c7e,0x62d24,
        0xa55de,0x3d85f,0xc5a52,0xa1b58,0xa851d,0xf5ccd,0x468c6,0x20001,
        0xbcaa8,0xe0044,0x01702,0x1e68e,0xcf750,0xa0ace,0x359e6,0xf0819,
        0xef0b2,0xadac0,0x3dda6,0x4f013,0x8fd96,0xaeedc,0x0d897,0x530b9,
        0xacd0e,0xeb48d,0x84122,0xad6fb,0xe4c5f,0x00a1d,0xc1ed7,0x2284e,
        0xa5474,0x35dbc,0x6f9a8,0x00008 } },
    /* 236 */
    { { 0xcc69f,0x55450,0xe1d90,0xf98f0,0xcc9ed,0xeb14b,0xa0150,0xee7eb,
        0x94e77,0x531bb,0x98f8e,0x67379,0x05f7a,0x16eef,0x4e31b,0x58838,
        0xc5e15,0x23d85,0xb9287,0x52aab,0x5cbd9,0x51e34,0x674fe,0x7e241,
        0x0ee28,0xf0c5d,0x00182,0x46ef1,0xcfdc1,0xf5be2,0xe92e7,0x0f739,
        0x6bd3e,0xafb65,0x01ab3,0xe2895,0xe5168,0x552dd,0x04ab1,0xb8ee1,
        0xdfe31,0x75940,0x43044,0x3603c,0x34292,0x60a91,0x114c4,0x9306f,
        0x51f86,0xaf03b,0xbfa9f,0x00005 },
      { 0xb258e,0x2c107,0xa23f5,0x41dc2,0xbd663,0x9e82b,0xf1a98,0x823cf,
        0x3ced8,0x1f54a,0x19b49,0x77947,0x8f45b,0x33dfb,0x21824,0x898c2,
        0x250ee,0x1cc49,0xf9dd9,0x76550,0xe4fa1,0xc2a2a,0xf4550,0x2c327,
        0xa1ce4,0x41f7a,0x83b1e,0x5ad65,0xe13a1,0xbfad9,0x5a5a1,0x9aa0d,
        0xfbdcd,0x288e1,0xb1caa,0x7f879,0x6915f,0x9283b,0xa1eaf,0x87e81,
        0xe4e0c,0x96c10,0x080d2,0xca561,0x804fd,0x755bd,0x61612,0x6acc9,
        0xfeeda,0xaa828,0xb1266,0x00001 } },
    /* 237 */
    { { 0xee49c,0x00774,0xebc0a,0x37d74,0x2cb62,0x6f685,0x8a377,0x5df93,
        0x544ac,0xbdfc0,0x6fbfb,0x8ec8b,0xec338,0x5f2ea,0xbcd74,0x84ac8,
        0xce937,0x09b1e,0x9c566,0xfa13a,0xc7de8,0x6fb6a,0x87165,0xa532b,
        0xded74,0x095f8,0xa889f,0x428ba,0x2ab0d,0xb7aec,0xf2810,0x43b27,
        0xcb34c,0x1efee,0x6426e,0xc2db2,0xb9e89,0x431b6,0x09044,0x39211,
        0x4bc5d,0x58aac,0xfd810,0x73684,0xe926f,0x1ef60,0x69147,0x452fa,
        0xd7a23,0xdb218,0x3517f,0x00003 },
      { 0xc4a36,0x46593,0x9c33f,0xa9eea,0x836b1,0x69d71,0xeecac,0x4277b,
        0x20c1d,0x9c55a,0xe4f17,0xa24e7,0x23e8c,0x6d88a,0x369d4,0x57373,
        0x702f8,0xcc730,0x1ceb1,0xd5747,0x735ee,0x184d9,0xec28b,0x0704c,
        0x517a2,0x537f4,0x7062a,0x9d18d,0xc7f12,0xd77e1,0x71bb1,0x07a45,
        0x0d8b2,0x09835,0x74ac3,0xb8ef7,0xf61fa,0xb2919,0x01b27,0xb5dd8,
        0x4cc13,0x1fa7c,0x43459,0x255b1,0x3e7e6,0x3592b,0x7b85a,0x34993,
        0x77549,0x3d30c,0x1fac6,0x00003 } },
    /* 238 */
    { { 0x13fb6,0x1b049,0xee8cf,0xa6b32,0x01769,0x40135,0x1f07e,0x783e6,
        0xebb71,0xfe790,0x27f2f,0x07f9e,0xf1e51,0xaf89b,0x67fed,0x124ba,
        0xde68d,0xe1e58,0x89200,0xabee1,0x36df5,0x2732a,0x4aa96,0xacbeb,
        0xc37cf,0x7672c,0x93c5a,0xfa96e,0xbb0c5,0x63393,0x17cde,0x4c2a3,
        0xb2d6c,0x67830,0x7f65e,0xb96a9,0x41be5,0xfc350,0x66d4a,0x730ce,
        0x40a60,0x4f0bf,0x340d8,0xba799,0x896a1,0x626b0,0x25407,0x3ee18,
        0x0cbf5,0xdb7ab,0x1db35,0x00000 },
      { 0xefee2,0x2dac0,0xe0fbc,0xbb456,0xdd71d,0x06ebc,0xabe84,0x19b69,
        0xbde3e,0x22e72,0x7e018,0x7e613,0xc49cb,0x458b4,0x01c11,0xcbb8c,
        0xc5d63,0x47687,0x20b48,0x67764,0x1454c,0x47dfa,0xd1818,0xd1839,
        0xe911d,0x46bed,0x78df0,0xc9c92,0xc1b9d,0x1a336,0x62b88,0x294bd,
        0x77adc,0x7993e,0xf0968,0x3ba77,0x543ce,0xc9066,0xefc7a,0x7764e,
        0x695fd,0xcf148,0xac465,0x0f0b9,0x1e0c2,0xe2cdb,0xd28a6,0x636e8,
        0x5341d,0x8cd75,0xb6ba9,0x00007 } },
    /* 239 */
    { { 0x81ab4,0x03c18,0xb1d9e,0x8c88c,0x5b316,0xc25d5,0x4ce19,0x28236,
        0xd3d47,0x24a82,0x161aa,0x4390f,0x99599,0xebb2c,0xc00e1,0x7838b,
        0xc7a75,0xccbde,0xfd5df,0x220a8,0x24ff7,0xd203c,0xf484d,0x0efef,
        0x173b3,0x355ec,0x6428b,0xd2b31,0xf99f1,0x6e813,0x9e505,0xc06bd,
        0x319f1,0xbac0b,0x29172,0x3b159,0x4fd22,0xe0e38,0x1ed6a,0x98d09,
        0x1059e,0x8ebd0,0x65464,0x68e4a,0x86b31,0x75e79,0x47f33,0x22114,
        0xb4508,0x1971e,0x7e810,0x00004 },
      { 0xc290d,0x5abc8,0x045d4,0xb33a7,0x5810f,0x3d135,0xf2fa3,0x46fbb,
        0xf0092,0xd92ba,0x85c7c,0x3f1b3,0xcacff,0x61985,0x0ece1,0xc5b15,
        0x88748,0x7f2a8,0x6ee0a,0xdcc8c,0xe5e88,0x888c8,0x4439d,0xccb86,
        0x735f2,0xf24dd,0xc40f6,0x13b73,0x1cc1e,0xfed69,0x5fff3,0xfc3a2,
        0xee5c7,0x17257,0xcb43b,0xb1354,0x3f32d,0x654f9,0x2d3aa,0x02dff,
        0x58d0a,0x9444f,0x8ca63,0xf188a,0x778e3,0xe8669,0xccef3,0x39646,
        0xce87b,0x02e0d,0x85b19,0x00007 } },
    /* 240 */
    { { 0xf9a20,0x61a92,0xcce23,0x540ef,0x79d64,0xbdca8,0x7c5b7,0x1d00d,
        0x39a85,0x26d47,0xe97c9,0xc8dc2,0xb067a,0xda6a8,0xffe78,0x2aea3,
        0x51b69,0x5463c,0x828bf,0x141a6,0x97155,0xf1c47,0x81076,0x3977d,
        0xcbef6,0x7af4b,0x41bce,0x49495,0x575bc,0x7041a,0x066d1,0xe01f4,
        0x55eaf,0xbd877,0x282d5,0xae80d,0xd59e7,0x2107d,0x36f6e,0x382ab,
        0x6e166,0x34aa5,0x9d1d6,0x8ef6b,0x465ee,0x4ed84,0x60ace,0x99a21,
        0x12c27,0x67b77,0x557c3,0x00006 },
      { 0xb6e52,0x68d75,0x61b02,0x0e895,0x0118d,0x81364,0x1aeb0,0x6a2eb,
        0x53330,0x94cff,0xd0908,0x22266,0x84e46,0xfc1d4,0x227b5,0xbb351,
        0x3062d,0x0757a,0x365ea,0x2dc59,0xbd66e,0xaca37,0x8874c,0xb9095,
        0xd7d23,0xbf220,0xc4473,0xd3938,0xf9c0f,0x87da4,0x70a67,0xadff3,
        0x7f4b8,0xccd05,0xf0aeb,0xf33ae,0xc1173,0x5e744,0x6b420,0x925a2,
        0x1f0a5,0xfdb8d,0x22fbb,0x4f497,0x4a936,0x27d28,0xe7782,0xc891a,
        0x08ab4,0x04a0e,0x5c40d,0x00001 } },
    /* 241 */
    { { 0xe18d1,0x9a2a0,0xbaf16,0x27c29,0x74c03,0x71c01,0x2ce99,0x7bc26,
        0xa323f,0x79d81,0x18ff3,0xdb8d8,0x02099,0xd3c33,0x63d4c,0x663f6,
        0xa0553,0xc3011,0xf5325,0xa470e,0xcf980,0xd70bd,0x0709c,0x1c9ed,
        0x452d1,0x13e64,0xc676e,0x43f4a,0x5afbf,0x85c2a,0x0a6ae,0x97bec,
        0x490c4,0x50470,0xfaae5,0x6ba92,0x7491e,0xb97a8,0x9140a,0xaafa9,
        0x5f537,0x57405,0x67265,0xadbb3,0xffc95,0x19d6b,0x3b9d1,0x64634,
        0x41e37,0xa09d3,0x88e94,0x00007 },
      { 0x3461a,0xe59c5,0x53a6f,0xb6ed0,0xe08e3,0xec897,0x93975,0x0768d,
        0x5d2f3,0x4fa8f,0xc213d,0xbff6c,0xc9bd6,0xb0147,0xb4105,0x590c7,
        0xb8169,0x8b7c7,0x0a362,0x78e92,0xe5bce,0x6a086,0xd8fc6,0x4dec1,
        0x4d282,0xe93dd,0x19dcc,0xcf44c,0xe890a,0x435a7,0x875d8,0x6632d,
        0x381b2,0xc1ea6,0x90167,0xc1285,0x7f0dc,0x25979,0x463b2,0x46f8d,
        0x612b4,0x3991a,0x15efa,0x5d78c,0x84218,0x9f678,0xc3711,0xdf55e,
        0xdea93,0xc6780,0x1b19c,0x00009 } },
    /* 242 */
    { { 0xd8b80,0x9dcb5,0xbf270,0x660ee,0x2fc35,0xb9618,0x96903,0x055ef,
        0x3d991,0x42b87,0x47c43,0x4b4de,0x7d1ea,0x4f886,0x244d5,0xcc4b9,
        0xd77ef,0xcafd8,0x3b1a2,0xf5639,0x7e8c1,0x8d24e,0x05606,0x49973,
        0xfabb6,0x4f5f5,0x54237,0x8c500,0x38324,0x38e91,0x2b53f,0xc36de,
        0x680be,0xeb7bb,0xd07e8,0x13b5e,0x7d8f3,0x4813d,0x39296,0xafd2d,
        0x6a069,0x1a7bb,0x848a3,0x848e0,0x5c06d,0xf0c32,0xb2fe4,0x6867f,
        0x343af,0x34067,0xc2ba8,0x00003 },
      { 0xad63b,0x759d3,0xb62d7,0xeb1fa,0x759e0,0x9cab9,0x1173f,0x3885e,
        0x32a63,0x9e703,0x20b2f,0xafcee,0x7f22c,0xeca94,0xa7e49,0xb529b,
        0x8d88d,0x16622,0x49542,0x95612,0xc3923,0xea23e,0x64480,0xd4370,
        0x907e7,0x441b8,0x63e4e,0xa4555,0xa4b7f,0xa4b0f,0x29eb2,0xcca98,
        0x60792,0xa4480,0x0a720,0x91ced,0xc2469,0xcdda0,0x86b8c,0x348d0,
        0x2325b,0x1337a,0x60aee,0xd509f,0xf566e,0x7f253,0x09114,0x3d30e,
        0x73bd8,0xa5c10,0xfa627,0x00001 } },
    /* 243 */
    { { 0x78fd4,0xa2424,0x11222,0x2000a,0x1670b,0xf4c6f,0x6deac,0x8359c,
        0xbb04f,0xbcf71,0xb93cd,0x28297,0xb618e,0x0db60,0xae323,0x96e1b,
        0xb3b29,0xb4965,0x17fd3,0x55ddf,0x6bc70,0x8639c,0xd7fa5,0x4b817,
        0xa92ed,0xa4c3e,0x23b08,0xb2a6d,0xe9082,0x17010,0x28adc,0x84712,
        0x89d97,0x4620e,0x53b9e,0x77c97,0x703ff,0x7e4f9,0x0e5cf,0x2bbe6,
        0xf8245,0x7d6c3,0x80e01,0x2cbcb,0xb9e43,0xa45ed,0xacdc0,0x150a5,
        0x8743e,0x05479,0x7b8bd,0x00006 },
      { 0x97cf7,0xb4f47,0x66079,0xde02e,0xad03f,0x1c998,0xef1e3,0x54caa,
        0x3763a,0x115aa,0x76497,0xa1fef,0x764d9,0x29b1a,0xc73af,0x7ce0d,
        0x6ca93,0x83fb6,0x661b0,0x6a786,0xe32fb,0x4d74f,0x561bf,0xdf00a,
        0x6ef09,0x5925f,0x31d11,0x383f8,0x72bc4,0x6bde3,0x10c53,0x6d5cc,
        0xcc65b,0x9f882,0x4945f,0x99b8d,0x3451a,0xf48f1,0x1a481,0x6bac1,
        0x161cd,0x0a140,0x18a4a,0xd4edf,0x49d94,0x67a82,0x165a4,0x65363,
        0x9aedf,0xa9a4c,0x4297a,0x00007 } },
    /* 244 */
    { { 0x124ba,0xa4e21,0x49758,0xfbd2c,0x8a87f,0xbd819,0x8a899,0x3d663,
        0xbcdd1,0x7645f,0x5f7bf,0x5ff81,0xe9464,0xe6d57,0x36fc4,0x5fa67,
        0x61db9,0x7592e,0xeae64,0x944a1,0xccbdf,0x575c0,0xd7479,0x25b31,
        0x13047,0xe6a3d,0xcab5a,0xdf224,0x27881,0x2887f,0x2991a,0x8dbfd,
        0xac459,0x90a26,0x3d075,0x1d4a2,0x2d866,0x58985,0x0f72e,0x8a014,
        0x5c13b,0x2a37b,0xfb378,0x199e3,0x00f94,0xc14e9,0x0591b,0x722aa,
        0xbbb12,0xbad55,0x9aab7,0x00008 },
      { 0x6bdc7,0x96d65,0xb345a,0xcd3b8,0xfe176,0xbdc8a,0xc4343,0x32d64,
        0x518b6,0x41d69,0x9b82b,0x64a77,0x2fcf3,0xb0cf8,0x44eff,0x907b3,
        0x1287b,0x3c510,0x3d0c8,0x90eff,0x934cd,0xf26a5,0xb5ce9,0x07082,
        0x5aaf2,0x65e5f,0xce7c1,0x2c75e,0x64eb7,0x986cd,0xa81be,0xe9590,
        0x536aa,0x8fff1,0xeef49,0x3d5ef,0x3a826,0x56024,0x72b04,0x54ae8,
        0xbe14f,0x86940,0x32076,0xbcc9e,0xabee7,0xbc4d7,0x27dc1,0xd496a,
        0x0ab46,0x97594,0x02dc2,0x00000 } },
    /* 245 */
    { { 0xd60c3,0x37b69,0xe5339,0x2755e,0x2fe97,0x0be55,0x5a626,0xc0c72,
        0xfb78d,0xc2b11,0xab2e7,0xc27ec,0xb6982,0x2322c,0xdd9ee,0x4bcee,
        0x704f7,0xed122,0x52b19,0x61659,0x5854a,0xf4c28,0x4852d,0x7b192,
        0x0b5bf,0x2aba4,0x119f5,0xa9500,0xffcbc,0xadd86,0x1cbe5,0x7467d,
        0x0f2c1,0xfbd9d,0xbf536,0xebc99,0x4b8d4,0x296e3,0x3173c,0x05a81,
        0x5f8f4,0x76049,0x3335f,0xe8d67,0x28c59,0x54212,0x324e0,0x0b53d,
        0xbda73,0x353c3,0xd5645,0x00004 },
      { 0xc0877,0x007e5,0x322f8,0xa7647,0x60ca9,0x1b43e,0x71648,0xa2c12,
        0xf4f4b,0xc2231,0xd3136,0x6857e,0xe0959,0xdb30d,0x32238,0xae826,
        0x08ebc,0x40999,0x52fad,0x231e6,0x4af0d,0x8d181,0x3490b,0x09cbc,
        0x0c54b,0x8e268,0xbf3bf,0x62f34,0xffd45,0x2b595,0x90b09,0x29850,
        0x5fc34,0xa45e1,0x6f39c,0x8168e,0x1bc37,0x17519,0xa8770,0x845a4,
        0x944b3,0x1a906,0x2a154,0xd74a8,0x4acc6,0x55c8b,0xab3b1,0xadc9b,
        0x06c62,0xce773,0xf2f89,0x00001 } },
    /* 246 */
    { { 0xfefdf,0x419af,0x253ef,0x256b8,0x54cf9,0xd7ece,0x48305,0xb444e,
        0x002f2,0x1f377,0xba547,0x755fc,0x5b189,0xcbe01,0x3cbd5,0xc8848,
        0xb8429,0x696a0,0x54f7c,0xf61d2,0x461f3,0x850bd,0x15718,0x0a247,
        0x21089,0x0d7ba,0x92eeb,0xbc2ed,0x935ab,0x5dec8,0xabe96,0xfb56c,
        0x5684a,0x24bc5,0xda237,0x74929,0xf6a7a,0xba396,0xa46d8,0x2ef4b,
        0x90db7,0x7afcb,0x909b2,0x4fe09,0xedd23,0xf4366,0x16476,0xbdf3c,
        0x50d47,0x7f17e,0x9c809,0x00000 },
      { 0x50c07,0x40600,0xa04b1,0xe37e6,0x843a8,0x9e831,0x41fc2,0xbb55e,
        0x429b2,0x3acb9,0xce60e,0xea5a2,0x4ed2f,0x9d82f,0xff3db,0xdc7b1,
        0xd37fa,0xc3687,0x8ebec,0x75394,0x2ecb0,0x153e3,0x69279,0x57075,
        0x0054f,0xba6a6,0x00759,0xcd0c8,0x13871,0x922df,0x86f30,0x17a73,
        0x57b7c,0x9e833,0xe9fc5,0x51864,0x93941,0x26b3a,0x8891d,0xd34db,
        0xa0222,0x71912,0x9fcdb,0xfcf45,0x66672,0xff303,0x68d44,0x5a3f2,
        0x1e16c,0xd3691,0xf113e,0x00006 } },
    /* 247 */
    { { 0x6f1c9,0x59183,0x2a9df,0x307d5,0x54232,0x6519f,0x85afa,0x5ded2,
        0x6c701,0x75840,0xf627f,0x45caa,0xd0a15,0xe0417,0x1eeac,0xae111,
        0x13443,0xf6a61,0xb28bd,0xcbcbf,0xb52db,0x9ef0a,0x658de,0x7813e,
        0xc181b,0x25e9d,0x91272,0xabdb9,0x90b1d,0x814c5,0x8e322,0x5f059,
        0x4ee7e,0x6ed93,0xc3b96,0xa4bf5,0xab99b,0xb84ed,0x5e74e,0x3c1b5,
        0x19a34,0x0fb29,0x4aa86,0xdb499,0x6a9ad,0x811ff,0x0dff6,0x1b722,
        0x183e2,0x3bd1a,0x636a2,0x00006 },
      { 0x87283,0x2d205,0xf5d5a,0xfc5dd,0x9ef07,0x3822c,0xe380b,0x0ef6d,
        0x6bd55,0x1d178,0x5d167,0xf9072,0xf163c,0xdb1de,0x71f1c,0x74bf9,
        0x2fc4a,0x30084,0x749e8,0x54f75,0x727f8,0x2edbc,0xacb0e,0xbce24,
        0x7bbda,0x8dbb2,0x5bed0,0x9cec0,0xcc1b1,0xc904b,0x23ef7,0xaada1,
        0x982db,0x1bd89,0x2429f,0xe6320,0xe65f6,0xd3616,0xd3249,0xee59f,
        0x89fa8,0xf5a37,0xe9f29,0xa3baf,0x0160b,0x5378a,0xb61af,0x0f2d3,
        0x2a6f8,0x7673c,0xaeecc,0x00007 } },
    /* 248 */
    { { 0x3b0db,0x7cdc4,0x3a475,0x9cadf,0x59811,0x8a4e8,0x1563d,0x4616c,
        0x95bf6,0x97f80,0xf533e,0x07bc4,0xd3e2a,0xcfc5a,0x36739,0xa9824,
        0x8052c,0x3acd6,0x8a6ba,0xec661,0x08a1c,0x60e59,0x695bd,0x02b1b,
        0x841a5,0x5bae3,0x90a19,0xff121,0xb986d,0x31fd9,0xeacad,0x2df2b,
        0x28f7b,0x24cc7,0xd8932,0xa9927,0x80cf0,0x8ea73,0x4eac3,0x586a4,
        0x39a80,0x3ca84,0x615f0,0xf7f01,0x5ede7,0xa1f88,0x90827,0x48249,
        0xa7645,0x06b78,0x8ec40,0x00002 },
      { 0xe0009,0x2ea2f,0x1820c,0x74e9e,0x2f138,0x1ba5d,0xb52e1,0xc524d,
        0x22454,0x29975,0xfede5,0x74267,0x44d47,0x2500d,0x19a9b,0x01d34,
        0x9244b,0x92186,0xe08a4,0xe1b9c,0x3dd1b,0x16902,0x1e0ba,0x32a30,
        0xc3e54,0x88242,0x09067,0xf7ba7,0x49b56,0x4a8cc,0xa09c7,0xf0ad2,
        0xf9439,0x41d76,0x9cd18,0xb60e9,0xb621f,0xdafe0,0x634ed,0xbc397,
        0xbee54,0x84056,0xf7f0a,0xf860f,0xf4653,0x11c0a,0x76f20,0x6bd48,
        0x525c3,0xc70c9,0x34f4c,0x00001 } },
    /* 249 */
    { { 0x8dff4,0xece93,0x621a3,0x79a39,0xb486a,0x101a7,0x5377d,0xde950,
        0x4ef97,0xdbf2c,0x65d87,0x4099e,0xaf318,0x3b8cf,0xffb37,0xb89c7,
        0x2916e,0x05e84,0x8baa5,0xa7646,0x94ebe,0x90fd0,0x92ba7,0xe5928,
        0xdf6d4,0x41679,0xcfed7,0x331cf,0x12023,0x80ff2,0xfd298,0x0bf4e,
        0x44501,0xddd03,0xca78d,0x58c87,0xb3428,0xb09ec,0x87a2c,0x25754,
        0xeb6dc,0x919e5,0xbcb04,0x5a15e,0x15067,0x81d47,0x74f73,0x09d2e,
        0x3d6f4,0x2983d,0xea378,0x00006 },
      { 0xcc40a,0x4b4e5,0x65c09,0x7dfbc,0xa1af3,0x2e3f6,0xe447a,0xf9026,
        0x77e9d,0x53ef6,0x3880f,0x8c959,0x9b787,0x644aa,0xb077f,0x4aa30,
        0x08c3c,0x832f2,0x0c516,0x663ba,0xe658d,0x0277a,0x1307c,0xae1d9,
        0xb3c38,0xa4ef0,0x95c3e,0x37a76,0xd302f,0x0c5e0,0x1c56a,0xe004c,
        0xbcf9f,0xc420c,0xfd495,0x0e7c9,0xd568a,0x6d5b9,0x45470,0x59286,
        0x25dff,0x9c8b2,0xd9a70,0x44658,0x8527d,0xc08d6,0x8da87,0x47c55,
        0xef07d,0xe6bb4,0x06ee6,0x00006 } },
    /* 250 */
    { { 0x621f6,0xc757c,0x2d99f,0x3d480,0x17fe8,0x2e40c,0x9b029,0x9ef19,
        0xfc7a1,0x661bd,0x62c76,0x4102e,0x378a0,0x73875,0x370e6,0x16cda,
        0xa65af,0x4d1e3,0xc8197,0xe209b,0x8f78f,0x74204,0x1c619,0xbf598,
        0xa058a,0x2dc83,0xc8970,0x24349,0xaf26b,0x1a678,0xf1e9d,0x988b2,
        0x9ae29,0xb0ff2,0x72bf9,0xf5ec4,0x81d7c,0x43e39,0xdd8a1,0xb268d,
        0xd7e45,0x769c9,0xfc4ff,0xda555,0x3166c,0xaa767,0xdf0a4,0x6044c,
        0x48707,0xf7e91,0x9dba6,0x00004 },
      { 0x8e37a,0xb2a75,0x0e47f,0xaf662,0x72d8e,0x6b31d,0x210af,0x6f9c2,
        0xad5f9,0x2b352,0x0efc3,0xf7279,0x40093,0xe4b26,0x9dc41,0x435c9,
        0x15795,0xe005b,0xfa878,0x3575b,0x40e67,0xc520a,0x75999,0x87eea,
        0x82594,0x8bca6,0x12a34,0x7b81f,0x5029f,0xa2ce3,0xc182a,0xa547c,
        0x5e2c5,0x4bead,0x11d87,0x2cdfa,0xb5568,0xf0349,0xe669a,0x8bbe8,
        0xebfea,0xabf86,0x55394,0x8782f,0xf3dab,0xc8eb8,0x797eb,0x458bf,
        0xde78c,0xa49b7,0x890a7,0x00004 } },
    /* 251 */
    { { 0x995f6,0x898da,0x72996,0x56efd,0x7ec61,0x9eaae,0x2d5d3,0x356a8,
        0x9040c,0xfe695,0x135bc,0x6b21c,0x8b204,0x595c7,0xb640f,0xea720,
        0x5fb40,0xfae7c,0x2824e,0x3bfc0,0xc0edb,0xd8fd4,0xebe97,0x79f24,
        0x02905,0xb912f,0x87ea6,0x47cf1,0x316fc,0x9d5c2,0xd2778,0xc219f,
        0x63ecc,0x6c892,0x33a6b,0x30a62,0x28b6d,0x3634b,0x68082,0xc9b33,
        0x52e25,0x56ca3,0x0c774,0xd6ca4,0xb9388,0x92065,0xb0b3c,0xf8e55,
        0x39a76,0x4b024,0xc1747,0x00005 },
      { 0xccab5,0xc28aa,0x888e7,0xd05bd,0x6aace,0x02783,0xf6518,0xccec0,
        0xb877d,0x82185,0x25c28,0xdc1c1,0xc93ca,0xfdc54,0x40a67,0x45df5,
        0x88a33,0xe2c27,0xf3c86,0xfa2c4,0x9e3a0,0x87446,0x3cf3e,0x27398,
        0xdaa47,0xa5c59,0xa96d8,0xc48b4,0x53063,0xe5891,0xbcfc2,0xc38d2,
        0x428c3,0x8784e,0x0e78b,0xfd539,0xcf0c4,0x0a292,0x00590,0x941e6,
        0x92db7,0x1cb7f,0xca53a,0x92416,0x79567,0xab0fa,0x31db1,0x35f6f,
        0x8408c,0xb47b5,0xd675e,0x00005 } },
    /* 252 */
    { { 0xc6025,0x77870,0xeee1a,0xdfcaa,0x791a2,0x4a23b,0x4c4fc,0x386b6,
        0xe60c4,0xb17b0,0x5ae72,0xb17de,0x2d5d5,0xefa21,0x8ac9e,0x6dfc8,
        0x38b96,0xbed40,0xfeaef,0x2ecc4,0x68e2d,0x9ac35,0x20709,0x012af,
        0xea612,0x18548,0x9c312,0xd9db8,0x14ffe,0xe6733,0x1c4e0,0x1c1e9,
        0x300e0,0x4faf8,0x09bb6,0xc3be0,0xc6773,0x80501,0x9fa87,0xc0821,
        0xd6ede,0xffe0c,0x81b06,0x5e07f,0xf7c05,0x80b36,0xf9ce0,0x82b63,
        0xfeca3,0xaf0a9,0x2fccb,0x00000 },
      { 0xcac61,0xd1b47,0x991d4,0xe12c9,0x7ab86,0x9d168,0x0422e,0x2b94f,
        0x855ec,0xe58c6,0x8e648,0x05194,0x7ca40,0x89ac5,0xfb2ef,0x9ba91,
        0x792cd,0x061be,0xf4192,0x1e154,0xbbd0f,0xd221c,0x01982,0xfc444,
        0xeb13b,0xdc062,0x9790f,0x7c329,0xbf3a9,0x67a64,0xd9460,0x4e796,
        0x3775a,0x006d2,0x46dd3,0x0f23c,0x5ed7f,0x72c4d,0x3d786,0x3b4f6,
        0x851dc,0xf2821,0x26273,0xae0cd,0xf50a3,0xc60f6,0x8fcea,0x800e5,
        0x45545,0x56138,0x6f1e4,0x00005 } },
    /* 253 */
    { { 0x24f3b,0xf632c,0x1ccb3,0x17e60,0xf06d8,0xeb1c7,0x77699,0x6aa26,
        0x640bb,0xe08dc,0x845d5,0xaffe0,0x87838,0x1a79a,0xcb1f8,0xf34fe,
        0x819b0,0x2d3e6,0xa2e28,0xa4b86,0xe8237,0xb977c,0x439c4,0x87636,
        0x6b3db,0x970f4,0x79704,0xf5409,0x3a465,0x91be4,0x76287,0xd7e08,
        0x98ec6,0x6c341,0x0220b,0x94bb0,0x7093d,0xb3863,0x0b257,0x29d69,
        0x12e16,0xa4840,0x0aad1,0x9db52,0x302ec,0xdc34e,0xfc685,0xafee2,
        0x00cf8,0x36255,0x11d19,0x00009 },
      { 0x5af5b,0x58f5e,0x3b1bd,0x22a71,0xb7b6a,0xca263,0xadca7,0xf3af2,
        0xbec4d,0xbdab6,0x04420,0x1e59a,0x11665,0xa36c1,0xb3b4b,0x3b448,
        0x24310,0xcdff4,0xc62bf,0x6cbb3,0x5f1a9,0x15c4a,0x980de,0xe4d1f,
        0xad8a1,0x3abe0,0x6673a,0xd14e3,0xd812b,0x12acd,0xaf692,0x40303,
        0x095ce,0x9c576,0xf6dab,0x5ca58,0xa107f,0xf1882,0x3b07d,0x8896a,
        0x3e63c,0xf0b90,0x863b3,0x8544d,0xef504,0x9887d,0x9b9c0,0x5e501,
        0x53865,0xfea0f,0xbe744,0x00002 } },
    /* 254 */
    { { 0x0f324,0x5f5b5,0x54cd0,0xc7a20,0x41ea3,0xb1eb2,0x6b7b9,0x7ff8e,
        0x58a5c,0x824a8,0xc0408,0x02fee,0xdd839,0xcba9b,0x494d0,0x72b26,
        0xc9e1e,0x90b29,0x0176f,0xdb81d,0x2ceba,0xd4eb0,0xbfc05,0x372b8,
        0x405b1,0x90874,0x9ead1,0x28817,0xd5c41,0x2b48c,0xdd3ec,0xd44a3,
        0xd5033,0x773f4,0x4499a,0x3a098,0xd564c,0x7b38c,0x03bb3,0xf42e8,
        0x99497,0xb280e,0x8f518,0x47a0b,0x4c07b,0x68fde,0x3c535,0xc710e,
        0xd0e7a,0x2fcea,0x35f54,0x00007 },
      { 0x80039,0x71383,0xaa9a1,0x19c8c,0x7f74d,0xfafe1,0xa8bad,0xccbc1,
        0x4393e,0x0592d,0xe0297,0xbf39f,0x63c5d,0x0e9b3,0x5ab93,0x4552b,
        0xd494a,0x322af,0xee630,0xac437,0x73f02,0x6a9ad,0x29882,0x99356,
        0x53562,0x3998c,0x342bb,0x9f877,0xa0c86,0xf9b79,0x020e4,0xd7510,
        0x789a9,0xa4d34,0x361d1,0x56376,0xacfa8,0xded5b,0x7e4f0,0x88ac0,
        0xee73f,0xbd407,0x9ef1c,0xd03f0,0xdfac7,0x475ba,0x7cb4d,0x25d69,
        0xd399e,0x9d14b,0xe984c,0x00001 } },
    /* 255 */
    { { 0x0c817,0x61485,0x76d05,0x812dc,0x93489,0x8a5b1,0xbbeb0,0x5e58c,
        0x3d154,0x5a727,0xbe61e,0xb5fa4,0x18900,0xaeb8e,0x691d7,0xaa088,
        0xa3d4b,0xafd35,0x66666,0x7d3de,0x957ec,0xa2c19,0xf5c38,0x668d6,
        0x48e8f,0x46a06,0xadc17,0xc92c7,0x31f9f,0x3065c,0x6c084,0x23a11,
        0x6ae69,0x2061e,0x6370a,0x7e733,0x62aa4,0x6c373,0xd8462,0xdeff6,
        0xc25f2,0xd4540,0xdbed2,0x824cc,0x29804,0x9a949,0xce003,0x4b5bf,
        0x42e01,0x56769,0xc474a,0x00006 },
      { 0x8e3a1,0x417d8,0xaeb9a,0x742a3,0x8c484,0x5d3c8,0x13110,0x3fe61,
        0xde8d1,0x8be59,0xa869e,0x5b6b1,0xa148f,0x75d90,0xc59aa,0x7a8ab,
        0x46013,0xc7621,0xf0c9b,0x4cd92,0x7c382,0xfaa74,0xb9243,0x6a5d0,
        0x63a18,0xbc817,0xbcbae,0x41bc9,0xdbbc3,0x45d1d,0x160f7,0xe1813,
        0xce5f4,0x2db75,0x53ce5,0xe4c2a,0xcd50d,0xeae66,0x56d15,0x75d76,
        0x8996c,0x2a5ed,0x4ca55,0x5711c,0x4e4ff,0x5305b,0x85a3c,0x215e9,
        0xba2ce,0x54fa1,0xb2589,0x00006 } },
};

/* Multiply the base point of P1024 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * Stripe implementation.
 * Pre-generated: 2^0, 2^128, ...
 * Pre-generated: products of all combinations of above.
 * 8 doubles and adds (with qz=1)
 *
 * r     Resulting point.
 * k     Scalar to multiply by.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
static int sp_1024_ecc_mulmod_base_52(sp_point_1024* r, const sp_digit* k,
        int map, void* heap)
{
    return sp_1024_ecc_mulmod_stripe_52(r, &p1024_base, p1024_table,
                                      k, map, heap);
}

#endif

/* Multiply the base point of P1024 by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * km    Scalar to multiply by.
 * r     Resulting point.
 * map   Indicates whether to convert result to affine.
 * heap  Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_mulmod_base_1024(const mp_int* km, ecc_point* r, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_1024 p;
    sp_digit kd[52];
#endif
    sp_point_1024* point;
    sp_digit* k = NULL;
    int err = MP_OKAY;

    err = sp_1024_point_new_52(heap, p, point);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * 52, heap, DYNAMIC_TYPE_ECC);
        if (k == NULL) {
            err = MEMORY_E;
        }
    }
#else
    k = kd;
#endif
    if (err == MP_OKAY) {
        sp_1024_from_mp(k, 52, km);

            err = sp_1024_ecc_mulmod_base_52(point, k, map, heap);
    }
    if (err == MP_OKAY) {
        err = sp_1024_point_to_ecc_point_52(point, r);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_1024_point_free_52(point, 0, heap);

    return err;
}

/* Multiply the base point of P1024 by the scalar, add point a and return
 * the result. If map is true then convert result to affine coordinates.
 *
 * km      Scalar to multiply by.
 * am      Point to add to scalar mulitply result.
 * inMont  Point to add is in montogmery form.
 * r       Resulting point.
 * map     Indicates whether to convert result to affine.
 * heap    Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_mulmod_base_add_1024(const mp_int* km, const ecc_point* am,
        int inMont, ecc_point* r, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_1024 p;
    sp_point_1024 a;
    sp_digit kd[52];
    sp_digit t[52 * 2 * 5];
#endif
    sp_point_1024* point;
    sp_point_1024* addP = NULL;
    sp_digit* tmp = NULL;
    sp_digit* k = NULL;
    int err = MP_OKAY;

    err = sp_1024_point_new_52(heap, p, point);
    if (err == MP_OKAY) {
        err = sp_1024_point_new_52(heap, a, addP);
    }
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * (52 + 52 * 2 * 5), heap, DYNAMIC_TYPE_ECC);
        if (k == NULL) {
            err = MEMORY_E;
        }
        else {
            tmp = k + 52;
        }
    }
#else
    k = kd;
    tmp = t;
#endif
    if (err == MP_OKAY) {
        sp_1024_from_mp(k, 52, km);
        sp_1024_point_from_ecc_point_52(addP, am);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_1024_mod_mul_norm_52(addP->x, addP->x, p1024_mod);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_1024_mod_mul_norm_52(addP->y, addP->y, p1024_mod);
    }
    if ((err == MP_OKAY) && (!inMont)) {
        err = sp_1024_mod_mul_norm_52(addP->z, addP->z, p1024_mod);
    }
    if (err == MP_OKAY) {
            err = sp_1024_ecc_mulmod_base_52(point, k, 0, heap);
    }
    if (err == MP_OKAY) {
            sp_1024_proj_point_add_52(point, point, addP, tmp);

        if (map) {
            sp_1024_map_52(point, point, tmp);
        }

        err = sp_1024_point_to_ecc_point_52(point, r);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_1024_point_free_52(addP, 0, heap);
    sp_1024_point_free_52(point, 0, heap);

    return err;
}

#ifndef WOLFSSL_SP_SMALL
/* Generate a pre-computation table for the point.
 *
 * gm     Point to generate table for.
 * table  Buffer to hold pre-computed points table.
 * len    Length of table.
 * heap   Heap to use for allocation.
 * returns BAD_FUNC_ARG when gm or len is NULL, LENGTH_ONLY_E when table is
 * NULL and length is returned, BUFFER_E if length is too small and 0 otherwise.
 */
int sp_ecc_gen_table_1024(const ecc_point* gm, byte* table, word32* len,
    void* heap)
{
    int err = 0;
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_1024 p;
#endif
    sp_point_1024* point = NULL;
    sp_digit t[5 * 2 * 52];

    if ((gm == NULL) || (len == NULL)) {
        err = BAD_FUNC_ARG;
    }

    if ((err == 0) && (table == NULL)) {
        *len = sizeof(sp_table_entry_1024) * 256;
        err = LENGTH_ONLY_E;
    }
    if ((err == 0) && (*len < (int)(sizeof(sp_table_entry_1024) * 256))) {
        err = BUFFER_E;
    }

    if (err == 0) {
        err = sp_1024_point_new_52(heap, p, point);
    }
    if (err == 0) {
        sp_1024_point_from_ecc_point_52(point, gm);
            err = sp_1024_gen_stripe_table_52(point,
                (sp_table_entry_1024*)table, t, heap);
    }
    if (err == 0) {
        *len = sizeof(sp_table_entry_1024) * 256;
    }

    sp_1024_point_free_52(point, 0, heap);

    return err;
}
#else
/* Generate a pre-computation table for the point.
 *
 * gm     Point to generate table for.
 * table  Buffer to hold pre-computed points table.
 * len    Length of table.
 * heap   Heap to use for allocation.
 * returns BAD_FUNC_ARG when gm or len is NULL, LENGTH_ONLY_E when table is
 * NULL and length is returned, BUFFER_E if length is too small and 0 otherwise.
 */
int sp_ecc_gen_table_1024(const ecc_point* gm, byte* table, word32* len,
    void* heap)
{
    int err = 0;

    if ((gm == NULL) || (len == NULL)) {
        err = BAD_FUNC_ARG;
    }

    if ((err == 0) && (table == NULL)) {
        *len = 0;
        err = LENGTH_ONLY_E;
    }
    if ((err == 0) && (*len != 0)) {
        err = BUFFER_E;
    }
    if (err == 0) {
        *len = 0;
    }

    (void)heap;

    return err;
}
#endif
/* Multiply the point by the scalar and return the result.
 * If map is true then convert result to affine coordinates.
 *
 * km     Scalar to multiply by.
 * gm     Point to multiply.
 * table  Pre-computed points.
 * r      Resulting point.
 * map    Indicates whether to convert result to affine.
 * heap   Heap to use for allocation.
 * returns MEMORY_E when memory allocation fails and MP_OKAY on success.
 */
int sp_ecc_mulmod_table_1024(const mp_int* km, const ecc_point* gm, byte* table,
        ecc_point* r, int map, void* heap)
{
#if (!defined(WOLFSSL_SP_SMALL) && !defined(WOLFSSL_SMALL_STACK)) || defined(WOLFSSL_SP_NO_MALLOC)
    sp_point_1024 p;
    sp_digit kd[52];
#endif
    sp_point_1024* point;
    sp_digit* k = NULL;
    int err = MP_OKAY;

    err = sp_1024_point_new_52(heap, p, point);
#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (err == MP_OKAY) {
        k = (sp_digit*)XMALLOC(sizeof(sp_digit) * 52, heap, DYNAMIC_TYPE_ECC);
        if (k == NULL)
            err = MEMORY_E;
    }
#else
    k = kd;
#endif
    if (err == MP_OKAY) {
        sp_1024_from_mp(k, 52, km);
        sp_1024_point_from_ecc_point_52(point, gm);

#ifndef WOLFSSL_SP_SMALL
            err = sp_1024_ecc_mulmod_stripe_52(point, point,
                (sp_table_entry_1024*)table, k, map, heap);
#else
        err = sp_1024_ecc_mulmod_52(point, point, k, map, heap);
        (void)table;
#endif
    }
    if (err == MP_OKAY) {
        err = sp_1024_point_to_ecc_point_52(point, r);
    }

#if (defined(WOLFSSL_SP_SMALL) || defined(WOLFSSL_SMALL_STACK)) && !defined(WOLFSSL_SP_NO_MALLOC)
    if (k != NULL) {
        XFREE(k, heap, DYNAMIC_TYPE_ECC);
    }
#endif
    sp_1024_point_free_52(point, 0, heap);

    return err;
}

/* Multiply p* in projective co-ordinates by q*.
 *
 * r.x = p.x - (p.y * q.y)
 * r.y = (p.x * q.y) + p.y
 *
 * px  [in,out]  A single precision integer - X ordinate of number to multiply.
 * py  [in,out]  A single precision integer - Y ordinate of number to multiply.
 * q   [in]      A single precision integer - multiplier.
 * t   [in]      Two single precision integers - temps.
 */
static void sp_1024_proj_mul_qx1_52(sp_digit* px, sp_digit* py,
        const sp_digit* q, sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2 * 52;

    /* t1 = p.x * q.y */
    sp_1024_mont_mul_52(t1, px, q, p1024_mod, p1024_mp_mod);
    /* t2 = p.y * q.y */
    sp_1024_mont_mul_52(t2, py, q, p1024_mod, p1024_mp_mod);
    /* r.x = p.x - (p.y * q.y) */
    sp_1024_mont_sub_52(px, px, t2, p1024_mod);
    /* r.y = (p.x * q.y) + p.y */
    sp_1024_mont_add_52(py, t1, py, p1024_mod);
}

/* Square p* in projective co-ordinates.
 *
 *   px' = (p.x + p.y) * (p.x - p.y) = p.x^2 - p.y^2
 *   py' = 2 * p.x * p.y
 *
 * px  [in,out]  A single precision integer - X ordinate of number to square.
 * py  [in,out]  A single precision integer - Y ordinate of number to square.
 * t   [in]      Two single precision integers - temps.
 */
static void sp_1024_proj_sqr_52(sp_digit* px, sp_digit* py, sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2 * 52;

    /* t1 = p.x + p.y */
    sp_1024_mont_add_52(t1, px, py, p1024_mod);
    /* t2 = p.x - p.y */
    sp_1024_mont_sub_52(t2, px, py, p1024_mod);
    /* r.y = p.x * p.y */
    sp_1024_mont_mul_52(py, px, py, p1024_mod, p1024_mp_mod);
    /* r.x = (p.x + p.y) * (p.x - p.y) */
    sp_1024_mont_mul_52(px, t1, t2, p1024_mod, p1024_mp_mod);
    /* r.y = (p.x * p.y) * 2 */
    sp_1024_mont_dbl_52(py, py, p1024_mod);
}

#ifdef WOLFSSL_SP_SMALL
/* Perform the modular exponentiation in Fp* for SAKKE.
 *
 * Simple square and multiply when expontent bit is one algorithm.
 * Square and multiply performed in Fp*.
 *
 * base  [in]   Base. MP integer.
 * exp   [in]   Exponent. MP integer.
 * res   [out]  Result. MP integer.
 * returns 0 on success and MEMORY_E if memory allocation fails.
 */
int sp_ModExp_Fp_star_1024(const mp_int* base, mp_int* exp, mp_int* res)
{
    sp_digit t[4 * 2 * 52];
    sp_digit tx[2 * 52];
    sp_digit ty[2 * 52];
    sp_digit b[2 * 52];
    sp_digit e[2 * 52];
    sp_digit* r = ty;
    int err = MP_OKAY;
    int bits;
    int i;

    if (err == MP_OKAY) {
        bits = mp_count_bits(exp);
        sp_1024_from_mp(b, 52, base);
        sp_1024_from_mp(e, 52, exp);

        XMEMCPY(tx, p1024_norm_mod, sizeof(sp_digit) * 52);
        sp_1024_mul_52(b, b, p1024_norm_mod);
        err = sp_1024_mod_52(b, b, p1024_mod);
    }
    if (err == MP_OKAY) {
        XMEMCPY(ty, b, sizeof(sp_digit) * 52);

        for (i = bits - 2; i >= 0; i--) {
            sp_1024_proj_sqr_52(tx, ty, t);
            if ((e[i / 20] >> (i % 20)) & 1) {
                sp_1024_proj_mul_qx1_52(tx, ty, b, t);
            }
        }
    }

    if (err == MP_OKAY) {
        sp_1024_mont_inv_52(tx, tx, t);

        XMEMSET(tx + 52, 0, sizeof(sp_digit) * 52);
        sp_1024_mont_reduce_52(tx, p1024_mod, p1024_mp_mod);
        XMEMSET(ty + 52, 0, sizeof(sp_digit) * 52);
        sp_1024_mont_reduce_52(ty, p1024_mod, p1024_mp_mod);

        sp_1024_mul_52(r, tx, ty);
        err = sp_1024_mod_52(r, r, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_to_mp(r, res);
    }

    return err;
}

#else
/* Pre-computed table for exponentiating g.
 * Striping: 8 points at a distance of (128 combined for
 * a total of 256 points.
 */
static const sp_digit sp_1024_g_table[256][52] = {
    { 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000,
      0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000,
      0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000,
      0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000,
      0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000,
      0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000,
      0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000,
      0x00000, 0x00000, 0x00000 },
    { 0xc1685, 0xd2335, 0x70a46, 0x7a581, 0x1e100, 0xc9e97, 0xa73ea,
      0x43ca4, 0x8f3df, 0x7540e, 0x26424, 0xf8158, 0x12646, 0x6576d,
      0xbb4b3, 0x3af49, 0xf1afb, 0x1472b, 0x89e2d, 0x51e6d, 0xc2fd1,
      0xbe882, 0x17c27, 0x8f887, 0xedc85, 0x6fadd, 0x6ac6c, 0x59bf1,
      0x8d6d8, 0x8eae5, 0xa1b2d, 0x0e741, 0x1f30d, 0x0061c, 0xfaf7a,
      0xe0966, 0xa9b67, 0xdbd09, 0xf7d66, 0x7d3b4, 0x11c06, 0x8e21f,
      0x727c9, 0xba02c, 0x16152, 0x6cb22, 0x891e8, 0xafd58, 0x3baf4,
      0x6a6bd, 0x9e93c, 0x00005 },
    { 0xd4594, 0x6f71d, 0x54dd3, 0xf1e6e, 0xf00ae, 0xc9cc9, 0x530bb,
      0xa19f6, 0x5a44e, 0x289ea, 0xf5209, 0xaa993, 0x88588, 0x5c141,
      0x94c8f, 0x97537, 0x399fa, 0x92c11, 0x18bd7, 0x6ab51, 0xdf5cb,
      0xbd3af, 0x652b9, 0x2ecb9, 0xd1cb2, 0x13813, 0x03898, 0x62674,
      0xcfd45, 0xc8431, 0x19b4a, 0x51f71, 0x80eb6, 0x910a1, 0xd9f6a,
      0xfa2ed, 0x79f7b, 0x946d1, 0x0d913, 0x50a9d, 0x18631, 0xd316f,
      0xf8373, 0xc20d6, 0x95f19, 0x6a52b, 0xc6a9b, 0xbe85a, 0x62e03,
      0x7b74f, 0x3ef18, 0x00006 },
    { 0xf45e7, 0x7f016, 0xc376b, 0x82f87, 0x72bec, 0x1bdb5, 0xb601c,
      0xce429, 0x2f741, 0x1d739, 0x7afd8, 0xf0a2c, 0xb6fdb, 0x41098,
      0xb1f72, 0xbda41, 0x0f8cf, 0x74bb6, 0xb4074, 0xbc4d5, 0x1b330,
      0x3e0d4, 0x3be93, 0x733fa, 0x82830, 0xd1ae1, 0xf5c6c, 0x299b0,
      0x8a0ed, 0x9860c, 0x54e3f, 0x7ff33, 0x59c41, 0x86155, 0x13609,
      0x85cbb, 0xc129f, 0x0cb63, 0xfbeab, 0x47685, 0xecc49, 0x33682,
      0xb1996, 0x8ec2e, 0xa505e, 0xac2cd, 0x794dd, 0x90dcc, 0x2da23,
      0x1cf19, 0xfe679, 0x00004 },
    { 0x8733c, 0xd505e, 0x4a423, 0x17c19, 0x51d57, 0x845e6, 0x322cc,
      0xe961b, 0xc7e88, 0xcc237, 0xb4181, 0x71c6d, 0x10c44, 0x3bd72,
      0x5e271, 0x00c87, 0x17b09, 0xedb2c, 0xdfde9, 0xeaf69, 0x5e88c,
      0x0a6de, 0xea643, 0x7b81c, 0x7a61a, 0xd5aaa, 0x33f98, 0xd0262,
      0xaea52, 0x689a9, 0xdd060, 0xb55ef, 0xc4aab, 0xce5ca, 0x0cfa7,
      0x07613, 0x48e95, 0x4db11, 0xe52fa, 0x4e9a1, 0x570c4, 0x70309,
      0xa0401, 0x1f611, 0x218c2, 0x78d9d, 0xffebe, 0x555d1, 0xdb297,
      0x18561, 0x4482a, 0x00000 },
    { 0x486d8, 0xc273d, 0x7758a, 0xc1e7e, 0x661cd, 0x69f94, 0xb4f81,
      0x2188a, 0xc99fc, 0x30723, 0x33736, 0x4f02f, 0x0a0e5, 0x8c226,
      0xe25bd, 0x560be, 0x1bc60, 0x7c453, 0x8fc30, 0xfeb52, 0xa7e44,
      0xf21f1, 0xd37d6, 0x57128, 0x4499c, 0x45c8e, 0x7b2ea, 0x053ed,
      0x2963b, 0xa3d22, 0xa0432, 0x40c27, 0x59668, 0x4d354, 0xb5185,
      0x57e95, 0xfd735, 0xe1a49, 0x77a66, 0x86920, 0x67fd9, 0x020d2,
      0x73427, 0x50d3e, 0x4fa13, 0xccdb4, 0xf2568, 0x1a9c3, 0xbf89f,
      0xf8ded, 0x33a0f, 0x00008 },
    { 0x76b76, 0xc7ab3, 0x8c419, 0xf0cca, 0x327d0, 0x7294f, 0x14d3b,
      0xa90c5, 0xbb9e2, 0xa6e56, 0x62575, 0xa51ea, 0x8931b, 0x8c0a8,
      0x07b09, 0x56fee, 0x16a2a, 0xeeb4c, 0x4be5a, 0x260b0, 0xbe6eb,
      0x13350, 0x270e5, 0xa1d5c, 0xedad6, 0xd1339, 0x9dbad, 0xed59e,
      0x0f366, 0xd06ec, 0xe882d, 0x4213b, 0x187db, 0xc8cb1, 0x2d639,
      0x058a2, 0x1d8a1, 0xec95e, 0x4f11f, 0xa2b74, 0x73ea6, 0x0c03f,
      0x4f05c, 0xd51af, 0x0741f, 0xf811a, 0x95a85, 0x2e2df, 0x4965f,
      0xe3eb2, 0x92b3c, 0x00006 },
    { 0x127b4, 0x72d2a, 0xce6cb, 0x816f0, 0x58f92, 0xa46ea, 0x61666,
      0x47a37, 0xcf463, 0xee43e, 0x0ab96, 0x9a01e, 0xc163d, 0xedbe8,
      0xc6db2, 0xc8145, 0x4e665, 0xae4de, 0xf426c, 0x52f92, 0x074e2,
      0x4d0b4, 0x83117, 0x7d2af, 0x240d7, 0x3654c, 0xd6529, 0xa3973,
      0x5581f, 0x9d469, 0x91ca0, 0x05b94, 0x2643c, 0x33545, 0xc4e85,
      0x83278, 0x1d412, 0xd6433, 0xf2532, 0x70361, 0x79038, 0xf2644,
      0x9ef09, 0x91b18, 0x07741, 0xde5fe, 0xaaf81, 0xc0cf0, 0x042d6,
      0x0af40, 0x33e43, 0x00003 },
    { 0x6d3b7, 0xe4cf2, 0xdf04d, 0x79be5, 0x6b53f, 0xa7730, 0x66457,
      0x1808b, 0x13c5f, 0x60a40, 0x50373, 0x1ea48, 0x7ef29, 0x06103,
      0xd7d0b, 0x1ffc9, 0x913bb, 0xd965c, 0x9d04d, 0x8587d, 0xff13b,
      0x8a37a, 0x75594, 0xfe3ee, 0x43483, 0x86b54, 0x46313, 0x1e740,
      0xc3fc2, 0xdeb58, 0x4e5cd, 0xb3a10, 0x2cd52, 0x62657, 0x4fe18,
      0xa4089, 0x115aa, 0x9a71a, 0x462eb, 0x459ea, 0xc6fe5, 0xa38ad,
      0xaeb02, 0xd1754, 0x1bb18, 0x7791d, 0x6362f, 0xae127, 0xbd708,
      0x1dd6b, 0x0e8b3, 0x00001 },
    { 0x9f1af, 0xe53ed, 0x87f03, 0x6166b, 0x75667, 0xad247, 0x5b803,
      0x74ce1, 0xcd630, 0x5b38d, 0x6b1e8, 0xe2b02, 0x51877, 0xf99c1,
      0xd171a, 0xb1654, 0x2547a, 0xe4938, 0x782e9, 0x5ef59, 0xc26d5,
      0xc7fc7, 0x54c6d, 0x2fbeb, 0x8f95d, 0x57903, 0x36c03, 0x0dfe0,
      0xffe59, 0xdc3f7, 0xeae4f, 0xcfcb6, 0xe1a88, 0x54f35, 0xb1fbc,
      0x5568c, 0x2da0a, 0x8e1db, 0x5573c, 0x5b6f5, 0x7393f, 0x069a8,
      0x7ac0a, 0x6b32e, 0xb3864, 0x8495a, 0xc832a, 0xfd261, 0xcc4bc,
      0x4c0cd, 0x48552, 0x00006 },
    { 0x6ff2a, 0xe2c4a, 0xabfb3, 0x428a1, 0xa35a6, 0xa03fb, 0x7422a,
      0x89aff, 0x227f0, 0x93884, 0xa5dbd, 0x883ab, 0xb2337, 0xa182c,
      0xae9d2, 0x38186, 0x01f05, 0x4d49a, 0x9f076, 0x1e7ab, 0xb917b,
      0x411fe, 0xb5b92, 0x570cb, 0xb1903, 0x7c700, 0x914be, 0x81d5b,
      0xd5d51, 0x81182, 0x43719, 0x135c4, 0xb9997, 0x24574, 0x2758d,
      0x28b23, 0x5632d, 0x50a8f, 0xf09a6, 0xfa383, 0x78bac, 0x80240,
      0x0a33d, 0xa60c0, 0x96546, 0xf8b44, 0xc7a2d, 0xa4061, 0x4563c,
      0xf2f23, 0xf76f3, 0x00001 },
    { 0x436b0, 0x4344c, 0xaa2c1, 0xc87a9, 0x61f69, 0x07055, 0x2df79,
      0x5f6db, 0x3117b, 0x8235f, 0xd56ba, 0x1f41e, 0x88576, 0x0afa4,
      0x64f7d, 0xf8314, 0xce71e, 0x153ad, 0x99f29, 0x7488a, 0x3116b,
      0x7bf69, 0x43ab2, 0x9bb94, 0xa5a8c, 0xe8a98, 0xee5fd, 0x80262,
      0x77f87, 0x12acb, 0x3dd18, 0x3a6f9, 0x4bc92, 0xccdc8, 0xf92a4,
      0x995aa, 0xff1d4, 0x2562a, 0x99d3c, 0x04ed8, 0xfc33c, 0x38fd9,
      0xed2a5, 0xca944, 0x6c028, 0x9ea72, 0x7bb04, 0xd0f36, 0x08e05,
      0xfb3d1, 0x4924f, 0x00000 },
    { 0x3562f, 0x3dc67, 0x6548e, 0xe48c0, 0x5e2ea, 0xb3302, 0x977d3,
      0x5e1c6, 0xfd32b, 0x7be61, 0xebe55, 0x20646, 0xe424e, 0xd6e18,
      0x1c041, 0x76739, 0x7e95b, 0x8e14d, 0xb8ebb, 0x1b8c4, 0x42099,
      0xe8b7d, 0x0d34a, 0xe0129, 0x0df66, 0x4ef8a, 0x25e5f, 0x24a39,
      0xac97e, 0x08272, 0x2cb15, 0x79a7b, 0x72661, 0x2e250, 0x40b07,
      0xfa49b, 0x29062, 0xd9e18, 0xbceda, 0xf3c53, 0x0a784, 0x99878,
      0xf1427, 0x2b769, 0x658a8, 0x46842, 0x49cc1, 0x08cd8, 0x0ae35,
      0x09c38, 0xdfce8, 0x00004 },
    { 0x7b780, 0xb2d52, 0x5069c, 0x30dd4, 0x59779, 0x2da01, 0x263d5,
      0xe27d0, 0xc600b, 0x2b10c, 0xb2d1b, 0x2c26b, 0xc3410, 0x4adf3,
      0x62355, 0x4c652, 0x0ff47, 0x8245f, 0x68913, 0x6e7cd, 0x5ca91,
      0xfa8cc, 0xd8a83, 0xd15c8, 0x0f139, 0xb31e1, 0x1dc56, 0xdc2e8,
      0xaf173, 0x4ed9b, 0xb045c, 0x7fcec, 0x01228, 0xd847d, 0x07fd7,
      0x532f3, 0x39f3a, 0xa5715, 0xc2224, 0xe2153, 0x9e81d, 0x0859e,
      0x428a4, 0x595de, 0x3c562, 0x39bd2, 0xff893, 0xdc7da, 0x06802,
      0x08b8a, 0xd0759, 0x00000 },
    { 0x85f2a, 0xa7de0, 0x70af2, 0xb2e58, 0xfbe99, 0xfcd24, 0x13b88,
      0x59ca4, 0x0d261, 0x5188c, 0x559f8, 0xa2e48, 0xd1f02, 0x22da0,
      0x021f6, 0x83b96, 0xa3615, 0xf56dc, 0xc05c2, 0xc6825, 0xc7910,
      0x48cf1, 0x5be01, 0x27269, 0xf2896, 0xf6392, 0x8d64e, 0x0bb5a,
      0x2883d, 0xfcbc5, 0x2441c, 0xef0d2, 0x117e5, 0xec526, 0x5dafc,
      0x28e9f, 0x9f049, 0x8612b, 0xe2ab6, 0x393f2, 0xf744d, 0x51283,
      0x00c11, 0xd7ed7, 0xefbee, 0x360df, 0x215a4, 0xf2cde, 0x8535a,
      0x1c2f0, 0x4fa96, 0x00002 },
    { 0xdf7f6, 0x3f616, 0x767db, 0x03260, 0x8fbd9, 0x3057d, 0x54464,
      0x6e82d, 0xdaa90, 0xdb174, 0x89643, 0xf3456, 0x02284, 0x89a06,
      0x1dfcc, 0x18b19, 0x27d12, 0xf4d6c, 0xab46a, 0x5145b, 0x6c989,
      0x57f48, 0xf9e5a, 0xcc942, 0x214e9, 0x58c03, 0x19501, 0x1c8f4,
      0xb273e, 0xad43a, 0x59f39, 0x8ceb7, 0xee173, 0x7fe50, 0xe1b8b,
      0x7d4e5, 0xc8f4d, 0x35b1f, 0x3f3f6, 0x75560, 0xf77e3, 0x608ef,
      0x752fa, 0x61d17, 0x1201f, 0x6fb6e, 0x03d4a, 0x94d7a, 0xf0114,
      0x3dfc4, 0x71cc2, 0x00003 },
    { 0x0c351, 0x5dda9, 0x89b11, 0x9c062, 0xf364d, 0x196eb, 0x31b6d,
      0xf650b, 0x89202, 0x2f77a, 0xf5764, 0xc1646, 0x7cc28, 0x10012,
      0xe3608, 0xdc4f7, 0xc807b, 0x08dc4, 0x836cd, 0x40f28, 0x6e002,
      0x80f15, 0x95312, 0x99cb3, 0xa6d78, 0x383f9, 0xa8020, 0x94d33,
      0x440a4, 0x7d347, 0xe91e8, 0x45697, 0xde24a, 0x0726d, 0x0d97d,
      0xc30e7, 0xd7640, 0xf6a58, 0x6c606, 0x5ba6e, 0x2c0e8, 0xe803c,
      0x1bc13, 0x6a7af, 0xf330f, 0xf4d78, 0xe4fc9, 0x3e602, 0x0fb7f,
      0xa00c8, 0x2b6bc, 0x00009 },
    { 0x0822e, 0x835f0, 0xe3d5c, 0x6f122, 0x2b8b1, 0x82571, 0x3300e,
      0x92b0a, 0x329c4, 0x5481c, 0x7cc19, 0x32ada, 0xf6b4e, 0xb1413,
      0xcee1b, 0x0bee9, 0x2ca27, 0xaa4a9, 0xdfb7b, 0x9153e, 0xaea3b,
      0x472af, 0x0f9cd, 0x00f0c, 0x09e7e, 0x70e8f, 0xcdebb, 0xd8725,
      0x6a4e1, 0x9b63b, 0xe084a, 0xfe2ba, 0x58f65, 0xb83fd, 0x40141,
      0x2759f, 0xaa3b6, 0xec5ed, 0x088d7, 0x790e3, 0xf6e67, 0x319aa,
      0xf277e, 0xd8301, 0xc215a, 0x33871, 0xb98cf, 0xe7db4, 0x2f89d,
      0xc94f0, 0x1ff62, 0x00007 },
    { 0xa84d9, 0x022a4, 0xa4c71, 0x71e6a, 0xd5ebc, 0xee4ac, 0x578e2,
      0xf1cd6, 0x1a8a5, 0xa53b1, 0xff120, 0xef9ff, 0x383f5, 0xe6503,
      0x8e109, 0xa4c59, 0x44180, 0x90ca0, 0x1e9f9, 0x28c1e, 0x6f598,
      0x832d4, 0x36b8b, 0x33af5, 0xf28a0, 0x8a753, 0x6d4f6, 0xc4b1b,
      0x092ed, 0xccd1f, 0x92a72, 0xedde6, 0x26432, 0x7dd22, 0x3aa0f,
      0x661cd, 0xea3d2, 0xdbb63, 0xdda38, 0xfdc37, 0x19fc6, 0x4cf1e,
      0x4ef6b, 0xb3508, 0x96c18, 0x1bba6, 0xfe9df, 0xe6a83, 0x58273,
      0xe75f9, 0x0fd47, 0x00004 },
    { 0x140a4, 0x46267, 0xb88b7, 0xf2fb5, 0xeeab6, 0xbbfc1, 0x5486d,
      0x69862, 0xec88e, 0xc2dd9, 0xeb6ef, 0xeba12, 0x869be, 0xc8ff8,
      0x14a8a, 0xcfc22, 0x21950, 0x6eb5a, 0x5d5c9, 0xfb699, 0x54171,
      0x389c0, 0x33793, 0x1b468, 0x5d452, 0x5c2d8, 0x11342, 0x8a084,
      0x414d6, 0x6c217, 0x139ec, 0xe52c0, 0x0084d, 0x97f73, 0x0cf0b,
      0x8aa32, 0x61f57, 0xc16a2, 0xe431a, 0xf9b6a, 0x9fab3, 0x9518b,
      0x854a6, 0x2111d, 0x668d8, 0xfbe28, 0xd98df, 0x0b334, 0x9338c,
      0x57e63, 0xb1c11, 0x00005 },
    { 0x6bb8f, 0xb172b, 0x0edaa, 0x92c29, 0x202fc, 0xc64ed, 0xc738d,
      0xfe694, 0xba3c5, 0xe4f42, 0xb54dc, 0xc65fc, 0xc316d, 0x2420d,
      0x6a363, 0xcb2d6, 0xdcf94, 0xe7056, 0x6e706, 0x2c9d1, 0x4a4f3,
      0x09c76, 0xca828, 0xea6ed, 0x8d830, 0x57ab1, 0x1c65f, 0xace68,
      0x04fd1, 0xa12c1, 0x51c7d, 0x1f916, 0x91a48, 0x66c77, 0xac3bd,
      0x67a30, 0x4785e, 0xad1cf, 0x591b6, 0xda0fd, 0x3fc44, 0x44e4d,
      0xe1c63, 0x48016, 0x3ce16, 0xe50ab, 0xcb833, 0x84de9, 0x6eef4,
      0x3aa75, 0x63ab8, 0x00009 },
    { 0xea5a3, 0xd8df4, 0x44b47, 0x45fe9, 0x55cfe, 0x56881, 0x56496,
      0x8a3c3, 0xe7d58, 0x15d16, 0x7c99e, 0x5b3ee, 0xc84e5, 0x5071b,
      0x04df5, 0x3fee2, 0x57dce, 0x29040, 0x1006f, 0x55707, 0xdbba7,
      0x8c390, 0xdacfe, 0x3319a, 0x5bcb6, 0xd8364, 0xc20bf, 0xe8b07,
      0x88189, 0x7d957, 0x9697d, 0x8e550, 0xf4e3b, 0x21b99, 0x37d13,
      0xfb6a0, 0x1a60c, 0x1b252, 0x2da01, 0x83738, 0x94aaa, 0x07665,
      0x3c1dc, 0x91fd8, 0x4c89b, 0x6b988, 0x89907, 0x6b82b, 0x5c558,
      0xfcbe4, 0x43480, 0x00004 },
    { 0x4221a, 0xb4911, 0x8ffff, 0x7a7af, 0xe3e85, 0xec4f2, 0x7874a,
      0x0fa54, 0x2d0e4, 0x5242e, 0x6f961, 0x6b31d, 0x7ef3e, 0xfe9b7,
      0x537fb, 0xb2296, 0x3a86a, 0xf2fb4, 0x2a9d0, 0x2ac6c, 0xd2457,
      0x1284e, 0xa7b24, 0xe721b, 0x68917, 0x8da38, 0x117a7, 0x7c00c,
      0xcdbef, 0x1605a, 0x071d3, 0x38149, 0xa8ee9, 0x9e065, 0x2dada,
      0xbe82c, 0x8c442, 0xb138d, 0xb58d5, 0xf6d72, 0xc224b, 0x6d9b6,
      0xeb03e, 0x55cf8, 0x1b9d3, 0x70037, 0xeb0a1, 0xab6d1, 0xaa7eb,
      0x88cff, 0x7118a, 0x00009 },
    { 0xcb5d8, 0xa2cde, 0xf9c59, 0x6866b, 0xba93a, 0x83c81, 0xfbf80,
      0x04774, 0x0dd81, 0xb424e, 0x02070, 0xa3caa, 0x1e779, 0xbfb78,
      0xfbb0f, 0x9d352, 0x2a1c4, 0x203ef, 0x8b0d8, 0xe501a, 0xb14b3,
      0x58637, 0xff2b8, 0x8a882, 0x70a49, 0xa55ba, 0xb06ef, 0x00833,
      0xaa273, 0x2fee2, 0x2f410, 0xa42c0, 0x223a5, 0x998a0, 0x4e762,
      0xfc72e, 0x685c3, 0xa2ba2, 0xae7db, 0xfe52e, 0xfe763, 0xf6554,
      0x70f45, 0x405a2, 0xc30b5, 0x73387, 0x77aa5, 0xd56a1, 0x1fa82,
      0x8d4b7, 0x7c077, 0x00001 },
    { 0x5e37b, 0x1d273, 0xe6dff, 0xc5720, 0x6656e, 0x884e5, 0x978c9,
      0x9ebba, 0x5ac9d, 0xc4a2f, 0xa09f3, 0x4518b, 0x740fa, 0xb0437,
      0x177f5, 0x8c3fa, 0xa2eca, 0xcd967, 0x1a1de, 0xbd40a, 0x00528,
      0x8bca7, 0xc4a76, 0x18691, 0x4952b, 0xd5f22, 0x86d5f, 0x2c45e,
      0xa16e1, 0x859a6, 0x15737, 0x7a0d9, 0xfce0e, 0x09a0f, 0x23f43,
      0xc9a37, 0xba96c, 0x8db79, 0xa385a, 0x1ad23, 0x12ae0, 0x846dd,
      0x2bf5d, 0xc3a1e, 0x69ffe, 0x52ed6, 0x4e1a4, 0xd6ce8, 0xfe4c6,
      0xc8571, 0x219d5, 0x00001 },
    { 0x969eb, 0x7f262, 0x3eaa6, 0xe7734, 0xd2f03, 0x3ab39, 0x9093a,
      0x57bb0, 0x27e51, 0x74e61, 0xd1502, 0xb0ed8, 0xd0f82, 0x80bdb,
      0xad8e5, 0xffffc, 0x43e6b, 0x75a97, 0x1d3d0, 0x11d65, 0x18bac,
      0x84bdb, 0x38814, 0xeb24c, 0xd9990, 0xc695c, 0xfac67, 0x61d07,
      0x7216a, 0x4e6b8, 0x762a0, 0x4308f, 0x57cc8, 0x61cba, 0x865dd,
      0xa07a2, 0xdd234, 0x296b0, 0x3f93c, 0x3a079, 0x92839, 0xce76f,
      0xbe29e, 0x7e1f0, 0x270b5, 0x626f4, 0x82f7e, 0x1314a, 0x7f230,
      0xb2d65, 0xc8d7a, 0x00002 },
    { 0x5e4d6, 0x92082, 0x7cf58, 0x3b446, 0x56ef8, 0x51eaa, 0x08ddf,
      0x13101, 0x665d8, 0x3f63e, 0xdd096, 0x89f58, 0xa229f, 0xf6436,
      0x4dd9d, 0x8c4b1, 0xebba7, 0x69d45, 0x9dae4, 0xf3819, 0x75a4d,
      0x8aab7, 0xfeb11, 0x29e37, 0x978bd, 0xefda8, 0xca2d7, 0xd5aaa,
      0xa69ce, 0x7d6a8, 0x05dc6, 0x6c98d, 0x84a34, 0x0d77f, 0x474bf,
      0xd59a7, 0xeed8c, 0x428b2, 0x8fbd4, 0xd1d39, 0xd1cd5, 0x11b0f,
      0x4a20b, 0x13db9, 0x45960, 0x404c4, 0x05a1b, 0x96eb7, 0x9d958,
      0x774b0, 0x299d2, 0x00002 },
    { 0x397e6, 0x8dc64, 0xb9cd5, 0xd31e5, 0xebf6d, 0x198f1, 0xdb2ac,
      0x3e9f1, 0x6d8e1, 0x8c586, 0xfcdc6, 0xe2878, 0xd405a, 0x3c01f,
      0x0cde5, 0xa4b28, 0xdb5f6, 0x2d411, 0xc963f, 0xf8a0d, 0x9bec4,
      0x5d518, 0x98bed, 0x916ee, 0xfd13d, 0x8e336, 0x42df4, 0xb1b30,
      0xe6925, 0xe0074, 0x291ac, 0x0cf56, 0x17e95, 0x48253, 0x8d38b,
      0x446be, 0xb821c, 0xad1d2, 0x934c7, 0xf0b65, 0x44135, 0x5071c,
      0x2ca0d, 0x736f5, 0x6971b, 0xb46c2, 0xa5727, 0xaf9ff, 0x6618e,
      0x79193, 0x1ac67, 0x00002 },
    { 0xfbcd2, 0x3f2d7, 0xb420e, 0xfc18a, 0x397bd, 0x72247, 0x4b412,
      0x4df5d, 0x033f8, 0xd3492, 0x807b7, 0x42363, 0x56fcd, 0x3c362,
      0xb09b3, 0xdfc19, 0x22814, 0x75a0f, 0x3d6f3, 0x19b81, 0x9037c,
      0x978a5, 0xb9c70, 0x0ff27, 0x98997, 0x894f3, 0x15a43, 0x1a456,
      0x4fc0e, 0x602f7, 0x96a3e, 0xffa34, 0x1ca1c, 0x31b26, 0x3f1c4,
      0x64cdc, 0xbee01, 0x2211d, 0xe9f61, 0xe7f7b, 0x63ee4, 0xbb304,
      0x2c2e1, 0x7e789, 0x6015f, 0x483a5, 0x8d624, 0x663d8, 0x2d9d8,
      0xe70e6, 0xe8ec1, 0x00000 },
    { 0x878dd, 0x298a0, 0x88ccc, 0x071aa, 0xd6640, 0xac175, 0x61799,
      0xa5173, 0x44820, 0x15903, 0xd58a3, 0x023ed, 0x1316d, 0xd221a,
      0xbd488, 0x30785, 0xc48e3, 0xe7959, 0x74b3d, 0xa771b, 0x24c67,
      0xee038, 0x45342, 0xe0b91, 0xf6cdd, 0x9159e, 0xb237e, 0xae289,
      0x57830, 0x5d832, 0xa4c49, 0xe1847, 0x73666, 0x7ed07, 0x7b121,
      0xa3256, 0x6a294, 0x192c8, 0x32658, 0x864d8, 0xa0f56, 0x5b76a,
      0x4b13e, 0xbd12f, 0xde2a2, 0x6b73f, 0x1c01b, 0xd850c, 0x03635,
      0x5f5d1, 0x53a79, 0x00006 },
    { 0xcb199, 0x8550d, 0xfe289, 0x2b60c, 0xe7fa0, 0x5b8e5, 0x3d0b3,
      0xc9760, 0x7d7c3, 0xb5bca, 0x7f131, 0x288d2, 0x2b0e5, 0xb12d5,
      0x4dee2, 0x3aa70, 0x725c7, 0xd81db, 0x206b1, 0xb113e, 0xac5d1,
      0x12839, 0x7630b, 0xdb45d, 0x970cb, 0x8e14f, 0x2125e, 0xf93eb,
      0x6c997, 0x7daa2, 0x39cee, 0xbd757, 0xf20e9, 0x3f1fe, 0x6ecbd,
      0x42b14, 0x47c6a, 0x94a11, 0xfd1f9, 0x27fb0, 0x9eb4f, 0x4bd28,
      0xa40da, 0x6d319, 0x61118, 0x9d797, 0x5a5fb, 0x083f6, 0x4675e,
      0x7bd44, 0x0dfc4, 0x00003 },
    { 0xadfe8, 0xe29ea, 0xcfc5a, 0xe812b, 0x4b4d4, 0x027e5, 0x56125,
      0x8b533, 0x702df, 0x14ab0, 0x6a6a2, 0xc2045, 0xea2b9, 0x59068,
      0xf7a30, 0xb1a3d, 0x3110f, 0x21988, 0x3514b, 0x8e1ca, 0x6c4b7,
      0xbe233, 0x984b7, 0x3e2f6, 0x73ce6, 0xc6170, 0xddf7a, 0x14a62,
      0x886e1, 0xd7c3c, 0x2bf07, 0x27619, 0xae289, 0x0beb1, 0xda69e,
      0x49395, 0x52518, 0x3af17, 0xaa098, 0x407a3, 0x52a4d, 0x189ac,
      0xe0fe2, 0xc7daa, 0x11535, 0x7f250, 0x87239, 0xe16fe, 0x212cf,
      0x1f54c, 0x72a59, 0x00005 },
    { 0x5553a, 0x1909a, 0x96684, 0x33bc4, 0x83277, 0x05431, 0x6903f,
      0x3eefd, 0xeb4b2, 0xd4f9c, 0x22126, 0xbf9bf, 0x8bd3c, 0xed957,
      0x1c02f, 0x6d967, 0x306d8, 0xceca0, 0xba597, 0x4fe5b, 0x13d67,
      0x05ed6, 0xf76b7, 0x67f33, 0x3622b, 0x31f1d, 0x1cb8c, 0xf3c61,
      0x915bc, 0x3d1aa, 0x7dce5, 0xa3846, 0x8ab43, 0x29f90, 0x02fe9,
      0x767a9, 0xd8d15, 0x3e499, 0x07b6e, 0x90afd, 0x2db5c, 0x0e814,
      0xc8b19, 0x6fbc6, 0xe120c, 0x919a4, 0x55324, 0x80c86, 0x82c3c,
      0xe1d8c, 0x5c2cb, 0x00006 },
    { 0x0bb63, 0x20a66, 0x84cda, 0x62456, 0xa86e8, 0xdc3b0, 0xed727,
      0x6ba0e, 0x72cf6, 0x58764, 0x79dd1, 0x62e56, 0x479c1, 0x452d4,
      0x27708, 0xb6884, 0xf579e, 0xb3413, 0x29bc6, 0x17708, 0xc9501,
      0xea15e, 0x18392, 0x47738, 0x4e300, 0xf15e3, 0x3e1d2, 0xa3497,
      0xe8c3c, 0x9bd3d, 0x1dc22, 0xa5c4f, 0xf7ed3, 0x1b94e, 0x83eff,
      0x7a1a7, 0xddfae, 0xdb738, 0x85246, 0x1a099, 0x3d72e, 0xab435,
      0x0dcf4, 0xad58a, 0x92533, 0x7888b, 0x0160e, 0xd8055, 0x77f66,
      0xd53ba, 0x31440, 0x00008 },
    { 0x1b2da, 0x32f61, 0x43e2e, 0x46acf, 0x9d0fa, 0x066e2, 0xc0d5d,
      0x820b3, 0x7f3e8, 0xf0e89, 0xd3e44, 0x28e61, 0x6c45c, 0xd27a6,
      0xf66df, 0x929d7, 0xe8517, 0x0a101, 0x35b86, 0x78dd7, 0x83de0,
      0x3fce9, 0x11aea, 0x638ce, 0x77db5, 0x3bc99, 0x8536b, 0x382f4,
      0x60488, 0xcadfc, 0xa3c64, 0x7e0c7, 0x47b71, 0x7f821, 0xcd17f,
      0x1e3e3, 0xc1b41, 0x5663c, 0x46de9, 0x985fb, 0x9ac8f, 0xca573,
      0xcf119, 0x99cdb, 0x53853, 0x5a281, 0xa70e1, 0x4a985, 0xf4566,
      0x8a6d5, 0x04c3a, 0x00005 },
    { 0xa53c7, 0x83b8f, 0x0b552, 0x74e30, 0x85094, 0x5cff3, 0x25f98,
      0x437ce, 0xd241c, 0xed234, 0x5a129, 0x2430e, 0x42983, 0xbcc67,
      0x956aa, 0x6ad38, 0x81ee1, 0x1d7ee, 0x2dc00, 0x2702a, 0x6670b,
      0x23c6b, 0x3bb4c, 0xa6e8a, 0xe567e, 0xeab35, 0x69673, 0xb3cea,
      0xcbc70, 0xe28ea, 0x9c3e6, 0x85a7a, 0x7b7da, 0xde553, 0xae684,
      0x37dc2, 0x56de9, 0xcac3e, 0x4225e, 0xf8430, 0xea6c9, 0x20bf2,
      0x7fdc5, 0xf7d07, 0xd38ca, 0xf56ad, 0x0b169, 0xc27af, 0xd21d2,
      0x99c71, 0x96e46, 0x00004 },
    { 0x93467, 0x829fa, 0xa14fc, 0xa614b, 0x40eb2, 0xe3768, 0x09bc2,
      0x4833e, 0xbcfaf, 0xcc659, 0x686bd, 0x97523, 0xabc85, 0xf3216,
      0x08081, 0x40bfd, 0x081b8, 0xa617c, 0x463bd, 0x793bc, 0x6bb04,
      0x01fa8, 0x0c5bd, 0x2cd64, 0x1ece6, 0xc45a2, 0x203d5, 0x6a542,
      0x797bf, 0x1167b, 0xedc95, 0xceb40, 0xba268, 0xaf765, 0x67aac,
      0x51f9d, 0x9aeab, 0xa0d9e, 0x63a8b, 0xb0d68, 0xb215e, 0x52c14,
      0x5f069, 0xdcdbe, 0x5354c, 0x3744b, 0xccfcb, 0x4f2b5, 0x37fe8,
      0x73130, 0x33891, 0x00001 },
    { 0x03cd1, 0x40450, 0xe6806, 0x2ac6e, 0xc44ae, 0xac17b, 0x314fd,
      0xde8e5, 0xd419f, 0x5c4bc, 0x7cea9, 0x4eb9c, 0x181e3, 0xf37e0,
      0x62d38, 0xbb577, 0x990c8, 0xb0260, 0xcc4cf, 0x4a7be, 0x950a3,
      0xc493f, 0x4ef0b, 0x54330, 0x74172, 0x2a680, 0xbc8aa, 0xfcb26,
      0x5aec0, 0x45fea, 0xb463b, 0x9e7a9, 0xbdbac, 0x2e55f, 0xbb295,
      0xdff44, 0x60485, 0xf0c0a, 0x79650, 0x4dea4, 0x5104d, 0x0202c,
      0x95e3a, 0xfa096, 0x5d2ce, 0xa1f34, 0x2b46d, 0x4c810, 0x33fbd,
      0x73f38, 0x22eb5, 0x00004 },
    { 0xd3f47, 0xb6a6a, 0xc592e, 0xba0ea, 0xd9714, 0x861f6, 0x459b0,
      0x07281, 0x1e919, 0x0357c, 0x4ea58, 0x94e26, 0x3cf7c, 0xb1272,
      0x6ac54, 0x72537, 0xb736a, 0x41daf, 0x2a6ba, 0x3cdcf, 0x0cba0,
      0x9e892, 0x3adc8, 0x5b0fd, 0x20cb4, 0xfef2e, 0x66059, 0x5a54d,
      0xc26ea, 0x9df8b, 0xa8b88, 0xee63f, 0x3f2bf, 0xe166a, 0x0f1c7,
      0x12e14, 0xc7473, 0xfebc9, 0x9ff09, 0x72799, 0x9b9c2, 0x057d1,
      0x7fd2b, 0xbb4cb, 0x6a9fb, 0xda2dc, 0x7d7a0, 0xcfba2, 0x52582,
      0xcf2c2, 0x68541, 0x00003 },
    { 0x99d37, 0x9e227, 0x10d3c, 0x333a5, 0x5acfa, 0x677de, 0x95b1b,
      0x080f7, 0xae18f, 0xc24e6, 0xfc8df, 0x3c2aa, 0x269b5, 0x842dc,
      0x1b60e, 0x79754, 0x67fe8, 0xafac0, 0x5a6f2, 0xd877d, 0x3bd07,
      0x208a0, 0x2f2d0, 0x654be, 0x473f0, 0x3e34b, 0x515e2, 0x102af,
      0x8e67c, 0xc1af4, 0xf9d2a, 0xb00db, 0x13d00, 0x41b6a, 0x264fa,
      0x4c11e, 0xa97e9, 0x69786, 0x6f416, 0x86a58, 0x8cf2d, 0xe909d,
      0x7f927, 0xf869c, 0x6073b, 0x41a56, 0x88022, 0xb8977, 0x61334,
      0x59222, 0x9a5bf, 0x00005 },
    { 0x47191, 0x1e813, 0x9d1c9, 0x9972e, 0xceb96, 0x6c1ab, 0xa7f18,
      0xa9d46, 0x88767, 0x97078, 0xaa7d3, 0xcfccd, 0x0da93, 0x1b9aa,
      0x9f1d9, 0x08bee, 0xd3c6c, 0x78f8d, 0x267fd, 0x81008, 0x09422,
      0x3860d, 0x7fbf9, 0xdadb4, 0xa71aa, 0x8a6a6, 0x6156f, 0x06b7a,
      0x99caa, 0x848bc, 0x5e039, 0xaa1b0, 0xa9135, 0x372aa, 0x6ddc2,
      0x3bd13, 0x9b13f, 0xe7e07, 0xf4d77, 0x4acc5, 0xb5cbe, 0x368d0,
      0x84cfd, 0x45f89, 0x804da, 0xd3e0f, 0x618d3, 0xf14ef, 0xb799c,
      0xc143e, 0x67564, 0x00004 },
    { 0xff5d7, 0x04b6f, 0xd7259, 0x47528, 0xf92dc, 0x7f33a, 0x8aa03,
      0x6d20b, 0x5d575, 0x39909, 0x3baec, 0x5fc14, 0x03223, 0xa2b9b,
      0x4af68, 0xa2feb, 0x35c61, 0x1894d, 0x1c503, 0x74866, 0x2ea87,
      0x92b6a, 0x6f3ac, 0x011bc, 0x48b15, 0xb28eb, 0x79edc, 0xe128c,
      0x6a28f, 0xd2a00, 0xc0ca5, 0x9f71b, 0x5b850, 0x322f1, 0x31677,
      0x6218f, 0xc7a03, 0x8d728, 0x09efe, 0x4f81e, 0xf39cb, 0xd9068,
      0xb7c50, 0xf0167, 0x31773, 0x6a1e0, 0xadbed, 0x0d0f7, 0x984d5,
      0x164ee, 0xa0dee, 0x00008 },
    { 0x66e6f, 0xbf473, 0x04991, 0x30055, 0xfe86c, 0x084d9, 0xe36b8,
      0xa40cc, 0x4c751, 0xe214c, 0xf1961, 0x6aa63, 0x3bbb4, 0x445e4,
      0x5f940, 0x56a78, 0xe215f, 0x57c91, 0xb8d1b, 0x808dd, 0xec7ee,
      0x8e453, 0xe8c6a, 0xbbaa1, 0x67ef8, 0x09c03, 0x3e181, 0x91f1e,
      0x3310d, 0x20a2c, 0xd0e7e, 0xf97cf, 0xcc277, 0x84554, 0x1e80c,
      0x8403f, 0xd7b62, 0x9bbc1, 0x17ce8, 0x3fe0a, 0x8a966, 0x73777,
      0x1f000, 0xb19fc, 0x29e9d, 0xf6bed, 0xe7db6, 0x2ce7f, 0x7ce23,
      0xd2ee9, 0xb04b5, 0x00007 },
    { 0x5faf8, 0xc782c, 0xb546b, 0x10975, 0xe8eb8, 0x734c5, 0x1e01a,
      0xe7785, 0x66861, 0x1f3d5, 0x956d5, 0x1013e, 0xc833a, 0xc3c37,
      0x731c3, 0xc7351, 0x148ec, 0xfbe0c, 0x07738, 0xef416, 0xbe1bb,
      0xc6f0b, 0x8572e, 0xcfa51, 0x2ac6e, 0xf00aa, 0x6e3ad, 0x02d76,
      0x30729, 0x22d6e, 0x089c6, 0xcd4d5, 0xd802f, 0x23a6d, 0xae21b,
      0x63723, 0x53388, 0x465a5, 0x822e5, 0xa8d81, 0x119a0, 0x7ad85,
      0x78697, 0xd0323, 0xc4f14, 0x7b272, 0x81c9c, 0x515b0, 0xbe31c,
      0xa4c99, 0xc6a95, 0x00001 },
    { 0x21363, 0xd5c28, 0x6b14a, 0xde1ca, 0x34d17, 0x9c182, 0x84882,
      0xccade, 0x5d2c4, 0x27aef, 0x2489e, 0xab398, 0x7f412, 0x81d92,
      0x098f0, 0x92c9c, 0xbad1f, 0xf475c, 0xf87bd, 0x9fb16, 0x81a1d,
      0xaadab, 0xb76f4, 0xb75f3, 0xa7923, 0xfe475, 0xbbba8, 0x0ad6d,
      0x599dd, 0x70ab4, 0x1644b, 0x836f6, 0xd9af1, 0x8134b, 0xa4648,
      0xbda32, 0xeba9a, 0x91226, 0x5fb5c, 0xe6562, 0xc8709, 0xbe4ce,
      0x818e4, 0x919e0, 0xcd4b3, 0xf6879, 0xc8414, 0xa5c09, 0x864c9,
      0x0230a, 0x2708a, 0x00007 },
    { 0xa466c, 0xb1f34, 0xf33c0, 0x45ba4, 0xc7f9d, 0xbae09, 0x85ca1,
      0x0e287, 0xf0fee, 0x81d70, 0x08808, 0x71469, 0x3824c, 0x043da,
      0xc2abb, 0xe2416, 0x6f432, 0x13cec, 0x33da7, 0x3e1c7, 0x9c979,
      0x59064, 0x3652b, 0xb35c9, 0x2d5b0, 0x2adb6, 0xe5c1b, 0xb6e23,
      0x5355e, 0x16b51, 0x5cebb, 0xcfe8b, 0x9691c, 0x69f70, 0xe0818,
      0x5bd59, 0xb61a8, 0x65f9f, 0x3f7c8, 0xfae10, 0x9d3cc, 0x9df16,
      0x3467e, 0xc4737, 0x39525, 0x69511, 0xc0b43, 0x7db55, 0x65d21,
      0x4c732, 0x491c7, 0x00007 },
    { 0x2b94d, 0xbf80d, 0x12ed5, 0x260b3, 0x3ba4b, 0x8ac63, 0x9a11b,
      0xd6221, 0x6c58c, 0x8eac8, 0xeb82c, 0xcf6ba, 0xd317c, 0xef9ce,
      0x9ee59, 0x2dfb2, 0xbcd5a, 0x98e42, 0xaa7d8, 0xb201d, 0x85974,
      0xe295c, 0xadc93, 0xd9fc5, 0x75784, 0xba69e, 0x12aa3, 0x709f0,
      0x9d6c4, 0x5d3cb, 0xf37c8, 0x1fda9, 0xd4abd, 0x25d3d, 0x5487e,
      0xa22ee, 0x10b3b, 0xfd4b0, 0xcbb00, 0xc6e8d, 0x91493, 0x64cb5,
      0xce686, 0x9fabb, 0x6b732, 0x906b7, 0x1c268, 0x6829d, 0x76841,
      0xe5741, 0xbcfd3, 0x00008 },
    { 0x8c314, 0x34d3c, 0x68827, 0x08330, 0x11187, 0xf0b2f, 0xa1695,
      0xc068b, 0x7f7c3, 0x87b93, 0x79247, 0xe0d87, 0x75365, 0x99222,
      0xe5e1f, 0x15527, 0xffd4f, 0x4827d, 0xa0696, 0x63890, 0x22f58,
      0x8b3df, 0xeadd5, 0x6af20, 0x46b89, 0x57834, 0x07462, 0x970b5,
      0x109d7, 0x22a69, 0x20640, 0xd9e8d, 0xec379, 0xaf671, 0x1e5f8,
      0xe91ed, 0x9057f, 0x54250, 0x4186f, 0x52890, 0xdda81, 0xadf14,
      0xdb932, 0x010e1, 0x8bd78, 0x5a937, 0x1e490, 0x3e18d, 0x7ab49,
      0xf7bd3, 0x3cadc, 0x00005 },
    { 0x3d0ff, 0xf75e5, 0xbb5ed, 0xbf671, 0xc888a, 0x86606, 0xd15d8,
      0x12206, 0x1b0f8, 0x33649, 0x22b6a, 0x8345e, 0x7b301, 0x73b31,
      0x94bb1, 0xaba67, 0x9e595, 0x677dc, 0xc1e58, 0x24d18, 0x22396,
      0x10648, 0xd534e, 0xda55d, 0x52e59, 0x9c617, 0xe4287, 0x4eab9,
      0xd018b, 0x1f2be, 0x84b49, 0xcaf67, 0x9429e, 0xd21e7, 0xdcdb9,
      0x62243, 0x510f2, 0x94148, 0xc5c36, 0xa650e, 0xf190a, 0x60106,
      0x69a97, 0xa5aeb, 0x67542, 0x2d104, 0x5e9c3, 0x69bd7, 0xc62b1,
      0x64bf8, 0x08499, 0x00009 },
    { 0x3c661, 0xf65a9, 0x1390c, 0xf056b, 0x49db5, 0x48626, 0x78818,
      0xa51a1, 0x93a9d, 0x9a92a, 0x772de, 0xbb8f6, 0xc1b0c, 0x71487,
      0xebd7c, 0x6e67f, 0x2423e, 0x2d4e6, 0x9b438, 0x42f8f, 0xebb5a,
      0xfda50, 0x4f296, 0x6089a, 0x1b337, 0x16c92, 0x75ec5, 0x2d7b8,
      0xb49d3, 0x10124, 0x2cac4, 0xbd86d, 0x1fb7a, 0x09c42, 0x68622,
      0xde33f, 0xbf6b7, 0x1949a, 0x2683e, 0xe93c9, 0xe18f0, 0xc0cde,
      0x8dc4c, 0xbd5e0, 0x2d4ed, 0x580d2, 0xbe473, 0xc2b75, 0xcd7e8,
      0xfa468, 0xd7f6f, 0x00003 },
    { 0xbd5d1, 0x0cdff, 0xa7b29, 0x38dfe, 0x69703, 0x759da, 0xdc99d,
      0x90fee, 0x80b08, 0x8e566, 0x2dce6, 0x0af54, 0x2bc69, 0xae4d8,
      0xf2bb2, 0x8519d, 0x95b60, 0x7f7f1, 0x61246, 0x21f45, 0xcd83c,
      0x9a342, 0x63365, 0x55651, 0x71bf5, 0x62557, 0x48ba5, 0x89355,
      0xa5fc6, 0x92f23, 0x20394, 0xb5419, 0xc6017, 0xe39c9, 0x67528,
      0x60195, 0x4511e, 0x064ed, 0x5553f, 0x1d16a, 0xf9eb9, 0xee303,
      0x254ab, 0xc4fd2, 0xc3e18, 0x434e7, 0xd6ffd, 0x40994, 0xe74e6,
      0x3f6dd, 0xfb12d, 0x00008 },
    { 0xcb7a4, 0xa2293, 0xc6381, 0x7e4d6, 0x0b87b, 0x3e09f, 0x3ef45,
      0x078ac, 0x12823, 0x914f2, 0x78cae, 0xfad05, 0xde89f, 0x6ba4d,
      0x96a71, 0x4a2b6, 0x580a0, 0x14f6f, 0x4681a, 0x13071, 0xb4c2f,
      0x58f97, 0xb8913, 0x2932f, 0x96996, 0xf7878, 0x68a5a, 0x850a2,
      0x329dd, 0x239f8, 0xf6dfe, 0xaf771, 0x7499d, 0x2e4f4, 0xf20fd,
      0xa0e95, 0x7867c, 0x643e7, 0x1ec9b, 0x37598, 0x58ecd, 0x97e78,
      0x9ab1c, 0x6a591, 0x3be94, 0xff345, 0x3a206, 0x4f930, 0x237b1,
      0x3175d, 0xfcc67, 0x00003 },
    { 0x1f920, 0xd5df2, 0x09deb, 0x1b905, 0xfc140, 0xf70e1, 0xaaffa,
      0x95a64, 0x9cbfd, 0x22242, 0xc37a1, 0x08552, 0xbf212, 0xeb926,
      0x3f47d, 0x1d4c9, 0x3f1dc, 0xc09fb, 0x2f3e4, 0xbc461, 0x95b51,
      0x085a5, 0xbd256, 0xf10fd, 0xf5d62, 0xc22a2, 0xf0cb3, 0x62cfd,
      0xb60dd, 0x0f254, 0x4a36b, 0x15442, 0x612b7, 0x5d564, 0x3a5a0,
      0x249cc, 0xfa1f5, 0xbe30c, 0x188be, 0x7e62a, 0xc6903, 0x3924e,
      0xf4299, 0xfbaca, 0x575f0, 0xfa868, 0x5dcb3, 0xd4134, 0x51c34,
      0xfdc71, 0x45146, 0x00006 },
    { 0x924f9, 0x3aba1, 0xcec63, 0x26e1e, 0x60063, 0xa6f13, 0xc17bb,
      0x7e50f, 0x757ac, 0x00203, 0xf3d8e, 0x1919e, 0x4ca53, 0xdc5a7,
      0x6aa51, 0x9545a, 0x412b8, 0x8fd31, 0xe21d5, 0xd0006, 0x57bb1,
      0xbc300, 0x9c301, 0x6ed1a, 0x89c69, 0x48f17, 0x858fa, 0xd35f9,
      0x57af2, 0x97be8, 0x9b981, 0x434d0, 0xa265d, 0x5529a, 0xdc077,
      0xfa801, 0x7c058, 0xd03be, 0x4ceca, 0x54ba1, 0x70a9f, 0x7492d,
      0xc050a, 0x85056, 0xa6dc7, 0x005dd, 0x4a94d, 0x2a7ca, 0xb9f2e,
      0x72abf, 0x48d3d, 0x00004 },
    { 0x33989, 0x4529b, 0xc56f1, 0x815ad, 0xca9ae, 0x8351b, 0x41486,
      0x4b074, 0x45613, 0x3bb3f, 0xcd9f3, 0xe42a3, 0x3955c, 0xf6e4a,
      0x4ec5f, 0x13ade, 0xeaa91, 0x15a50, 0x3aac7, 0xefdfd, 0x95666,
      0x61ec9, 0x70a0c, 0xf6a44, 0xa28b8, 0xc9108, 0x54844, 0xf584e,
      0x7402e, 0xe2f33, 0x162d0, 0xb825b, 0xf7cbc, 0x1fb46, 0xdcd13,
      0xfd893, 0xc96f2, 0x8178e, 0xc7820, 0x25928, 0xc5d67, 0x594d8,
      0x963c4, 0x33df9, 0xf285a, 0x2a309, 0x175d9, 0x72497, 0x019a5,
      0x79cb7, 0x68814, 0x00007 },
    { 0x67eed, 0x14917, 0xa43a1, 0x65dbb, 0xd92bf, 0x11b9a, 0x21a5e,
      0x03a5e, 0x22ce0, 0x15e8a, 0xa3354, 0x44212, 0x26360, 0x9ead6,
      0x3b44a, 0xc2c56, 0x2aee5, 0x64a0b, 0xbc062, 0xe1d74, 0x58bf2,
      0xb8d57, 0x65d75, 0xd08a2, 0xf0ee7, 0xa71cf, 0x0b712, 0x4e1db,
      0xd1791, 0x18692, 0x5d04b, 0xc3592, 0xce815, 0x4c56c, 0xe253f,
      0x0e3ad, 0xc9fff, 0x79241, 0xd19a4, 0xddabe, 0x9d06e, 0x0650b,
      0x9fae5, 0x52605, 0x06713, 0x2ce18, 0x0fb53, 0xf3760, 0xa8626,
      0x1c5e5, 0x70eb0, 0x00006 },
    { 0xdbb43, 0xaf73c, 0xf73c0, 0x31add, 0x57f24, 0x08ecc, 0x845cf,
      0x2a1a3, 0x80541, 0xf1917, 0x224dd, 0x04f29, 0xf69a1, 0xac7ef,
      0x38dbe, 0x4352f, 0xd1322, 0x4e7c2, 0xc3b3b, 0xb476f, 0x0b5e4,
      0x9e943, 0x6f0a6, 0x975a4, 0x32340, 0xce7d9, 0xd64ee, 0x899e5,
      0x98093, 0x2345e, 0x250db, 0x7b821, 0xb796b, 0x327f4, 0x35529,
      0x0b1f2, 0x54bb9, 0xe9cc1, 0x7d62e, 0x9112f, 0x9c8f5, 0x321fa,
      0xcbaae, 0x2f981, 0xa2d0f, 0x75166, 0x36600, 0xb77f0, 0xdff27,
      0xe7635, 0x04852, 0x00005 },
    { 0x392fa, 0xe5a2f, 0xf0f3c, 0x90782, 0xaec6c, 0x6c076, 0xaf632,
      0x84baa, 0x1de92, 0x93ad0, 0xbe8e9, 0x16d3c, 0x8b01b, 0x95090,
      0xc242d, 0x71305, 0x3af38, 0x17385, 0x66fd6, 0x29a0c, 0xed3c4,
      0x35140, 0x02777, 0x1fabf, 0x1b12a, 0x778a3, 0x58b31, 0x00020,
      0x9a053, 0xc7deb, 0x9fca9, 0xabffd, 0x67d30, 0x9be86, 0x05ef6,
      0xe13fd, 0x8e9a9, 0x3a730, 0xe9c2f, 0xb91ea, 0xc9a19, 0xc43f4,
      0x18ce6, 0xcee76, 0x050d0, 0x40f8b, 0xc4052, 0xfb24d, 0x90cc4,
      0x51f7e, 0x92fe1, 0x00009 },
    { 0x197aa, 0x3138f, 0x454db, 0x2f984, 0xd8787, 0xded69, 0x828a4,
      0x44f0a, 0x427b0, 0xc697b, 0x31e48, 0xe1aea, 0xc9821, 0x98efe,
      0x09fdd, 0xe38cb, 0xcb3ae, 0xa8480, 0x0b84f, 0x55732, 0x84747,
      0x5bb4a, 0x96bba, 0xcd50e, 0xe080a, 0x50a9b, 0xf1035, 0x1e9ce,
      0xcc445, 0x41325, 0x75fc4, 0x626ee, 0x5e33d, 0x9838a, 0xeea5e,
      0xabd26, 0x9a2b0, 0x21beb, 0x2a973, 0x9b608, 0x2e484, 0x2aca9,
      0x92bcc, 0x168a9, 0xb1dc8, 0x8eb9f, 0xf4b9c, 0x134ec, 0xb71e0,
      0xa84c5, 0xa68bf, 0x00005 },
    { 0xa2bfb, 0x45ff0, 0x4ff3b, 0xf8b0b, 0x95502, 0x05fff, 0xc26d1,
      0x5b1c0, 0xe5885, 0x0414d, 0xd3b9d, 0x865b0, 0x7ed16, 0x6d391,
      0x45302, 0x2f5a2, 0xb3c0e, 0x93f4d, 0xa22f4, 0x8f2e6, 0xae241,
      0x71548, 0xf6148, 0x509be, 0x363a8, 0xec6ab, 0x8cbbb, 0x1e3ab,
      0x691ca, 0x11a39, 0xc9840, 0x71e0d, 0xca577, 0x0a0d5, 0xf982e,
      0x7bc1f, 0x58189, 0x40b04, 0x5e7eb, 0x085ad, 0x24a46, 0x7c4bc,
      0x6337b, 0x8fa0a, 0xfd15c, 0xf1628, 0xef7be, 0x56ce6, 0xef439,
      0xf99f5, 0x8acfd, 0x00007 },
    { 0x20189, 0x15f85, 0x5bf7f, 0x61c44, 0x0c77f, 0x4202a, 0xe1b95,
      0xdfa22, 0xdc6b9, 0x8739e, 0xf4a34, 0x02671, 0x2d2d6, 0x14cc5,
      0x92948, 0xcd933, 0x9f123, 0x2405e, 0xe76a1, 0xb6f7d, 0x0ae36,
      0x306ea, 0x8e0e2, 0xb83a5, 0x15218, 0x1a538, 0x04123, 0xbb76a,
      0x19862, 0x31be7, 0x53cbf, 0xe8da2, 0xe861f, 0x3237d, 0xdfc53,
      0x48902, 0x690ae, 0x5c93f, 0xed2f2, 0x8baa6, 0xcb8f0, 0x2966b,
      0x08b4a, 0xae0f9, 0x96f10, 0x61c94, 0x48cb0, 0x8cb4b, 0x5a366,
      0x73d07, 0xad92d, 0x00000 },
    { 0xa548a, 0xedc2c, 0xfb95f, 0x89abb, 0x080cd, 0x78c62, 0x28047,
      0x3466c, 0x9154b, 0x02be9, 0x4be89, 0xe093d, 0xdea3b, 0xe681e,
      0x99513, 0x847b7, 0x40161, 0x4b02f, 0x22a8f, 0x7fe8f, 0xd4aeb,
      0xf2cb4, 0x5f63e, 0xb3aed, 0xc5151, 0x639ad, 0x8c311, 0xcfd19,
      0xfec1c, 0xd7d88, 0x17ba3, 0xdc2ac, 0x21097, 0xd3464, 0x8fa64,
      0x0bcf0, 0x794b9, 0xbf80b, 0x9eb5e, 0x0b50a, 0x8b4ba, 0x6b1b7,
      0x79aa6, 0xe9342, 0xd1a4f, 0x5b3ce, 0xcaf07, 0x8ef4d, 0x6e9ae,
      0xa070a, 0x5bbd8, 0x00009 },
    { 0x4bbd0, 0x95e61, 0x9f924, 0xe3635, 0x7b823, 0x67a88, 0x6a775,
      0xfc1bd, 0x7c9ec, 0x42e24, 0xe835c, 0xaf478, 0xa2bfa, 0xde066,
      0x4e0aa, 0x314ef, 0x6d336, 0x635c1, 0x72baa, 0xe3890, 0x1e2f0,
      0x429c7, 0x90ffa, 0xbd07d, 0x1e5d0, 0x04cac, 0x14f5c, 0x35ea5,
      0x169ff, 0x554ec, 0x3fcc0, 0x89305, 0x5947f, 0xb72a3, 0xb1d86,
      0xe487a, 0x02aeb, 0x9fb06, 0xf21e2, 0xdfb9c, 0x10d6d, 0xf5a0a,
      0x20dfc, 0x7059f, 0xaad14, 0x867a2, 0x66fb8, 0x480dc, 0x5a919,
      0x4fc12, 0x75a88, 0x00003 },
    { 0x7f7ea, 0x2e121, 0x78cbe, 0x6dab1, 0xa875c, 0x161e2, 0xa541a,
      0x1bdb1, 0x07ec0, 0xcaf77, 0x4fd73, 0x64a0e, 0x66788, 0x3a0d8,
      0x664d1, 0xbaebc, 0x30668, 0x99c8d, 0x0325f, 0x59504, 0x92f1c,
      0x3ed9c, 0x667b9, 0x541e0, 0x36763, 0x63fdf, 0x91a67, 0xfbb0b,
      0x0fd97, 0x79c9a, 0x9ea60, 0x26aa6, 0xa8c47, 0x801ea, 0x7303c,
      0x3c55c, 0x1afa6, 0xc75c8, 0xadbde, 0x4fd12, 0xdcde2, 0x8a01c,
      0x96883, 0xdda71, 0x99fe0, 0x41537, 0x93b38, 0x66bb0, 0xb84ec,
      0x8b08c, 0x68d81, 0x00002 },
    { 0x80555, 0x58415, 0x3dae3, 0x103b7, 0x7473d, 0xc32e6, 0x1ab4f,
      0xbeccc, 0xc1013, 0xde240, 0x24ee9, 0x99f2b, 0x6da40, 0xa8e06,
      0xb5b9f, 0x37b0c, 0x8d7ee, 0xe4643, 0x5ae04, 0x0140b, 0x42b72,
      0x7d316, 0xa787f, 0x339e4, 0xf4edb, 0x7586e, 0xa7d83, 0x7eed3,
      0xea5e7, 0x707c2, 0xd37bd, 0x883fa, 0x79189, 0x3a0f9, 0x16b63,
      0x208e8, 0xa2e7a, 0x4c028, 0x16ae2, 0x44355, 0x1fe3c, 0xf5117,
      0xf5f2b, 0x3b334, 0x63eb9, 0xb53a5, 0xd4b01, 0x8419e, 0xca44b,
      0x5c056, 0xb0273, 0x00008 },
    { 0x19195, 0x64e10, 0x89bb4, 0x28c1b, 0x6f3fc, 0xe4c02, 0xb211d,
      0x2bfc3, 0x20e6e, 0x2fac1, 0x1bdf9, 0xbc5a9, 0x9ec71, 0x995bc,
      0xab40d, 0x485d7, 0x91ffe, 0x8ee64, 0x7c676, 0xe2659, 0x9afbc,
      0x552d1, 0x6c2d9, 0x8e1b7, 0x6c7fe, 0x1bbae, 0x7e3ad, 0x8281d,
      0x4167d, 0x98973, 0xaf95e, 0x3e149, 0xc8182, 0x4c8a0, 0x1f002,
      0x6c0dd, 0xbc300, 0x71ffd, 0xd4cf5, 0x58773, 0xecf7e, 0xd8b32,
      0xd3540, 0xa782f, 0x25822, 0x36504, 0xc3f04, 0x5ab45, 0xd85fe,
      0xa04b4, 0x00e3a, 0x00004 },
    { 0x6e4a2, 0x495e4, 0x73216, 0x60744, 0x42413, 0xa2ed6, 0x77d37,
      0xc60ec, 0x223b1, 0x2e659, 0x5e0ac, 0xaac3e, 0x75e13, 0x107ab,
      0x41bc5, 0xda17c, 0x253db, 0xc973c, 0x5b22e, 0x22966, 0x8a501,
      0x3867b, 0x99bff, 0x0621a, 0x660d5, 0xf5fed, 0x89fc3, 0x8506c,
      0x7a3c2, 0x6451a, 0x0b9f1, 0x3ed35, 0xb586f, 0x3267c, 0x7c3e0,
      0x85b12, 0x99671, 0x07c77, 0x09bc8, 0x4a130, 0x157d4, 0x4d09c,
      0xdaf1f, 0x7647a, 0x8362f, 0xa6a19, 0x9acf3, 0x4a42b, 0x6e039,
      0xa28da, 0x31c3d, 0x00001 },
    { 0xa83ba, 0xf1a7d, 0xa785f, 0x44364, 0x5d04f, 0x15b42, 0x812f4,
      0xec03f, 0x899bd, 0xa27c0, 0x0f5f4, 0x411a8, 0x9c58d, 0xa251b,
      0x610fd, 0x3d32d, 0xb2f32, 0x04cd3, 0x9bb45, 0x083c9, 0xbf4c2,
      0x8c444, 0x3fd19, 0x730e8, 0x261af, 0x9060c, 0xb02db, 0xa4dfc,
      0x8060c, 0xf1e7c, 0x38b9d, 0x0ff78, 0x690c9, 0x97c4c, 0xb79cf,
      0xf1546, 0x75d75, 0x1514d, 0x8ff13, 0x1cb0e, 0x074f1, 0x15a7c,
      0x2c176, 0xaac1b, 0x0b920, 0xaa0ff, 0x8ad44, 0xde809, 0x45ce9,
      0x6a345, 0x1d1a4, 0x00007 },
    { 0xb382e, 0x76fa1, 0x6178f, 0xda0d7, 0x3772d, 0xd8ecc, 0x130a0,
      0xc5d4d, 0xaab2a, 0x2caa5, 0xd7262, 0x8ba48, 0x627d3, 0x3bed0,
      0xdb6ca, 0xc5410, 0xceccf, 0x88793, 0x637a5, 0xe3d7f, 0xd6e65,
      0x65daf, 0x6411f, 0x60a45, 0x44a85, 0x0bc3b, 0xf7854, 0xb3a84,
      0x60f47, 0x4d60f, 0xadd5e, 0x824fd, 0x3b6d5, 0x0c17d, 0x8ccf9,
      0xc13ad, 0xf325f, 0x8eabd, 0xab900, 0x3648f, 0x0d716, 0x4b3e9,
      0x4c52d, 0xff3a2, 0xb3964, 0x3d0ac, 0x41653, 0xb95cc, 0x7f521,
      0x9f116, 0xcd269, 0x00006 },
    { 0x4f3ac, 0x3b12f, 0xd8c0b, 0xbdfb2, 0x299d1, 0x3dcfe, 0x326b0,
      0x30f37, 0x034f8, 0x82540, 0xc5a8c, 0x68937, 0x222dd, 0x8f144,
      0x3d0cd, 0xeb709, 0x742f2, 0xa7585, 0x92795, 0xdadd8, 0xc087a,
      0x5f282, 0xb5ee1, 0x16ab7, 0xdc749, 0xb47bb, 0x58acb, 0xe40ba,
      0xbd30f, 0xbac39, 0x7ebe2, 0x0de41, 0xa04bc, 0xa6c61, 0xb4b19,
      0x55694, 0xdf273, 0x38c34, 0x96f93, 0x30ab1, 0x03742, 0x65e8f,
      0xc88c9, 0xfcb86, 0x6fa2e, 0xeeb82, 0x274c7, 0x19eee, 0x45dc2,
      0x3fda3, 0x27c06, 0x00003 },
    { 0x7cd53, 0xff5b4, 0xb399e, 0xaefea, 0xd1943, 0xe9869, 0x866bb,
      0x1402a, 0xecc7b, 0x16e64, 0x1c25a, 0xc2aab, 0x1c3e7, 0x2de27,
      0xb7902, 0xc4216, 0xd6a5f, 0xc8366, 0x58dfc, 0x3336e, 0xeda81,
      0x59509, 0xb7cd1, 0x130bf, 0x400f2, 0x80370, 0x3b487, 0xe0599,
      0x21be4, 0xf3cd2, 0x1fe39, 0x0623a, 0xb4f87, 0xb2eec, 0x2aa22,
      0xb83b7, 0x66c27, 0xf4c49, 0x5bf1a, 0xda5fa, 0x2a94b, 0xf27a4,
      0x8b01a, 0xa8224, 0xc9afb, 0x70112, 0xd2a36, 0xeb6b9, 0xf6856,
      0xd1c0d, 0x20f19, 0x00000 },
    { 0xbba20, 0x86a4d, 0x7051a, 0xe5c53, 0x6db1d, 0x18ebc, 0x840b6,
      0xe6525, 0x80a19, 0x4d9a7, 0x2bccc, 0x302dd, 0x49440, 0x285a2,
      0x23d10, 0xe9ff0, 0x86268, 0xe33a4, 0xb937e, 0x11473, 0x24cd6,
      0x7ee2f, 0x7cfe3, 0xa3d05, 0xbbfd3, 0xce79f, 0xcddef, 0x16d3c,
      0x75fba, 0x23172, 0x8ec5b, 0x91605, 0xc3adb, 0xbe720, 0x7699e,
      0x6bba4, 0x68b4f, 0x27438, 0x77026, 0xf18a0, 0x0092a, 0x6054b,
      0xcca11, 0x90eba, 0x099d0, 0x888f6, 0x1ff0c, 0xf757e, 0x50544,
      0x20b00, 0x9e727, 0x00007 },
    { 0x0a239, 0x25282, 0x32acf, 0xb3106, 0xeaae6, 0xa3974, 0x1dfb1,
      0x48c0a, 0xfd6ba, 0xaad61, 0xa3ee7, 0x3c395, 0xdd245, 0x80446,
      0x5a0b9, 0x54845, 0x6676f, 0x7bde1, 0xf29d9, 0x75a19, 0xc7893,
      0x52ca0, 0x985f2, 0x7743a, 0x1af3e, 0x8de96, 0x6cdbd, 0x9c566,
      0x970c7, 0xc538f, 0x54ecb, 0x14a38, 0x6851c, 0x3aa12, 0x8daa7,
      0x558c5, 0x52a9f, 0xb5bb4, 0xe05e9, 0xfbd15, 0xf7f83, 0x9d37a,
      0x8a193, 0x79273, 0x6a448, 0x11a05, 0x2b595, 0xe428b, 0x5846d,
      0xe3701, 0x01d3c, 0x00000 },
    { 0x5b1d7, 0xb9e14, 0x6be36, 0x5664d, 0xa009c, 0xe3938, 0x6dbf3,
      0xe7c0f, 0x62e7d, 0x392e5, 0x343f5, 0x44e6c, 0x19510, 0x0897b,
      0x2b8d9, 0xa5ab6, 0xf797c, 0x0b512, 0x1a1f7, 0x28e4b, 0x4750f,
      0xcdd75, 0x65d91, 0xffb81, 0x80e2f, 0xb3b4c, 0x94d02, 0x39c75,
      0xc65ed, 0x833ed, 0x49d56, 0xcc12a, 0x93a18, 0xbcf36, 0x73694,
      0xc404e, 0xafcd2, 0xcc134, 0x19434, 0x11d40, 0xbd5fc, 0x46071,
      0xc585e, 0x9047f, 0x40575, 0x0b7a0, 0x36079, 0xb3280, 0xfc684,
      0xfc40a, 0xbb8c6, 0x00004 },
    { 0xf8796, 0xddfd0, 0x120e2, 0xc9de3, 0xdb133, 0x68a40, 0xc6e69,
      0xa9369, 0x366c0, 0x3bfea, 0x00727, 0xb6d66, 0x937e5, 0xb8143,
      0xcf08c, 0x39e4e, 0xbc005, 0xcd9fe, 0x87fe9, 0xb53c4, 0x40199,
      0x8af44, 0x9ebeb, 0x29351, 0x24e3b, 0x162f1, 0x82c9c, 0x218ac,
      0x0860c, 0x9dc59, 0x6f270, 0xacd1d, 0x50529, 0x4536d, 0x696d5,
      0x0bfc5, 0x95912, 0x3f5df, 0x690c0, 0x10ffa, 0x3e88d, 0x2799a,
      0xc4328, 0xcfa56, 0x9d4f9, 0x135d8, 0xa9e9a, 0x2e8fe, 0x77e78,
      0x81b6a, 0x699a8, 0x00003 },
    { 0x1c64d, 0x721eb, 0xbca33, 0x81545, 0xdf1d2, 0xcf3a2, 0x06fe9,
      0x65371, 0x2e9b3, 0x4db7e, 0xf7cbf, 0x71514, 0xf06c1, 0x58b37,
      0x16e20, 0xcbde4, 0x4e9c5, 0x7e883, 0x2c53a, 0x3a758, 0x2e9ac,
      0xdbdfe, 0xc0294, 0xc5e67, 0xec6cb, 0x0d795, 0x426a8, 0xc25f1,
      0xf8c23, 0x8d4f9, 0x20d6a, 0xee2cd, 0x7c235, 0x54d3b, 0x38daa,
      0x4d528, 0x03d7a, 0xe08ec, 0x473b9, 0x781cb, 0x475e9, 0xaaca9,
      0xec31c, 0xf39e5, 0x77271, 0x53518, 0xe9f82, 0x1df08, 0xaff8b,
      0x03208, 0xf3a4b, 0x00004 },
    { 0x095f8, 0x071ed, 0xf7b81, 0x6d4e0, 0x6da22, 0xe37fa, 0xd1d23,
      0xafb36, 0xf9852, 0x118b0, 0x7d8e3, 0x634e0, 0xeb114, 0xe0f16,
      0xa97e3, 0xb9634, 0xeec37, 0x9c421, 0x454bb, 0x21c12, 0xbd72b,
      0xecd5d, 0xd7cb4, 0x6df20, 0x03868, 0xa2f96, 0xf86e0, 0x59fdd,
      0xa9f53, 0xc488a, 0x4fa5a, 0xc43d5, 0x49df4, 0xabd10, 0x6d714,
      0x607a5, 0xeb020, 0x152b3, 0x25e13, 0x7a023, 0xe1c18, 0xdb49b,
      0x2ae84, 0x4f4a5, 0x044f2, 0x5a7b8, 0xc030b, 0x9e525, 0x179fd,
      0x46a6d, 0xd8744, 0x00006 },
    { 0xa42f5, 0xaabe9, 0x29d07, 0xccc8d, 0xc3781, 0xd5316, 0xea11f,
      0x9dc69, 0x75a6d, 0x1a71a, 0x8fee9, 0xe0df8, 0x24e19, 0xd44f1,
      0x4dcf8, 0x99c2b, 0xe94e4, 0x9231a, 0x5f6df, 0xccc20, 0x6cf28,
      0xfba87, 0xceb27, 0xf57f7, 0xa0f01, 0x746e1, 0x3fd3b, 0x1f34f,
      0x3e03f, 0xc1d21, 0x4a742, 0xa0edc, 0xb8580, 0x707de, 0xcaac2,
      0x48bc5, 0xfaf08, 0x5d791, 0x59d0f, 0x07ac7, 0x514ad, 0x3117f,
      0x04fc5, 0x97349, 0xd95a3, 0xb70f3, 0xca97b, 0x95a4a, 0xc5609,
      0xc9ff9, 0xcf384, 0x00003 },
    { 0xfc9e3, 0xbace1, 0x00506, 0x03997, 0x2676b, 0x72174, 0x7b349,
      0xe72bf, 0xa1b8d, 0xf72b4, 0x9b209, 0x02a87, 0x1ca86, 0x26a8e,
      0xb90ce, 0x90580, 0x4f39a, 0xb7fe2, 0xef339, 0x62e11, 0x16293,
      0xc5d99, 0x4f4b6, 0x577b2, 0x74e1a, 0xe9511, 0x5e451, 0xfcb50,
      0xdf380, 0x8321b, 0xafb14, 0xf4d97, 0xe5d2a, 0xbb747, 0x99806,
      0xa6080, 0x5be99, 0x525d6, 0x82085, 0xd455e, 0x828d9, 0x65264,
      0x8560a, 0x5405d, 0x08c8c, 0x03077, 0x73c71, 0x3c67e, 0x3df26,
      0x50ee7, 0xb2488, 0x00002 },
    { 0x1159f, 0xe6854, 0x173cd, 0x10b22, 0x84fb4, 0x224c1, 0x1c778,
      0x1f2ca, 0x28619, 0x4007a, 0x8b23e, 0x07d6a, 0xa52c2, 0xb2344,
      0x210a6, 0x071a0, 0xd2945, 0x7cb5e, 0xb0e58, 0xcc6cd, 0xf810f,
      0x56b8e, 0x3b96c, 0x62d84, 0x8c58f, 0x75124, 0x4c669, 0x363d7,
      0x64b90, 0x6c66f, 0x7f2e6, 0x6348f, 0x6bcbe, 0x41c12, 0x2f9d4,
      0x49e8b, 0x373ce, 0x07f2a, 0xdf0ac, 0xe81b0, 0x86758, 0xd1524,
      0xd4621, 0xb54d1, 0xca108, 0x414a1, 0xece74, 0x17261, 0xac215,
      0xcc6a3, 0x38b3b, 0x00009 },
    { 0xed340, 0x6be4d, 0x9e4a1, 0x8036a, 0xa80e8, 0x65fb2, 0xacb8e,
      0xdcd73, 0x89606, 0xa9970, 0xaa657, 0x0434a, 0x61c3a, 0x101b0,
      0xc5849, 0xf304f, 0xbb64c, 0x1ada0, 0x60fb6, 0x2df5e, 0xcf554,
      0x8c2ae, 0xd5f81, 0x56f76, 0x20576, 0x97740, 0x2533d, 0xb7909,
      0xfb566, 0xd6eb5, 0x5e574, 0xae465, 0xb44b7, 0xb5a55, 0x0f7a1,
      0x7ea56, 0xb9374, 0x70179, 0xe5679, 0xf2dac, 0x7e0e8, 0x068ae,
      0x4e83c, 0x46078, 0x19847, 0x30734, 0x9ed15, 0x24e8c, 0x89d6b,
      0xa5d9e, 0xcff58, 0x00006 },
    { 0x51f68, 0xb003e, 0x08c01, 0xe7d65, 0x51d2f, 0xd1f22, 0x805e1,
      0x09bd8, 0x98d0b, 0xb7f79, 0x3e415, 0x907a0, 0x8255e, 0x7d979,
      0x67d60, 0xd1484, 0x53896, 0x1e9b4, 0x55c3b, 0x50f40, 0x3809f,
      0x00101, 0xfdc35, 0xd0233, 0xb2fa6, 0xb8fbb, 0xf1820, 0x0b0af,
      0x00b68, 0xd317e, 0x4dc38, 0xb1d40, 0x8c7df, 0x44ccc, 0x33d54,
      0x3f841, 0x66ec1, 0xa847e, 0xe487f, 0x046e2, 0xf83d8, 0xacc33,
      0x863b3, 0x7fc54, 0x73c62, 0x936af, 0x8aaeb, 0x5f67f, 0x79327,
      0x8f31b, 0xfe4ac, 0x00005 },
    { 0xf401e, 0xbf8b6, 0x81aa4, 0x7ed45, 0x3ad5c, 0xdb12a, 0xb4a05,
      0x6fb07, 0x18726, 0xd47b0, 0xc22bc, 0x1f049, 0x5fdd1, 0x371c9,
      0x7d469, 0x5454a, 0x46eaf, 0xfb99a, 0x66c55, 0x96d00, 0xc7fef,
      0x637c7, 0x95c18, 0x6b83e, 0xc1d34, 0xdcbaf, 0x0bb42, 0x85930,
      0x255c3, 0xe7e71, 0xc2b34, 0xdd8de, 0x4cee8, 0xb0b18, 0x9c9cf,
      0x78646, 0x249a2, 0xcc0c4, 0x2e78d, 0x2010f, 0xd95f2, 0x20290,
      0x977a4, 0x54c96, 0xd86e2, 0x2abda, 0xc89eb, 0x20931, 0xc0548,
      0x64121, 0x13771, 0x00008 },
    { 0xa8edf, 0x5e9c5, 0x266b2, 0xa7ad6, 0x21078, 0x1388c, 0xedf6e,
      0x4876e, 0x2737d, 0x175f0, 0x27446, 0xa7f96, 0xa242f, 0x85382,
      0xbd9b3, 0x3e2cf, 0x71bef, 0xb102f, 0xadad7, 0x0a92b, 0xa677d,
      0x2abcf, 0xf3456, 0x51fdf, 0xebd17, 0x78573, 0xc250c, 0x58527,
      0x6d7f6, 0x7ca89, 0x6eec4, 0xe0cf1, 0x22c9e, 0xb0676, 0xccd79,
      0xc0758, 0x2f8f2, 0xfc588, 0x51531, 0xa6008, 0x2b37e, 0xba923,
      0x2e8c5, 0xb3618, 0xe4d7b, 0xf146f, 0x35cd2, 0xbf247, 0x2db98,
      0xee9cd, 0x9c280, 0x00007 },
    { 0x48122, 0x03f2b, 0xdcc82, 0xc48eb, 0x6b04a, 0xc0491, 0x85ea8,
      0x9fc48, 0x064dc, 0x1cacf, 0x2c100, 0x89978, 0x0ab83, 0x6de25,
      0x72167, 0x7339e, 0xab820, 0xea8e1, 0x7aa5a, 0x4b2e1, 0x06bc1,
      0xd28ca, 0x23024, 0x816b6, 0xc5bb7, 0x06570, 0xee6b6, 0x235cc,
      0x26c51, 0x3eae4, 0x89f18, 0x1b2bf, 0x6274b, 0xc69c6, 0xe3af3,
      0x38bc3, 0x6b51e, 0xb0442, 0xe3be0, 0x73e40, 0xbc58e, 0xe426d,
      0x5be5b, 0xd578b, 0x83f9d, 0xc8f40, 0x79152, 0x9fd9f, 0x3ff4f,
      0xa4a9e, 0x58073, 0x00007 },
    { 0x1ca22, 0x57869, 0xd27b0, 0xa1b67, 0x613a2, 0x06bfd, 0x413f2,
      0xac795, 0xbd385, 0x07e84, 0x55366, 0x8a2a7, 0xcc5d1, 0xa0e24,
      0xde7c8, 0x2e166, 0x74dbd, 0x0c3c4, 0x6d575, 0x843a5, 0x11366,
      0xf444c, 0x432de, 0xcf4b8, 0x46e53, 0x83146, 0x9fd97, 0xd030a,
      0x34bc0, 0x7ee20, 0x82429, 0xbda4c, 0xbe6c7, 0xbffd7, 0xd0b10,
      0xf3ff3, 0x608c7, 0x21647, 0xc452d, 0xb4fd4, 0x52599, 0x0406e,
      0x9e9e1, 0x9fa14, 0xdfbab, 0x61d32, 0x7fa86, 0x9342a, 0x66aa8,
      0x58faf, 0xf3e34, 0x00003 },
    { 0x597aa, 0xaf951, 0x1ec35, 0x64eb5, 0xc49df, 0x77d4a, 0xff5b6,
      0x9bf4e, 0x6cd9c, 0x35027, 0x15a29, 0xca495, 0x3423e, 0x9bb9c,
      0x553fd, 0x8a696, 0x1f09c, 0xdfede, 0x99ee9, 0x5f98f, 0x6199e,
      0xfa295, 0xc32b8, 0x35292, 0x38758, 0x1bb76, 0xc40e8, 0xeddcf,
      0x58734, 0x457d9, 0xe9f65, 0xd82d5, 0x78d2b, 0x3e30c, 0x8ee32,
      0x3d67c, 0xcc143, 0x7b2e4, 0x4aee7, 0x3c831, 0x9f807, 0x6356d,
      0xa0e2f, 0xede22, 0xe441e, 0x48295, 0x7ed6c, 0x1e9e1, 0x294ef,
      0xc434c, 0x40d20, 0x00006 },
    { 0x4d513, 0x8e328, 0xe9a0b, 0x053a4, 0x5f315, 0x4c354, 0x52a07,
      0x45acd, 0xe7407, 0xb7b36, 0xde50d, 0xdcfc1, 0x6d80b, 0x49fc4,
      0x7dc25, 0x8d9d4, 0xf07a8, 0x13303, 0x9b6ef, 0xd4c22, 0xa6d4a,
      0x461ac, 0xb734e, 0xfc9f1, 0xe351d, 0x65ca8, 0x7460e, 0x094d5,
      0x78bc4, 0x32d36, 0xb330f, 0xb6302, 0x742e8, 0xb6285, 0x9a074,
      0x29c36, 0x1876c, 0xe52b1, 0x17adf, 0x912bd, 0xe4609, 0x39f39,
      0x49aa6, 0x0d663, 0x18ee4, 0x2e05c, 0x02ac7, 0xb9689, 0x92816,
      0xa8c0d, 0xf9c1c, 0x00000 },
    { 0x33df3, 0xb3674, 0xebbaa, 0x628c1, 0x715d3, 0xaa534, 0x5ccb6,
      0x97f0c, 0x320d8, 0xf913a, 0x5e408, 0x18cb6, 0x172c9, 0x37345,
      0x854d5, 0x4b638, 0xdca09, 0xa30b4, 0x31399, 0x13267, 0x00a3b,
      0x25673, 0x388cf, 0x6608b, 0x60dfa, 0xfd5ea, 0xb290d, 0x74b07,
      0xb58ad, 0x694f9, 0x789d7, 0x83202, 0x30fb1, 0xb8b66, 0x8593d,
      0x3eaf4, 0x0c65e, 0xb47f7, 0x3f83d, 0x3e726, 0x49c91, 0x33639,
      0x6e6ff, 0xcec6e, 0x09b9a, 0x8a824, 0xba709, 0x34bd9, 0x36ec5,
      0x2f45d, 0xe31c1, 0x00007 },
    { 0xd2dd7, 0x680df, 0xe281d, 0x61d8b, 0x024ab, 0xfacb0, 0xf971e,
      0x94431, 0x3005f, 0xbcb9c, 0x59cb3, 0x8dfa9, 0x6660c, 0xfbb40,
      0xc30cf, 0xfdd5f, 0x9a10d, 0xbe796, 0xa4631, 0xfd1b7, 0xede13,
      0x6e309, 0x07633, 0xfc947, 0x3bfad, 0x2376b, 0xcc722, 0x925dd,
      0x1fa91, 0x6c4ee, 0xd7315, 0x741f0, 0xb3747, 0x410e2, 0xf64ee,
      0xd93c4, 0x3efc4, 0xbe92d, 0xb2e86, 0xfc4fb, 0xb7e03, 0xbbc53,
      0x37ca1, 0x6cf53, 0x0ac19, 0x23ba6, 0xa307e, 0x4de41, 0xd5357,
      0x45326, 0xa219c, 0x00001 },
    { 0xdb0bc, 0xf8aa4, 0xdcf7e, 0x9963f, 0x67b6c, 0x23180, 0x92f2e,
      0x3d8a1, 0x39067, 0x71c26, 0xfdc77, 0xc2e2f, 0xbc0ce, 0xfc0ed,
      0xe35a2, 0x997c8, 0xc6043, 0xc182c, 0x8e10e, 0x81207, 0xb2b0c,
      0x0de2c, 0xf8efd, 0x69e57, 0xc457f, 0xc34d6, 0xb53f1, 0x69b25,
      0x8953e, 0xf89cb, 0x30ac4, 0x422a3, 0x66be6, 0x29955, 0x2ff23,
      0x42d19, 0xd4374, 0xcd502, 0x40373, 0xbea69, 0xce590, 0x62f04,
      0x80306, 0x537ef, 0x36ac1, 0xd0bf9, 0xf77b6, 0xe02bc, 0x0192f,
      0x99bc9, 0x7aaa9, 0x00001 },
    { 0x5db2e, 0x438e5, 0xd3d56, 0x68510, 0x33b94, 0x5dee4, 0x62f83,
      0x5b884, 0x440e5, 0x7c1a1, 0xa17e2, 0x3b35e, 0x9a6ff, 0x95f7a,
      0xc36dd, 0x23f99, 0x672cf, 0xd9bdd, 0x217fd, 0x45c07, 0xedd20,
      0x00ac1, 0xb25f4, 0x4ff06, 0x55c87, 0xbe94b, 0xe4a49, 0xa0e50,
      0x30a44, 0x3b681, 0xe91b4, 0xe8925, 0xf96c5, 0xe1214, 0x8bedd,
      0xfa977, 0xc0f97, 0x456a4, 0x2670f, 0xa5bfd, 0xfd86b, 0xefa28,
      0xe7608, 0x2d8fb, 0xc3b4b, 0x6474b, 0xf8c22, 0xfbd5f, 0x3b24a,
      0xf0a5f, 0xb282a, 0x00006 },
    { 0x1a595, 0x5f634, 0x8fc02, 0xe28c7, 0x6a445, 0x1c38d, 0x84259,
      0xeb446, 0xd6e3d, 0x3372b, 0x55478, 0x66d37, 0x43f94, 0x3e16c,
      0x4d308, 0x91141, 0x7acb4, 0x6695a, 0x45d94, 0xfb641, 0x98fd2,
      0x2ddf0, 0x7b110, 0x0bfd8, 0xb2d2d, 0x882a2, 0x94550, 0xbe5c5,
      0xe69e9, 0x0245d, 0xbf4a8, 0xee378, 0x06b0e, 0x68b23, 0x0b0bd,
      0x9f3d8, 0x6c2be, 0xa545c, 0x24576, 0x4802c, 0xd167b, 0xfb429,
      0xb412d, 0x44272, 0x213e6, 0x8d976, 0x529ee, 0xb664f, 0x06ebf,
      0x23547, 0xd4f5d, 0x00006 },
    { 0xa9f88, 0xb600b, 0x5c8f2, 0xd0bf3, 0x07bb6, 0xc807e, 0xe5bfd,
      0xb3b81, 0x26d42, 0x1e0a1, 0x7ac78, 0xe6cea, 0x6335c, 0x7dcba,
      0xe6ff3, 0x3e308, 0x96487, 0x6263c, 0x28dca, 0x434d0, 0xe8818,
      0xeba57, 0xa2672, 0x79b78, 0x3d59f, 0xa3a9e, 0xf07ae, 0xa7dd2,
      0x4d2f0, 0xd05f7, 0x67824, 0xe0fe4, 0x6deb6, 0x70011, 0x20851,
      0x7580b, 0x258f3, 0x2a5e9, 0xbb39c, 0x74070, 0xbd7a5, 0x90e78,
      0x9977d, 0xc872b, 0x4551f, 0xdb81b, 0x3c440, 0x6eda9, 0xd34ad,
      0x4fd65, 0xaaf0b, 0x00004 },
    { 0x4c7af, 0x06351, 0xbef25, 0x1ead9, 0xdbc18, 0x9e7da, 0xc58b0,
      0x8fa3e, 0xcae87, 0x85ef3, 0x73b86, 0xfab51, 0xdd8db, 0x1d32d,
      0xfc092, 0xb2490, 0x9c466, 0x6b8bd, 0xeef38, 0xdbdb4, 0xfa061,
      0xcdd52, 0x4dbc1, 0x25bc0, 0xe989a, 0x3664d, 0x57286, 0x836b8,
      0x006f9, 0xe44aa, 0x8048b, 0x11a5a, 0x018c7, 0x4e097, 0x6dede,
      0x1fb11, 0x7b2c1, 0xaec57, 0xcd972, 0xa721e, 0xdade1, 0xa9144,
      0x6ebf3, 0x526bd, 0x7f99c, 0x2e14d, 0x65b1c, 0xa1d41, 0xc6337,
      0x3982b, 0xb2cbd, 0x00008 },
    { 0x2e991, 0xf28a5, 0x8ec1b, 0x42ec2, 0x6cf9d, 0xa202f, 0xa450b,
      0xc634e, 0x7d130, 0x9c830, 0x5762b, 0x57b3c, 0xd3fc2, 0x7c2a2,
      0x8d148, 0xbd329, 0x9488a, 0xa7a31, 0xa14f1, 0x06d2c, 0xb06ba,
      0x0ca93, 0xe89c7, 0xee405, 0x3f4b3, 0xe79aa, 0x5deea, 0xeeb33,
      0xccc64, 0xbf1d4, 0x57803, 0xd155f, 0x16bfd, 0xb5456, 0x41ec0,
      0x33f60, 0x6086e, 0xdf80e, 0xcf523, 0xf0243, 0xa79c8, 0x58399,
      0x74ccd, 0x824e8, 0x186c2, 0xc5c83, 0xaec8f, 0x220ee, 0xe3670,
      0x047db, 0x7e283, 0x00005 },
    { 0xdf666, 0x98fbc, 0xe60b6, 0xb1d26, 0x98beb, 0xd06a9, 0x436bd,
      0x80498, 0x4adba, 0x8d404, 0x22bc8, 0xf75e5, 0x0d76b, 0x423b2,
      0xb9b28, 0x655c4, 0x98a72, 0x92533, 0x5c0f4, 0x76016, 0x70ca3,
      0xd4f2b, 0xa5a76, 0x2030f, 0x89925, 0x05469, 0x60547, 0x7e87b,
      0xf96b3, 0xde1b2, 0x73153, 0xef96f, 0x4ef05, 0x8cad5, 0xecbbc,
      0x17b05, 0xaa936, 0x289d0, 0x17deb, 0x7cba2, 0x0fbd5, 0xd73ac,
      0x9d4a2, 0xcb561, 0x3d0d3, 0x1d606, 0x9d4c9, 0xe8bee, 0xffda6,
      0x37696, 0xf12e0, 0x00004 },
    { 0x1a610, 0x2215f, 0xccfa4, 0x519a4, 0x53786, 0x4a5c5, 0x13480,
      0x73838, 0x6a454, 0x2a124, 0xb284e, 0xb4844, 0x0fa15, 0x6d132,
      0xc6514, 0x36464, 0x8a0fa, 0x8c70a, 0xb6ba8, 0x804ef, 0x793c4,
      0xe7cee, 0x16a74, 0xb95ae, 0x4d22c, 0xdd8c3, 0x9c1d4, 0xd89ff,
      0x19d9e, 0x02537, 0x66d32, 0x61a08, 0x6444a, 0xb29bd, 0x5b232,
      0xbab14, 0xcf277, 0x88e92, 0xb02f8, 0xa9448, 0x69c6e, 0xcb73e,
      0xb521e, 0x6ea95, 0x21a49, 0x58afb, 0xea758, 0xa8f78, 0x66f91,
      0x3eb12, 0x3d233, 0x00008 },
    { 0x478d7, 0x8867b, 0xc6332, 0xfc9c1, 0x150a2, 0xee1ae, 0x41ba1,
      0x18d22, 0x6ab30, 0x9605b, 0x93cd6, 0xf2888, 0x769f1, 0x117a8,
      0x660a8, 0x159d6, 0x73d77, 0x1970e, 0x81201, 0x5f0ae, 0x093f5,
      0x8fef0, 0xfb252, 0xd854d, 0x78db8, 0xbbb39, 0x45d9f, 0x3ef6f,
      0x7d6b4, 0xbee39, 0xbfed5, 0x17de4, 0x76dad, 0x596bf, 0x01e0f,
      0x754ca, 0xe3d40, 0xb2280, 0xef328, 0xf8e86, 0xb6122, 0x868ed,
      0x7d1e5, 0xb6afb, 0xb8226, 0x40a55, 0x2152f, 0x46353, 0x31621,
      0x3ec5a, 0x362f1, 0x00007 },
    { 0x0c430, 0x7c73c, 0x92eb2, 0x36577, 0xfa51c, 0xc0a65, 0xf1b8c,
      0xd2194, 0x5cece, 0x4750a, 0x14b49, 0x56888, 0x41894, 0x6fbbf,
      0x81a4b, 0xbbf0a, 0xa8608, 0x58f0a, 0x76f4f, 0x795e3, 0x83987,
      0x361d6, 0x0d5d9, 0xe3a8d, 0x10cd8, 0x55b65, 0x6c1a4, 0xfdbfb,
      0x963e2, 0xc891f, 0x54eae, 0x2c911, 0x68f64, 0x15ff5, 0xeb1e7,
      0x399e0, 0x72f2b, 0xaf9cd, 0xf0be7, 0x89f0b, 0x39bac, 0x951fc,
      0x09836, 0x1d929, 0x8f086, 0x0a20a, 0xf02da, 0xd9b16, 0xc0ead,
      0x3fa38, 0xf1069, 0x00002 },
    { 0x6ded2, 0x910c0, 0x7a6ce, 0x087b0, 0xf2fd9, 0x74842, 0x5a6f9,
      0xa9f63, 0x8bfd6, 0x26e46, 0xed606, 0x18911, 0x804b6, 0x9ee54,
      0x89f36, 0x1fb2f, 0x6a201, 0x13dc9, 0xcbd11, 0x33ac9, 0xe10d6,
      0x59acf, 0x29e67, 0x8faa6, 0xa66fc, 0x8364b, 0x7f382, 0xae494,
      0x9a686, 0x9cda9, 0xa05d5, 0x828c3, 0xa2f6e, 0x1408e, 0xc7afb,
      0x53c87, 0x4af39, 0x51c8e, 0xe4f25, 0x9daa9, 0x3d279, 0x405b5,
      0xd6f19, 0x68d4a, 0xb1eff, 0x437cd, 0xbdd96, 0x2775d, 0x7a043,
      0xe44fe, 0x85f83, 0x00009 },
    { 0x45294, 0x16eaf, 0x9603c, 0x57518, 0x0c24b, 0x13116, 0x52d70,
      0x39d6b, 0x12018, 0x404c1, 0xd9433, 0xcf02e, 0x87079, 0xf41b6,
      0x28b74, 0x0c5b0, 0xac1e1, 0x769c8, 0xdc3f0, 0x4f0e3, 0x3f8b2,
      0xc5eea, 0xc225a, 0xe34c5, 0x684ba, 0x2aee6, 0xabc45, 0x9e639,
      0xca525, 0xdf45c, 0xcd1e9, 0xb07d2, 0x43cfa, 0x931a4, 0x7019c,
      0x03b30, 0x992c0, 0xfddaa, 0xc2e68, 0x0d8cb, 0xf179c, 0xa72d9,
      0xe781c, 0x5a6f1, 0x9bbf1, 0xdcc79, 0x9d550, 0x54d77, 0x962f1,
      0x400fe, 0xc88e5, 0x00000 },
    { 0x44357, 0x6ae8f, 0x4f71a, 0xab6a8, 0x63a3c, 0x5b4bf, 0x680f7,
      0x5aebc, 0xc9d9e, 0xf2334, 0xa753e, 0xf0848, 0xececa, 0x5e3c8,
      0x4c107, 0xe2801, 0xf8d3a, 0x38f74, 0xb9d5a, 0x32aeb, 0x4b80e,
      0x98846, 0x79275, 0xf2bc3, 0x28e6f, 0x977b3, 0xed0e1, 0x1fafe,
      0xaebbb, 0x33065, 0xc955a, 0x674ea, 0xdbce8, 0x8f922, 0xc19fd,
      0x907a8, 0x5987b, 0x17ae8, 0xcd78c, 0x3b3a2, 0x33627, 0x2f89f,
      0xa8777, 0xa019f, 0x6ebae, 0x25ced, 0x4993a, 0x4e5de, 0x10715,
      0xb8af1, 0xe2560, 0x00008 },
    { 0x1aba6, 0x6c314, 0x6d374, 0xcf9e5, 0xfbab2, 0xa1079, 0x7c745,
      0x9cdd2, 0x82831, 0x0eb63, 0xdfd95, 0x76329, 0xf2223, 0x9408f,
      0x5cd3a, 0x1e0b1, 0x60118, 0x00b11, 0x9a802, 0xbba74, 0xda383,
      0x19db5, 0x6d527, 0x65104, 0x8340a, 0x1f607, 0x7523b, 0xd4de9,
      0xb8929, 0x0a28a, 0x45c8e, 0x40403, 0xf09c7, 0xc20ad, 0x1275a,
      0xd6116, 0x52331, 0x1ab26, 0xa50b4, 0x5391c, 0xcc77c, 0x15230,
      0xf9223, 0x0c928, 0x988be, 0xfd9a2, 0x92b92, 0xfef3d, 0x4f2e5,
      0x22832, 0x9005f, 0x00005 },
    { 0xc1c74, 0x0c3c4, 0xbb175, 0xfb796, 0x0e966, 0x73aac, 0x73fbe,
      0x66c59, 0x75d92, 0xb685a, 0xa8656, 0xf9323, 0xe8c97, 0x446cd,
      0x3b150, 0x2b704, 0x3897f, 0xf73ff, 0x48916, 0x72b25, 0xcb18b,
      0x3dd01, 0xde691, 0x488c0, 0x751f1, 0x58d0a, 0x558ca, 0x57148,
      0xa1917, 0xa663d, 0x30144, 0x97714, 0x08618, 0xacb0e, 0xdf190,
      0xad9c2, 0xcf39e, 0x80fc0, 0xda100, 0x17382, 0x5ac6e, 0x38008,
      0x262a3, 0x18513, 0xde979, 0x3bae8, 0x936b4, 0xe4495, 0x3df6e,
      0x26d78, 0x7a78e, 0x00005 },
    { 0xbddd8, 0x6f40d, 0x61b34, 0xc3ac1, 0x79410, 0x49a92, 0xf3b2b,
      0x1886c, 0x42783, 0xeb8c5, 0x3b93d, 0x32323, 0xd72df, 0xdf579,
      0x9f540, 0x9c8d5, 0xef500, 0x7dc20, 0x5d7a6, 0x8643e, 0x867f0,
      0x6b391, 0xdc3c4, 0xad96a, 0xa2445, 0xd0ecf, 0xc4544, 0x589b0,
      0x7658f, 0x8417d, 0x301e0, 0xe6ec9, 0x4e288, 0x6ac45, 0xca5ef,
      0x462d6, 0xfac0f, 0x91048, 0x03641, 0x08d8a, 0x407d8, 0x7e852,
      0x6d35b, 0x33a7f, 0x7b4c5, 0x6ada8, 0x4128f, 0x3251e, 0x472e8,
      0xc581c, 0xca370, 0x00001 },
    { 0x1b68a, 0x71a80, 0x4bd51, 0x98b39, 0xcfd19, 0x12879, 0x20273,
      0x41163, 0x5aabf, 0xdb490, 0x5b01f, 0x87f4f, 0xbb5fe, 0xda128,
      0x23a9c, 0x78de5, 0xd31f7, 0xa1c7b, 0xbf161, 0x4c350, 0x02390,
      0xdecfd, 0x12db5, 0xe188f, 0xb2882, 0x74224, 0x99dae, 0x801df,
      0x20dd2, 0xcd1cd, 0x7b508, 0xcad46, 0x67e39, 0x3dc08, 0xc311c,
      0x50726, 0x02b42, 0xa1172, 0x00371, 0x2efd9, 0xf464e, 0x0383b,
      0xdbd3b, 0x448a1, 0xa53d0, 0x265ba, 0x2f4e6, 0x32db5, 0x3ac79,
      0x4c4c3, 0x584b3, 0x00002 },
    { 0xec688, 0x892ae, 0xcb863, 0xe5233, 0xa45fb, 0xe740b, 0x5f8a5,
      0xfd60b, 0xe71f7, 0x3d422, 0x87491, 0x185c4, 0xd455d, 0x17d80,
      0xb36fa, 0x04c2b, 0x54524, 0x54ac0, 0xf2718, 0xa6573, 0x5a8b9,
      0xdd304, 0xcc876, 0x62ee7, 0x2c3e1, 0xd02e4, 0xdf6c7, 0x67064,
      0x80026, 0x7cb48, 0xd51dc, 0x5927d, 0x897e0, 0xbe187, 0xb3faa,
      0x737c6, 0xef2d5, 0x6ad22, 0x9fffe, 0xff51a, 0x60269, 0xaaafb,
      0x9807b, 0x35456, 0xae1c8, 0x1ca49, 0x6ff95, 0xacddb, 0xab085,
      0x743f9, 0xe8113, 0x00007 },
    { 0xa88b1, 0x8b830, 0xd722a, 0x17e1a, 0x8ce11, 0x918ea, 0x47d91,
      0x0409b, 0x2d0b8, 0xd33e0, 0xc46d1, 0x12d36, 0xcb538, 0x89669,
      0xdb0e5, 0x2fd09, 0x0cd5e, 0x0615b, 0x845cd, 0xc4539, 0xa2386,
      0x1c155, 0x3cb0c, 0xf5ff4, 0x74de5, 0xcdda7, 0x391c0, 0x6b98e,
      0x6bb07, 0x04f28, 0xeff50, 0x97d71, 0xc0bfe, 0x6caee, 0x3e0b4,
      0xad942, 0x732a1, 0x53866, 0x422e4, 0x396da, 0xc9f81, 0xfefe0,
      0x3db2b, 0xc1a26, 0x16376, 0x56fa9, 0x918ba, 0x001c7, 0x485a6,
      0x64df8, 0x36b8c, 0x00004 },
    { 0x764bc, 0x9d8ab, 0x8117e, 0xdf848, 0x4a077, 0xa61e9, 0xebddf,
      0x0c18e, 0x765d3, 0xdc5a7, 0xc9451, 0x16aff, 0xa5489, 0x1a347,
      0xe3307, 0x01a52, 0xb41df, 0xdeb23, 0x33b95, 0xc2866, 0x943c8,
      0x7d68c, 0x068dd, 0x18d97, 0x9d41e, 0x9de4f, 0xc9279, 0x8b908,
      0x37990, 0x7394a, 0x48ed4, 0xe6141, 0x1e53f, 0x17cd5, 0x50185,
      0xdcb6e, 0xe0243, 0x60075, 0x40550, 0x17954, 0xcde62, 0xffe5d,
      0x37da5, 0x90e15, 0x66f7c, 0x68cb6, 0xae407, 0x1df7a, 0xe95e1,
      0x9e6db, 0x266ca, 0x00005 },
    { 0x6b3db, 0x6d138, 0x4ddee, 0xe5408, 0xa7c38, 0xe4af5, 0x49df9,
      0xeb04f, 0x18440, 0xfdb34, 0xde5a4, 0xa1e8f, 0xc2138, 0x257cf,
      0x92430, 0x3e6e6, 0xd70c1, 0xe319f, 0x519c6, 0x1ff03, 0x486c3,
      0x34e17, 0x1e88f, 0x940ce, 0x298fd, 0x7cf1e, 0x4960d, 0xcb1d1,
      0xf6fb8, 0x2f3bf, 0x3472b, 0x207c1, 0xef8ff, 0xb4146, 0x99a20,
      0xe2208, 0xb7bd3, 0xec362, 0xa277d, 0x626be, 0x5044e, 0x67a97,
      0xfb4cb, 0xb4494, 0xa0f32, 0xc6703, 0x9201f, 0xc17a0, 0x84a2b,
      0xb99cd, 0x1f325, 0x00004 },
    { 0x843a4, 0x13ce2, 0x12ed5, 0x8afc3, 0xe0072, 0x48498, 0xce5e7,
      0x4d864, 0xf2822, 0x3ba8e, 0x62008, 0x4704a, 0xd3406, 0xed338,
      0x1d94b, 0x5905e, 0xe7b38, 0xb5063, 0xa578c, 0x7bb92, 0x6289e,
      0x276d9, 0x34198, 0xf17b7, 0x2dc47, 0x44dfe, 0xdac89, 0x521f1,
      0x75923, 0x400aa, 0x28d23, 0x3db6d, 0x1ba43, 0x5ea76, 0x64770,
      0x07ddc, 0xd9bfd, 0x47ba6, 0x8fd89, 0x242ca, 0x2e3ac, 0x6800f,
      0xb8c34, 0x4670e, 0xd49ef, 0xaa18f, 0x37bd9, 0x7db3d, 0xcea9e,
      0xb6e58, 0x6b30f, 0x00005 },
    { 0x0a428, 0xaacd8, 0x7ecdc, 0xc8910, 0xc8732, 0xf922d, 0x41f7a,
      0x3ada4, 0x88798, 0x8a20d, 0x24b00, 0x9a449, 0xa3bed, 0xe81c3,
      0x33cb2, 0x21235, 0x807d3, 0x7565f, 0x34e40, 0xaecbc, 0x51f2f,
      0xfaefa, 0x88d0b, 0xade8a, 0x634a5, 0x9178b, 0x4392a, 0xb7f89,
      0x8c4e0, 0xbb1cd, 0x37790, 0x30922, 0x204ae, 0xfaf87, 0xea9b4,
      0xcd83d, 0x585d3, 0xdf81f, 0xa793e, 0xc6523, 0x88c51, 0x6958f,
      0x7c0d9, 0xfb8b1, 0x7e472, 0xcf7f0, 0x1e5dc, 0x89908, 0xdd146,
      0x5758b, 0x353cc, 0x00001 },
    { 0xf6e18, 0x9739b, 0x8a564, 0x89c72, 0x2649b, 0xe8b5a, 0x8e759,
      0xdce8b, 0x434a0, 0x0c8d9, 0x04704, 0xbf512, 0x2d935, 0x7b8e8,
      0x1646a, 0x2ab3a, 0x81294, 0xd627f, 0x1583e, 0x7297f, 0x072d6,
      0x16a7e, 0x42b84, 0xcd39e, 0x85d86, 0xad496, 0x58ddb, 0x7fc79,
      0xe8a79, 0x5ce6d, 0x92815, 0xa558f, 0x36235, 0x70f8a, 0x5f4e5,
      0x7ae57, 0x05287, 0x69cfc, 0xebdbc, 0xa6b16, 0x193a9, 0xf18f4,
      0xb1cc1, 0xf43cb, 0x98d1d, 0x21e78, 0x30e5a, 0x723a8, 0x1df58,
      0x5df45, 0xec218, 0x00003 },
    { 0xbc2d7, 0xd71f0, 0x9d4c7, 0xd412b, 0xc6e51, 0x82c6c, 0x0f669,
      0xa09f8, 0x02d93, 0x9c92e, 0x47ae0, 0x2d250, 0x9b7dd, 0xf351f,
      0x49f37, 0x35031, 0x850be, 0xe1c77, 0x9d49c, 0xd2c86, 0xb12f0,
      0x242ac, 0xb9d60, 0x7bc28, 0x88c56, 0x50ba1, 0x6bc05, 0x61210,
      0x98e40, 0x7d432, 0xb1f8d, 0xb0d84, 0x951e0, 0xe7d38, 0x4a67a,
      0x7607b, 0xb8bc9, 0x27c57, 0xa72b5, 0x5497a, 0x3c5f3, 0x66bc9,
      0x9bdd6, 0xe8cc3, 0x35f1d, 0xd447a, 0xc5ce9, 0x3087d, 0x1abe5,
      0xb6a21, 0x9b356, 0x00008 },
    { 0xcc837, 0xafdfd, 0xd6db0, 0xb7a9e, 0xaa871, 0xb80ba, 0xb720f,
      0x1c1d4, 0xabfc9, 0x5c413, 0xdac9e, 0x6bf7a, 0x3f5b5, 0x8657a,
      0x2da8b, 0x5664a, 0x1d94e, 0x720e4, 0x1b04f, 0x36581, 0x63743,
      0xe11d2, 0xaea63, 0xf426d, 0x28ece, 0xc2ee6, 0xb162d, 0x19c9c,
      0x30116, 0x64864, 0x17f87, 0x9cf58, 0x4bc86, 0x02558, 0x1bb97,
      0x7928e, 0xf00bf, 0xc27ce, 0xee52c, 0xdc60e, 0x3a80e, 0xf94ef,
      0x7adc2, 0x02be8, 0x27e12, 0x0d4f5, 0x8e08a, 0x656f1, 0x5d126,
      0x0d57c, 0x9c4f1, 0x00003 },
    { 0xaecd3, 0x8ce88, 0x3a9b6, 0xaa9db, 0x8a518, 0x5b091, 0xe5455,
      0x4bd4e, 0x1cdad, 0x84edc, 0x2068d, 0x8b670, 0xd79b6, 0x1ac72,
      0x0d081, 0x7dac8, 0xa0a78, 0x35a81, 0xd1e6d, 0x62836, 0xa3bd1,
      0x41e9e, 0x444c8, 0x894c4, 0xc1775, 0x02a7b, 0x1aa12, 0x3725f,
      0x6f2b6, 0xd4c55, 0x67ec7, 0xbec77, 0xff51b, 0xb3d46, 0x817eb,
      0xe3392, 0xd73f7, 0xe5be8, 0x4c4fd, 0x5aed2, 0x6c977, 0xcf44c,
      0x6e579, 0x1707b, 0xc0b9a, 0x69fbc, 0x47890, 0xcff16, 0x52b00,
      0x2d491, 0x14b54, 0x00004 },
    { 0xe173b, 0x58606, 0x3c31e, 0x713a3, 0xb90e6, 0x7f4e1, 0x0af5b,
      0xdebb2, 0xfb512, 0x70425, 0x5120e, 0xc6170, 0xcc788, 0x13e4e,
      0x60290, 0x3ef05, 0x6e6d7, 0xac81c, 0xf9d35, 0x690a9, 0xf9450,
      0x31e88, 0x82ee1, 0x44af0, 0xf9b32, 0xa9708, 0xba2ae, 0xd66c1,
      0xcb2e4, 0x0db29, 0xa6e74, 0xaf1f4, 0x43007, 0x48d18, 0x4ab92,
      0x6a6c7, 0x8ed55, 0x338ef, 0x7a613, 0x270d1, 0xe623e, 0xbff48,
      0x608f5, 0x62fa9, 0x53c73, 0x4e851, 0x87444, 0x43977, 0xb8b2a,
      0x6ae00, 0x2678d, 0x00005 },
    { 0x6aeb4, 0x59df3, 0xdff1c, 0xc0ab5, 0xca92b, 0xd6653, 0xf8152,
      0x927a5, 0x3f496, 0x1f0e0, 0xdfd49, 0xd4142, 0xb8509, 0x71f89,
      0xc52a5, 0x258c2, 0x34485, 0x04933, 0xbd618, 0x9e092, 0xf3f7d,
      0x33e94, 0x9061a, 0x2c1bf, 0x418d3, 0x5cfab, 0xaa569, 0x490e5,
      0xff39c, 0xd2d7f, 0x96ef6, 0x0e411, 0x948a9, 0x750f7, 0xecd40,
      0x3b4f3, 0x2d305, 0x58f9b, 0x4c94b, 0x5d997, 0xe842a, 0x82b8e,
      0xf22f6, 0x9c1db, 0x623a5, 0xefcea, 0x614c8, 0x045ac, 0xceedd,
      0x5bc10, 0x040ba, 0x00007 },
    { 0xa1a96, 0x81515, 0xc364f, 0x27e02, 0x31843, 0xa6350, 0xd4f31,
      0x1ad93, 0x96650, 0x730a0, 0x73b61, 0x94f12, 0x29d76, 0xcda9d,
      0x876d2, 0x8886d, 0x4c177, 0x42281, 0xe01a7, 0x696b1, 0xb8667,
      0x92276, 0x00634, 0x5b25f, 0x4f0c6, 0x4a2fd, 0xb294c, 0x349ff,
      0xf6527, 0x1d336, 0xd8ade, 0xc1fe0, 0x3860e, 0xe8e7e, 0xf9a23,
      0xc31ea, 0x1b774, 0xd2b72, 0x84a97, 0x43657, 0x3e582, 0xa3fac,
      0x0f4ea, 0xff4e7, 0x8ff2d, 0x87324, 0xe1afe, 0x3d281, 0x1c9c1,
      0xd60bd, 0x043a6, 0x00009 },
    { 0xc7937, 0xfe766, 0x511a0, 0x3be31, 0xcabbc, 0x2ded5, 0x8ac1b,
      0xe0088, 0x160cc, 0xf32ac, 0x16200, 0x54bd6, 0x69287, 0xa2ea0,
      0x83d34, 0xb801c, 0xe106f, 0x3a9cb, 0xad7a0, 0xcd948, 0x2cedf,
      0x6b082, 0x88099, 0xe4069, 0x3463a, 0x63c3c, 0x597f6, 0xea4df,
      0x9fb12, 0xc92af, 0x83440, 0x2c8d3, 0xda154, 0xc64e8, 0x9bc85,
      0x801a7, 0x2db4e, 0x771fa, 0x9b295, 0x1e357, 0x2c138, 0x787bd,
      0xfaad0, 0x75dff, 0x6e45c, 0x3eac4, 0xa3cb7, 0xb0760, 0x25f35,
      0x483a1, 0x6362b, 0x00002 },
    { 0xc3e89, 0x28eef, 0x5c68d, 0xee712, 0x769e9, 0x0ee87, 0xb752d,
      0xaf5e4, 0x7bb86, 0x338b0, 0xb86b3, 0x9072c, 0xcdb70, 0x552ba,
      0x0eaff, 0xfd3d2, 0xda1e9, 0xb14c0, 0x5eeb2, 0x7145a, 0xa44f9,
      0x1f688, 0x48539, 0x1e06d, 0xbd310, 0x4921f, 0xea9cd, 0xf2a5b,
      0xa45e4, 0xbf21d, 0x464a7, 0x7b60d, 0xd5471, 0xc8054, 0x93f88,
      0xf2e91, 0x1bee0, 0xce53d, 0x2735a, 0xc1439, 0x26563, 0xee92c,
      0x6c6b5, 0xe0b29, 0xa9c86, 0xff59b, 0x23109, 0x452fe, 0xc935e,
      0x20555, 0xe952b, 0x00002 },
    { 0xf886e, 0xcad75, 0xa846b, 0xfc582, 0xed43d, 0x8a5db, 0xb86e6,
      0x007b1, 0xe45b6, 0xb5103, 0x55ff2, 0x2ec93, 0x9580e, 0x63ecc,
      0xf26a2, 0xbc702, 0xe5e33, 0x86181, 0x835b3, 0x20762, 0xc6c12,
      0x5113e, 0x56d02, 0x7fbd8, 0x26e3a, 0xb1a5c, 0xd6ebc, 0x3fb39,
      0x88ef8, 0x4d2fa, 0x3f2a4, 0x7aaa5, 0x1fa97, 0x3353b, 0xc14ef,
      0x9a307, 0x11755, 0x604a1, 0x7e0ff, 0xb0937, 0xd96b0, 0x732bc,
      0xb2f02, 0x4896d, 0x6a5c1, 0x53ef0, 0x4c9eb, 0x1c0a8, 0x78e4b,
      0x17303, 0x236d0, 0x00001 },
    { 0x4373b, 0x8fc08, 0x7481c, 0x97aed, 0x86460, 0xae476, 0x34b29,
      0x613bc, 0x0dfa0, 0xb0130, 0x34bc2, 0x714c9, 0x23712, 0x2be7e,
      0x6290e, 0x86524, 0x10800, 0x9fed0, 0x54fbb, 0x45765, 0x84231,
      0xec0b3, 0x282f0, 0x330a3, 0xaf594, 0x1765b, 0x06ef8, 0xe1a87,
      0x93bdd, 0x7530e, 0x27dba, 0x7d2c7, 0xc95cb, 0x6674c, 0xb0c5d,
      0x906db, 0x52438, 0xfcd36, 0x8f3b3, 0xd1465, 0x81941, 0xe9198,
      0xc97f0, 0xf5556, 0xae616, 0x9ec7e, 0xd854b, 0x353c2, 0xcb56e,
      0x14620, 0x2a480, 0x00000 },
    { 0xccd38, 0x3d506, 0x1d6d2, 0xbaa61, 0x49059, 0x9a1c5, 0x1c522,
      0x69d01, 0xc9c27, 0x7d717, 0x82893, 0x1b46d, 0x3e87e, 0x83508,
      0xbbb83, 0xf5d63, 0xac258, 0x27aad, 0x0a7b4, 0x4d1ff, 0xd9f15,
      0xab26b, 0x5fd99, 0x8ec95, 0x0ffbf, 0x80dec, 0x9fcb8, 0x7c674,
      0xeee95, 0x0114d, 0xdee1e, 0x32395, 0xf46c7, 0xb7369, 0x92a64,
      0x25991, 0x091eb, 0x04466, 0x3da43, 0xa2e8c, 0xda887, 0x18be2,
      0x3556d, 0x2c25c, 0x3a44e, 0x5f75f, 0x414b5, 0x31390, 0x17fe0,
      0x6f8f2, 0xd8bde, 0x00001 },
    { 0x28924, 0xf8a20, 0x3cd39, 0xcb9f0, 0xcb06e, 0x54f19, 0x8466e,
      0xd6f05, 0xbbcb7, 0x76862, 0xa0607, 0x67165, 0x0dbe0, 0x0fec1,
      0x97ab1, 0x9397c, 0xbb65c, 0x266f1, 0x42138, 0xba38f, 0xba672,
      0x4decc, 0x5e641, 0xf88b0, 0xd4d43, 0xd1594, 0xc94d4, 0xf57aa,
      0x87993, 0xb1763, 0xa6abf, 0x74fc2, 0xc655a, 0x5bb6f, 0x8196b,
      0x2139d, 0x4ee8d, 0x375c8, 0xa26dc, 0x360d3, 0x00a02, 0x87b9b,
      0xeb93b, 0xd35cd, 0xeb36e, 0x83209, 0x28bcc, 0xf565b, 0x013c1,
      0x43c61, 0x49c69, 0x00003 },
    { 0x6c88a, 0x444de, 0x1b394, 0x207ed, 0x14700, 0xc2c47, 0x780d5,
      0x21c2b, 0x458a2, 0x3eb6f, 0x85099, 0x75640, 0x8749f, 0xef0c1,
      0x579ba, 0x400ba, 0xc70f0, 0x38737, 0xd7429, 0x7ebf2, 0xc2146,
      0xa8e2e, 0x453c5, 0x5337f, 0xa666e, 0x0a243, 0xd0bd5, 0xf1c7e,
      0x1c991, 0xbd1f9, 0xe90f4, 0x3a7f3, 0xe129b, 0x8a5f0, 0x6089e,
      0x96359, 0x70738, 0xd3a17, 0xac9d0, 0x27182, 0x842d5, 0xc29cf,
      0x817c5, 0x52990, 0x92119, 0x25576, 0x27e87, 0xa32f3, 0x2d8fa,
      0xab89c, 0x56587, 0x00000 },
    { 0x4733d, 0xed1ce, 0x08562, 0x14440, 0xb98e5, 0xaff7c, 0x6b95f,
      0xa9ab4, 0x3021f, 0x135f0, 0x61a8c, 0x4c5eb, 0x68949, 0xb3597,
      0x03636, 0x57c95, 0x2d2f6, 0x8f2ac, 0xbe84c, 0x703e6, 0x89bd2,
      0x5b34d, 0xabb0e, 0x7e872, 0xd918f, 0xe1c4a, 0x4052e, 0x9e9fc,
      0xec2a8, 0x90b51, 0xe3f31, 0xc2cae, 0xf254f, 0x376ff, 0x8fd14,
      0x09725, 0x8883e, 0x3c0d6, 0x4386f, 0x0fb15, 0x0a0e9, 0x0063d,
      0x6caae, 0x764bf, 0xcc438, 0x1d0f6, 0x5653f, 0x815f1, 0xcdbde,
      0xedb86, 0xb87f2, 0x00001 },
    { 0xb15b1, 0xbb2b0, 0x5792b, 0xa7793, 0x7ce6b, 0xe4b5a, 0x779a3,
      0xdd8f3, 0xcffd9, 0xeffba, 0x298d1, 0x50bdc, 0x60054, 0x7031c,
      0x556c4, 0x0e3f5, 0x68066, 0x7a95d, 0x770f0, 0x52c20, 0x02d10,
      0x3e84e, 0xc54ce, 0x7aa8c, 0x0791e, 0xa3b05, 0xa3223, 0x1e73b,
      0x04d62, 0x63299, 0x94d39, 0x87b9b, 0x8056d, 0x477eb, 0xdf9cb,
      0xa0cc8, 0x8edfc, 0x430de, 0x0cae2, 0x9712a, 0xbf416, 0x99374,
      0x8848a, 0x3c778, 0xebe3f, 0xa3e59, 0x7b1c4, 0xb22b8, 0x5bc23,
      0xc43e9, 0xe0227, 0x00008 },
    { 0x0964d, 0xa8321, 0x00e22, 0x6eeb0, 0x5ff05, 0xcd5df, 0xad7dc,
      0xdaf1e, 0x73a1f, 0xe3021, 0x7cdca, 0x33e06, 0xcd028, 0xdcc90,
      0x4cb8b, 0x1cc57, 0x4b4f5, 0x14322, 0x6eca7, 0x82988, 0xabb3f,
      0x0e603, 0xdebd0, 0x0c1a8, 0xece1b, 0x1db98, 0x78c26, 0x46e43,
      0xd228a, 0x165e5, 0xd0da6, 0xc6f9d, 0xef0e2, 0x994b7, 0x3ae38,
      0xf306b, 0x3bda9, 0x3c16b, 0x4db3a, 0x38a08, 0xa26d3, 0x505e9,
      0x394e9, 0x59935, 0xc528e, 0xa206b, 0xb114e, 0x848ec, 0x45d6e,
      0xb5405, 0x4b15a, 0x00001 },
    { 0xc59a2, 0xc9664, 0xf6d86, 0x7aa50, 0x160fd, 0xfe2be, 0xb8e3d,
      0x9072c, 0x9b569, 0xe033f, 0x176a7, 0x25d98, 0xb5f23, 0x87080,
      0x4e745, 0x79a0d, 0xd4e05, 0xef0d5, 0x4ee0d, 0x28e1a, 0xac87b,
      0xad9ff, 0x4eec0, 0x3f09b, 0x18d2f, 0x87d6f, 0x92e9d, 0x6ae72,
      0xccc89, 0x94763, 0x53d60, 0xca889, 0xbf9fa, 0xa818f, 0xbee97,
      0xd701d, 0x94b63, 0x20e0e, 0x22fdf, 0x47ea7, 0xa6e30, 0x1fcbb,
      0x12b57, 0xe1ca6, 0x5ce57, 0x9a55f, 0xc7600, 0x1e16a, 0x89e2e,
      0xd8c43, 0x42bbe, 0x00007 },
    { 0xc2c73, 0xdcc1d, 0x3ea86, 0x3abf2, 0xbc164, 0xbbfd5, 0xa1f4b,
      0x24d8c, 0x8fa1f, 0xc707f, 0xcb5ca, 0xa6e08, 0xdde68, 0xe66a7,
      0x64b54, 0x7d54c, 0x7ad78, 0x22a9b, 0x89dba, 0xab947, 0x0e364,
      0x88d54, 0x0114d, 0x1f72e, 0x2e02d, 0x78c8c, 0x6e2a2, 0x60574,
      0xd4c82, 0x187c7, 0xbb34b, 0xe6c35, 0xfe0c9, 0xfeeb8, 0xd8b3d,
      0xe415e, 0x87d11, 0xbc34e, 0x7f9b6, 0xb865c, 0x08bbf, 0x7cb39,
      0x1ecc1, 0x1ce6e, 0xb717d, 0xcdd69, 0x308f7, 0x151e3, 0x94124,
      0x14b5c, 0x7bd5a, 0x00009 },
    { 0x82861, 0xfe81e, 0x01c62, 0xc40ee, 0xddd42, 0x3d4b6, 0x1e570,
      0xe65e9, 0x2e55b, 0xdd7e5, 0xabbbf, 0x93745, 0x4b8b4, 0x2a45f,
      0xf52c7, 0xb4f15, 0xf29d8, 0xa8550, 0xe8435, 0xe75fc, 0xb582d,
      0xf76b9, 0xb969d, 0xa20c8, 0x84c5f, 0xf452e, 0xa8a0a, 0xd2d10,
      0x3af77, 0x6013c, 0xbd8ca, 0x0389b, 0x8305f, 0xba26f, 0x0d9b9,
      0x8b9ab, 0x80cec, 0x53e84, 0xa18f0, 0xffabd, 0x3367a, 0x2a4d6,
      0x6424c, 0x3be4a, 0xe50f5, 0x4fba2, 0x58c86, 0xf892c, 0xc5469,
      0x3148c, 0x17c6d, 0x00003 },
    { 0x7d42b, 0xb02cb, 0xc3525, 0xacae0, 0x9310f, 0x240bc, 0x08f55,
      0xff204, 0xd2022, 0xa08d5, 0x0c10e, 0x402fe, 0xd6b01, 0x8eb23,
      0x68a71, 0x7fbef, 0x52a19, 0x5a412, 0x0146b, 0x0d6ea, 0x8110e,
      0xafce4, 0x18159, 0x022de, 0x1d27f, 0xdae9a, 0xc3f49, 0x6d16d,
      0x86db9, 0xbe400, 0x3f5ef, 0xfc1ae, 0xbc11c, 0x41ecc, 0x9d706,
      0x8636f, 0x9525f, 0x02227, 0xc3049, 0xc2763, 0x9796a, 0x0b376,
      0xd9063, 0x483c1, 0x79cc3, 0x3d3f1, 0x1f0ee, 0x45165, 0x0b8fd,
      0x399da, 0xae597, 0x00006 },
    { 0x4d2ee, 0xc7bff, 0x7b13b, 0x73d85, 0x930b1, 0x75422, 0x36c20,
      0x07949, 0x54bd5, 0xbeb62, 0xefd55, 0x232a5, 0x91d5f, 0x0c338,
      0xa854e, 0xc06f4, 0x1f944, 0x598e6, 0xf2c5b, 0x87b7c, 0xffd5f,
      0x64861, 0xa4cc5, 0x5a2af, 0x61fb1, 0x74ee2, 0xd97a7, 0x72262,
      0xab0ff, 0xcf007, 0xe22d6, 0x1a89a, 0x6f214, 0x34d34, 0x88805,
      0x497e2, 0xf97b6, 0xe73bf, 0xffc8f, 0xfa2af, 0x595b2, 0x268a8,
      0x151a7, 0xcf3ef, 0xb9ef9, 0x44b82, 0x5f1e7, 0xa84ee, 0x3fe72,
      0x8dbc6, 0x64904, 0x00006 },
    { 0xb760d, 0x781e8, 0x1b7bb, 0xdaa09, 0x825aa, 0x7b0bd, 0x26fd4,
      0xfab52, 0x93d9f, 0x8e814, 0xffc14, 0xd226b, 0xb4a6d, 0x9be3d,
      0xf8aa2, 0x5a032, 0x0ab0b, 0x7034b, 0x18dbc, 0x48683, 0x57d65,
      0xccbfb, 0xe46dc, 0x9c581, 0x6ab37, 0xe2850, 0x830ec, 0x6a6e2,
      0x70913, 0x6c80c, 0x356cf, 0x48b79, 0xb1e86, 0x77ef6, 0xa1763,
      0xf1c9f, 0x183f0, 0x9c1cc, 0xddd2c, 0x16abe, 0x0526d, 0xe496f,
      0x93b0d, 0x98e2a, 0xa3e0e, 0x13873, 0xada0f, 0x6f2d7, 0xa49ec,
      0x5cf3f, 0xeb93b, 0x00004 },
    { 0xfae32, 0xe5e11, 0xd89f7, 0x3f51b, 0x5c402, 0x3d74f, 0xf6fd1,
      0x491c3, 0x014df, 0xb71b0, 0x55279, 0x9a575, 0x81d84, 0xba006,
      0x89705, 0xbb9e8, 0xca2ca, 0x19c13, 0x22224, 0x676f8, 0x5fd33,
      0xbbb68, 0xa2aaf, 0x75878, 0xc3f52, 0x73931, 0xf3d51, 0xefefe,
      0x812ae, 0x8a687, 0xcc8bd, 0x189a5, 0xf0c16, 0xb3d99, 0x2cffd,
      0x48b68, 0x6a19d, 0x56540, 0x4e0bf, 0xe9c6c, 0x5e223, 0x72560,
      0x68041, 0x81de8, 0x853e7, 0x001cc, 0x90bc7, 0xcdf5c, 0x43f68,
      0x937c0, 0xb582d, 0x00002 },
    { 0xbc2ae, 0x8281a, 0x1165c, 0x9ecaa, 0x5e2b6, 0x3380f, 0x66fa7,
      0x07fff, 0x7b3d2, 0x06c09, 0x47765, 0x38265, 0xc5d60, 0x7fa21,
      0x9f3b5, 0xdcbac, 0xdbdd5, 0xb4c98, 0x8750d, 0xf32a7, 0x3d9ef,
      0xe2110, 0x41c85, 0x2f11c, 0xd172c, 0x09cee, 0xe348c, 0x92649,
      0xba8e3, 0x1eddf, 0x36b83, 0x71cb9, 0x864a3, 0x06f50, 0x15c3d,
      0xcfcd9, 0xde93a, 0x8e33c, 0x7aafe, 0xb3f2f, 0xe10d7, 0x9a4be,
      0xb7cee, 0xeb48e, 0xdc1d8, 0x574af, 0xce3fa, 0x4fa49, 0xdb4c0,
      0x09862, 0x86151, 0x00007 },
    { 0x72c21, 0x807ae, 0xfe3f4, 0x0da53, 0x4fd0f, 0x1aa14, 0x45463,
      0xf8c3a, 0xee1e8, 0xabc76, 0x1b4f1, 0xe0945, 0x4379a, 0xcdbb2,
      0x397d7, 0x2a3a4, 0xd5fcd, 0xfe82b, 0xa14cf, 0xef5a7, 0x2f427,
      0xe4ed1, 0xccfbb, 0x284d3, 0xa43ee, 0x1e9b0, 0xeec6e, 0x8b938,
      0xb57b7, 0xb8e87, 0x4e467, 0x18d40, 0x74c20, 0x05343, 0xc8adc,
      0xdeb50, 0x55428, 0x37360, 0x2cf64, 0xc3afa, 0x80ec0, 0xf9b4d,
      0xaa956, 0xf93c3, 0x86d51, 0x161c6, 0x8ab84, 0x9f9a2, 0x9c025,
      0xb76bc, 0x40b6b, 0x00005 },
    { 0xd315d, 0x4c321, 0x4e173, 0x05d00, 0x2d86e, 0xf5661, 0xd814e,
      0xbba8c, 0xae145, 0x9aeaf, 0xcdc78, 0x7a49a, 0xf1fb0, 0x77570,
      0x9ad58, 0x6a21e, 0xc53de, 0x7eb9b, 0xe4a83, 0x98eb2, 0x31d62,
      0x6db29, 0xf4543, 0xea362, 0xfbc78, 0x8543a, 0xabf65, 0x3d97a,
      0x02a97, 0x924d6, 0xabe0c, 0xdce7d, 0xdf0e9, 0xf07ca, 0x69d98,
      0x0538f, 0x17502, 0xb505a, 0xd29e0, 0x4461c, 0x7d1a3, 0x183db,
      0xe20e8, 0x87765, 0x6e1c2, 0xdd50f, 0x86752, 0x2ca25, 0x0388c,
      0x1492e, 0x97cab, 0x00008 },
    { 0xbab8a, 0x130d8, 0x9ed38, 0x200a5, 0xca438, 0x1d364, 0x415c1,
      0x40581, 0x7bf2c, 0x74068, 0xac896, 0x0d3a7, 0x086ad, 0x7411a,
      0x105b9, 0x44928, 0x3371c, 0x11f38, 0x4984b, 0x831e7, 0x40d1a,
      0xd2ed8, 0xfe070, 0x6c912, 0x3628b, 0xd2d88, 0x4fa88, 0xf7fb1,
      0xe44f8, 0x0ac93, 0xa4dcf, 0x564f2, 0x24fa6, 0xaaa6c, 0x2f629,
      0xd9498, 0x3bf6c, 0x906ba, 0x82dab, 0x20a51, 0x22e67, 0xa52c8,
      0x0eb93, 0x7dac3, 0xa2ff4, 0xf673a, 0x4a4ff, 0xdc62c, 0xb0ec5,
      0x63476, 0x4b007, 0x00006 },
    { 0x9a404, 0x3eb3c, 0xe3f53, 0x99521, 0x3b7ef, 0xdb7f7, 0x693b1,
      0x6c253, 0x13e29, 0xd4c7f, 0x738ee, 0xf4c40, 0x07ce7, 0x26cad,
      0xb33ce, 0xccfd3, 0xc5cf1, 0x3501e, 0x87849, 0x4e01d, 0xddc08,
      0x8fc09, 0xacf3f, 0xc39b5, 0xcab32, 0x1c217, 0xef555, 0xf0bb9,
      0x542da, 0x217a9, 0xf56e1, 0xfbc76, 0x7002a, 0x12c23, 0x0178b,
      0xa2938, 0xfb070, 0x52c39, 0x9640b, 0x576ca, 0x25153, 0x36e39,
      0x9d68e, 0x94241, 0x42555, 0xe50e8, 0x82c09, 0x291fb, 0x8ed8c,
      0xa6661, 0xdd22e, 0x00007 },
    { 0xbb3bf, 0x4b49c, 0xffe84, 0xfb257, 0x45562, 0x0cc70, 0x45ade,
      0x9f5a8, 0xee537, 0xfc1e6, 0x51277, 0x7f26e, 0x8956d, 0x63571,
      0x4b930, 0x2c75d, 0x57f34, 0x92969, 0x9a148, 0x742b3, 0x282e5,
      0xf4eb3, 0xb728c, 0x83247, 0xd3ddd, 0x376b0, 0x01a42, 0xf6332,
      0x567a9, 0x14a48, 0x3c114, 0x41640, 0x6a916, 0x47b6f, 0x0afd4,
      0xf7906, 0x0dac6, 0xf9493, 0xd8295, 0xbd3b9, 0xff94b, 0x0f685,
      0x1cadf, 0x98fc5, 0x95c8f, 0x3b748, 0x88ab1, 0x9559c, 0x8fcc8,
      0x665f1, 0x1377c, 0x00003 },
    { 0xfb35f, 0x097dc, 0x5c5de, 0x36f83, 0xf01cc, 0xccca9, 0xb632d,
      0x7576c, 0x3e85d, 0x757e9, 0x7b4b3, 0xd48af, 0x50c2d, 0x9a19b,
      0xd4fb0, 0x9d95c, 0xfe607, 0x5971b, 0x52ed1, 0xdad27, 0xf2596,
      0x9880c, 0xa6f43, 0x69e90, 0xefb53, 0x0ae52, 0x3d3e6, 0x76630,
      0x04409, 0x5070e, 0x4faa9, 0xfcf36, 0x24dd2, 0xb6056, 0x8f993,
      0xe467d, 0x400d5, 0x5a982, 0x524b3, 0x0c8f4, 0x9d024, 0x79e28,
      0x48a01, 0x423c6, 0xdef45, 0x7edab, 0x69558, 0x3a5fd, 0xe5271,
      0x0ca11, 0xdacc5, 0x00003 },
    { 0x9ae4c, 0x94649, 0xb3e4f, 0xc527c, 0x17053, 0x6dcbe, 0xe8aa4,
      0xbe782, 0xf5ce9, 0x45807, 0x8481e, 0x4d28d, 0x0b6c6, 0x286fd,
      0x518aa, 0xf35e4, 0xcdb49, 0xbadf1, 0x7b7b9, 0x3eaff, 0x0aec2,
      0xfb621, 0x2fbf3, 0xb9bfd, 0xba385, 0xa00a9, 0x807f3, 0x0d538,
      0x2e51a, 0x7b284, 0x404b1, 0x7ab24, 0xd9f0a, 0x87f9d, 0xfd576,
      0xdf646, 0x4f3e9, 0x1efdb, 0x94dcd, 0x60df1, 0x2df7a, 0x055dd,
      0x069df, 0xf2c3e, 0x1bed3, 0x248a3, 0x56123, 0x469b7, 0x744f7,
      0xe1694, 0x66949, 0x00008 },
    { 0xab07a, 0xa53f4, 0xa9a0d, 0x6fbf3, 0x3f54a, 0xd6f33, 0x2902c,
      0xb23cf, 0x2e921, 0x580c9, 0x48e3d, 0x1c3e8, 0xbc958, 0xb218a,
      0xfbdd3, 0x93af1, 0xcb4d7, 0xa1066, 0x8598e, 0x03a03, 0xe990c,
      0x01394, 0x7b550, 0x7d087, 0x64b1e, 0x913b6, 0x74c70, 0xb1bbd,
      0x0d79d, 0x2d5dd, 0x4354e, 0x852d4, 0x9db82, 0x1b332, 0xd2b84,
      0xd4800, 0x07b96, 0x844eb, 0xc46fa, 0xc295d, 0x50569, 0x4e37a,
      0x4f7ec, 0x83739, 0x7c2d3, 0x08317, 0x4ff5b, 0xdc388, 0xfa598,
      0xb88b1, 0x74352, 0x00005 },
    { 0xd7ce9, 0xf70d5, 0xd2193, 0x7eafe, 0x60b48, 0x19fd2, 0xfd03c,
      0x7be65, 0x4ab59, 0x567c4, 0x8270d, 0xa8607, 0x8dd9d, 0xa7019,
      0xc00ba, 0x8a84e, 0x985df, 0x49285, 0xec27e, 0x28d82, 0x0de20,
      0x6ccaf, 0x01d99, 0x61c22, 0x648c7, 0xeb4e7, 0x91c19, 0x35bc0,
      0xba963, 0xd6782, 0xa69f0, 0x253a3, 0x46493, 0x40d29, 0xf2043,
      0x68733, 0x1099f, 0x4521a, 0x11a44, 0x69960, 0xbcc09, 0x4e5fc,
      0x853a9, 0xd5d8f, 0x13884, 0xb6a3a, 0x624d3, 0x2418c, 0xe3c4f,
      0xf206a, 0xe431a, 0x00003 },
    { 0x381f1, 0x3983d, 0x967d9, 0x33c3f, 0xed0c0, 0x501aa, 0x76836,
      0x54410, 0xaf4d0, 0xd3bf3, 0x093a6, 0x15985, 0x0a86d, 0x2f290,
      0x741d9, 0x43ae0, 0x0b755, 0xa636f, 0xeb2af, 0x6d6ff, 0x3aa45,
      0x90a6a, 0x646d0, 0xaefdb, 0xa4fda, 0x7d336, 0xa942f, 0xfe441,
      0xefd1b, 0x1ee41, 0x3ed85, 0x7fc2a, 0x935c5, 0x8611e, 0xf1c96,
      0xb3434, 0x653bb, 0x57766, 0xc2acd, 0xad896, 0x931ba, 0x41f26,
      0x6bbfa, 0xbbd18, 0x18a0f, 0x03cef, 0xd82a2, 0x1c3d7, 0x64d35,
      0x15e26, 0xdad3f, 0x00006 },
    { 0xc35a1, 0x7d12e, 0x1940b, 0xb128d, 0x6e7df, 0x19c5b, 0x1d562,
      0xf1332, 0x278c6, 0xb62cc, 0x3c58e, 0x904a3, 0x35e76, 0x903c4,
      0xf55d9, 0x15090, 0x96a19, 0x26c3d, 0x61bc9, 0xcba70, 0x38c0a,
      0x4a9f0, 0x21b97, 0x7198b, 0x14021, 0x6f7a4, 0x8958c, 0x599df,
      0x9b069, 0xbd012, 0xf1dbe, 0x517f2, 0xa8dc3, 0x13df3, 0x109a6,
      0x75c51, 0x86723, 0xe5844, 0x2d308, 0x9383d, 0x90ba4, 0x7c565,
      0xbff83, 0xe7c60, 0xffc3e, 0xd2d55, 0x39027, 0xc87a5, 0x17a3f,
      0xd45f5, 0x438e9, 0x00002 },
    { 0x5af3c, 0x08881, 0x4a453, 0xbed5c, 0x2f3c9, 0x5f1a3, 0xddfe5,
      0x97b65, 0x1cdc9, 0xb5aef, 0x2e51e, 0x1d941, 0x061c6, 0x3f249,
      0xc54e6, 0xbd0da, 0x3e231, 0x9cd0b, 0xf1442, 0x60106, 0x2f1da,
      0x37c3c, 0xfb1f7, 0x6bbc4, 0x0e04b, 0xcb715, 0xbe281, 0x4c891,
      0xb205b, 0x701f5, 0x33cd7, 0xf1b46, 0x13490, 0x462a5, 0xb33ef,
      0xf7f28, 0x368f1, 0xb47c7, 0xb67dd, 0xbd416, 0xda511, 0xb3f4a,
      0xf795b, 0x97cdf, 0x79d2a, 0x200e6, 0x7b296, 0x00a8b, 0x30e01,
      0x11afe, 0x3f390, 0x00001 },
    { 0x0c827, 0xef7bd, 0xdd296, 0xff463, 0x34a29, 0x6110f, 0x15a50,
      0x1c9a5, 0x93068, 0x77f87, 0x68bca, 0x80452, 0xfde8d, 0x8045d,
      0x02499, 0xcbb83, 0x0e584, 0x1068c, 0xf90d7, 0x60623, 0x8263b,
      0x838ca, 0xd0b2a, 0x535c5, 0xbb5e7, 0x10293, 0x64151, 0x99d55,
      0x5ceea, 0xbda00, 0xad01b, 0xfe311, 0x8d018, 0xbfa4d, 0x497e0,
      0xb8662, 0x01cf2, 0xdd77a, 0xa8b33, 0xd8c4b, 0x75b73, 0xc9bc0,
      0x22b7b, 0x66d47, 0xb2984, 0xda1b0, 0xe24cb, 0x17a7c, 0x703b6,
      0x6b680, 0x58d4b, 0x00004 },
    { 0x4d8b2, 0x0e4d5, 0xa26a2, 0x0a0d8, 0xe4d32, 0xa5696, 0x70005,
      0xf994f, 0xb5858, 0xa8698, 0xf6549, 0xdc3c2, 0xd7a4a, 0x94d00,
      0x81936, 0x1812e, 0x402bd, 0x00730, 0x6b9b0, 0x64104, 0x9a1b3,
      0x0a144, 0x220e1, 0x99230, 0x95ea5, 0xc3eae, 0xb4820, 0x2e9b1,
      0xa3efc, 0xc9eb8, 0xcb585, 0xfe5b5, 0x47064, 0x19978, 0x1ae03,
      0xd49f2, 0x08f27, 0xef0b7, 0x56b68, 0x2f725, 0x9ef18, 0x1a325,
      0x24db0, 0x04576, 0xc00ae, 0x68f95, 0xb0656, 0x628e3, 0xbbf91,
      0xfab6f, 0xf13f5, 0x00005 },
    { 0xb0dc6, 0xae3a9, 0xc6ed9, 0x3ec87, 0x96f88, 0xa1bde, 0x677ae,
      0xea8b3, 0x6bf88, 0xabea6, 0xa66e3, 0x6abc9, 0xddefa, 0x217ff,
      0x17b68, 0xc4d33, 0xdf05c, 0xf2290, 0x741c8, 0x674ef, 0x77d11,
      0x0fdf1, 0x9ca1f, 0xc3598, 0x0ece7, 0x2dfdf, 0xb9c48, 0x92df6,
      0x70eed, 0xbf1ca, 0xe6655, 0x73713, 0xec99c, 0x9025c, 0x0acb2,
      0xe69c9, 0x2e803, 0xc9e3a, 0xa1a37, 0x17713, 0xa3c53, 0x4d7c0,
      0xf5a17, 0xc5656, 0x6350d, 0xf802f, 0xa4405, 0x11625, 0xba4a2,
      0x5da37, 0x19649, 0x00002 },
    { 0x42680, 0xd3131, 0x0cb2f, 0x4cf40, 0x765d1, 0x9e91d, 0x69eab,
      0xdfe26, 0x0ceab, 0xc5c6a, 0xae22b, 0xce580, 0x0beef, 0x6ec25,
      0x986cb, 0x3c2b7, 0x8f1ff, 0xa2d73, 0x4adb1, 0xc8ec8, 0x8516e,
      0x09bc2, 0xdb597, 0x8e8f7, 0x93129, 0xf9f36, 0x5b197, 0xfc6b9,
      0x4c48e, 0xaaa40, 0x9529a, 0x9ff10, 0x154b0, 0xbd144, 0xc3c8c,
      0x34352, 0x3427f, 0xef7bc, 0x7c133, 0xd2189, 0x17940, 0xa004a,
      0xce548, 0xc47d6, 0x25aa0, 0x56fa6, 0xea73d, 0x2971c, 0x75f08,
      0xb0044, 0x3ad0e, 0x00009 },
    { 0xa9963, 0x67988, 0xa0b69, 0xe8dd7, 0x76515, 0xe477f, 0x0f261,
      0x3b6b5, 0x4e386, 0xde627, 0x33922, 0xb8d5d, 0xd63a9, 0x7a5b3,
      0x3fb68, 0x3c38d, 0x2e323, 0x9c130, 0x8f6f0, 0xcccf1, 0x3e02f,
      0x4c05c, 0x2f725, 0x26e66, 0xed0b7, 0x79c04, 0x43fe0, 0x46b81,
      0xc1d56, 0x016c8, 0x448c9, 0xef8a9, 0x3d797, 0x4bf82, 0x5674c,
      0xe451e, 0xfbccd, 0x86f72, 0xade05, 0x4417e, 0xc88d5, 0x8dc5f,
      0x76e58, 0x22095, 0x92b95, 0x44d1f, 0xd4258, 0x4408d, 0x1c034,
      0xf0ea4, 0x3f8c3, 0x00007 },
    { 0x763dd, 0xc85df, 0x9534f, 0x18368, 0x33ac7, 0x1427f, 0x5a03b,
      0x6e8f1, 0x5be17, 0x8e0db, 0xb2088, 0x0944c, 0x61d39, 0x7caea,
      0x9ad85, 0x7804c, 0xf7bf3, 0x28519, 0xa5844, 0xa8cfa, 0x1293a,
      0x6eecf, 0x01562, 0xea36a, 0xe0d98, 0xcd749, 0x321ed, 0x6dae3,
      0xcefff, 0xb791c, 0xea628, 0x963de, 0x6e361, 0x522d1, 0x14e05,
      0xe206a, 0xcb15a, 0xe058f, 0x5e4a2, 0xfca32, 0x68745, 0x8a0f2,
      0x1341a, 0xd4072, 0x87cf9, 0xaa51b, 0x5d97c, 0xdfed2, 0xedd75,
      0x39adb, 0x108ae, 0x00000 },
    { 0x88f63, 0xf3a9e, 0x4d178, 0x73255, 0xeab0c, 0x05b11, 0x8a6aa,
      0xe261d, 0xa53e6, 0xc8773, 0xd0b91, 0x7dae8, 0xd24db, 0xbb004,
      0x073e9, 0xde10b, 0x3090b, 0xe754e, 0xc8bef, 0x9c89f, 0x90cc6,
      0xaf059, 0x11a16, 0x9d595, 0x83803, 0xfcddc, 0x6c5da, 0x5b994,
      0x9c3f6, 0xe0a59, 0xbe81e, 0xfbbe4, 0xa9b17, 0x36fb3, 0x8891e,
      0xad008, 0x5445d, 0x9aad7, 0xe1f0c, 0xd5097, 0xc46ab, 0xe1dff,
      0xc85a4, 0x089ba, 0x38848, 0xc4523, 0x42fa0, 0x348bb, 0x3c1df,
      0xd8eb1, 0x07c06, 0x00008 },
    { 0xe0ef6, 0xec98e, 0x0a969, 0xb7af0, 0x38bb7, 0x9d548, 0xfdbba,
      0xa02f8, 0x84c92, 0x7c244, 0xb7055, 0x201a8, 0x27bdb, 0xad1af,
      0x3e460, 0xe5934, 0xc95fb, 0x42998, 0x3a9a9, 0x1d3b5, 0xeda86,
      0x4db3d, 0xc0e97, 0xed399, 0x525c9, 0xbdce1, 0x72109, 0x6881f,
      0x489b5, 0x8211a, 0xd1599, 0x08ff7, 0xf275a, 0x3aef0, 0xdf76b,
      0x358b5, 0x7fa2f, 0xf180f, 0x63493, 0xc39b0, 0x4ffcf, 0x53aac,
      0x7583b, 0xc6261, 0xc2692, 0x5399f, 0xa36b5, 0xb2fdf, 0x07a61,
      0x6c996, 0x6424c, 0x00001 },
    { 0x744a9, 0x55dd2, 0xdd65c, 0xf4185, 0x2fe3a, 0x44c1c, 0x08925,
      0xefe8b, 0x82e99, 0x1a32c, 0x9df69, 0xab25a, 0x430b7, 0xe9967,
      0x5509b, 0x98384, 0x2d122, 0x58caf, 0xcecd2, 0x7272b, 0x8bcc7,
      0xae409, 0xa0c88, 0x4b8ef, 0x96141, 0x2cd43, 0xd64d1, 0x67b9e,
      0x444ff, 0x7f340, 0x5e42e, 0xa9e65, 0x0e9eb, 0x4545b, 0xd16fc,
      0xed283, 0x4f03d, 0x4a3e1, 0x85c47, 0xacccb, 0x9adff, 0x1ba3c,
      0x253a5, 0x6bc17, 0x13dfe, 0x5831b, 0x4b9fb, 0xdddaf, 0x4478a,
      0x02a4f, 0x544e6, 0x00005 },
    { 0x80b4f, 0x13baa, 0x97c53, 0xc8ef8, 0xf63bd, 0x22716, 0x5a801,
      0x7b42c, 0x742db, 0x8cae2, 0x88330, 0xe1e90, 0x1e9d9, 0x341ab,
      0xc3f2d, 0x352c8, 0x45870, 0x00ed9, 0x63d05, 0xd9d81, 0x3c290,
      0x49dd7, 0xd2983, 0x1f6c7, 0x3c5e0, 0x3c205, 0xb4203, 0x7446c,
      0x18310, 0xd09af, 0xbd209, 0x76c88, 0x94681, 0x6eb27, 0x0f70e,
      0xb540d, 0xe19b1, 0x0b59d, 0xb4372, 0x22994, 0x7ecdc, 0xcf80b,
      0xdec53, 0xcdce2, 0x2c1a4, 0xd60f4, 0xedd1e, 0xdd7d3, 0x1d261,
      0x5ce24, 0x73599, 0x00005 },
    { 0x37056, 0xfba02, 0xc4ba3, 0x3388d, 0x433ab, 0x56c16, 0x61268,
      0x271ec, 0xeebbd, 0xecc01, 0x3031b, 0xb033e, 0x5abde, 0x18a1f,
      0x41961, 0x4eee4, 0x00f33, 0x215b6, 0xc4974, 0x8773e, 0xf0886,
      0x7185c, 0xdfd1b, 0x7c1b7, 0xc46cd, 0x897b0, 0xa4c5e, 0xb2da4,
      0xdd143, 0x1ff94, 0x984bb, 0xdb9a5, 0xf3465, 0xe4c9c, 0xc3904,
      0x64c9a, 0x0eace, 0x729bc, 0x99af8, 0x768ad, 0x22821, 0xc25cc,
      0xa9540, 0xb0818, 0x7bbd3, 0x9a691, 0xd5f04, 0xe468e, 0x45ef0,
      0xdf3ec, 0x85486, 0x00008 },
    { 0xff464, 0x934bd, 0xa942c, 0xb4516, 0xf25a7, 0xb2719, 0x3243d,
      0x325be, 0x0070b, 0x39ccb, 0x9fe33, 0xa31b1, 0xf2055, 0x1ee8f,
      0xae824, 0xaca69, 0xf8def, 0x0855e, 0x607dd, 0x73c67, 0xf1a1b,
      0x24960, 0x8109e, 0x71d36, 0x0e8a2, 0xb9bcb, 0x885e6, 0x1aa26,
      0x929e1, 0x5eae1, 0x0ab18, 0x98b5d, 0x1f91c, 0xe40f8, 0xa0b96,
      0xc5031, 0xf994f, 0x0e8bc, 0x6e04d, 0xf119d, 0x81697, 0x0c33d,
      0xaa4ce, 0x3287a, 0x72908, 0x1ff9d, 0xd3ec9, 0xc5dd4, 0xb962d,
      0xe8d4a, 0x1cecf, 0x00003 },
    { 0xb21e8, 0x9afc8, 0x37bfd, 0x36df4, 0x3b194, 0xdd32b, 0x6a0e5,
      0x921c3, 0x902d4, 0x90fe5, 0x3d0fa, 0xe84da, 0xd8e9d, 0xb523b,
      0x6ad5b, 0x9663e, 0xd6975, 0x3faec, 0x800a2, 0xb59c9, 0x9b4fb,
      0x09c0d, 0xff110, 0xc9d20, 0xaa7bd, 0x3d839, 0xcd6fa, 0xf66de,
      0x9f502, 0x516ca, 0x4fbc5, 0x480ed, 0x42ac4, 0xf66c7, 0x5ffa5,
      0x52f86, 0x5ff32, 0x7c794, 0xb3d2b, 0x75d9c, 0xefc05, 0xd272f,
      0x6d6f1, 0x863bd, 0x311b0, 0x6a4ec, 0xcf09a, 0x5d8f3, 0x547b3,
      0x6ada2, 0x961b4, 0x00006 },
    { 0x5e2ac, 0x7ecb3, 0x07b58, 0x14d9d, 0xb57af, 0xd5546, 0x04c1e,
      0xdb28a, 0x17a5b, 0xf0eca, 0x09d54, 0x1d447, 0xea1f9, 0x6f400,
      0x9fd9c, 0xa6e71, 0xce190, 0xedfb8, 0xe4b88, 0x3fd24, 0xd246e,
      0x781ed, 0xf5df9, 0xb655a, 0x120e6, 0xa7d67, 0x3413c, 0x2d1d9,
      0x1da78, 0x07fa2, 0x0a297, 0x697e2, 0x84123, 0x3254e, 0xeb51f,
      0x1f9f1, 0xe3605, 0x254d9, 0xbe92e, 0x73ce5, 0xec42b, 0x4fdda,
      0xd3f79, 0xa32ec, 0x989a9, 0x81aad, 0x22f07, 0x1964e, 0x55212,
      0x0c537, 0xa63a9, 0x00006 },
    { 0xacbbb, 0x003d7, 0x6554e, 0x61087, 0xab74f, 0x01668, 0x19b2c,
      0x388c5, 0x29672, 0x4fe4a, 0xeb94d, 0x77143, 0x60166, 0xd6d2f,
      0xcdf0c, 0x086a3, 0x70f7f, 0x217b3, 0x86580, 0x3e7cf, 0x15a4d,
      0x8880c, 0x4a165, 0x5ba3f, 0xd5816, 0xddd6e, 0xca471, 0x78135,
      0x6abcc, 0x44a57, 0x074e8, 0x809bf, 0x502ea, 0xb36ea, 0x53a81,
      0x1ed3a, 0x70e02, 0x0b930, 0x165c2, 0x8617f, 0x7f892, 0x0b8c2,
      0x235cd, 0x64468, 0x1a547, 0x55296, 0xffd82, 0xffc89, 0x1d90e,
      0x22d15, 0x1ed4a, 0x00005 },
    { 0x701b4, 0x3a449, 0x7d696, 0xcaf23, 0x3bb27, 0x8d91a, 0x65fea,
      0xb5729, 0x9be15, 0x7d3ef, 0xb50bf, 0xa055d, 0xb75a7, 0x643b9,
      0x80ece, 0xfd674, 0xb5d5e, 0x2d6ce, 0x2a60d, 0xc897f, 0xc5ed7,
      0xfc320, 0x85f68, 0x28ce6, 0x53cf6, 0x5e41c, 0x10661, 0x711f7,
      0xc0e29, 0x500ec, 0x13823, 0x7a872, 0x9fe48, 0x606c2, 0xf0a92,
      0x9712a, 0xae1ef, 0xdf3f2, 0x9bf93, 0xd2d16, 0xf6fb1, 0x3c0d5,
      0x4a979, 0xfe267, 0x6eb7a, 0xf4925, 0x94ae9, 0x4173d, 0xb5ce5,
      0xbc2b8, 0xd6951, 0x00002 },
    { 0xe222e, 0x9f904, 0xd007d, 0xe109d, 0xf86f4, 0x3f248, 0xeee33,
      0x8f429, 0x94e8b, 0x18d49, 0xfc775, 0x3415c, 0x12957, 0x0f42f,
      0xa3a0b, 0x6e7fe, 0x43519, 0x7dc27, 0x795cb, 0x71a0c, 0x6711e,
      0x0a8f6, 0xf5582, 0x2b874, 0x95d9c, 0x2783d, 0x70e16, 0x4d78e,
      0x2d4b6, 0x92a74, 0x3f58b, 0x92435, 0xb5e6d, 0xb1447, 0x22048,
      0x31a03, 0xcbcf9, 0xad730, 0x2680b, 0xa7af2, 0x4d089, 0xf975c,
      0x83b93, 0x04c1b, 0xe4649, 0x5b3ae, 0xa0216, 0xa24eb, 0xcc5f0,
      0x78e08, 0x5c48e, 0x00006 },
    { 0x22c22, 0xcede2, 0xa1c73, 0x23b41, 0xdfcea, 0x83d8c, 0xb0656,
      0xb2143, 0x1cb14, 0x77030, 0x9fcec, 0xdf8f5, 0xf284a, 0x204ce,
      0x81c31, 0xfb1c5, 0x35107, 0xee947, 0x54d3e, 0x88c0f, 0xb4d31,
      0xf67f0, 0xd12db, 0x10f18, 0x3f2d1, 0x1376a, 0x7d3e0, 0xfa280,
      0x03809, 0xe7ece, 0xa4625, 0xf06f0, 0x95d2e, 0xedb28, 0x82867,
      0x553ad, 0x908b0, 0x06f48, 0x445e1, 0xef245, 0x80fa6, 0xcbe22,
      0x8d9a3, 0x5785a, 0xd402d, 0x38ba2, 0x9ffd4, 0xf63dd, 0xb226f,
      0x2c7a6, 0x6b5cd, 0x00003 },
    { 0x679a7, 0x20545, 0x7ff4e, 0xc7508, 0x14520, 0xd80b4, 0xcd864,
      0x9b459, 0x357fa, 0xa390a, 0x85af1, 0xaf39c, 0xea19e, 0x935a5,
      0xd798d, 0x0d475, 0xa678a, 0x83781, 0x45019, 0xe8107, 0x90cc2,
      0x83977, 0x24474, 0x2f412, 0x21d11, 0x37c6a, 0x6a51a, 0x85f93,
      0x88d0e, 0xa74df, 0x51eea, 0xff501, 0xf99c4, 0xa793c, 0x4e182,
      0x9ab61, 0x1376a, 0x593df, 0x9ff45, 0x52238, 0x73caf, 0x8a18f,
      0x7445e, 0xc960f, 0x8d27c, 0xa51dc, 0x4c539, 0x0692f, 0x9bfd8,
      0x44db3, 0x8d7c1, 0x00000 },
    { 0xca773, 0x963ec, 0x09c0d, 0x21568, 0x2d48c, 0xea919, 0x64187,
      0xdb6bd, 0xccd74, 0xdff0e, 0xa678c, 0x23742, 0xe7731, 0x587b7,
      0xd8bd1, 0x7a966, 0x0a4c6, 0x01613, 0x3c1a1, 0x17bdf, 0x85fce,
      0xc6e83, 0xaa47c, 0xa8de7, 0x95bb8, 0xe395e, 0x98308, 0xe8b58,
      0xa3fe1, 0x47694, 0x43ee3, 0x01972, 0xcd2bf, 0x42bb0, 0x3fe9c,
      0x2b49f, 0x40f9b, 0x90526, 0xd1fb5, 0xc7367, 0x85e8b, 0x7b4c3,
      0x5ee14, 0x50aeb, 0x91d30, 0x004ad, 0x87904, 0x8e2c3, 0x70202,
      0xeebab, 0xf2aa8, 0x00005 },
    { 0x6524b, 0x64126, 0x208d4, 0x9f66e, 0x0d0a1, 0xbf388, 0xebfb7,
      0xda106, 0xa685e, 0x46a5a, 0x642dd, 0xe8d3e, 0x60a69, 0x82e4d,
      0xc61c6, 0xef349, 0xb534c, 0x3b0fc, 0x6f6ee, 0x67b82, 0x705eb,
      0xaba12, 0x5f67d, 0x18be0, 0xbb27e, 0xd12ba, 0xe2d85, 0xfcba8,
      0x6959a, 0xd9d38, 0xd1ae2, 0xedcf2, 0x6f06e, 0xe61ea, 0x9dc52,
      0x5ae85, 0x4866e, 0x8278b, 0x3c7c2, 0x02bcd, 0xf0340, 0x2fd9f,
      0x84be8, 0xac767, 0x4e884, 0xc9f22, 0x98083, 0xa3164, 0xff949,
      0x98b46, 0x2501a, 0x00006 },
    { 0x64086, 0x9aad2, 0x63f7d, 0xe4bd5, 0xba5e0, 0x6a33d, 0xd67ca,
      0x8c8d3, 0x53002, 0x19e82, 0x6e64b, 0xdac84, 0x6a288, 0xaa453,
      0x19720, 0xfa3c9, 0x53eac, 0xb0ed5, 0x130c9, 0xabd38, 0x02ea8,
      0x2806e, 0xe7762, 0xceccf, 0xbf54d, 0x7052f, 0xf0d1b, 0x8e314,
      0x1bd9a, 0x9b174, 0x133d5, 0x519d2, 0xfea8a, 0x1c9a6, 0xd7410,
      0xeb10f, 0x0b5c4, 0xacf7a, 0xa5ed1, 0x91f9d, 0x99b73, 0x86784,
      0x0dea5, 0x4c49c, 0xaabaa, 0xf3531, 0xf73a1, 0xcc9c5, 0xfc665,
      0xfefd3, 0x97b15, 0x00004 },
    { 0x568e9, 0xaaf45, 0xa56cb, 0x2a6f8, 0xec719, 0x91a0f, 0x39af4,
      0x9ab25, 0x03dd3, 0xa9dbb, 0xac37d, 0x22f84, 0x4c865, 0xa0f5b,
      0xba202, 0x8c8cd, 0xc539f, 0x75a29, 0x109fc, 0xf02e8, 0x1ca90,
      0xd06d3, 0xdbf9c, 0x3e216, 0x1f044, 0x918f3, 0xa3ebd, 0x68acb,
      0x499aa, 0xc007f, 0x0d242, 0x2a80d, 0x9b7ce, 0xbf86a, 0xd8dff,
      0x8edcd, 0x4d630, 0x5d3e8, 0x2ca40, 0x06801, 0xa33fe, 0x71daf,
      0xdea10, 0xbd13e, 0x6c2ee, 0xf637e, 0xe5c2f, 0xb7ae7, 0x14cb7,
      0x6c9e5, 0x8d46a, 0x00001 },
    { 0xb7802, 0x22a78, 0x68cbb, 0xbaf48, 0x2497c, 0x45ddb, 0xadd07,
      0x42ae8, 0xb2f3e, 0xe4c4e, 0x4ceb4, 0xbcdab, 0x0ac0a, 0x25fd4,
      0x325a3, 0x2e0d8, 0xc7345, 0x7113a, 0xcfe05, 0x71b96, 0x8b141,
      0x07a78, 0x52b74, 0x6da7a, 0xb0603, 0xac70e, 0x85176, 0x36f9d,
      0x3ab0b, 0x2954f, 0xd297c, 0x14109, 0x705ad, 0xc8dcd, 0x70de9,
      0xe7513, 0xd7bb5, 0x0db5c, 0x08c3f, 0xa06e7, 0x93d41, 0x0d45f,
      0xe9305, 0x4f8a7, 0x910d5, 0x38fef, 0x8e45a, 0x69e6f, 0x62e40,
      0x01d3f, 0x50446, 0x00005 },
    { 0xb9cc9, 0x1006c, 0x1c5c9, 0x0014d, 0x741d0, 0x2074d, 0xfb854,
      0x11236, 0x8663e, 0x827cd, 0x9ad5f, 0x1ffe2, 0x33972, 0x51fc8,
      0xbfa29, 0x1d21f, 0xd144f, 0xe7400, 0xcde06, 0x2e6b1, 0xb9179,
      0x42596, 0x16690, 0x29ad5, 0x5c8e5, 0x98336, 0xaeefe, 0x0e859,
      0x3e222, 0xc2aee, 0x18970, 0xbcb53, 0x100bc, 0xdb9ff, 0x77ca3,
      0x973f4, 0x6f532, 0x07417, 0x01b27, 0x9a2bd, 0x118ac, 0x93a12,
      0xdd79f, 0x52093, 0xbf342, 0xf5d7d, 0xff7c6, 0x563a8, 0x0ec4f,
      0xfcd7b, 0xda313, 0x00000 },
    { 0xa2557, 0x8c15a, 0x7125a, 0x3e9c3, 0xc0089, 0x21d70, 0x823ca,
      0x67b8a, 0x13994, 0x2a487, 0xcb004, 0x9a747, 0x80d3e, 0xe2ce1,
      0x4ffc9, 0x2d2bf, 0xaeac2, 0x0d049, 0x5531a, 0x0660d, 0x6f03d,
      0x29a61, 0xf004d, 0x1f1b7, 0xd50d6, 0x0c473, 0xa3de5, 0xecbbc,
      0x73af0, 0xc28f2, 0xbea09, 0xe2959, 0x04664, 0xa0f87, 0xd7c2e,
      0x83ef6, 0x17310, 0xfae4e, 0x554ad, 0x941c2, 0x40c26, 0x03509,
      0x1162d, 0x7410a, 0xe4416, 0x82290, 0x0d81e, 0x62023, 0x14acc,
      0xe8db4, 0x3630b, 0x00006 },
    { 0xd2e41, 0x228a7, 0xf8d52, 0xf879b, 0x3eb62, 0xe7582, 0xd8949,
      0x6c402, 0xd33dd, 0xad1b4, 0xe2c59, 0x04d6d, 0x8883e, 0xb9dc3,
      0x8f449, 0xbf3f3, 0x70c4c, 0x18b4b, 0xd997d, 0xa0459, 0xc13ce,
      0x69b20, 0x06d1f, 0x58e26, 0xd7025, 0x79ca3, 0x61d1b, 0xd9772,
      0xa3d4f, 0x1436f, 0xfa85a, 0x56aea, 0x43c07, 0x98bb4, 0x69b3e,
      0xf6be3, 0xce558, 0xe5186, 0xf89fc, 0xf8ac8, 0xcd478, 0x72eb0,
      0x5e5aa, 0x4f37d, 0x06807, 0x544eb, 0x5c068, 0x29584, 0x688ed,
      0x71f16, 0x06a98, 0x00003 },
    { 0xec136, 0x9d634, 0xc451e, 0x658fb, 0xa0e6f, 0xdf27c, 0x1201e,
      0xc0db4, 0xe0152, 0x67a9b, 0x5bfee, 0xef20c, 0x387b6, 0x2d602,
      0x2389a, 0x35283, 0xfb899, 0xd8c7a, 0x0e564, 0xc2de6, 0x00ac9,
      0xf22bc, 0x22b4a, 0x82a9d, 0x6f631, 0x1b28e, 0x53270, 0xc701f,
      0x1c075, 0x075f9, 0x8f882, 0xf6d41, 0xaa511, 0x8d1be, 0x9fa62,
      0xa13df, 0x76e72, 0x1e7a1, 0x01c55, 0x77f4c, 0x6215b, 0x88930,
      0x3c9d5, 0xa7319, 0x471ab, 0xe57cd, 0xbe058, 0x6443e, 0x03e37,
      0x41e81, 0x833ac, 0x00002 },
    { 0x5ec5c, 0x868da, 0xe564b, 0xdb247, 0x81c08, 0x3d9da, 0x728ac,
      0x8c57a, 0xc1f0b, 0xc29d7, 0xd343d, 0xafe79, 0x93512, 0xc6033,
      0x4cffd, 0xb438e, 0xa1941, 0x00dcf, 0xd5a27, 0x04497, 0x82732,
      0xf323f, 0x6e6d5, 0x1393c, 0x7a58e, 0x311b8, 0x4baa4, 0x8bd10,
      0x7ecb6, 0x22b4d, 0xc5a47, 0xc09c1, 0xb5faa, 0x97206, 0x42faa,
      0x327ef, 0x69976, 0xdcbcd, 0x7d9e1, 0x08778, 0xba9e4, 0x91655,
      0xe5c01, 0xc757d, 0x8bd59, 0xcf353, 0x0ed0b, 0x67302, 0xd6303,
      0x54a49, 0x20cd4, 0x00001 },
    { 0x0f9ee, 0xf4cab, 0xbfdb8, 0x58eee, 0x02cce, 0x003ef, 0x665bc,
      0x5a8d0, 0xa6841, 0x749b6, 0xb9577, 0xd3a69, 0xc642e, 0x21ab5,
      0x7f047, 0x3de48, 0x4f0d3, 0x8021a, 0xf2ff3, 0xddcde, 0x829db,
      0x16f55, 0xff2bd, 0x0e93d, 0x05b4b, 0xc12ef, 0xbc9ae, 0xaa120,
      0x2de1f, 0x67fa9, 0x2c2d4, 0x66dae, 0x33e34, 0x645eb, 0x58daf,
      0x03cb7, 0x68f01, 0x7ad9f, 0x430a6, 0x9be02, 0xf693a, 0xbc151,
      0xb4054, 0x8496e, 0xed569, 0x19336, 0x77e70, 0x8ef16, 0xeea3e,
      0x167fd, 0x21cfd, 0x00000 },
    { 0xc36f3, 0x5fdf5, 0xc7371, 0xd2545, 0x7d64a, 0x3bde3, 0x71370,
      0xf2cf7, 0x68d10, 0xc8553, 0xf3993, 0xc7b70, 0xa1e5e, 0x4ae4c,
      0x77630, 0xfdb16, 0xbb18b, 0x7e3d3, 0xd8f71, 0x3d5a0, 0xf6634,
      0x67073, 0x8b552, 0x15600, 0xb52ef, 0x0ffae, 0x24a47, 0xd5f92,
      0xab97a, 0x2ab51, 0x391ed, 0xaf86e, 0x4302c, 0x57997, 0xc0c7e,
      0xe28ad, 0x7fd0a, 0x8fa81, 0x59cc8, 0xbf8ed, 0xc22df, 0xb6807,
      0xb128b, 0xc231e, 0x35ded, 0x0595a, 0xd9ca2, 0x71edc, 0xcf78e,
      0x46c73, 0x7265b, 0x00000 },
    { 0x6232f, 0xf0bd6, 0x3dd99, 0x77167, 0x9c402, 0x9aaf8, 0xfc4c5,
      0x5b860, 0x26dfa, 0x3baf8, 0xa943f, 0xa8aa7, 0xd239e, 0x3c428,
      0xb1a52, 0x0e0e1, 0x3b95a, 0x3a697, 0x5ea0e, 0x753b5, 0xa2557,
      0x399ca, 0xb1fea, 0x06957, 0xdf72f, 0x02f8a, 0xbd343, 0xf3413,
      0x70389, 0xa43a9, 0x7d0f8, 0x333f2, 0xf796f, 0x08ada, 0xd9c0c,
      0x2aa2c, 0xb49c1, 0xcca49, 0x6e96d, 0x7a0ac, 0x8deee, 0x0edd8,
      0x64408, 0x575d0, 0xd8f47, 0xc2f4b, 0x67d0c, 0x6e9d6, 0x1496c,
      0x4b31d, 0x6c575, 0x00003 },
    { 0x3d84b, 0x6ef32, 0x12004, 0x9c4f9, 0x27e78, 0x99112, 0x055a6,
      0x921b8, 0xeaf4e, 0x4e4b0, 0x07997, 0x844a8, 0x96339, 0x0f8c7,
      0x66a74, 0xc9054, 0xdef49, 0xf7cd6, 0xc18d0, 0xe4ba1, 0xb4b23,
      0x97da6, 0x0c552, 0xc4180, 0x9dff3, 0x771c0, 0x7ef67, 0x075b3,
      0xd6c49, 0x513de, 0xa4050, 0xa94c3, 0xb1705, 0xe96b0, 0xd6742,
      0xf5ae3, 0x4c48a, 0x78449, 0x2dec0, 0xc9582, 0x01532, 0x4f40c,
      0x164d9, 0xade5c, 0x5a2dd, 0x975eb, 0xac9a2, 0xfc8a8, 0x6944e,
      0x61194, 0x6fbf8, 0x00000 },
    { 0x5aa97, 0x8e3f4, 0xd6533, 0x0feb2, 0x81d04, 0x3b58c, 0x8b9d8,
      0x0fdef, 0xef59b, 0x7c05f, 0x4d741, 0x071ae, 0x37beb, 0x0a1a2,
      0x1f5b3, 0x982b6, 0x5bd03, 0x2afb6, 0xc5f2a, 0x6bf34, 0xd5cbf,
      0x0abc9, 0x2a5e4, 0xf0661, 0xc326d, 0x28422, 0x571ae, 0xe69d9,
      0xec921, 0xd3434, 0x10b23, 0x7c88b, 0x07933, 0x579da, 0x6d2e9,
      0xcf4d9, 0x13619, 0x3d46a, 0xfa183, 0xd95ee, 0x19653, 0x0ed9d,
      0x03e8f, 0x8411a, 0x12a7d, 0xbb5ab, 0x95304, 0x5e642, 0xfa9ea,
      0xfd1f0, 0xe9ca0, 0x00005 },
    { 0xc5dc4, 0x71197, 0xbd545, 0x95a25, 0xfe78a, 0xda40b, 0xeb2e2,
      0xffdb0, 0xb9efc, 0x7c65f, 0xd1746, 0xdc2c0, 0x3e952, 0x58c6a,
      0xc7bc7, 0xc1fc9, 0x34a9a, 0x2cd40, 0xc7956, 0x4b56f, 0xe61f6,
      0xe36fb, 0x28b26, 0x1e847, 0xc4b9e, 0x8a6ad, 0x8f9ac, 0x5fd3a,
      0x37f16, 0xe3e01, 0xa4503, 0x7bc93, 0x478e3, 0x13656, 0xacc55,
      0xdc77e, 0x7064d, 0x39171, 0x914d3, 0x76936, 0x318dc, 0xa675b,
      0x62424, 0xf1c73, 0x469b1, 0x955f3, 0x45b49, 0x8cc20, 0x36af8,
      0xb3c68, 0x40622, 0x00009 },
    { 0x97973, 0xb70d9, 0x710cc, 0xf1154, 0xdd3f8, 0x29625, 0xbd53b,
      0x5b97a, 0x0c4d5, 0xa58cf, 0x73e14, 0x1e0a6, 0x6c632, 0x26224,
      0xf9d3d, 0x0541a, 0x83b11, 0x546fc, 0xe6d87, 0x52a4d, 0x8f016,
      0xe97da, 0x2b647, 0xad980, 0x2b3a6, 0xb20f8, 0xe9c44, 0x4075a,
      0x769aa, 0xd2bf7, 0xde2ce, 0xaf3f5, 0xa40da, 0x8a497, 0xef1ea,
      0xba9c1, 0x83c23, 0x0f860, 0x2c82e, 0xf190a, 0x998a4, 0x68d8a,
      0xfde33, 0x9c8cc, 0x1e2b4, 0xe6bd7, 0x824bd, 0xb9f49, 0xbedb6,
      0x64785, 0x0bb16, 0x00008 },
    { 0x45cb5, 0xfefd1, 0x5e575, 0x68830, 0x1ac5e, 0x5ee56, 0x27315,
      0x8793b, 0xe70cf, 0x38461, 0x33b23, 0x53de1, 0x79f15, 0xa7ba0,
      0x0c3a2, 0x2fb9e, 0x086fa, 0xa83e7, 0x3bfd6, 0xcb93c, 0x08bb4,
      0xba850, 0xdbdb6, 0x76f82, 0x6d789, 0xff0b6, 0x4eb49, 0x6ff65,
      0x27d5a, 0x20b32, 0x2371f, 0xcd65d, 0x29cdc, 0xc254e, 0x9ea49,
      0x8ff97, 0x3cb11, 0x97596, 0x00b64, 0xcc580, 0x598dd, 0x9c969,
      0x10c77, 0x79181, 0x59510, 0xb85a3, 0x54863, 0xedfc1, 0x12350,
      0xea412, 0x77ba5, 0x00000 },
    { 0x86f61, 0xd3cdd, 0xb3a38, 0xa0ab0, 0x50502, 0x12144, 0x27243,
      0x806d0, 0x2edc5, 0x0f191, 0xa32f1, 0x1f988, 0x001dc, 0x80c76,
      0x1d10e, 0xbb1d3, 0x4e8b3, 0xe5f46, 0x46ec7, 0x49eed, 0x69abf,
      0x69af3, 0xe77d5, 0x2cdad, 0x86ea7, 0x209d2, 0x5ad59, 0x020d4,
      0xf2be7, 0x99ae7, 0x36e62, 0xabe52, 0x55c07, 0xbdd3f, 0x93179,
      0x0e80c, 0xa5235, 0x38995, 0x58681, 0xaff07, 0x1265c, 0x53090,
      0x47396, 0x81b2f, 0x15b3c, 0xc77d2, 0x81d9b, 0xbaf75, 0x1a2e2,
      0xdf459, 0xb2006, 0x00006 },
    { 0xb1bc1, 0xa8965, 0x2fe50, 0xb4fdb, 0xa962b, 0x1f536, 0xf9993,
      0x000e7, 0x18d33, 0x5ed57, 0x3d512, 0x8f255, 0xf8472, 0x125ca,
      0x184d2, 0x4f8a6, 0xf679e, 0x01357, 0x4f1a7, 0xc05a5, 0xc1531,
      0xa9f40, 0x77570, 0x6fa8b, 0x0cb97, 0xe910d, 0xdc12c, 0xf41e9,
      0x4b476, 0x55f89, 0xa7527, 0x5c8d7, 0x741a4, 0x10625, 0x6c12e,
      0xb16cd, 0x8c917, 0x2a6fb, 0x0a026, 0x38d6b, 0x116e6, 0x8324d,
      0x2c38e, 0x40c03, 0xc8495, 0x868af, 0x11c66, 0x855b9, 0x6b550,
      0xa6bd2, 0x3217e, 0x00005 },
    { 0xf52b4, 0x73259, 0xc8404, 0x146cf, 0xbe621, 0x8da9c, 0x26e96,
      0xcacbd, 0xeb85e, 0x44964, 0x4a543, 0xaa2de, 0x7ab7d, 0x1a4ff,
      0x84838, 0x6dc3b, 0x815ef, 0xb341c, 0x07a96, 0xb1e1a, 0x8c3d4,
      0xfae9e, 0xea8c4, 0x42ce9, 0x38d1e, 0x2f0f9, 0x5cc05, 0xdacc3,
      0x7a727, 0xa06f0, 0x1c9e9, 0xc81e0, 0xd65a1, 0xcb4a6, 0x9e08d,
      0xa9a6a, 0x36044, 0xe2d17, 0x95bf8, 0xf2bd2, 0x93dd0, 0x12998,
      0x9781b, 0x3379f, 0x2a08d, 0x830ac, 0x00161, 0x64bd6, 0xdbeef,
      0x1ed9a, 0x38693, 0x00000 },
    { 0x885a5, 0xb3d09, 0x0d7ab, 0xbb07d, 0x7e355, 0x9d2b6, 0xaeded,
      0x536eb, 0x238cf, 0xd63bc, 0x99ce4, 0x2e786, 0xd61ca, 0x1594c,
      0x44711, 0x354ff, 0x16ad2, 0x09033, 0x5cbe7, 0xf5c45, 0xd49ff,
      0x8679f, 0xc4041, 0x0f9c6, 0xacd75, 0x1a75b, 0x97272, 0xdc882,
      0xf677e, 0xef502, 0x887e5, 0x82596, 0x20e0e, 0x67bf3, 0x59e93,
      0xccb24, 0xf8bbd, 0xce36e, 0x63d81, 0xb7668, 0x097fc, 0xb81ba,
      0x58c6d, 0x21d6d, 0xbcd3a, 0xa8748, 0x7cdb4, 0x0e496, 0x41c20,
      0x49150, 0xcaaf7, 0x00002 },
    { 0x20424, 0x066ed, 0x4f980, 0x15454, 0x32247, 0xe4ea2, 0xc86b3,
      0x781a8, 0xed1a5, 0x0b268, 0xae5b7, 0xab757, 0x248d0, 0x6d398,
      0x32035, 0x6ca8b, 0x31fa4, 0x812df, 0xce8e6, 0xdcf29, 0x2d925,
      0x09d23, 0x3deb9, 0xf5672, 0xc8f78, 0xf9302, 0xbac96, 0x5d69a,
      0x01172, 0xd1a17, 0x7ca57, 0x656a4, 0xa2be7, 0x11c18, 0xbb5d5,
      0xd9d96, 0x1ad50, 0x6e45f, 0x518b5, 0x70b05, 0x886e2, 0x9136e,
      0x9d8ff, 0x1f3d0, 0xec7c7, 0x50361, 0xbe293, 0x65a1b, 0xe3bd8,
      0x3245f, 0x6d7f5, 0x00008 },
    { 0xf719a, 0xb6b0b, 0x9f16e, 0xd9139, 0x88bc3, 0x97509, 0x1b4b6,
      0x26cd0, 0x50e52, 0x1cfae, 0x0898d, 0xac549, 0x6d3e3, 0x7ec66,
      0x9db88, 0x4da3b, 0xa45b8, 0x44fbe, 0x83006, 0xb0585, 0x98355,
      0x9f3bd, 0xc1336, 0x579bc, 0x239a8, 0x110fb, 0xe2bd8, 0x45396,
      0x24f5b, 0x198fd, 0xbaf24, 0x007f3, 0x7d51d, 0xdb883, 0x8a676,
      0x5b166, 0x2eae7, 0xeeea6, 0x83c68, 0x3db60, 0xe5f94, 0x5a5ff,
      0xd836c, 0x4d0f7, 0x552c9, 0xc1ff8, 0xc6fcb, 0x5a4c3, 0x0b4dd,
      0xe386c, 0x82a55, 0x00006 },
    { 0x495aa, 0xa4587, 0x8f235, 0x245dc, 0xc34c7, 0x76026, 0x6e322,
      0xb75a4, 0xe0cc5, 0xe7d6a, 0xcc3e5, 0x3965e, 0x9890d, 0x29662,
      0x42f14, 0x1b133, 0x77227, 0xe68a8, 0x89927, 0xa68bc, 0xe2324,
      0x43f27, 0x21a15, 0x49cdc, 0x47684, 0xac6c4, 0x452d0, 0xfd4f1,
      0xc9bc7, 0x4b045, 0xa31ff, 0x2cc30, 0xf7611, 0xa0852, 0x15d46,
      0xd7a64, 0x2c6fd, 0x73705, 0xc91ad, 0x7b4c7, 0xcc3ab, 0x0cdce,
      0x688d7, 0xf01b7, 0x5d2cd, 0x0d390, 0x542e4, 0x054f2, 0xe4dcd,
      0xa6fef, 0x2227f, 0x00000 },
    { 0x1948b, 0xd9b75, 0x805ef, 0x225d1, 0x6fdfd, 0xfeed4, 0xb228e,
      0x4f2c8, 0x28e09, 0xe5cb1, 0x6f7c5, 0x90bf9, 0x09d10, 0xcbeca,
      0x044b4, 0x0959d, 0x8cb04, 0xf98e0, 0x1c955, 0x4fce2, 0xd68fa,
      0x1f279, 0xe9abc, 0x0710a, 0x1e14e, 0xf4b02, 0x81167, 0x6e9f8,
      0x564d1, 0xc9f1a, 0x22ebb, 0xf5a5c, 0x20eea, 0xdfe34, 0xf3716,
      0xe8435, 0x5d5c4, 0x1eb91, 0xa8197, 0x28ffb, 0xc55fc, 0x7864f,
      0xdd375, 0xe54d7, 0x03427, 0xebc7d, 0xa6215, 0x446e6, 0x69778,
      0x9a292, 0x47e24, 0x00005 },
    { 0xfda27, 0x8aa1f, 0x70686, 0xcf504, 0xc7955, 0xe6cdc, 0x3d8b4,
      0x0a63f, 0x151e1, 0x0af65, 0xde5e7, 0x27ea9, 0x35b41, 0x34282,
      0x9baf9, 0x3d2c0, 0xf7d51, 0x83aa2, 0x8c99d, 0xc0251, 0xdddee,
      0xc5bb1, 0x1cea0, 0x03dcf, 0xddf84, 0xda7ff, 0x16fde, 0x4d296,
      0x0e57e, 0x32a1f, 0x56979, 0xd2456, 0x1d4e3, 0xe8319, 0x475e0,
      0x218b7, 0x1c220, 0x79bea, 0x50534, 0x8bcb2, 0xb5c90, 0xe6fce,
      0xc6132, 0x5cea3, 0xb1c68, 0xe6c1e, 0x745bf, 0xc42dc, 0x08eea,
      0xc0d2b, 0x5a41c, 0x00004 },
    { 0xbf0e1, 0xc74db, 0xea9b2, 0xf70e3, 0xfa17c, 0xff962, 0xc6641,
      0x5eeb4, 0xea758, 0x7edc1, 0x9beb1, 0x12d2a, 0xa4f54, 0x85741,
      0xf52a2, 0x2c9e4, 0xfd11f, 0xa4984, 0x3df7d, 0x184e9, 0xc0df3,
      0xafbdd, 0x375b2, 0x2421e, 0x23d25, 0x1e963, 0x9df78, 0xe1e44,
      0xac87b, 0x589be, 0x1ed3d, 0x14560, 0xff6dd, 0xbd28f, 0xf0bd9,
      0x298c0, 0x48a0f, 0x3259d, 0x9442d, 0xd88e6, 0xd7a77, 0xf6362,
      0x6ac2a, 0x06b6b, 0x2a84c, 0x87da0, 0xac9d0, 0xba850, 0xe40c8,
      0xc942e, 0x28763, 0x00001 },
    { 0xac178, 0x07acb, 0x9a80f, 0x8f6e2, 0x434b0, 0xc2004, 0xed27c,
      0x70fed, 0x31d14, 0x67e96, 0x66157, 0x5da38, 0x8b211, 0x08854,
      0x5c4cb, 0x7c75f, 0xe8e03, 0x139a2, 0xb29d2, 0x17525, 0x68b88,
      0x9fda6, 0xebcfe, 0xc1de7, 0xd8d88, 0x233f1, 0x32181, 0x565e0,
      0x3b476, 0xc995f, 0x561b1, 0x07365, 0xeb71b, 0x18b13, 0x160cb,
      0xa0eb2, 0x399b3, 0x8da51, 0xd747e, 0xb20fc, 0xca1f9, 0x725e8,
      0x4126d, 0x0067b, 0xf6a7e, 0xbb637, 0x4b768, 0x1e820, 0xf74d2,
      0xccfc4, 0x5e96b, 0x00007 },
    { 0x9716e, 0xdc0d1, 0x89d1f, 0x45251, 0x87c38, 0x58505, 0xd2adf,
      0xea987, 0x846d1, 0x0f64a, 0xc0715, 0xbf836, 0x712b6, 0x6fd5b,
      0xd464d, 0x91d85, 0x3f55f, 0x364f5, 0x97888, 0x9129a, 0x88150,
      0x083bd, 0xf4860, 0xea876, 0x72683, 0x89a76, 0x15b24, 0x2e7ac,
      0x2e80b, 0xd1d99, 0x8d242, 0x985ef, 0xde492, 0x29cf3, 0xc57b0,
      0x76279, 0xcb148, 0x02f83, 0x687fe, 0x8ae5b, 0xa4fe4, 0x96aeb,
      0xd6b81, 0xf09b5, 0xd8a86, 0x6e523, 0x66ba1, 0xd88f5, 0x68949,
      0x9aba2, 0x09a6e, 0x00003 },
    { 0xbe97a, 0x50bdf, 0xf27ee, 0x0c4de, 0xfb8c5, 0x5fe70, 0xf5c1a,
      0x7fe09, 0xbeb01, 0xc5cc7, 0xed36c, 0x5a85b, 0xa8fa1, 0x50ed3,
      0xcdb75, 0xc0c3a, 0x08681, 0x87eb9, 0x581ef, 0x5ccbc, 0x2c49d,
      0x5b336, 0x4e8a1, 0x1fa26, 0xb1714, 0x880fb, 0xe1eee, 0x8d8f8,
      0xd267f, 0xc2b63, 0xfd621, 0xd31cc, 0xe7efd, 0x7d53b, 0x24dbe,
      0x358a9, 0xfdb2a, 0x2e877, 0xac1d4, 0x75d68, 0x673c7, 0x55cf9,
      0x14fea, 0x78fd7, 0x2e359, 0x69b20, 0x65357, 0xeeb36, 0x93789,
      0x8ad75, 0x45825, 0x00000 },
    { 0x2dbdf, 0x74a04, 0xdf71a, 0xdfa25, 0x75779, 0x40585, 0x6572d,
      0x0d2e6, 0x6cba7, 0x2e0e6, 0xa2e89, 0x6745c, 0xf285d, 0x0e6b5,
      0xdef0f, 0xf56a8, 0x767c3, 0x1da30, 0x0ee85, 0x6b9ce, 0x84334,
      0xc0565, 0x74298, 0xd6b3c, 0xfce26, 0x00b35, 0x9777e, 0x5bff3,
      0x6c089, 0xb6d88, 0x6a6e7, 0x83c8f, 0x2904b, 0x434f0, 0xee148,
      0xec34b, 0xb2e84, 0x74915, 0x9917f, 0x96d10, 0xf663c, 0xc0baa,
      0x41fac, 0x8757e, 0x9004b, 0x86c02, 0x0e56f, 0xa2b88, 0x77358,
      0xe095b, 0x3f4a3, 0x00005 },
    { 0xc48e7, 0xce89f, 0x1bb08, 0x5aeb1, 0x7afab, 0x60c57, 0xb5aba,
      0xa0c1c, 0xbcbf8, 0xb6f06, 0x9757c, 0xfaea7, 0x07d2e, 0x31916,
      0x0b176, 0xe26d9, 0x7b7a9, 0xb62b7, 0x2aa1a, 0xf2bf4, 0xd285d,
      0xeec0c, 0x7f038, 0xf3a8f, 0x947f5, 0xb5d35, 0xc1cb5, 0xdc0ef,
      0xf97c8, 0x5845c, 0xca0c4, 0xfeb8c, 0xe26f2, 0x89249, 0x6e8d9,
      0xd89a1, 0xd483e, 0x264e6, 0x0737c, 0x51d91, 0x3f145, 0xf013a,
      0x05e99, 0x562e3, 0x38501, 0x08d56, 0xd7469, 0xaaf98, 0x3d236,
      0x53d72, 0xa99e6, 0x00000 },
    { 0xc0559, 0x46abb, 0x3536f, 0xa1602, 0xb9aa1, 0x63067, 0x1b5c1,
      0x0c168, 0xfd229, 0x07229, 0x378e9, 0x4be11, 0xd6125, 0x793a2,
      0x57aab, 0xc60ff, 0x552db, 0x8b466, 0x6f2df, 0x0a36a, 0x38c17,
      0xd3189, 0xd9a9a, 0x29b74, 0xd9abe, 0x23c5c, 0x78485, 0x7273f,
      0x3cf74, 0x0e306, 0x93a0d, 0xc126a, 0x8e3d8, 0xe3424, 0xe2021,
      0xddfaf, 0xe8323, 0x7343e, 0x9e7d9, 0x33263, 0x68775, 0x489f7,
      0x53255, 0xfc317, 0xa9650, 0xebf7e, 0xbd13e, 0xb595d, 0xfcbc0,
      0x45010, 0xa95cb, 0x00003 },
    { 0x7ff2e, 0xcb39d, 0x54e68, 0xc48f9, 0xbc1d5, 0xd1cb4, 0x38a8d,
      0x71694, 0x92c77, 0xce02a, 0x1cad8, 0xc0b09, 0x27965, 0xcd08d,
      0x8ab32, 0x0c579, 0x02bda, 0xc3a69, 0xa5bc3, 0xd2181, 0x55186,
      0x5d092, 0x4db54, 0xd27e6, 0x77cdb, 0xdaf00, 0xcd092, 0xcaa48,
      0x30157, 0x532ab, 0x3a024, 0x2a2fa, 0xcaba3, 0x9b41c, 0x5fb63,
      0xaee6a, 0x14744, 0x702dc, 0x3da01, 0xcdba9, 0xbb436, 0xf1485,
      0x29784, 0x7f663, 0x39359, 0xd672c, 0xc1dda, 0x5d713, 0xb7245,
      0x2e030, 0x66d22, 0x00003 },
    { 0xea5b2, 0x75573, 0x50b48, 0xa44dd, 0xba90d, 0xce401, 0x3100f,
      0x7a1a0, 0x3fa65, 0x607b5, 0xf1144, 0x80a5c, 0x9722a, 0x38bf4,
      0xf05a5, 0x0b8eb, 0xacd21, 0x47d32, 0xe1411, 0xd07da, 0xc7b5a,
      0x92712, 0xa0766, 0x3f48c, 0x5fee7, 0xd86dc, 0xb8a78, 0x14992,
      0x998ed, 0x2f175, 0x145dd, 0x4e8b3, 0x71b8e, 0xe15f9, 0x3408d,
      0xb3684, 0xdadf1, 0x5ea6d, 0xb7e05, 0xe5932, 0x76e73, 0xfd4bb,
      0x30893, 0x7153d, 0xa4428, 0x61bfd, 0xcd206, 0x173dc, 0xefd25,
      0x9979d, 0x072ba, 0x00009 },
    { 0x0ea39, 0xdd962, 0x74de4, 0xcee84, 0xfc831, 0xf1649, 0xc43fb,
      0xcd3a9, 0xe8bb1, 0xd50b0, 0xf3df1, 0x286f3, 0x36a38, 0x0ec9b,
      0x2b38f, 0x4ed07, 0xc09e3, 0x87729, 0x6e4c9, 0x2242a, 0x68ad1,
      0x3e8ac, 0x5baea, 0xfbdfa, 0x0e22b, 0x926ae, 0x0a0f5, 0x1ecfb,
      0xd5617, 0x871f8, 0x86d6b, 0x33b28, 0x11bda, 0xa935e, 0xb19be,
      0x153f6, 0x07f0f, 0x815a4, 0x2ee4d, 0x7d6c0, 0x08d97, 0x467e6,
      0x6a88f, 0x23d9b, 0x47e8f, 0x9d165, 0x65243, 0x26ac9, 0x46c29,
      0xbd355, 0xd92c6, 0x00008 },
    { 0xb0ff7, 0xceabe, 0x3e0d7, 0x42f8b, 0x43e0e, 0xe3525, 0x499fb,
      0xde808, 0x1b226, 0xc357d, 0xcd44b, 0x2e1f1, 0x19ece, 0x5cfee,
      0xdbc43, 0x1245a, 0xf581c, 0x40f93, 0x74ee8, 0xb9478, 0xcbda0,
      0x6a779, 0xe0a91, 0xfa57a, 0xc815a, 0xb0abc, 0x0a621, 0xec2df,
      0xc97ad, 0xf90bd, 0x02b81, 0xbe6a5, 0xde63d, 0xe153b, 0x4bf9d,
      0x4c255, 0xf7888, 0x8fdab, 0x470a8, 0xcbbb5, 0xa52b1, 0xf530a,
      0x9053e, 0x396c2, 0xaf805, 0xd827e, 0x8988d, 0x8d43d, 0xae5c0,
      0x175c1, 0xe4bec, 0x00004 },
    { 0x09676, 0xa2fcc, 0xf8483, 0x9a94b, 0xf19ea, 0x7c4a3, 0x5dd45,
      0xd702a, 0x52ef3, 0xd8a68, 0x43fe7, 0x5fd28, 0x8e791, 0xe3515,
      0xa9816, 0x644bb, 0x746f0, 0xd09ed, 0xd1b95, 0xf0b58, 0x1b90a,
      0x70458, 0x35e47, 0xd4fd1, 0x4bc6b, 0xa50bd, 0x4e833, 0xe067b,
      0x1a6dc, 0x56a9a, 0xf30ff, 0x2c0e8, 0xc63fe, 0x00ec2, 0x9c808,
      0x08a8a, 0x598f5, 0x9c20a, 0x13a44, 0x32928, 0x94cb3, 0xa202b,
      0xc7e81, 0x3d28e, 0x7647e, 0x87767, 0xd1ab4, 0x72e67, 0xded24,
      0xf56f9, 0xa4aa3, 0x00007 },
    { 0xa0045, 0xbae27, 0x59ef1, 0xcb505, 0xfb242, 0x812d4, 0xd24dc,
      0x39cf8, 0x478e4, 0x5423a, 0xb3f9c, 0x4fc59, 0xf9754, 0xfa1fc,
      0x132af, 0x5ac68, 0x2c83b, 0xe034a, 0x4f8fe, 0x4bb77, 0xfcd3f,
      0xcc640, 0xea696, 0xb0512, 0xdce9d, 0x1e775, 0xdce38, 0xa19dc,
      0x567dc, 0xd3fe5, 0x3f3a9, 0xc1eeb, 0x9274f, 0x421a1, 0x8e0bf,
      0x9b123, 0x428d6, 0x992fb, 0xdf815, 0x9fd09, 0xcebde, 0xdf48f,
      0x41ab5, 0xfa4fb, 0x5dc9d, 0xa269c, 0xdc8c0, 0x0cbd7, 0x0ade1,
      0x7bf7f, 0x0282a, 0x00006 },
    { 0xea2e7, 0x38dce, 0xc07e5, 0x061d7, 0x83c42, 0xa322c, 0x51638,
      0x4f1f6, 0x828f9, 0x10676, 0x7776a, 0x69fbc, 0x5f21b, 0xe6b40,
      0x417b5, 0xc63a3, 0x7b642, 0x5891a, 0xc99f2, 0x14404, 0x82cad,
      0x692ca, 0xbcd38, 0x00869, 0x82ffe, 0x6af1e, 0x6fe46, 0x714e1,
      0x8c30b, 0x01913, 0x2f919, 0x5fb74, 0x516ae, 0xd00fa, 0x90166,
      0x3a43e, 0xcd8c7, 0x50f7a, 0x37255, 0xfbc5c, 0xa407d, 0xed2d6,
      0x8cc39, 0x75396, 0x0e47a, 0x5fbe7, 0x6d94a, 0x3fd28, 0x6b942,
      0xc723c, 0xf4ae9, 0x00005 },
    { 0x4d561, 0xda53f, 0x96a2d, 0x1992d, 0x016da, 0x6d45d, 0x05128,
      0xfdd4b, 0xa01fb, 0xea449, 0xf2195, 0x8a0d9, 0x32548, 0x7661b,
      0xb0aa3, 0xc4151, 0x5ee02, 0x1ef9e, 0x98c47, 0x8817b, 0xea865,
      0xbca86, 0xc0aa4, 0x7a68f, 0xadb87, 0xa9bbc, 0xb7366, 0x46496,
      0xd88b3, 0x661c2, 0x8d415, 0x32ee9, 0x1420c, 0xc6c90, 0x5b3b4,
      0x52aff, 0x52f27, 0x35273, 0xd9ca2, 0x510e4, 0x4ce73, 0x802f6,
      0xca4aa, 0x7f26a, 0x3939a, 0x1aa50, 0x29140, 0x9cd3e, 0x6afd2,
      0x23dc4, 0x2a014, 0x00009 },
    { 0xf7dbd, 0xe11c2, 0x9f24b, 0x27fae, 0xfb7d5, 0x8c900, 0x128da,
      0x8648f, 0xe25bb, 0x41963, 0x81419, 0x13e24, 0xb9ab7, 0x6756f,
      0xd017a, 0xe87f7, 0xd90bd, 0x5e058, 0x74dd8, 0x6abd2, 0xa8256,
      0x3fee7, 0x19582, 0x74240, 0x230d7, 0x6e9f6, 0xcb5e4, 0x9f2ca,
      0xe0457, 0xa4c87, 0x26316, 0x2a226, 0xb0857, 0x43d99, 0xca19a,
      0x789e9, 0x3e488, 0xdc2ba, 0x3bd86, 0x9406c, 0x0b5b9, 0x7ef96,
      0x96095, 0x428b8, 0xb6f2c, 0x1c515, 0x70616, 0x90748, 0x8cb9b,
      0x1eaa8, 0xfc8fe, 0x00000 },
    { 0x90f2d, 0xedfeb, 0x8ae1b, 0x15596, 0xca48b, 0x93bb3, 0x635f3,
      0xf64e9, 0x62f9c, 0xc22be, 0x8be75, 0x2410f, 0x9354c, 0x6f752,
      0x7035e, 0xbd7ea, 0xcab31, 0x8e162, 0x26486, 0xf3ffc, 0x0c860,
      0x391e7, 0x37eb1, 0x1d898, 0x67c75, 0x41df3, 0xbf329, 0xb6b42,
      0xfe150, 0xc1318, 0x46e78, 0x95e8f, 0x4b160, 0xaba2c, 0xb3f1d,
      0xfbf32, 0xe701a, 0xccf5c, 0x4c5c6, 0x5e887, 0x27530, 0xbe3ad,
      0xdc6dc, 0x5e515, 0xd3928, 0x9892d, 0xd86d9, 0x3c954, 0x3789f,
      0x62dfd, 0xd0ba8, 0x00002 },
    { 0x2e1af, 0xe8b47, 0xacd8e, 0xbbcce, 0xeb76a, 0x354ea, 0xfbdeb,
      0xd0d93, 0x20bf8, 0x069b5, 0xe6fc7, 0x60d7f, 0x9fccd, 0xee2f3,
      0xddea4, 0xa9353, 0x1e51e, 0x5e9a8, 0xeb092, 0x67775, 0x1d136,
      0x334da, 0xd69ee, 0xd5354, 0x28c9f, 0x54c1d, 0x2a5ed, 0x17559,
      0x1b977, 0xf70d8, 0x67fb7, 0x5d3e3, 0x3ae7a, 0xcaa93, 0xbe7ee,
      0xfbb77, 0x9e23c, 0x4cf1f, 0x68126, 0x89497, 0x29f4a, 0x5b0d1,
      0x9b623, 0x75a40, 0xa7053, 0xa376d, 0xc7548, 0xccf64, 0x1dbfc,
      0x124d4, 0x63c87, 0x00009 },
    { 0x6a814, 0xcbde3, 0xae290, 0x12b5b, 0x5733b, 0xdb019, 0x0e19b,
      0xf77fe, 0xad867, 0xea0eb, 0x9720c, 0x19fd2, 0x20a7d, 0x29ec7,
      0x65190, 0x434d7, 0x1911e, 0x17bb5, 0x56aff, 0x7f608, 0xad80a,
      0xa25d9, 0x106d0, 0xf848c, 0xa86af, 0x9cffc, 0x3ad74, 0xbdf94,
      0xb53e8, 0xe696b, 0x284e3, 0xfb9e0, 0xe4215, 0x0aeee, 0xeb663,
      0x3c633, 0xe2ecf, 0x8fbb9, 0x0c09d, 0x4e00c, 0xa4ffa, 0xac71d,
      0xd57be, 0xbe595, 0xfb296, 0xcec7e, 0xbada8, 0x1751f, 0x5d7bd,
      0x3cff5, 0xd03eb, 0x00002 },
    { 0x2ec1d, 0x5f04f, 0xb1692, 0x7ee2e, 0x60d14, 0x78f27, 0x9e0a8,
      0xaad9d, 0xdf604, 0x5b442, 0xf7103, 0xf44b3, 0xb891d, 0xb95d5,
      0x2b38c, 0xc2827, 0x8ed23, 0xb55ee, 0xf14ef, 0xf3e36, 0xf13b0,
      0xc4460, 0x35ef3, 0x6bd73, 0xf9bd7, 0x6e889, 0x755ba, 0xe771f,
      0xc889e, 0x219b6, 0x4feed, 0x62698, 0xee411, 0x37ec2, 0xd44c7,
      0xcd372, 0x263ef, 0x4385a, 0x26bb9, 0x66378, 0x9321b, 0xa7d90,
      0xee6b7, 0x8a793, 0x7c24f, 0xcf61b, 0xd24a7, 0xa3ca8, 0xbacd9,
      0xc1c54, 0x42e40, 0x00008 },
    { 0x1d843, 0xd6a66, 0xa268e, 0x30cd5, 0xa4f5b, 0x328cc, 0x17702,
      0x1311e, 0x6fed1, 0x6716e, 0x66959, 0xecb4c, 0x0690d, 0xb2e28,
      0xbf657, 0xbdac5, 0xe42d0, 0xca1ef, 0x27f82, 0xca2f8, 0xaca5f,
      0x54ec0, 0x506c5, 0xdde45, 0x276c1, 0x13ac5, 0x30775, 0xcb08e,
      0xcb7f4, 0x8797c, 0xd9acc, 0x8caf6, 0x332d2, 0x140d9, 0x59648,
      0x409fd, 0x7285a, 0x6ae29, 0x093cc, 0x6223d, 0x3c2a5, 0x09777,
      0x128fc, 0x66ac5, 0xc2d52, 0x31fe6, 0x7cbbc, 0xa596b, 0x91328,
      0x9acac, 0xe6331, 0x00000 },
    { 0x60ac2, 0xadf03, 0x5cd2f, 0x605ab, 0xe285e, 0xb660d, 0xb1486,
      0xe25b9, 0x6cf10, 0x5482c, 0xa9ac5, 0xa38da, 0xe9d5f, 0x6c070,
      0x1b852, 0x3dfcf, 0xcc52d, 0x6b3fc, 0x379a9, 0xc7f50, 0x90bfc,
      0x659c2, 0x6a1e3, 0x69d3e, 0xa3db5, 0xd55b1, 0xb7b42, 0x28b59,
      0x6b415, 0x22a00, 0xfa49c, 0x934de, 0xce3b6, 0x189b4, 0x0f380,
      0xaf329, 0x4b3ab, 0x73bc0, 0x9e2b0, 0xff838, 0x5a222, 0x5b27a,
      0xfa5a3, 0x9d51f, 0x20b7a, 0xe1a7c, 0xcef28, 0x4939e, 0x2705a,
      0xa2187, 0x8839d, 0x00008 },
    { 0xce29a, 0x30701, 0x6b66c, 0x1d505, 0x65898, 0xcaf12, 0xf213a,
      0x105f9, 0xafc0c, 0x13d4d, 0x73e3d, 0x71e63, 0xafee5, 0x2ee3c,
      0xc86fa, 0xe7269, 0x0385a, 0x4add2, 0x5cca6, 0xe9acf, 0x73000,
      0x7f275, 0x3ef21, 0x0e727, 0x4db47, 0x76c93, 0x55b67, 0xf4f73,
      0x04294, 0xc0518, 0x6b96f, 0x1faa3, 0x2190b, 0xdbb05, 0xf88b1,
      0xef528, 0x0e9ea, 0x791b9, 0xb9035, 0xdb681, 0xfb2eb, 0x69f37,
      0x415c3, 0xa51d4, 0x939d0, 0x2e21c, 0xca71d, 0xfc59c, 0x50c26,
      0xfea1f, 0x4128c, 0x00006 },
    { 0x5b0b5, 0xa2e8f, 0x03678, 0xf059f, 0xcd340, 0x7e249, 0xcec5c,
      0x93ca7, 0x40441, 0x98414, 0xc83af, 0xa346b, 0x0075c, 0xa8bbb,
      0x033fa, 0xf39f0, 0x230f7, 0xedf38, 0xd18f0, 0xf3453, 0xcd448,
      0xdff00, 0x47578, 0xd51aa, 0x228c0, 0xd1849, 0x0c928, 0x27083,
      0x3dd4e, 0x12cfd, 0x6868f, 0xc66ba, 0x3a206, 0xdb88b, 0x91049,
      0xae010, 0x9016d, 0x65d05, 0x37dd8, 0xe253e, 0x9e905, 0x1b459,
      0xce987, 0xf0c27, 0xe322c, 0x4a132, 0x4da17, 0x014f5, 0xbcbda,
      0x09bda, 0x3634a, 0x00009 },
    { 0x2e304, 0x27a9a, 0x2826b, 0xc1246, 0x6c1a4, 0x7e186, 0x710c5,
      0x22381, 0xab832, 0xfe913, 0x9847c, 0x6b85a, 0xd7e9b, 0x5f46f,
      0xcf12b, 0x29655, 0x8e66d, 0x2b803, 0x29557, 0x5eab7, 0x16fa9,
      0xcba60, 0xa81e4, 0xb9ded, 0x11071, 0x1ebbc, 0xf1cf6, 0x009a3,
      0xb97f0, 0x3e0cf, 0x77b37, 0x53727, 0x9d63b, 0x9cd13, 0x02f90,
      0xd78e3, 0xa4f87, 0xd672d, 0x7631e, 0xb4048, 0x077a3, 0xb2362,
      0xdcc22, 0xc32d9, 0x7c408, 0xdeeee, 0xbf226, 0x4b4c5, 0x6357e,
      0x67bc0, 0x66cb4, 0x00002 },
    { 0x363e8, 0x54b56, 0xfaa41, 0xa4db6, 0x83c1a, 0x4fd07, 0x5974b,
      0x2b9e6, 0x58dde, 0x84143, 0xa004b, 0xae3ef, 0x65b34, 0x9911a,
      0x2ecf1, 0xcf44b, 0x6bf78, 0x33a53, 0x5caa8, 0xdc955, 0x98870,
      0x6e1eb, 0x11d60, 0x09f35, 0x3287d, 0x64e3c, 0xd5cf3, 0xf4eb9,
      0xe68b2, 0xab8c9, 0x89263, 0xc154e, 0xab611, 0x8ec36, 0x54882,
      0xd1201, 0xba1b7, 0x32bfc, 0x8d709, 0x5315b, 0x7b5bc, 0xc17ee,
      0x7473a, 0xd0d1f, 0x3782f, 0x8f2af, 0x9a83c, 0xbcb02, 0x54ee1,
      0x1b524, 0xb1d5a, 0x00004 },
    { 0x52c0c, 0x7463d, 0x2fe51, 0x099d1, 0xe188c, 0x35525, 0x95637,
      0x360e3, 0x21563, 0x435c6, 0xcfa5a, 0xf1caa, 0x788b3, 0x7e810,
      0xa0a79, 0x90123, 0xe080a, 0xb5b15, 0xa31f6, 0xdadab, 0x2fca3,
      0xde5e1, 0x1c8d7, 0x0df51, 0x7361b, 0x4e328, 0x5757d, 0x00d46,
      0x17cc8, 0x07ec9, 0xf3d52, 0x10810, 0xea0e3, 0xf130e, 0xd4e56,
      0xa2ec0, 0x33ea5, 0xf7ee1, 0xbd0bb, 0xbe6ab, 0x07762, 0x196fc,
      0x20bf6, 0xfdce1, 0xac831, 0x22d42, 0x9fab6, 0xe0743, 0xe4b27,
      0x3f508, 0x186b9, 0x00008 },
    { 0x12867, 0x54093, 0x619d1, 0x7db4c, 0x5bfaf, 0x042c0, 0xdda7e,
      0x1f5f5, 0xf1668, 0x82c1c, 0x4fc3d, 0x5057a, 0xe50aa, 0x68b8f,
      0xd65ce, 0xed30e, 0x4d644, 0x0bbeb, 0xcb01c, 0x0497e, 0x4831c,
      0x5dc44, 0xb1c7b, 0x9b7d9, 0xe6a00, 0x91351, 0x9477c, 0x63b9d,
      0xa4bb8, 0xd4110, 0x89105, 0xaba65, 0x80b7a, 0xf4435, 0x0086c,
      0x357e3, 0x690be, 0x39c07, 0x14eb1, 0x27b52, 0xfff1a, 0x5712b,
      0x2c3ab, 0xc6d72, 0xa79cf, 0x4a9bf, 0xe57f3, 0x4743d, 0xe2b2a,
      0x97c9e, 0xbf97e, 0x00000 },
    { 0x19e96, 0xc8dda, 0x6ec4e, 0x6e8b9, 0xa6c30, 0xce18e, 0x18a54,
      0x65f69, 0x3612b, 0x997e8, 0xd9a0d, 0xf68b0, 0x91ac6, 0xfdcc0,
      0x7a462, 0x98a69, 0xc3e13, 0xf195b, 0x5ce25, 0x97306, 0xab393,
      0x96ecd, 0x80618, 0x32f12, 0x81a0f, 0xdf9eb, 0xd2dc7, 0x416e1,
      0x9d3d7, 0x47359, 0x976ad, 0xe22c7, 0xef439, 0x9a9f5, 0xde37a,
      0xd94e3, 0xb9e69, 0x7ac0a, 0xbc86b, 0x0a9d0, 0xfa9e0, 0x20e6b,
      0x676f1, 0x870d5, 0xf576a, 0xaac23, 0xbb4fe, 0x3bd91, 0x0aabb,
      0x2c3e4, 0xfe548, 0x00008 },
    { 0xa4d1e, 0xc2ce9, 0x5ae67, 0x20388, 0x34f1d, 0x3eb80, 0x1924c,
      0x25d06, 0xc8f3a, 0x1c5c6, 0x08fb4, 0xe0ad3, 0xe803d, 0x1c294,
      0x5bce7, 0x9961f, 0xeb0da, 0x8df02, 0xc6207, 0xe8b6d, 0x5b64a,
      0x7ef51, 0x18fc8, 0x50b4d, 0x79f1e, 0x43696, 0x2199f, 0x09a15,
      0xfc5c0, 0x640a5, 0x4be0f, 0xa7d48, 0xab566, 0xb123d, 0xc918b,
      0x5d2c4, 0xc6427, 0x7c114, 0xed6a6, 0xcad2d, 0x913b9, 0x8d95a,
      0xb4b5c, 0xd18b6, 0x6189e, 0x2d3bf, 0x206b4, 0x4aeb6, 0x8bc3f,
      0x69bbc, 0x928c6, 0x00003 },
    { 0xb4b64, 0x4adac, 0xe4bea, 0x79a1d, 0x4f261, 0xf62a4, 0x2a403,
      0x7a911, 0xac94e, 0x1ef3a, 0x36f33, 0x8fbdd, 0x49044, 0x7b85c,
      0x2bc40, 0x42604, 0x1b77b, 0x96212, 0xad8a5, 0xe9845, 0xf67ce,
      0x674a4, 0xf0d31, 0x4e3b2, 0xe8bbe, 0xeb7fa, 0x7c930, 0xf6dda,
      0x4681d, 0x59d0d, 0xa98c2, 0xadeef, 0x1c1fd, 0xe6bea, 0xb14d9,
      0x05d11, 0xb21d4, 0xaadc8, 0x7543b, 0x73892, 0xdff93, 0xe4f01,
      0x071cd, 0x5b3ef, 0x981c3, 0x50d0d, 0x2e191, 0x1704d, 0x134f6,
      0x8f355, 0xccc88, 0x00006 },
    { 0x7504c, 0x0e7ad, 0x8d36f, 0x9dddf, 0xff795, 0xa3265, 0x7aabc,
      0xfede6, 0xd1ede, 0x2f0dc, 0xaebf3, 0xf4ceb, 0xc1276, 0x4edcf,
      0x6e601, 0x6825a, 0xd8eb7, 0x8299a, 0xb8c1a, 0xce1e0, 0x909b8,
      0x2024a, 0x51a31, 0x9cbd3, 0xfd98b, 0xbecb8, 0xab1e8, 0x1378f,
      0xfa484, 0x73cac, 0xf5d39, 0x17ed0, 0xd5254, 0x84259, 0x17e14,
      0x1393a, 0x374b9, 0xd5b84, 0xce953, 0x1aca3, 0x92b21, 0x158f7,
      0x8c0f8, 0xf110c, 0xd035f, 0x4ed7b, 0x357ad, 0x6afa6, 0xfaef9,
      0x80b26, 0xf1519, 0x00002 },
    { 0x2d439, 0xda29d, 0xc8631, 0x99550, 0x2bc03, 0x1fbbc, 0x75b12,
      0x6c05b, 0xa9792, 0xec3e5, 0x6ce47, 0xf4c0b, 0x86d6c, 0x88c65,
      0x7679d, 0xbaaa1, 0x55a17, 0xe7f33, 0x31db9, 0x5a850, 0x80aef,
      0x81e3d, 0xbdf83, 0x15a31, 0xdb290, 0x7dc71, 0x498fd, 0x6b749,
      0x6638f, 0xbeeef, 0x3f913, 0x44edf, 0xb67b3, 0x71f4a, 0x61732,
      0xdf11e, 0x0fd22, 0x202c7, 0xe923a, 0x205c4, 0xe0389, 0x20f7b,
      0x8eb99, 0x9085a, 0xa1c21, 0xb54aa, 0xce8be, 0x6c805, 0x58d65,
      0xb70ac, 0x54b05, 0x00003 },
    { 0x170e9, 0x367a9, 0x171e2, 0x50cd7, 0xd4cad, 0xeec42, 0xcfb01,
      0x3cddc, 0xe824f, 0x1affb, 0x66cae, 0x8ce3a, 0x1a73e, 0x5c7d0,
      0xa7f96, 0xb7138, 0xd971e, 0x3f5c3, 0x0058e, 0xa72b0, 0x32ff0,
      0x591ac, 0x76f52, 0xbbbce, 0xfb5bc, 0x18a32, 0x9f81a, 0x1ab8a,
      0x0f324, 0xa6863, 0x332ec, 0xf31d3, 0x2f13b, 0xfc448, 0x47af9,
      0x1be28, 0x7a468, 0x96e21, 0xcf961, 0xe55ef, 0x8f932, 0x05993,
      0x0acc7, 0xacb87, 0x23e7d, 0x09fac, 0x893cf, 0xd41be, 0x523a1,
      0xc4ae3, 0x8dc55, 0x00004 },
    { 0x92193, 0x26a50, 0xe6238, 0x970c8, 0x26898, 0x6ec36, 0xb41e4,
      0x25c9e, 0x356af, 0x452f1, 0x3c7d2, 0x06408, 0x84178, 0xd00e3,
      0xf6797, 0x982de, 0x2151c, 0xe7a51, 0x82eb6, 0x88693, 0x78af5,
      0x4e107, 0xf0215, 0x8a51c, 0x07075, 0x58187, 0x1313c, 0xa9f77,
      0x4cdeb, 0x15590, 0x973ba, 0x5d67b, 0xd7b3a, 0x4b1d0, 0x51c9f,
      0xf2cd8, 0x18b8a, 0xf29d7, 0xd6219, 0x986b8, 0x4ccff, 0x33cb9,
      0x93b9c, 0xe24bb, 0x88725, 0xe38c6, 0x4c566, 0x405ce, 0xdc021,
      0xdd0b6, 0xf6a8e, 0x00005 },
    { 0xa8690, 0xa58f9, 0x3704c, 0xa4078, 0x62f76, 0x36976, 0x0283f,
      0x69201, 0x12d8c, 0xcffbc, 0xce3a4, 0x8f16b, 0xd4cd5, 0xaab26,
      0x64a04, 0x78046, 0x457a8, 0xba4ea, 0x05cfb, 0x97940, 0x3b8a5,
      0x7951b, 0x73953, 0x4fe1f, 0x2b9e4, 0x974ca, 0xf3257, 0x8acdd,
      0xbe442, 0xa243d, 0x3420e, 0x648da, 0xce01e, 0x2bf43, 0xce656,
      0xb490c, 0x1f27d, 0x0f042, 0xcf084, 0x8bfb7, 0xccb70, 0xd3156,
      0xa8797, 0x480d5, 0xb9b33, 0xb814b, 0x07a9e, 0x2e12e, 0xf87ac,
      0x72ca7, 0xca650, 0x00001 },
    { 0xd25a0, 0xcf2b9, 0xbb321, 0x46dbf, 0xa40a7, 0xaffdc, 0x8b566,
      0x59e36, 0x1530e, 0x8fc1c, 0xd8006, 0x1ea47, 0x856ed, 0x47dd6,
      0x8fe56, 0x9b74d, 0x78da8, 0x0789b, 0xd96b5, 0x33911, 0x38bbe,
      0xb7524, 0xc5f39, 0x0d858, 0xd443e, 0x34ef8, 0x646aa, 0xdb499,
      0xc4dd2, 0x67543, 0xbd1e6, 0x7fad3, 0x80985, 0xc0689, 0x0d710,
      0xcabad, 0x249fa, 0x7aff3, 0x1929f, 0x14f9a, 0xdec1c, 0xa1055,
      0xfb307, 0x63991, 0x4aca6, 0xffff6, 0xd9135, 0xac44f, 0xd3cee,
      0xb6cba, 0x62caf, 0x00004 },
    { 0x237dd, 0x47de3, 0x660a6, 0x74041, 0xc82b8, 0xf735c, 0x5f895,
      0xddfa5, 0x79f59, 0x4af78, 0x26b91, 0x043e7, 0x815ef, 0x93e29,
      0x93d1c, 0x18753, 0x18331, 0x746ef, 0x1a2be, 0xa12ba, 0xc25a9,
      0x7e8df, 0x17f4e, 0xa9c39, 0xfc97d, 0x41dfe, 0xa2ebe, 0x5d030,
      0xcbc87, 0x32d1c, 0x235a7, 0x0f75d, 0xaa6d3, 0xfed9b, 0x6fee7,
      0x85760, 0xb65f4, 0x784fa, 0x3c0aa, 0x513f8, 0x55e22, 0x13231,
      0xe8f9d, 0x77183, 0xdd2fb, 0x46eaf, 0x503b5, 0x2a291, 0x93608,
      0x8c6cd, 0x293c9, 0x00001 },
    { 0x53b77, 0x5149d, 0x27812, 0xfac77, 0xd96ea, 0xab403, 0x711a6,
      0x4a36b, 0x7c7db, 0xc1b7d, 0x7e771, 0xc7088, 0x28238, 0xb3752,
      0xabf33, 0x495f6, 0x7530d, 0x9c8c8, 0x0b028, 0x111ab, 0x6e77b,
      0x83cb8, 0x89eca, 0xa1bd1, 0xc0fb8, 0xc7be1, 0xae9d7, 0xb2fb1,
      0x858cf, 0x40c3e, 0x3c549, 0xd05c2, 0xd9107, 0x4174a, 0x6e79e,
      0x71421, 0x5064e, 0xa47f0, 0x14fa0, 0xfdfd6, 0x29cd4, 0x8bc69,
      0x94698, 0x584c3, 0x1edb2, 0x6f8fb, 0x5f3e4, 0x73e4b, 0xa94ba,
      0xa168e, 0x3b79a, 0x00005 },
    { 0xbb6a1, 0xce44b, 0x16faf, 0x17282, 0x06782, 0xa5bba, 0x39ad3,
      0xa9dd9, 0xe4b30, 0xfeef1, 0x19efa, 0xaf3df, 0x4022e, 0x4ec01,
      0xbce7b, 0xfed5a, 0xc6738, 0xe6512, 0x4968e, 0x89a26, 0x929fe,
      0x11986, 0xc0523, 0x47397, 0x39d8d, 0xc40d5, 0x34596, 0xbc542,
      0xd6400, 0x46611, 0xf5853, 0xb9287, 0x5da0f, 0x03c9d, 0x40999,
      0xf2a80, 0x7c83a, 0xef499, 0x1e1e5, 0x32815, 0xdc01b, 0x04c89,
      0x84011, 0xb4a95, 0xd150f, 0x872c9, 0x7d5f3, 0x40a6f, 0x2e833,
      0xd156c, 0x290d6, 0x00008 },
    { 0x46946, 0xc6d85, 0x84637, 0x57faf, 0x969ec, 0x134a3, 0x07eda,
      0xd7890, 0x359a4, 0x09d42, 0xdc7b8, 0x57fe0, 0x9b425, 0x6784a,
      0x52d2d, 0xe62ae, 0xadb5f, 0xa60bc, 0x2714c, 0xfca5a, 0x633aa,
      0x208de, 0x811cc, 0xed967, 0x0ed5c, 0x60238, 0xb3216, 0x55e9d,
      0xa6e6b, 0x75235, 0x02ca6, 0x1bead, 0xfa0e1, 0xf9b33, 0x1cc6e,
      0x2a085, 0x6f06a, 0x223e2, 0x3cffd, 0xec47b, 0x332e1, 0x4e00f,
      0x0aa98, 0x297ba, 0x4459f, 0x952e1, 0x969ee, 0x6fa1d, 0xfabb0,
      0xab304, 0x06ef1, 0x00005 },
    { 0xff163, 0x2735b, 0x1b4eb, 0xa9841, 0xfea9f, 0x30b96, 0x7ce71,
      0x9deb2, 0xceb3f, 0xd566a, 0xdd1c3, 0xf1a59, 0xaa2da, 0x3075a,
      0xa7ea7, 0xf5090, 0x71b58, 0x39e30, 0x6a6af, 0xad9c3, 0xddf73,
      0x8d633, 0xa16a2, 0xbdc89, 0x54cac, 0x3cdd3, 0x4dcbc, 0x3423d,
      0x1dfea, 0x9d92d, 0x4d237, 0x6eec7, 0xd6765, 0x6f8ee, 0x14a45,
      0xeb1fe, 0x3fa8f, 0xbe774, 0xbc7fa, 0xb98fc, 0x4ccf8, 0x6e140,
      0x71a70, 0x2fbff, 0x86ccd, 0x85c67, 0xfdb4d, 0xdaaf3, 0x00344,
      0xbf152, 0x15b7d, 0x00004 },
    { 0x377a7, 0x867d8, 0x70105, 0x32729, 0x8cb80, 0x8a3d6, 0xc3206,
      0xf03a4, 0x7d289, 0x90fd6, 0x3c8f2, 0x095d9, 0x84bc7, 0xe5a2b,
      0x13ce9, 0x712fa, 0xb9f3b, 0xc60fe, 0xc6ac6, 0x54c2f, 0x96e0e,
      0xda36d, 0xa010c, 0x86320, 0x99751, 0x11454, 0x7f00f, 0x8c919,
      0x8f931, 0x93650, 0xc3fe6, 0x01dc4, 0x068aa, 0xf985f, 0x69a2e,
      0x511c7, 0x0a2b5, 0x22cef, 0xe0535, 0xb4122, 0x965ed, 0x3f006,
      0x175d4, 0xfafcc, 0x9fce0, 0x831d5, 0x9bdec, 0x525dc, 0x8879d,
      0xf1af5, 0xec314, 0x00001 },
    { 0x310c2, 0xef2c8, 0x663fe, 0x3f740, 0xa457e, 0x7e14d, 0x887aa,
      0xe5346, 0xb10fc, 0xc5392, 0x37ec2, 0xa38f6, 0xfcde4, 0x42f8d,
      0x320b5, 0x50773, 0xe1711, 0xf9f7d, 0x41302, 0x9bc63, 0x3ae4b,
      0x8b1c6, 0xe6f01, 0xdd2f9, 0x1c46e, 0xa0f00, 0x6eccf, 0x0a972,
      0x7d3bb, 0x46e0c, 0x99d77, 0xa931b, 0x75aec, 0xf7f58, 0x0c8b6,
      0x9c82e, 0xc9693, 0x32f17, 0x664bb, 0x3de5a, 0x135d2, 0x6b765,
      0x2abfa, 0x6cb45, 0xe7193, 0xc105d, 0x08f2d, 0xad5cc, 0xf5788,
      0x127ff, 0x7e91d, 0x00001 },
    { 0x051ca, 0xd3b7e, 0xe92ce, 0x76d4b, 0xd19c7, 0x44d4f, 0x84bc6,
      0x00867, 0xb4b52, 0x31c8a, 0xe9d6b, 0x6227c, 0x73ea6, 0x89e9c,
      0x9a3d2, 0x39524, 0xa19ee, 0x65d12, 0x4509e, 0x5aec5, 0x28c36,
      0xbd469, 0xe0ea7, 0x77963, 0x997e4, 0x2d354, 0x59973, 0x5957b,
      0x60d76, 0xd4a3b, 0xaeb91, 0x99584, 0xb3e28, 0xa41de, 0xe653e,
      0x71df6, 0xd5725, 0x7c98e, 0x1f9ca, 0xb18ae, 0x1a38f, 0x7ef30,
      0x3f7b9, 0xf7c26, 0x51629, 0xc4a0d, 0x282af, 0xdf242, 0xd0c01,
      0x4b3dd, 0x18f3b, 0x00001 },
    { 0x4762b, 0xa87ad, 0x4a0a0, 0xd1757, 0xa8c58, 0xef84d, 0xd861a,
      0x4cf76, 0xf4960, 0x8b16f, 0xe60d9, 0x87867, 0xac0be, 0xcc1db,
      0xffb3e, 0x83637, 0x6147a, 0x095dd, 0x244a6, 0x46e5c, 0x45b08,
      0xe1783, 0xc05a3, 0xe77a4, 0xeb686, 0x95735, 0xf7586, 0x8b4fd,
      0xf5bc1, 0xdfe52, 0xd0b1b, 0x15618, 0x15ba1, 0x0d007, 0x78ecc,
      0x617f8, 0xac2dd, 0xbdbd1, 0x7101d, 0x21b61, 0x2b631, 0xc221d,
      0x4f593, 0x8a794, 0x422ce, 0xf1702, 0x36a44, 0x3b9b5, 0x3e727,
      0x7c8d0, 0x1d0a6, 0x00000 },
    { 0x6533c, 0x361e4, 0xb9642, 0xc2ae7, 0x0fb88, 0x47799, 0xa18e9,
      0xa42c4, 0xb5d16, 0x45019, 0x83c7a, 0xe81dd, 0x37135, 0xb663e,
      0xbdd4c, 0x74a69, 0xc0d63, 0xdbe76, 0xb67ec, 0x8da67, 0x111e6,
      0xd5452, 0x50a03, 0xd2e86, 0xcceb5, 0x37596, 0xaf03b, 0x2dfd2,
      0x2cd57, 0xbd595, 0xba1fa, 0x52364, 0xd8569, 0x56b4e, 0xf47d4,
      0xd5d47, 0x2c950, 0xd8b57, 0xf845a, 0x486e2, 0xd2dfa, 0x44cad,
      0x56bb0, 0x7b43c, 0x6dd52, 0x7c08e, 0xa2499, 0xc9adb, 0x6320f,
      0x067da, 0xb625b, 0x00001 },
    { 0x8446d, 0x7b4fd, 0x4dfaa, 0xebeb4, 0x1af6f, 0x1b2f0, 0x8b5c0,
      0xfe883, 0x44388, 0x8bbf4, 0xba975, 0x434fb, 0x9f33c, 0x156bc,
      0xcba87, 0x2b971, 0x9098b, 0x5c1f4, 0xb245e, 0xc5dd6, 0x42b41,
      0xdcb53, 0x2d787, 0x34d85, 0xf80c6, 0x34db1, 0x433da, 0x32582,
      0x26d6e, 0x7df0c, 0x0653f, 0xf6682, 0xcb365, 0x7c360, 0x4ca56,
      0x656ac, 0x29826, 0x1faac, 0x76832, 0xbf069, 0x5ca6f, 0x3913f,
      0x70766, 0x7921a, 0xe1539, 0x00736, 0x32884, 0xbdf14, 0xc948d,
      0x9619f, 0x33eca, 0x00003 },
    { 0x75d81, 0x48ac7, 0x33379, 0xbbca2, 0xfd41d, 0xc2518, 0x94838,
      0xbcfce, 0xc7a4f, 0xe7623, 0x4703f, 0x62365, 0xbaad3, 0xfb3b5,
      0x3a413, 0x2b3a1, 0xc01f0, 0x5a7f5, 0xdb356, 0x96615, 0xc5235,
      0x2408d, 0xe91d7, 0x1d616, 0x7f8e5, 0x995a1, 0xb25b9, 0x6eebc,
      0xe90c1, 0x93743, 0xcf133, 0xf35e8, 0xb64a7, 0x4ae54, 0x87da7,
      0x449d9, 0xa65cd, 0x7b322, 0x15d55, 0x37e7b, 0x082a5, 0x4f765,
      0x2cd13, 0xc742f, 0x64d25, 0xcf074, 0xc074c, 0xae9d9, 0x8d135,
      0x10872, 0x2fc21, 0x00007 },
    { 0x004c8, 0x03f96, 0x906b2, 0x55ffa, 0xf4580, 0x3f95c, 0x909d8,
      0x55f35, 0xd5867, 0xeed77, 0x550c8, 0xa6fbe, 0x14a9e, 0xa0608,
      0xca955, 0x91c8c, 0x82062, 0x78bce, 0xa1fee, 0xf85e4, 0x69a3d,
      0x9ade0, 0x666eb, 0x7d3de, 0xdcf0c, 0x51fbb, 0xd336d, 0x391b5,
      0xc228a, 0x2ffc3, 0xd285c, 0x760f8, 0xb165b, 0xe32f7, 0xee48d,
      0x70401, 0x45617, 0x803d8, 0x9a003, 0x9deff, 0x3f648, 0xa4e57,
      0x17e35, 0x738ea, 0x6e1a2, 0x40a6c, 0x17c88, 0x238ef, 0xed92d,
      0xf8b11, 0x80946, 0x00004 },
    { 0x1f119, 0xa8fd7, 0x4c747, 0x36958, 0xe53eb, 0xe65c5, 0x87a19,
      0x62985, 0xf6786, 0xf40e2, 0xb18d6, 0x8899a, 0x048a4, 0x30b8c,
      0x024c6, 0xa1a99, 0xaf892, 0x962ca, 0x49750, 0xd6248, 0xae20f,
      0x869ab, 0xdd4c8, 0x6c2b7, 0x2b04d, 0xd03b7, 0x992f7, 0x5eb60,
      0x4e277, 0x06e68, 0x06e7d, 0x0089c, 0xbd007, 0x61e4b, 0xb3b43,
      0x46e4c, 0xb4ba8, 0xae666, 0xd9ea1, 0x46464, 0xc2eb2, 0x9fc01,
      0x1f853, 0x2be6c, 0x7f86f, 0x68afc, 0x8aecf, 0x16e8e, 0x86902,
      0xfdc73, 0xdab61, 0x00008 },
    { 0xd1d45, 0x03d54, 0x2a5c9, 0x9ba24, 0xeff4f, 0xd4297, 0x8b4ac,
      0x34d47, 0x8b520, 0x1a2d8, 0x8c462, 0xba2b0, 0x235b2, 0x86540,
      0x9bb34, 0xd3d23, 0xf32e6, 0xed911, 0xde76a, 0xfdc21, 0xf3f06,
      0x7f8bc, 0x50287, 0x9ec51, 0x714c1, 0x0d802, 0x59070, 0x44eba,
      0x7a104, 0xdcc95, 0x29f31, 0x86942, 0x69fed, 0xabb81, 0xece77,
      0x080e5, 0x52caf, 0xbe8a1, 0xef155, 0xcbd7c, 0x21b14, 0xe13eb,
      0x7b97e, 0x7ad16, 0xc9def, 0x8f690, 0x87911, 0xe03ca, 0xb29e7,
      0x2df99, 0xf77e6, 0x00006 },
    { 0xbbf59, 0xede40, 0x271bd, 0xaad6a, 0x36401, 0x7ba45, 0xcd117,
      0x73541, 0x5e035, 0x2f175, 0xb71b0, 0xb4664, 0xf3465, 0x13359,
      0x113a8, 0x22eb7, 0x8eac7, 0xfd6f3, 0x792a8, 0xf3b59, 0xfff3b,
      0xaa012, 0xfbf11, 0xf85c3, 0xafabf, 0x4299a, 0x6c0cc, 0xa2ef0,
      0xa91e0, 0x3b7b3, 0xd5777, 0x314d5, 0x9840a, 0x76d66, 0xe5e2e,
      0x8be6a, 0x32e5a, 0x13607, 0x58086, 0xc1cf5, 0xd7578, 0x02ee6,
      0x8bed1, 0xe00f6, 0xb2344, 0x84f0e, 0x88681, 0x799d7, 0x2cf80,
      0x91c3d, 0x3819c, 0x00006 },
    { 0x4b073, 0xe1788, 0xa5392, 0x67eac, 0xceb12, 0xc3a1f, 0x8a79e,
      0x90703, 0x7f5f0, 0x703d0, 0x4c47b, 0xc07ce, 0x1cb2a, 0xf96b9,
      0x4ee1b, 0xf9666, 0xa4fbf, 0x892ae, 0xbf575, 0x6500e, 0x1fade,
      0xabf39, 0x2045a, 0x171d1, 0x3376f, 0x1ac5b, 0x0d3d8, 0x0c51a,
      0xb1ff6, 0x6a844, 0xfe797, 0x10b2c, 0x6125a, 0x9abda, 0x131cc,
      0x453ee, 0x34ebd, 0xfc16d, 0xbc1e0, 0x504b6, 0x0319a, 0xabc0d,
      0xa2f8c, 0x0be70, 0x7e43a, 0xe49b4, 0xeec55, 0xc80af, 0x5d7ee,
      0x12826, 0x7d48d, 0x00006 },
    { 0xd56d6, 0xa7ea2, 0x68d59, 0x0a630, 0xe2748, 0x1abd0, 0x6cdd7,
      0xae736, 0x11db0, 0xbc6bd, 0x7204e, 0x39ca0, 0x3fbb6, 0x7e629,
      0x2e7f7, 0x89a24, 0xa8c3d, 0x2b75b, 0xee7ca, 0xf9a8d, 0xd64a2,
      0x2ddc3, 0x01047, 0x7561a, 0x29df4, 0xd4842, 0x5b649, 0x2c85c,
      0xd95f6, 0xc927c, 0xb1b4d, 0xfdd56, 0x60596, 0x205ee, 0xe8bb1,
      0x9401f, 0x0abf2, 0xfcaa5, 0x1843e, 0x10d1c, 0x00d0f, 0xf5d49,
      0x8b01d, 0x13a92, 0x52cf1, 0x0e43f, 0xbc31f, 0xa3d7e, 0x84dc7,
      0x38e83, 0x7950e, 0x00002 },
    { 0x0fa79, 0xf0e1d, 0xab21f, 0x5de9e, 0x3048b, 0x9fd03, 0x4cb4b,
      0x2fe37, 0x34689, 0x6b4c9, 0xeb21f, 0x27fa4, 0x7bb48, 0x25e7e,
      0xf79a9, 0x46716, 0x4c531, 0x367dd, 0x442bf, 0x6ddf1, 0xcd2e9,
      0x73954, 0xa8920, 0x8502a, 0x141ae, 0xc94e0, 0xeef6c, 0x0e1a8,
      0xf8ee0, 0x80cda, 0x49158, 0x55ce8, 0x28046, 0x5c696, 0xf3aba,
      0xdfbff, 0x85d15, 0x5cc4f, 0xf2533, 0x9f684, 0x0440c, 0xd8a7f,
      0xb1e5b, 0x453fb, 0xbae80, 0x2225a, 0x813ff, 0xa1c99, 0x25d71,
      0x8479b, 0x4ff78, 0x00005 },
    { 0x0b068, 0x30de4, 0x7c6ee, 0xa51e2, 0xbe6f3, 0x26465, 0x1f692,
      0xfa3b2, 0xa4604, 0x15e24, 0x04181, 0xa5adc, 0xb50a5, 0xf90d2,
      0x4418d, 0xe3285, 0x0c00f, 0x8fdcb, 0xb74e5, 0x08e3b, 0xb4a2c,
      0x8f1b3, 0xec9c6, 0x0ccd9, 0xdf081, 0x9f339, 0x786ea, 0x62dcb,
      0xd9153, 0x55aea, 0xe31c9, 0x28945, 0xa6c6b, 0x1d8b6, 0x6a2c0,
      0xa427d, 0xc3678, 0x9e82d, 0x02c06, 0x28c93, 0x75500, 0xe6178,
      0xfa101, 0xa9659, 0x68acd, 0x30b28, 0x573ee, 0x4e4e4, 0x830fe,
      0x853f1, 0xadbad, 0x00008 },
    { 0x9d524, 0x1f096, 0x60ae1, 0xcc790, 0x7f39b, 0x2fdaf, 0xcc2f4,
      0x7cc1f, 0xc6766, 0x4f3ce, 0x2336d, 0x9cf2e, 0xf456b, 0x1c0f7,
      0x5de8e, 0x6aa1f, 0x4fb0e, 0xd2098, 0xdbc2a, 0x4b28c, 0x61b46,
      0x90cfa, 0x3ef40, 0x1243f, 0x86f30, 0xe740d, 0xd5e87, 0x6cccc,
      0x195b1, 0x26cd4, 0x68c30, 0x403f1, 0xc0730, 0xcb816, 0xbe386,
      0x7a1dd, 0x35840, 0xeb86f, 0x1af14, 0x1717e, 0x8b4f8, 0x6cf58,
      0x6cbc9, 0x41a66, 0x1b75c, 0x7e71c, 0x1aa02, 0xf342c, 0x45e5f,
      0x36c09, 0x39300, 0x00007 },
    { 0xdaf42, 0x7d22c, 0x54f75, 0x1aab9, 0xdf418, 0x8b591, 0xf2578,
      0xf5514, 0x86819, 0xbc8b9, 0x18fd5, 0x2e08f, 0x16964, 0x2ceb9,
      0x5d102, 0x92b30, 0xf6985, 0x3e6a4, 0x71590, 0x9cae1, 0xd6117,
      0xd7d69, 0x1aa4b, 0xd29c0, 0xdfd5d, 0xccdac, 0x91108, 0xdd5ad,
      0x5705d, 0xac8f1, 0x7b164, 0x434ac, 0x4632f, 0xe1b52, 0x1a514,
      0xc4476, 0xb731f, 0xb9e61, 0xb3145, 0xe0961, 0x61348, 0x23cf5,
      0x3eaf2, 0xa9677, 0x39c28, 0x7c99d, 0x182aa, 0x5bd10, 0x965e2,
      0x4ae42, 0xbc6ec, 0x00008 },
    { 0x2a32b, 0xc0e7f, 0x096e5, 0x8a30d, 0xc0938, 0x54800, 0x60cff,
      0x401e3, 0xe437c, 0xa606f, 0xb6054, 0xfc9cb, 0xe6655, 0x57aa6,
      0x86084, 0x510e1, 0x9b2b7, 0xa22b2, 0x0acfc, 0xda61a, 0x351b7,
      0x2483e, 0x8ca73, 0x6be6c, 0x471ee, 0xa1e31, 0xb65c9, 0x431c8,
      0xbe565, 0xd65cb, 0x3b948, 0xfc9ac, 0xb2aa8, 0x21ae9, 0x308fc,
      0xaa6ad, 0xdaa60, 0xa7df0, 0x0d4d6, 0x982fc, 0x4d96a, 0xd7284,
      0x847a4, 0x2c2c5, 0x5ab01, 0xeb895, 0xf71dc, 0x2b3c8, 0xc7e15,
      0x7dbe9, 0xe8543, 0x00008 },
};

/* Perform the modular exponentiation in Fp* for SAKKE.
 *
 * Base is fixed to be the g parameter - a precomputed table is used.
 *
 * Striping: 128 points at a distance of (8 combined for
 * a total of 340282366920938463463374607431768211456 points in table.
 * Square and multiply performed in Fp*.
 *
 * base  [in]   Base. MP integer.
 * exp   [in]   Exponent. MP integer.
 * res   [out]  Result. MP integer.
 * returns 0 on success, MP_READ_E if there are too many bytes in an array
 * and MEMORY_E if memory allocation fails.
 */
int sp_ModExp_Fp_star_1024(const mp_int* base, mp_int* exp, mp_int* res)
{
    sp_digit t[4 * 2 * 52];
    sp_digit tx[2 * 52];
    sp_digit ty[2 * 52];
    sp_digit* r = ty;
    unsigned char e[128];
    int err = MP_OKAY;
    int i;
    int y;

    (void)base;

    if (err == MP_OKAY) {
        (void)mp_to_unsigned_bin_len(exp, e, 128);

        XMEMCPY(tx, p1024_norm_mod, sizeof(sp_digit) * 52);
        y  =  (e[112] >> 7) & 1;
        y |= ((e[96] >> 7) & 1) << 1;
        y |= ((e[80] >> 7) & 1) << 2;
        y |= ((e[64] >> 7) & 1) << 3;
        y |= ((e[48] >> 7) & 1) << 4;
        y |= ((e[32] >> 7) & 1) << 5;
        y |= ((e[16] >> 7) & 1) << 6;
        y |= ((e[0] >> 7) & 1) << 7;
        XMEMCPY(ty, sp_1024_g_table[y], sizeof(sp_digit) * 52);
        for (i = 128-2; i >= 0; i--) {
            y  =  (e[127 - (i / 8 + 0)] >> (i & 0x7)) & 1;
            y |= ((e[127 - (i / 8 + 16)] >> (i & 0x7)) & 1) << 1;
            y |= ((e[127 - (i / 8 + 32)] >> (i & 0x7)) & 1) << 2;
            y |= ((e[127 - (i / 8 + 48)] >> (i & 0x7)) & 1) << 3;
            y |= ((e[127 - (i / 8 + 64)] >> (i & 0x7)) & 1) << 4;
            y |= ((e[127 - (i / 8 + 80)] >> (i & 0x7)) & 1) << 5;
            y |= ((e[127 - (i / 8 + 96)] >> (i & 0x7)) & 1) << 6;
            y |= ((e[127 - (i / 8 + 112)] >> (i & 0x7)) & 1) << 7;

            sp_1024_proj_sqr_52(tx, ty, t);
            sp_1024_proj_mul_qx1_52(tx, ty, sp_1024_g_table[y], t);
        }
    }

    if (err == MP_OKAY) {
        sp_1024_mont_inv_52(tx, tx, t);
        sp_1024_mont_mul_52(r, tx, ty, p1024_mod, p1024_mp_mod);
        XMEMSET(r + 52, 0, sizeof(sp_digit) * 52);
        sp_1024_mont_reduce_52(r, p1024_mod, p1024_mp_mod);

        err = sp_1024_to_mp(r, res);
    }

    return err;
}

#endif /* WOLFSSL_SP_SMALL */
/* Multiply p* by q* in projective co-ordinates.
 *
 *   p.x' = (p.x * q.x) - (p.y * q.y)
 *   p.y' = (p.x * q.y) + (p.y * q.x)
 *
 * px  [in,out]  A single precision integer - X ordinate of number to multiply.
 * py  [in,out]  A single precision integer - Y ordinate of number to multiply.
 * qx  [in]      A single precision integer - X ordinate of number of
 *               multiplier.
 * qy  [in]      A single precision integer - Y ordinate of number of
 *               multiplier.
 * t   [in]      Two single precision integers - temps.
 */
static void sp_1024_proj_mul_52(sp_digit* px, sp_digit* py,
        const sp_digit* qx, const sp_digit* qy, sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2 * 52;

    /* t1 = p.x * q.y */
    sp_1024_mont_mul_52(t1, px, qy, p1024_mod, p1024_mp_mod);
    /* r->x = p.x * q.x */
    sp_1024_mont_mul_52(px, px, qx, p1024_mod, p1024_mp_mod);
    /* t2 = p.y * q.y */
    sp_1024_mont_mul_52(t2, py, qy, p1024_mod, p1024_mp_mod);
    /* r.x = (p.x * q.x) - (p.y * q.y) */
    sp_1024_mont_sub_52(px, px, t2, p1024_mod);
    /* r.y = p.y * q.x */
    sp_1024_mont_mul_52(py, py, qx, p1024_mod, p1024_mp_mod);
    /* r.y = (p.x * q.y) + (p.y * q.x) */
    sp_1024_mont_add_52(py, t1, py, p1024_mod);
}

#ifndef WOLFSSL_SP_SMALL
/*
 * Convert point from projective to affine but keep in Montgomery form.
 *
 * p  [in,out]  Point to convert.
 * t  [in]      Temporary numbers: 2.
 */
static void sp_1024_mont_map_52(sp_point_1024* p, sp_digit* t)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t + 2 * 52;

    sp_1024_mont_inv_52(t1, p->z, t2);
    sp_1024_mont_sqr_52(t2, t1, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(t1, t2, t1, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(p->x, p->x, t2, p1024_mod, p1024_mp_mod);
    sp_1024_mont_mul_52(p->y, p->y, t1, p1024_mod, p1024_mp_mod);
    XMEMCPY(p->z, p1024_norm_mod, sizeof(sp_digit) * 52);
}

#endif /* WOLFSSL_SP_SMALL */
/*
 * Calculate gradient of line through P, P and [-2]P, accumulate line and
 * double P.
 *
 * Calculations:
 *   l = 3 * (p.x^2 - p.z^4) = 3 * (p.x - p.z^2) * (p.x + p.z^2)
 *   r.x = l * (p.x + q.x * p.z^2) - 2 * p.y^2
 *   r.y = 2 * p.y * p.z^3 * q.y
 *   v* = v*^2 * r*
 *   p'.x = l^2 - 8 * p.y^2 * p.x
 *   p'.y = (4 * p.y^2 * p.x - p'.x) * l - 8 * p.y^4
 *   p'.z = 2 * p.y * p.z
 *
 * @param  [in]  vx  X-ordinate of projective value in F*.
 * @param  [in]  vy  Y-ordinate of projective value in F*.
 * @param  [in]  p   ECC point - point on E(F_p^2) to double.
 * @param  [in]  q   ECC point - second point on E(F_P^2).
 * @param  [in]  t   SP temporaries (6 used).
 */
static void sp_1024_accumulate_line_dbl_52(sp_digit* vx, sp_digit* vy,
        sp_point_1024* p, const sp_point_1024* q, sp_digit* t)
{
    sp_digit* t1  = t +  0 * 52;
    sp_digit* pz2 = t +  2 * 52;
    sp_digit* rx  = t +  4 * 52;
    sp_digit* ry  = t +  6 * 52;
    sp_digit* l   = t +  8 * 52;
    sp_digit* ty  = t + 10 * 52;

    /* v = v^2 */
    sp_1024_proj_sqr_52(vx, vy, t);
    /* pz2 = p.z^2 */
    sp_1024_mont_sqr_52(pz2, p->z, p1024_mod, p1024_mp_mod);
    /* t1 = p.x + p.z^2 */
    sp_1024_mont_add_52(t1, p->x, pz2, p1024_mod);
    /* l = p.x - p.z^2 */
    sp_1024_mont_sub_52(l, p->x, pz2, p1024_mod);
    /* t1 = (p.x + p.z^2) * (p.x - p.z^2) = p.x^2 - p.z^4 */
    sp_1024_mont_mul_52(t1, l, t1, p1024_mod, p1024_mp_mod);
    /* l = 3 * (p.x^2 - p.z^4) */
    sp_1024_mont_tpl_52(l, t1, p1024_mod);
    /* t1 = q.x * p.z^2 */
    sp_1024_mont_mul_52(t1, q->x, pz2, p1024_mod, p1024_mp_mod);
    /* t1 = p.x + q.x * p.z^2 */
    sp_1024_mont_add_52(t1, p->x, t1, p1024_mod);
    /* r.x = l * (p.x + q.x * p.z^2) */
    sp_1024_mont_mul_52(rx, l, t1, p1024_mod, p1024_mp_mod);
    /* r.y = 2 * p.y */
    sp_1024_mont_dbl_52(ry, p->y, p1024_mod);
    /* ty = 4 * p.y ^ 2 */
    sp_1024_mont_sqr_52(ty, ry, p1024_mod, p1024_mp_mod);
    /* t1 = 2 * p.y ^ 2 */
    sp_1024_div2_52(t1, ty, p1024_mod);
    /* r.x -= 2 * (p.y ^ 2) */
    sp_1024_mont_sub_52(rx, rx, t1, p1024_mod);
    /* p'.z = p.y * 2 * p.z */
    sp_1024_mont_mul_52(p->z, p->z, ry, p1024_mod, p1024_mp_mod);
    /* r.y = p'.z * p.z^2 */
    sp_1024_mont_mul_52(ry, p->z, pz2, p1024_mod, p1024_mp_mod);
    /* r.y = p'.z * p.z^2 * q.y */
    sp_1024_mont_mul_52(ry, ry, q->y, p1024_mod, p1024_mp_mod);
    /* v = v^2 * r */
    sp_1024_proj_mul_52(vx, vy, rx, ry, t);

    /* Double point using previously calculated values
     *   l = 3 * (p.x - p.z^2).(p.x + p.z^2)
     *   ty = 4 * p.y^2
     *   p'.z = 2 * p.y * p.z
     */
    /* t1 = (4 * p.y^2) ^ 2 = 16 * p.y^4 */
    sp_1024_mont_sqr_52(t1, ty, p1024_mod, p1024_mp_mod);
    /* t1 = 16 * p.y^4 / 2 = 8 * p.y^4 */
    sp_1024_div2_52(t1, t1, p1024_mod);
    /* p'.y = 4 * p.y^2 * p.x */
    sp_1024_mont_mul_52(p->y, ty, p->x, p1024_mod, p1024_mp_mod);
    /* p'.x = l^2 */
    sp_1024_mont_sqr_52(p->x, l, p1024_mod, p1024_mp_mod);
    /* p'.x = l^2 - 4 * p.y^2 * p.x */
    sp_1024_mont_sub_52(p->x, p->x, p->y, p1024_mod);
    /* p'.x = l^2 - 8 * p.y^2 * p.x */
    sp_1024_mont_sub_52(p->x, p->x, p->y, p1024_mod);
    /* p'.y = 4 * p.y^2 * p.x - p.x' */
    sp_1024_mont_sub_52(p->y, p->y, p->x, p1024_mod);
    /* p'.y = (4 * p.y^2 * p.x - p'.x) * l */
    sp_1024_mont_mul_52(p->y, p->y, l, p1024_mod, p1024_mp_mod);
    /* p'.y = (4 * p.y^2 * p.x - p'.x) * l - 8 * p.y^4 */
    sp_1024_mont_sub_52(p->y, p->y, t1, p1024_mod);
}

#ifdef WOLFSSL_SP_SMALL
/*
 * Calculate gradient of line through C, P and -C-P, accumulate line and
 * add P to C.
 *
 * Calculations:
 *   r.x = (q.x + p.x) * c.y - (q.x * c.z^2 + c.x) * p.y * c.z
 *   r.y = (c.x - p.x * c.z^2) * q.y * c.z
 *   v* = v* * r*
 *   r = p.y * c.z^3 - c.y
 *   c'.x = r^2 + h^3 - 2 * c.x * h^2
 *   c'.y = r * (c'.x - c.x * h^2) - c.y * h^3
 *   c'.z = (c.x - p.x * c.z^2) * c.z
 *
 * @param  [in]  vx     X-ordinate of projective value in F*.
 * @param  [in]  vy     Y-ordinate of projective value in F*.
 * @param  [in]  c      ECC point - current point on E(F_p^2) to be added to.
 * @param  [in]  p      ECC point - point on E(F_p^2) to add.
 * @param  [in]  q      ECC point - second point on E(F_P^2).
 * @param  [in]  qx_px  SP that is a constant value across adds.
 * @param  [in]  t      SP temporaries (6 used).
 */
static void sp_1024_accumulate_line_add_one_52(sp_digit* vx, sp_digit* vy,
        sp_point_1024* c, sp_point_1024* p, sp_point_1024* q, sp_digit* qx_px,
        sp_digit* t)
{
    sp_digit* t1  = t;
    sp_digit* t2  = t +  2 * 52;
    sp_digit* rx  = t +  4 * 52;
    sp_digit* ry  = t +  6 * 52;
    sp_digit* h   = t +  8 * 52;
    sp_digit* r   = t + 10 * 52;

    /* r.x = (q.x + p.x) * c.y */
    sp_1024_mont_mul_52(rx, qx_px, c->y, p1024_mod, p1024_mp_mod);
    /* t2 = c.z^2 */
    sp_1024_mont_sqr_52(t2, c->z, p1024_mod, p1024_mp_mod);
    /* t1 = q.x * c.z^2 */
    sp_1024_mont_mul_52(t1, q->x, t2, p1024_mod, p1024_mp_mod);
    /* t1 = q.x * c.z^2 + c.x */
    sp_1024_mont_add_52(t1, t1, c->x, p1024_mod);
    /* r = p.y * c.z */
    sp_1024_mont_mul_52(r, p->y, c->z, p1024_mod, p1024_mp_mod);
    /* t1 = (q.x * c.z^2 + c.x) * p.y * c.z */
    sp_1024_mont_mul_52(t1, t1, r, p1024_mod, p1024_mp_mod);
    /* r.x -= (q.x * c.z^2 + c.x) * p.y * c.z */
    sp_1024_mont_sub_52(rx, rx, t1, p1024_mod);
    /* t1 = p.x * c.z^2 */
    sp_1024_mont_mul_52(t1, p->x, t2, p1024_mod, p1024_mp_mod);
    /* h = c.x - p.x * c.z^2 */
    sp_1024_mont_sub_52(h, c->x, t1, p1024_mod);
    /* c'.z = (c.x - p.x * c.z^2) * c.z */
    sp_1024_mont_mul_52(c->z, h, c->z, p1024_mod, p1024_mp_mod);
    /* r.y = (c.x - p.x * c.z^2) * c.z * q.y */
    sp_1024_mont_mul_52(ry, c->z, q->y, p1024_mod, p1024_mp_mod);
    /* r = p.y * c.z * c.z^2 = p.y * c.z^3  */
    sp_1024_mont_mul_52(r, r, t2, p1024_mod, p1024_mp_mod);
    /* v = v * r */
    sp_1024_proj_mul_52(vx, vy, rx, ry, t);

    /* Add p to c using previously calculated values.
     *   h = c.x - p.x * c.z^2
     *   r = p.y * c.z^3
     *   c'.z = (c.x - p.x * c.z^2) * c.z
     */

    /* r = p.y * c.z^3 - c.y */
    sp_1024_mont_sub_52(r, r, c->y, p1024_mod);
    /* t1 = r^2 */
    sp_1024_mont_sqr_52(t1, r, p1024_mod, p1024_mp_mod);
    /* t2 = h^2 */
    sp_1024_mont_sqr_52(t2, h, p1024_mod, p1024_mp_mod);
    /* ry = c.x * h^2 */
    sp_1024_mont_mul_52(ry, c->x, t2, p1024_mod, p1024_mp_mod);
    /* t2 = h^3 */
    sp_1024_mont_mul_52(t2, t2, h, p1024_mod, p1024_mp_mod);
    /* c->x = r^2 + h^3 */
    sp_1024_mont_add_52(c->x, t1, t2, p1024_mod);
    /* t1 = 2 * c.x * h^2 */
    sp_1024_mont_dbl_52(t1, ry, p1024_mod);
    /* c'.x = r^2 + h^3 - 2 * c.x * h^2 */
    sp_1024_mont_sub_52(c->x, c->x, t1, p1024_mod);
    /* ry = c'.x - c.x * h^2 */
    sp_1024_mont_sub_52(ry, c->x, ry, p1024_mod);
    /* ry = r * (c'.x - c.x * h^2) */
    sp_1024_mont_mul_52(ry, ry, r, p1024_mod, p1024_mp_mod);
    /* t2 = c.y * h^3 */
    sp_1024_mont_mul_52(t2, t2, c->y, p1024_mod, p1024_mp_mod);
    /* c'.y = r * (c'.x - c.x * h^2) - c.y * h^3 */
    sp_1024_mont_sub_52(c->y, ry, t2, p1024_mod);
}

/*
 * Calculate r = pairing <P, Q>.
 *
 * That is, multiply base in PF_p[q] by the scalar s, such that s.P = Q.
 *
 * @param  [in]  key  SAKKE key.
 * @param  [in]  p    First point on E(F_p)[q].
 * @param  [in]  q    Second point on E(F_p)[q].
 * @param  [in]  r    Result of calculation.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  Other -ve value on internal failure.
 */
int sp_Pairing_1024(const ecc_point* pm, const ecc_point* qm, mp_int* res)
{
    int err;
    sp_digit vx[2 * 52];
    sp_digit vy[2 * 52];
    sp_digit qx_px[2 * 52];
    sp_digit* r = vy;
    sp_point_1024 p[1];
    sp_point_1024 q[1];
    sp_point_1024 c[1];
    sp_digit t[6 * 2 * 52];
    int i;

    sp_1024_point_from_ecc_point_52(p, pm);
    sp_1024_point_from_ecc_point_52(q, qm);

    err = sp_1024_mod_mul_norm_52(p->x, p->x, p1024_mod);
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(p->y, p->y, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(p->z, p->z, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(q->x, q->x, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(q->y, q->y, p1024_mod);
    }
    if (err == MP_OKAY) {
        XMEMCPY(c, p, sizeof(sp_point_1024));
        XMEMSET(vx, 0, sizeof(sp_digit) * 2 * 52);
        vx[0] = 1;
        XMEMSET(vy, 0, sizeof(sp_digit) * 2 * 52);

        sp_1024_mont_add_52(qx_px, q->x, p->x, p1024_mod);

        for (i = 1020; i >= 0; i--) {
            /* Accumulate line into v and double point. */
            sp_1024_accumulate_line_dbl_52(vx, vy, c, q, t);

            if ((i > 0) && ((p1024_order[i / 20] >> (i % 20)) & 1)) {
                /* Accumulate line into v and add P into C. */
                sp_1024_accumulate_line_add_one_52(vx, vy, c, p, q, qx_px, t);
            }
        }

        /* Final exponentiation */
        sp_1024_proj_sqr_52(vx, vy, t);
        sp_1024_proj_sqr_52(vx, vy, t);

        /* Convert from PF_p[q] to F_p */
        sp_1024_mont_inv_52(vx, vx, t);
        sp_1024_mont_mul_52(r, vx, vy, p1024_mod, p1024_mp_mod);
        XMEMSET(r + 52, 0, sizeof(sp_digit) * 52);
        sp_1024_mont_reduce_52(r, p1024_mod, p1024_mp_mod);

        err = sp_1024_to_mp(r, res);
    }

    return err;
}

#else
/*
 * Calculate gradient of line through C, P and -C-P, accumulate line and
 * add P to C.
 *
 * Both C and P have z ordinates to use in the calculation.
 *
 * Calculations:
 *   r.x = (q.x * p.z^2 + p.x) * c.y * p.z - (q.x * c.z^2 + c.x) * p.y * c.z
 *   r.y = (c.x * p.z^2 - p.x * c.z^2) * q.y * p.z * c.z
 *   v = v * r
 *   c'.x = r^2 - h^3 - 2 * c.x * p.z^2 * h^2
 *   c'.y = r * (c.x * p.z^2 * h^2 - c'.x) - c.y * p.z^3 * h^3
 *   c'.z = (p.x * c.z^2 - c.x * p.z^2) * c.z
 *
 * @param  [in]  vx     X-ordinate of projective value in F*.
 * @param  [in]  vy     Y-ordinate of projective value in F*.
 * @param  [in]  c      ECC point - current point on E(F_p^2) to be added to.
 * @param  [in]  p      ECC point - point on E(F_p^2) to add.
 * @param  [in]  q      ECC point - second point on E(F_P^2).
 * @param  [in]  t      SP temporaries (6 used).
 * @param  [in]  neg    Indicates to use negative P.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  Other -ve value on internal failure.
 */
static void sp_1024_accumulate_line_add_n_52(sp_digit* vx, sp_digit* vy,
        const sp_point_1024* p, const sp_point_1024* q,
        sp_point_1024* c, sp_digit* t, int neg)
{
    sp_digit* t1 = t;
    sp_digit* t2 = t +  2 * 52;
    sp_digit* rx = t +  4 * 52;
    sp_digit* ry = t +  6 * 52;
    sp_digit* h  = t +  8 * 52;
    sp_digit* r  = t + 10 * 52;

    /* h = p.z^2 */
    sp_1024_mont_sqr_52(h, p->z, p1024_mod, p1024_mp_mod);
    /* rx = q.x * p.z^2 */
    sp_1024_mont_mul_52(rx, q->x, h, p1024_mod, p1024_mp_mod);
    /* rx = q.x * p.z^2 + p.x */
    sp_1024_mont_add_52(rx, rx, p->x, p1024_mod);
    /* c.y = c.y * p.z */
    sp_1024_mont_mul_52(c->y, c->y, p->z, p1024_mod, p1024_mp_mod);
    /* r.x = (q.x * p.z^2 + p.x) * c.y * p.z */
    sp_1024_mont_mul_52(rx, rx, c->y, p1024_mod, p1024_mp_mod);
    /* c.y = c.y * p.z^3 */
    sp_1024_mont_mul_52(c->y, c->y, h, p1024_mod, p1024_mp_mod);
    /* t2 = c.z^2 */
    sp_1024_mont_sqr_52(t2, c->z, p1024_mod, p1024_mp_mod);
    /* t1 = q.x * c.z^2 */
    sp_1024_mont_mul_52(t1, q->x, t2, p1024_mod, p1024_mp_mod);
    /* t1 = q.x * c.z^2 + c.x */
    sp_1024_mont_add_52(t1, t1, c->x, p1024_mod);
    /* c.x = c.x * p.z^2 */
    sp_1024_mont_mul_52(c->x, c->x, h, p1024_mod, p1024_mp_mod);
    /* r = p.y * c.z */
    sp_1024_mont_mul_52(r, p->y, c->z, p1024_mod, p1024_mp_mod);
    if (neg) {
        /* r = -p.y * c.z */
        sp_1024_mont_sub_52(r, p1024_mod, r, p1024_mod);
    }
    /* t1 = (q.x * c.z^2 + c.x) * p.y * c.z */
    sp_1024_mont_mul_52(t1, t1, r, p1024_mod, p1024_mp_mod);
    /* r.x -= (q.x * c.z^2 + c.x) * p.y * c.z */
    sp_1024_mont_sub_52(rx, t1, rx, p1024_mod);
    /* t1 = p.x * c.z^2 */
    sp_1024_mont_mul_52(t1, p->x, t2, p1024_mod, p1024_mp_mod);
    /* h = p.x * c.z^2 - c.x * p.z^2 */
    sp_1024_mont_sub_52(h, t1, c->x, p1024_mod);
    /* c'.z = (p.x * c.z^2 - c.x * p.z^2) * c.z */
    sp_1024_mont_mul_52(c->z, h, c->z, p1024_mod, p1024_mp_mod);
    /* c'.z = (p.x * c.z^2 - c.x * p.z^2) * c.z * p.z */
    sp_1024_mont_mul_52(c->z, c->z, p->z, p1024_mod, p1024_mp_mod);
    /* r.y = (p.x * c.z^2 - c.x * p.z^2) * c.z * p.z * q.y */
    sp_1024_mont_mul_52(ry, c->z, q->y, p1024_mod, p1024_mp_mod);
    /* r = p.y * c.z^3 */
    sp_1024_mont_mul_52(r, r, t2, p1024_mod, p1024_mp_mod);
    /* r = p.y * c.z^3 - c.y * p.z^3 */
    sp_1024_mont_sub_52(r, r, c->y, p1024_mod);
    /* v = v * r */
    sp_1024_proj_mul_52(vx, vy, rx, ry, t);

    /* Add p to c using previously calculated values.
     *   h = p.x * c.z^2 - c.x * p.z^2
     *   r = p.y * c.z^3
     *   c'.z = (p.x * c.z^2 - c.x * p.z^2) * c.z
     */

    /* t1 = r^2 */
    sp_1024_mont_sqr_52(t1, r, p1024_mod, p1024_mp_mod);
    /* t2 = h^2 */
    sp_1024_mont_sqr_52(t2, h, p1024_mod, p1024_mp_mod);
    /* ry = c.x * p.z^2 * h^2 */
    sp_1024_mont_mul_52(ry, t2, c->x, p1024_mod, p1024_mp_mod);
    /* t2 = h^3 */
    sp_1024_mont_mul_52(t2, t2, h, p1024_mod, p1024_mp_mod);
    /* c'.x = r^2 - h^3 */
    sp_1024_mont_sub_52(c->x, t1, t2, p1024_mod);
    /* t1 = 2 * c.x * p.z^2 * h^2 */
    sp_1024_mont_dbl_52(t1, ry, p1024_mod);
    /* c'.x = r^2 - h^3 - 2 * c.x * p.z^2 * h^2 */
    sp_1024_mont_sub_52(c->x, c->x, t1, p1024_mod);
    /* ry = c.x * p.z^2 * h^2 - c'.x */
    sp_1024_mont_sub_52(ry, ry, c->x, p1024_mod);
    /* ry = r * (c.x * p.z^2 * h^2 - c'.x) */
    sp_1024_mont_mul_52(ry, ry, r, p1024_mod, p1024_mp_mod);
    /* t2 = c.y * p.z^3 * h^3 */
    sp_1024_mont_mul_52(t2, t2, c->y, p1024_mod, p1024_mp_mod);
    /* c'.y = r * (c.x * p.z^2 * h^2 - c'.x) - c.y * p.z^3 * h^3 */
    sp_1024_mont_sub_52(c->y, ry, t2, p1024_mod);
}

/* Operations to perform based on order - 1.
 * Sliding window. Start at bottom and stop when bottom bit is one.
 * Subtract if top bit in window is one.
 * Width of 6 bits.
 * Pairs: #dbls, add/subtract window value
 */
static const signed char sp_1024_order_op[] = {
   5,   6, -13,   9, -21,   6,  -5,   8,  31,   6,   3,   6, -27,   6,  25,   9,
  -1,   6, -11,   6, -13,   6,  -7,   6, -15,   6, -29,   7,  25,   6,  -9,   6,
 -19,   7,   3,   6,  11,   9, -23,   6,   1,   6,  27,   6,   1,   7, -25,   8,
  13,   7, -13,   7, -23,  10,  19,   7,   7,   7,  -3,   7,  27,   6,  -7,   7,
 -21,   7,  11,   7,  31,   8,   1,   7, -23,   6, -17,   6,  -3,  10,  11,   6,
 -21,   7, -27,  11, -29,   6,  -1,  10,  15,   8,  27,   7,  17,   6,  17,   7,
 -13,   8,  13,   6,  21,   7, -29,   6,  19,   7, -25,   6,  11,   9,  29,   7,
  -7,   8,  27,   7,  29,  10,  -1,   8,  -7,   8,  17,   6,  17,   7, -27,   7,
 -21,   6,  -9,   6, -27,  12, -23,   6,  19,   6,  13,   6, -11,   7,  27,   6,
  17,   6,  -7,   6, -25,   7, -29,   6,   9,   7,   7,   6,  13,   6, -25,   6,
 -19,   6,  13,   6, -11,   6,   5,   8,  19,   6, -21,   8,  23,   7,  27,   6,
 -13,   6, -19,  11,  29,   7, -15,   6,  -9,   7, -21,  10,  -3,   7,  21,  10,
  25,   6, -15,   6, -23,   6,  21,   6,   1,   6,  21,   7,  -3,   6,  -3,   7,
  -7,   6, -23,   7,   7,   8,  15,   9,   5,   6, -11,   6,  21,  11, -27,   7,
  27,   6, -11,   6,  31,   6, -21,   6,  19,   6,  -7,   8,  -7,  13,  -3,   6,
  -7,   7,  -3,   6,   1,   6,   7,   8,  19,   8,  11,   9,  -9,   7, -31,  12,
  25,   6, -17,   9, -15,   7,   5,   6,  25,   7,  -5,   7, -25,   6,  17,   8,
 -19,   6, -13,   6,  27,   8,   1,   7,  -5,   7,  -1,   6,  21,   6,   3,  10,
  -3,   1,
};
/*
 * Calculate r = pairing <P, Q>.
 *
 * That is, multiply base in PF_p[q] by the scalar s, such that s.P = Q.
 *
 * Sliding window. Start at bottom and stop when bottom bit is one.
 * Subtract if top bit in window is one.
 * Width of 6 bits.
 *
 * @param  [in]  pm   First point on E(F_p)[q].
 * @param  [in]  qm   Second point on E(F_p)[q].
 * @param  [in]  res  Result of calculation.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
int sp_Pairing_1024(const ecc_point* pm, const ecc_point* qm, mp_int* res)
{
    int err;
    sp_digit vx[2 * 52];
    sp_digit vy[2 * 52];
    sp_digit* r = vy;
    sp_point_1024 p[1];
    sp_point_1024 q[1];
    sp_point_1024 c[1];
    sp_point_1024 pre_p[16];
    sp_digit pre_vx[16][104];
    sp_digit pre_vy[16][104];
    sp_digit pre_nvy[16][104];
    sp_digit t[6 * 2 * 52];
    int i;
    int j;

    sp_1024_point_from_ecc_point_52(p, pm);
    sp_1024_point_from_ecc_point_52(q, qm);

    err = sp_1024_mod_mul_norm_52(p->x, p->x, p1024_mod);
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(p->y, p->y, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(p->z, p->z, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(q->x, q->x, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(q->y, q->y, p1024_mod);
    }
    if (err == MP_OKAY) {
        /* Generate pre-computation table: 1, 3, ... , 31 */
        XMEMCPY(&pre_p[0], p, sizeof(sp_point_1024));
        XMEMSET(pre_vx[0], 0, sizeof(sp_digit) * 2 * 52);
        pre_vx[0][0] = 1;
        XMEMSET(pre_vy[0], 0, sizeof(sp_digit) * 2 * 52);
        sp_1024_mont_sub_52(pre_nvy[0], p1024_mod, pre_vy[0], p1024_mod);

        /* [2]P for adding */
        XMEMCPY(c, p, sizeof(sp_point_1024));
        XMEMSET(vx, 0, sizeof(sp_digit) * 2 * 52);
        vx[0] = 1;
        XMEMSET(vy, 0, sizeof(sp_digit) * 2 * 52);
        sp_1024_accumulate_line_dbl_52(vx, vy, c, q, t);

        /* 3, 5, ... */
        for (i = 1; i < 16; i++) {
            XMEMCPY(&pre_p[i], &pre_p[i-1], sizeof(sp_point_1024));
            XMEMCPY(pre_vx[i], pre_vx[i-1], sizeof(sp_digit) * 2 * 52);
            XMEMCPY(pre_vy[i], pre_vy[i-1], sizeof(sp_digit) * 2 * 52);
            sp_1024_proj_mul_52(pre_vx[i], pre_vy[i], vx, vy, t);
            sp_1024_accumulate_line_add_n_52(pre_vx[i], pre_vy[i], c,
                    q, &pre_p[i], t, 0);
            sp_1024_mont_sub_52(pre_nvy[i], p1024_mod, pre_vy[i], p1024_mod);
        }

        j = sp_1024_order_op[0] / 2;
        XMEMCPY(c, &pre_p[j], sizeof(sp_point_1024));
        XMEMCPY(vx, pre_vx[j], sizeof(sp_digit) * 2 * 52);
        XMEMCPY(vy, pre_vy[j], sizeof(sp_digit) * 2 * 52);

        for (j = 0; j < sp_1024_order_op[1]; j++) {
            /* Accumulate line into v and double point. */
            sp_1024_accumulate_line_dbl_52(vx, vy, c, q, t);
        }

        for (i = 2; i < 290; i += 2) {
            j = sp_1024_order_op[i];
            if (j > 0) {
                j /= 2;
                /* Accumulate line into v and add P into C. */
                sp_1024_proj_mul_52(vx, vy, pre_vx[j], pre_vy[j], t);
                sp_1024_accumulate_line_add_n_52(vx, vy, &pre_p[j], q, c,
                    t, 0);
            }
            else {
                j = -j / 2;
                /* Accumulate line into v and add P into C. */

                sp_1024_proj_mul_52(vx, vy, pre_vx[j], pre_nvy[j], t);
                sp_1024_accumulate_line_add_n_52(vx, vy, &pre_p[j], q, c,
                    t, 1);
            }

            for (j = 0; j < sp_1024_order_op[i + 1]; j++) {
                /* Accumulate line into v and double point. */
                sp_1024_accumulate_line_dbl_52(vx, vy, c, q, t);
            }
        }

        /* Final exponentiation */
        sp_1024_proj_sqr_52(vx, vy, t);
        sp_1024_proj_sqr_52(vx, vy, t);

        /* Convert from PF_p[q] to F_p */
        sp_1024_mont_inv_52(vx, vx, t);
        sp_1024_mont_mul_52(r, vx, vy, p1024_mod, p1024_mp_mod);
        XMEMSET(r + 52, 0, sizeof(sp_digit) * 52);
        sp_1024_mont_reduce_52(r, p1024_mod, p1024_mp_mod);

        err = sp_1024_to_mp(r, res);
    }

    return err;
}

#endif /* WOLFSSL_SP_SMALL */
#ifdef WOLFSSL_SP_SMALL
/*
 * Generate table for pairing.
 *
 * Small implementation does not use a table - returns 0 length.
 *
 * pm     [in]      Point to generate table for.
 * table  [in]      Generated table.
 * len    [in,out]  On in, the size of the buffer.
 *                  On out, length of table generated.
 * @return  0 on success.
 *          LENGTH_ONLY_E when table is NULL and only length returned.
 *          BUFFER_E when len is too small.
 */
int sp_Pairing_gen_precomp_1024(const ecc_point* pm, byte* table,
        word32* len)
{
    int err = 0;

    if (table == NULL) {
        *len = 0;
        err = LENGTH_ONLY_E;
    }
    else if (*len != 0) {
        err = BUFFER_E;
    }

    (void)*pm;

    return err;
}

/*
 * Calculate r = pairing <P, Q>.
 *
 * That is, multiply base in PF_p[q] by the scalar s, such that s.P = Q.
 *
 * Small implementation does not use a table - use the normal implementation.
 *
 * @param  [in]  pm     First point on E(F_p)[q].
 * @param  [in]  qm     Second point on E(F_p)[q].
 * @param  [in]  res    Result of calculation.
 * @param  [in]  table  Precomputed table of values.
 * @param  [in]  len    Length of precomputed table of values in bytes.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
int sp_Pairing_precomp_1024(const ecc_point* pm, const ecc_point* qm,
    mp_int* res, const byte* table, word32 len)
{
    (void)table;
    (void)len;
    return sp_Pairing_1024(pm, qm, res);
}

#else
/*
 * Calc l and c for the point when doubling p.
 *
 * l = 3 * (p.x^2 - 1) / (2 * p.y)
 * c = l * p.x - p.y
 *
 * @param  [out]  lr  Gradient result - table entry.
 * @param  [out]  cr  Constant result - table entry.
 * @param  [in]   px  X-ordinate of point to double.
 * @param  [in]   py  Y-ordinate of point to double.
 * @param  [in]   t   SP temporaries (3 used).
 */
static void sp_1024_accum_dbl_calc_lc_52(sp_digit* lr, sp_digit* cr,
        const sp_digit* px, const sp_digit* py, sp_digit* t)
{
    sp_digit* t1 = t + 0 * 2 * 52;
    sp_digit* t2 = t + 2 * 2 * 52;
    sp_digit* l  = t + 4 * 2 * 52;


    /* l = 1 / 2 * p.y */
    sp_1024_mont_dbl_52(l, py, p1024_mod);
    sp_1024_mont_inv_52(l, l, t);

    /* t1 = p.x^2 */
    sp_1024_mont_sqr_52(t1, px, p1024_mod, p1024_mp_mod);
    /* t1 = p.x - 1 */
    sp_1024_mont_sub_52(t1, t1, p1024_norm_mod, p1024_mod);
    /* t1 = 3 * (p.x^2 - 1) */
    sp_1024_mont_dbl_52(t2, t1, p1024_mod);
    sp_1024_mont_add_52(t1, t1, t2, p1024_mod);
    /* t1 = 3 * (p.x^2 - 1) / (2 * p.y) */
    sp_1024_mont_mul_52(l, l, t1, p1024_mod, p1024_mp_mod);
    /* t2 = l * p.x */
    sp_1024_mont_mul_52(t2, l, px, p1024_mod, p1024_mp_mod);
    /* c = t2 = l * p.x - p.y */
    sp_1024_mont_sub_52(t2, t2, py, p1024_mod);

    XMEMCPY(lr, l, sizeof(sp_digit) * 52);
    XMEMCPY(cr, t2, sizeof(sp_digit) * 52);
}

/*
 * Calc l and c when adding p and c.
 *
 * l = (c.y - p.y) / (c.x - p.x)
 * c = (p.x * c.y - cx * p.y) / (cx - p.x)
 *
 * @param  [out]  lr  Gradient result - table entry.
 * @param  [out]  cr  Constant result - table entry.
 * @param  [in]   px  X-ordinate of point to add.
 * @param  [in]   py  Y-ordinate of point to add.
 * @param  [in]   cx  X-ordinate of current point.
 * @param  [in]   cy  Y-ordinate of current point.
 * @param  [in]   t   SP temporaries (3 used).
 */
static void sp_1024_accum_add_calc_lc_52(sp_digit* lr, sp_digit* cr,
        const sp_digit* px, const sp_digit* py, const sp_digit* cx,
        const sp_digit* cy, sp_digit* t)
{
    sp_digit* t1 = t + 0 * 2 * 52;
    sp_digit* c  = t + 2 * 2 * 52;
    sp_digit* l  = t + 4 * 2 * 52;


    /* l = 1 / (c.x - p.x) */
    sp_1024_mont_sub_52(l, cx, px, p1024_mod);
    sp_1024_mont_inv_52(l, l, t);

    /* c = p.x * c.y */
    sp_1024_mont_mul_52(c, px, cy, p1024_mod, p1024_mp_mod);
    /* t1 = c.x * p.y */
    sp_1024_mont_mul_52(t1, cx, py, p1024_mod, p1024_mp_mod);
    /* c = (p.x * c.y) - (c.x * p.y) */
    sp_1024_mont_sub_52(c, c, t1, p1024_mod);
    /* c = ((p.x * c.y) - (c.x * p.y)) / (c.x - p.x) */
    sp_1024_mont_mul_52(c, c, l, p1024_mod, p1024_mp_mod);
    /* t1 = c.y - p.y */
    sp_1024_mont_sub_52(t1, cy, py, p1024_mod);
    /* l = (c.y - p.y) / (c.x - p.x) */
    sp_1024_mont_mul_52(l, t1, l, p1024_mod, p1024_mp_mod);

    XMEMCPY(lr, l, sizeof(sp_digit) * 52);
    XMEMCPY(cr, c, sizeof(sp_digit) * 52);
}

/*
 * Calculate vx and vy given gradient l and constant c and point q.
 *
 * l is a the gradient and is multiplied by q->x.
 * c is a the constant that is added to the multiplicative result.
 * q->y is the y-ordinate in result to multiply.
 *
 * if dbl
 *   v*  = v*^2
 * r.x = l * q.x + c
 * r.y = q->y
 * v*  = v* * r*
 *
 * @param  [in,out]  vx     X-ordinate of projective value in F*.
 * @param  [in,out]  vy     Y-ordinate of projective value in F*.
 * @param  [in]      l      Gradient to multiply with.
 * @param  [in]      c      Constant to add with.
 * @param  [in]      q      ECC point - second point on E(F_P^2).
 * @param  [in]      t      SP temporaries (3 used).
 * @param  [in]      dbl    Indicates whether this is for doubling. Otherwise
 *                          adding.
 */
static void sp_1024_accumulate_line_lc_52(sp_digit* vx, sp_digit* vy,
        const sp_digit* l, const sp_digit* c, const sp_point_1024* q,
        sp_digit* t, int dbl)
{
    sp_digit* rx = t + 4 * 2 * 52;

    /* v = v^2 */
    if (dbl) {
        sp_1024_proj_sqr_52(vx, vy, t);
    }
    /* rx = l * q.x + c */
    sp_1024_mont_mul_52(rx, l, q->x, p1024_mod, p1024_mp_mod);
    sp_1024_mont_add_52(rx, rx, c, p1024_mod);
    /* v = v^2 * r */
    sp_1024_proj_mul_52(vx, vy, rx, q->y, t);
}

/* Operations to perform based on order - 1.
 * Sliding window. Start at bottom and stop when bottom bit is one.
 * Subtract if top bit in window is one.
 * Width of 6 bits.
 * Pairs: #dbls, add/subtract window value
 */
static const signed char sp_1024_order_op_pre[] = {
   5,   6, -13,   9, -21,   6,  -5,   8,  31,   6,   3,   6, -27,   6,  25,   9,
  -1,   6, -11,   6, -13,   6,  -7,   6, -15,   6, -29,   7,  25,   6,  -9,   6,
 -19,   7,   3,   6,  11,   9, -23,   6,   1,   6,  27,   6,   1,   7, -25,   8,
  13,   7, -13,   7, -23,  10,  19,   7,   7,   7,  -3,   7,  27,   6,  -7,   7,
 -21,   7,  11,   7,  31,   8,   1,   7, -23,   6, -17,   6,  -3,  10,  11,   6,
 -21,   7, -27,  11, -29,   6,  -1,  10,  15,   8,  27,   7,  17,   6,  17,   7,
 -13,   8,  13,   6,  21,   7, -29,   6,  19,   7, -25,   6,  11,   9,  29,   7,
  -7,   8,  27,   7,  29,  10,  -1,   8,  -7,   8,  17,   6,  17,   7, -27,   7,
 -21,   6,  -9,   6, -27,  12, -23,   6,  19,   6,  13,   6, -11,   7,  27,   6,
  17,   6,  -7,   6, -25,   7, -29,   6,   9,   7,   7,   6,  13,   6, -25,   6,
 -19,   6,  13,   6, -11,   6,   5,   8,  19,   6, -21,   8,  23,   7,  27,   6,
 -13,   6, -19,  11,  29,   7, -15,   6,  -9,   7, -21,  10,  -3,   7,  21,  10,
  25,   6, -15,   6, -23,   6,  21,   6,   1,   6,  21,   7,  -3,   6,  -3,   7,
  -7,   6, -23,   7,   7,   8,  15,   9,   5,   6, -11,   6,  21,  11, -27,   7,
  27,   6, -11,   6,  31,   6, -21,   6,  19,   6,  -7,   8,  -7,  13,  -3,   6,
  -7,   7,  -3,   6,   1,   6,   7,   8,  19,   8,  11,   9,  -9,   7, -31,  12,
  25,   6, -17,   9, -15,   7,   5,   6,  25,   7,  -5,   7, -25,   6,  17,   8,
 -19,   6, -13,   6,  27,   8,   1,   7,  -5,   7,  -1,   6,  21,   6,   3,  10,
  -3,   1,
};

/*
 * Generate table for pairing.
 *
 * Calculate the graident (l) and constant (c) at each step of the way.
 * Sliding window. Start at bottom and stop when bottom bit is one.
 * Subtract if top bit in window is one.
 * Width of 6 bits.
 *
 * pm     [in]      Point to generate table for.
 * table  [in]      Generated table.
 * len    [in,out]  On in, the size of the buffer.
 *                  On out, length of table generated.
 * @return  0 on success.
 *          LENGTH_ONLY_E when table is NULL and only length returned.
 *          BUFFER_E when len is too small.
 *          MEMORY_E when dynamic memory allocation fauls.
 */
int sp_Pairing_gen_precomp_1024(const ecc_point* pm, byte* table,
        word32* len)
{
    int err = 0;
    sp_point_1024 p[1];
    sp_point_1024 c[1];
    sp_point_1024 neg[1];
    sp_point_1024 pre_p[16];
    sp_digit t[6 * 2 * 52];
    int i;
    int j;
    int k;
    sp_table_entry_1024* precomp = (sp_table_entry_1024*)table;

    if (table == NULL) {
        *len = sizeof(sp_table_entry_1024) * 1167;
        err = LENGTH_ONLY_E;
    }

    if ((err == MP_OKAY) &&
            (*len < (int)(sizeof(sp_table_entry_1024) * 1167))) {
        err = BUFFER_E;
    }

    if (err == MP_OKAY) {
        sp_1024_point_from_ecc_point_52(p, pm);

        err = sp_1024_mod_mul_norm_52(p->x, p->x, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(p->y, p->y, p1024_mod);
    }
    if (err == MP_OKAY) {
        XMEMCPY(p->z, p1024_norm_mod, sizeof(p1024_norm_mod));
        neg->infinity = 0;
        c->infinity = 0;

        /* Generate pre-computation table: 1, 3, ... , 31 */
        XMEMCPY(&pre_p[0], p, sizeof(sp_point_1024));
        /* [2]P for adding */
        sp_1024_proj_point_dbl_52(c, p, t);

        /* 1, 3, ... */
        for (i = 1; i < 16; i++) {
            sp_1024_proj_point_add_52(&pre_p[i], &pre_p[i-1], c, t);
            sp_1024_mont_map_52(&pre_p[i], t);
        }

        k = 0;
        j = sp_1024_order_op_pre[0] / 2;
        XMEMCPY(c, &pre_p[j], sizeof(sp_point_1024));

        for (j = 0; j < sp_1024_order_op_pre[1]; j++) {
            sp_1024_accum_dbl_calc_lc_52(precomp[k].x, precomp[k].y, c->x, c->y, t);
            k++;
            sp_1024_proj_point_dbl_52(c, c, t);
            sp_1024_mont_map_52(c, t);
        }

        for (i = 2; i < 290; i += 2) {
            j = sp_1024_order_op_pre[i];
            if (j > 0) {
                sp_1024_accum_add_calc_lc_52(precomp[k].x, precomp[k].y,
                    pre_p[j/2].x, pre_p[j/2].y, c->x, c->y, t);
                k++;
                sp_1024_proj_point_add_52(c, c, &pre_p[j/2], t);
                sp_1024_mont_map_52(c, t);
            }
            else {
                XMEMCPY(neg->x, pre_p[-j / 2].x, sizeof(pre_p->x));
                sp_1024_mont_sub_52(neg->y, p1024_mod, pre_p[-j / 2].y,
                        p1024_mod);
                XMEMCPY(neg->z, pre_p[-j / 2].z, sizeof(pre_p->z));

                sp_1024_accum_add_calc_lc_52(precomp[k].x, precomp[k].y,
                    neg->x, neg->y, c->x, c->y, t);
                k++;
                sp_1024_proj_point_add_52(c, c, neg, t);
                sp_1024_mont_map_52(c, t);
            }

            for (j = 0; j < sp_1024_order_op_pre[i + 1]; j++) {
                sp_1024_accum_dbl_calc_lc_52(precomp[k].x, precomp[k].y, c->x, c->y, t);
                k++;
                sp_1024_proj_point_dbl_52(c, c, t);
                sp_1024_mont_map_52(c, t);
            }
        }

        *len = sizeof(sp_table_entry_1024) * 1167;
    }

    return err;
}

/*
 * Calculate r = pairing <P, Q>.
 *
 * That is, multiply base in PF_p[q] by the scalar s, such that s.P = Q.
 *
 * Sliding window. Start at bottom and stop when bottom bit is one.
 * Subtract if top bit in window is one.
 * Width of 6 bits.
 * Pre-generate values in window (1, 3, ...) - only V.
 * Table contains all gradient l and a constant for each point on the path.
 *
 * @param  [in]  pm     First point on E(F_p)[q].
 * @param  [in]  qm     Second point on E(F_p)[q].
 * @param  [in]  res    Result of calculation.
 * @param  [in]  table  Precomputed table of values.
 * @param  [in]  len    Length of precomputed table of values in bytes.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
int sp_Pairing_precomp_1024(const ecc_point* pm, const ecc_point* qm,
    mp_int* res, const byte* table, word32 len)
{
    int err = 0;
    sp_digit vx[2 * 52];
    sp_digit vy[2 * 52];
    sp_digit* r = vy;
    sp_point_1024 p[1];
    sp_point_1024 q[1];
    sp_point_1024 c[1];
    sp_digit pre_vx[16][104];
    sp_digit pre_vy[16][104];
    sp_digit pre_nvy[16][104];
    sp_digit t[6 * 2 * 52];
    int i;
    int j;
    int k;
    const sp_table_entry_1024* precomp = (const sp_table_entry_1024*)table;

    if (len < (int)(sizeof(sp_table_entry_1024) * 1167)) {
        err = BUFFER_E;
    }

    if (err == MP_OKAY) {
        sp_1024_point_from_ecc_point_52(p, pm);
        sp_1024_point_from_ecc_point_52(q, qm);

        err = sp_1024_mod_mul_norm_52(p->x, p->x, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(p->y, p->y, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(p->z, p->z, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(q->x, q->x, p1024_mod);
    }
    if (err == MP_OKAY) {
        err = sp_1024_mod_mul_norm_52(q->y, q->y, p1024_mod);
    }
    if (err == MP_OKAY) {
        /* Generate pre-computation table: 1, 3, ... , 31 */
        XMEMSET(pre_vx[0], 0, sizeof(sp_digit) * 2 * 52);
        pre_vx[0][0] = 1;
        XMEMSET(pre_vy[0], 0, sizeof(sp_digit) * 2 * 52);
        sp_1024_mont_sub_52(pre_nvy[0], p1024_mod, pre_vy[0], p1024_mod);

        /* [2]P for adding */
        XMEMCPY(c, p, sizeof(sp_point_1024));
        XMEMSET(vx, 0, sizeof(sp_digit) * 2 * 52);
        vx[0] = 1;
        XMEMSET(vy, 0, sizeof(sp_digit) * 2 * 52);
        sp_1024_accumulate_line_dbl_52(vx, vy, c, q, t);

        /* 3, 5, ... */
        for (i = 1; i < 16; i++) {
            XMEMCPY(pre_vx[i], pre_vx[i-1], sizeof(sp_digit) * 2 * 52);
            XMEMCPY(pre_vy[i], pre_vy[i-1], sizeof(sp_digit) * 2 * 52);
            sp_1024_proj_mul_52(pre_vx[i], pre_vy[i], vx, vy, t);
            sp_1024_accumulate_line_add_n_52(pre_vx[i], pre_vy[i], c,
                q, p, t, 0);
            sp_1024_mont_sub_52(pre_nvy[i], p1024_mod, pre_vy[i],
                p1024_mod);
        }

        XMEMCPY(c->z, p1024_norm_mod, sizeof(sp_digit) * 52);
        c->infinity = 0;
        j = sp_1024_order_op_pre[0] / 2;
        XMEMCPY(vx, pre_vx[j], sizeof(sp_digit) * 2 * 52);
        XMEMCPY(vy, pre_vy[j], sizeof(sp_digit) * 2 * 52);

        k = 0;
        for (j = 0; j < sp_1024_order_op_pre[1]; j++) {
            /* Accumulate line into v and double point. */
            sp_1024_accumulate_line_lc_52(vx, vy, precomp[k].x,
                precomp[k].y, q, t, 1);
            k++;
        }

        for (i = 2; i < 290; i += 2) {
            sp_1024_accumulate_line_lc_52(vx, vy, precomp[k].x,
                precomp[k].y, q, t, 0);
            k++;

            j = sp_1024_order_op_pre[i];
            if (j > 0) {
                j /= 2;
                /* Accumulate line into v. */
                sp_1024_proj_mul_52(vx, vy, pre_vx[j], pre_vy[j], t);
            }
            else {
                j = -j / 2;
                /* Accumulate line into v. */
                sp_1024_proj_mul_52(vx, vy, pre_vx[j], pre_nvy[j], t);
            }

            for (j = 0; j < sp_1024_order_op_pre[i + 1]; j++) {
                /* Accumulate line into v and double point. */
                sp_1024_accumulate_line_lc_52(vx, vy, precomp[k].x,
                    precomp[k].y, q, t, 1);
                k++;
            }
        }

        /* Final exponentiation */
        sp_1024_proj_sqr_52(vx, vy, t);
        sp_1024_proj_sqr_52(vx, vy, t);

        /* Convert from PF_p[q] to F_p */
        sp_1024_mont_inv_52(vx, vx, t);
        sp_1024_mont_mul_52(r, vx, vy, p1024_mod, p1024_mp_mod);
        XMEMSET(r + 52, 0, sizeof(sp_digit) * 52);
        sp_1024_mont_reduce_52(r, p1024_mod, p1024_mp_mod);

        err = sp_1024_to_mp(r, res);
    }

    return err;
}

#endif /* WOLFSSL_SP_SMALL */
#endif /* WOLFSSL_SP_1024 */
#endif /* WOLFSSL_HAVE_SP_ECC */
#endif /* SP_WORD_SIZE == 32 */
#endif /* !WOLFSSL_SP_ASM */
#endif /* WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH | WOLFSSL_HAVE_SP_ECC */
